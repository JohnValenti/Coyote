<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeRecordManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timerecord.ejb</a> &gt; <span class="el_source">TimeRecordManagerEJB.java</span></div><h1>TimeRecordManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timerecord.ejb;

import java.rmi.ConnectException;
import java.rmi.RemoteException;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.cache.Cache;
import com.bluepumpkin.common.cache.CacheFactory;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoDuplicateKeyException;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoPCommand;
import com.bluepumpkin.common.jdmo.JdmoParam;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.jdmo.SPMultiUserException;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.Priority;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.JNDINames;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmTimePeriodOverlapException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeRecordException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateDuplicateKeyException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbLogBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.paypolicy.ejb.PayPeriodTypeManager;
import com.bluepumpkin.ejb.bbm.paypolicy.model.PayPeriod;
import com.bluepumpkin.ejb.bbm.paypolicy.model.PayPolicy;
import com.bluepumpkin.ejb.bbm.payroll.util.RulesTimeSpan;
import com.bluepumpkin.ejb.bbm.payroll.util.StateChange;
import com.bluepumpkin.ejb.bbm.payroll.util.TimeSpanNarrower;
import com.bluepumpkin.ejb.bbm.timerecord.cache.TimeRecordCacheUtil;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeEntrySourceCode;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeInterval;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecordEntry;
import com.bluepumpkin.ejb.bbm.util.DateAdjustmentUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourcePayPolicy;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.User;

/**
 * Title: Blue Pumpkin Software Basic Business Model Description:
 * TimeRecordManager EJB implementation Copyright: Copyright (c) 2001 Company:
 * Blue Pumpkin Software, inc
 * 
 * @author Sheng Song
 * @version 1.0
 */

<span class="fc" id="L94">public class TimeRecordManagerEJB extends SessionEJBBase {</span>
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	// cache reference to other EJBs
	private WorkResourceManager m_WorkResourceManager;
	private UserManager m_UserManager;
	private DBConfigManager m_DBConfigManager;
	private Cache m_TimeRecordCache;
	private Cache m_LastEntryCache;
	private EventAuditTrailManager m_EventAuditTrailManager;
	private ActivityManager m_ActivityManager;

	// Retrieved from DBConfig
<span class="fc" id="L109">	private long AutoCloseTimeoutInMillis = (long) 10 * TimeZoneUtil.HOUR_IN_MILLISECONDS;</span>
	private int m_Overlap;
<span class="fc" id="L111">	private int m_LookBackMinutes = TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="fc" id="L112">	private int m_CachedMilliSeconds = TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="fc" id="L113">	private boolean m_DebugEnabled = false;</span>
<span class="fc" id="L114">	private long m_LookBackTimeEntryDays = 14 * TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="fc" id="L115">	private boolean m_ResetImmidiateToLastActivity = false;</span>
	// used to ignore data in the future for data filling project
<span class="fc" id="L117">	private static boolean m_ignoreFutureData = false;</span>

	// Used by Cache transition check
<span class="fc" id="L120">	private static boolean LastCheckStatus = true;</span>

	private static final int OVERLAP = 0;
	private static final int LOOKBACK = 1;
	private static final int CACHEDINTV = 2;

	private static final int MILLISECONDS_IN_MINUTE = 1000;
	private static final int MINUTES_IN_HOUR = 60;

<span class="fc" id="L129">	private final static String clsName = TimeRecordManagerEJB.class.getName();</span>
	{
<span class="fc" id="L131">		super.init(clsName);</span>
<span class="fc" id="L132">	}</span>

<span class="fc" id="L134">	private static Category m_cat = Log.initCategory(clsName);</span>

	// override the base class to provide the appropriate logging category
	protected Category getCategory() {
<span class="fc" id="L138">		return m_cat;</span>
	}

	/**
	 * Caching the ejb reference to other EJBs
	 */
	public void onEjbCreate() {
		try {
<span class="fc" id="L146">			m_DBConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="fc" id="L147">			m_Overlap = m_DBConfigManager.getPeriodOverlap();</span>

<span class="fc" id="L149">			String valueStr = m_DBConfigManager.getValue(ConfigKey.RESET_IMMIDIATE_TO_LAST_ACTIVITY);</span>
<span class="pc bpc" id="L150" title="3 of 4 branches missed.">			if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;true&quot;)) {</span>
<span class="nc" id="L151">				m_ResetImmidiateToLastActivity = true;</span>
			} else {
<span class="fc" id="L153">				m_ResetImmidiateToLastActivity = false;</span>
			}

<span class="fc" id="L156">			String lookBackVal = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_LOOKBACK_INTERVAL);</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">			if (lookBackVal != null) {</span>
<span class="fc" id="L158">				m_LookBackMinutes = Integer.parseInt(lookBackVal) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
			}
<span class="fc" id="L160">			String lookBackTimeEntryVal = m_DBConfigManager.getValue(ConfigKey.TIMEETRIES_LOOKBACK_INTERVAL);</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">			if (lookBackTimeEntryVal != null) {</span>
<span class="fc" id="L162">				m_LookBackTimeEntryDays = Integer.parseInt(lookBackTimeEntryVal)</span>
						* TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;
			}
<span class="fc" id="L165">			String autoCloseVal = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_TIMEOUT);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">			if (autoCloseVal != null) {</span>
<span class="fc" id="L167">				AutoCloseTimeoutInMillis = Long.parseLong(autoCloseVal) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
			}
<span class="fc" id="L169">			String cacheInt = m_DBConfigManager.getValue(TimeRecordManager.TIMERECORDS_CACHE_INTERVAL);</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">			if (cacheInt != null) {</span>
<span class="nc" id="L171">				m_CachedMilliSeconds = Integer.parseInt(cacheInt) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
			}
			// If cache is enabled at first, instantiate cache
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">			if (ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.TIMERECORD_CACHE_USAGE)) {</span>
<span class="fc" id="L175">				m_TimeRecordCache = CacheFactory.getCache(JNDINames.BBM_TIMERECORDMANAGER_EJBHOME,</span>
<span class="fc" id="L176">						TimeRecordManagerEJB.class.getClassLoader());</span>
			} else {
<span class="nc" id="L178">				LastCheckStatus = false;</span>
			}

<span class="fc" id="L181">			m_ignoreFutureData = m_DBConfigManager.getBooleanValue(ConfigKey.IGNORE_FUTURE_DATA);</span>
<span class="fc" id="L182">			TimeRecordDAO.setIgnoreFutureData(m_ignoreFutureData);</span>

			// Check if last entry cache is needed
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">			if (cacheUsed()</span>
<span class="pc bpc" id="L186" title="1 of 2 branches missed.">					&amp;&amp; ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.TIMERECORD_LASTENTRYCACHE_USAGE)) {</span>
<span class="fc" id="L187">				m_LastEntryCache = CacheFactory.getCache(TimeRecordManager.TIMEENTRY_CACHE_NAME,</span>
<span class="fc" id="L188">						TimeRecordManagerEJB.class.getClassLoader());</span>
			}
			// Check debug enabled or not
<span class="fc" id="L191">			String debugUsage = m_DBConfigManager.getValue(TimeRecordManager.TIMERECORD_CACHE_DEBUG);</span>
<span class="pc bpc" id="L192" title="2 of 4 branches missed.">			if (debugUsage != null &amp;&amp; debugUsage.equalsIgnoreCase(&quot;true&quot;))</span>
<span class="nc" id="L193">				m_DebugEnabled = true;</span>
<span class="fc" id="L194">			m_EventAuditTrailManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="fc" id="L195">			m_ActivityManager = WfmManagerFactory.getActivityManager();</span>
<span class="fc" id="L196">			m_UserManager = CoreManagerFactory.getUserManager(false);</span>
<span class="fc" id="L197">			m_WorkResourceManager = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L198">		} catch (Exception e) {</span>
<span class="nc" id="L199">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="fc" id="L200">		}</span>
<span class="fc" id="L201">	}</span>

	protected boolean cacheUsed() {
		// If Cache is null, then cache is not used
<span class="fc" id="L205">		boolean currentStatus = false;</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">		if (!m_ignoreFutureData) { // do not cache for demo mode</span>
			try {
				// If cache is never instantiated, give it a chance to get
				// initialized
				// If ConfigManager is cache aware, then always check it
				// dynamically
<span class="pc bpc" id="L212" title="2 of 4 branches missed.">				if (m_TimeRecordCache == null || m_DBConfigManager.cacheUsed()) {</span>
					// Access ConfigManager for the cache setting
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">					if (ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.TIMERECORD_CACHE_USAGE)) {</span>
						// If Cache is null, initialize it
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">						if (m_TimeRecordCache == null)</span>
<span class="nc" id="L217">							m_TimeRecordCache = CacheFactory.getCache(JNDINames.BBM_TIMERECORDMANAGER_EJBHOME,</span>
<span class="nc" id="L218">									TimeRecordManagerEJB.class.getClassLoader());</span>
<span class="fc" id="L219">						currentStatus = true;</span>
					} else {
<span class="nc" id="L221">						currentStatus = false;</span>
					}
				} else {
					// Or if m_TimeRecordCache is available, we think cache is
					// enabled
<span class="nc bnc" id="L226" title="All 2 branches missed.">					currentStatus = (m_TimeRecordCache != null);</span>
				}
<span class="nc" id="L228">			} catch (Exception e) {</span>
<span class="nc" id="L229">				currentStatus = false;</span>
<span class="fc" id="L230">			}</span>
			// If there is state transition, we need flush cache content
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">			if (LastCheckStatus != currentStatus) {</span>
				// If from Cache turn on to off, or vice versa, we will flush
				// cache content
<span class="nc bnc" id="L235" title="All 2 branches missed.">				if (m_TimeRecordCache != null) {</span>
<span class="nc" id="L236">					m_TimeRecordCache.clear();</span>
				}
<span class="nc" id="L238">				LastCheckStatus = currentStatus;</span>
			}
		}
<span class="fc" id="L241">		return currentStatus;</span>
	}

	private int getConfigData(int config) {
<span class="pc bpc" id="L245" title="2 of 4 branches missed.">		switch (config) {</span>
		case OVERLAP:
			// If cache is in use, DBConfig will dynamically serve request
			try {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">				if (m_DBConfigManager.cacheUsed()) {</span>
<span class="fc" id="L250">					m_Overlap = m_DBConfigManager.getPeriodOverlap();</span>
				}
<span class="nc" id="L252">			} catch (Exception e) {</span>
<span class="nc" id="L253">				m_cat.debug(e);</span>
<span class="fc" id="L254">			}</span>
<span class="fc" id="L255">			return m_Overlap;</span>
		case LOOKBACK:
			// If cache is in use, DBConfig will dynamically serve request
			try {
<span class="nc bnc" id="L259" title="All 2 branches missed.">				if (m_DBConfigManager.cacheUsed()) {</span>
<span class="nc" id="L260">					String lookBackVal = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_LOOKBACK_INTERVAL);</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">					if (lookBackVal != null) {</span>
<span class="nc" id="L262">						m_LookBackMinutes = Integer.parseInt(lookBackVal) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
					}
				}
<span class="nc" id="L265">			} catch (Exception e) {</span>
<span class="nc" id="L266">				m_cat.debug(e);</span>
<span class="nc" id="L267">			}</span>
<span class="nc" id="L268">			return m_LookBackMinutes;</span>
		case CACHEDINTV:
			// If cache is in use, DBConfig will dynamically serve request
			try {
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">				if (m_DBConfigManager.cacheUsed()) {</span>
<span class="fc" id="L273">					String cacheInt = m_DBConfigManager.getValue(TimeRecordManager.TIMERECORDS_CACHE_INTERVAL);</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">					if (cacheInt != null) {</span>
<span class="nc" id="L275">						m_CachedMilliSeconds = Integer.parseInt(cacheInt) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
					}
				}
<span class="nc" id="L278">			} catch (Exception e) {</span>
<span class="nc" id="L279">				m_cat.debug(e);</span>
<span class="fc" id="L280">			}</span>
<span class="fc" id="L281">			return m_CachedMilliSeconds;</span>
		default:
<span class="nc" id="L283">			return -1;</span>
		}
	}

	public int getTimecordCacheInterval() {
<span class="nc" id="L288">		methodStart(&quot;getTimecordCacheInterval&quot;);</span>
		try {
<span class="nc" id="L290">			return getConfigData(CACHEDINTV);</span>
		} finally {
<span class="nc" id="L292">			methodFinish();</span>
		}
	}

	/**
	 * The current implementation may have risk to approve the version which is
	 * not shown on the current user screen
	 * 
	 * @param ID
	 *            , timerecord ID
	 * @param String
	 *            , approver
	 * @param boolean
	 * @param long, version
	 */
	public void approveTimeRecord(ID id, String approver, boolean vote, long version) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc" id="L309">		methodStart(&quot;approveTimeRecord&quot;, id, approver, JdmoParam.getObject(vote), new Long(version));</span>
<span class="nc" id="L310">		TimeRecord tr = null;</span>
		try {
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L313" title="All 2 branches missed.">			if (approver == null) {</span>
<span class="nc" id="L314">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			}
<span class="nc" id="L316">			tr = TimeRecordDAO.getTimeRecordForUpdate(id, version, false);</span>
<span class="nc bnc" id="L317" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">				if (tr.getApprove() != vote) {</span>
<span class="nc bnc" id="L319" title="All 4 branches missed.">					if (!tr.validate(true) || tr.isOpenShift()) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">						if (tr.isOpenShift()) {</span>
<span class="nc" id="L321">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OPEN_SHIFT);</span>
						}
<span class="nc" id="L323">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
					}
				} else {
<span class="nc" id="L326">					return;</span>
				}
			} else {
<span class="nc bnc" id="L329" title="All 2 branches missed.">				if (tr != null) {</span>
<span class="nc" id="L330">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
				}
				// Special handle TimeInterval
<span class="nc" id="L333">				tr = TimeRecordDAO.getTimeRecordForUpdate(id, version, true);</span>
<span class="nc bnc" id="L334" title="All 4 branches missed.">				if (tr == null || tr.getVersion() != version) {</span>
<span class="nc" id="L335">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
			}
<span class="nc" id="L338">			TimeRecordDAO.approveTimeRecord(tr, approver, vote);</span>
<span class="nc" id="L339">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L340">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L341">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L342">		} catch (JdmoException e) {</span>
<span class="nc" id="L343">			handleException(e);</span>
<span class="nc" id="L344">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L345">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L346">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L347">			e.setContent(tr);</span>
<span class="nc" id="L348">			throw e;</span>
<span class="nc" id="L349">		} catch (Exception e) {</span>
<span class="nc" id="L350">			handleException(e);</span>
<span class="nc" id="L351">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L353">			methodFinish();</span>
<span class="nc" id="L354">		}</span>
<span class="nc" id="L355">	} // approveTimeRecord</span>

	/**
	 * The current implementation ignores the validation check This is mainly
	 * used by AutoApproval function
	 * 
	 * @param ID
	 *            , timerecord ID
	 * @param String
	 *            , approver
	 * @param boolean
	 */
	public void approveTimeRecord(ID id, String approver, boolean vote) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc" id="L369">		methodStart(&quot;approveTimeRecord&quot;, id, approver, JdmoParam.getObject(vote));</span>
<span class="nc" id="L370">		TimeRecord tr = null;</span>
		try {
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L373" title="All 2 branches missed.">			if (approver == null) {</span>
<span class="nc" id="L374">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			}
<span class="nc" id="L376">			tr = TimeRecordDAO.getTimeRecordByID(id);</span>
<span class="nc bnc" id="L377" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">				if (tr.getApprove() != vote) {</span>
<span class="nc bnc" id="L379" title="All 4 branches missed.">					if (!tr.validate(true) || tr.isOpenShift()) {</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">						if (tr.isOpenShift()) {</span>
<span class="nc" id="L381">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OPEN_SHIFT);</span>
						}
<span class="nc" id="L383">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
					}
				} else {
<span class="nc" id="L386">					return;</span>
				}
			} else {
<span class="nc bnc" id="L389" title="All 2 branches missed.">				if (tr != null) {</span>
<span class="nc" id="L390">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
				}
<span class="nc" id="L392">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
			}
<span class="nc" id="L394">			TimeRecordDAO.approveTimeRecord(tr, approver, vote);</span>
<span class="nc" id="L395">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L396">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L397">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L398">		} catch (JdmoException e) {</span>
<span class="nc" id="L399">			handleException(e);</span>
<span class="nc" id="L400">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L401">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L402">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L403">			e.setContent(tr);</span>
<span class="nc" id="L404">			throw e;</span>
<span class="nc" id="L405">		} catch (Exception e) {</span>
<span class="nc" id="L406">			handleException(e);</span>
<span class="nc" id="L407">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L409">			methodFinish();</span>
<span class="nc" id="L410">		}</span>
<span class="nc" id="L411">	} // approveTimeRecord</span>

	/**
	 * Approve a day, ignoring the version, used by &quot;Approve Day&quot;
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param String
	 *            , approver
	 * @param LocalDate
	 *            , day
	 * @boolean, vote
	 * @throw BbmTimeRecordException, if there are invalid TimeRecords
	 */
	public void approveTimeRecord(ID workResourceID, String approver, LocalDate dayStart, LocalDate dayEnd, boolean vote)
			throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L427">		methodStart(&quot;approveTimeRecord&quot;, workResourceID, dayStart.toLogString(), dayEnd.toLogString(),</span>
<span class="nc" id="L428">				JdmoParam.getObject(vote));</span>
		try {
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L431" title="All 2 branches missed.">			if (approver == null) {</span>
<span class="nc" id="L432">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			}
<span class="nc" id="L434">			Collection trCol = null;</span>
			try {
<span class="nc" id="L436">				Pair result = findTimeRecord(workResourceID, dayStart, dayEnd);</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">				if (((Boolean) result.getFirst()).booleanValue()) {</span>
<span class="nc" id="L438">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_PAYPERIOD_LOCK);</span>
				}
<span class="nc" id="L440">				trCol = (Collection) result.getSecond();</span>
<span class="nc" id="L441">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L442">				trCol = (Collection) e.getContent();</span>
<span class="nc" id="L443">			}</span>
<span class="nc bnc" id="L444" title="All 4 branches missed.">			if (trCol == null || trCol.isEmpty()) {</span>
<span class="nc" id="L445">				return;</span>
			}
<span class="nc" id="L447">			boolean rethrow = false;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">			for (Iterator it = trCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L449">				TimeRecord tr = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L450" title="All 4 branches missed.">				if (tr.getApprove() != vote &amp;&amp; !tr.isLocked()) {</span>
<span class="nc bnc" id="L451" title="All 6 branches missed.">					if (tr.validate(true) &amp;&amp; !tr.getOverlap() &amp;&amp; !tr.isOpenShift()) {</span>
<span class="nc" id="L452">						TimeRecordDAO.approveTimeRecord(tr, approver, vote);</span>
					} else {
<span class="nc" id="L454">						rethrow = true;</span>
					}
				}
<span class="nc" id="L457">			}</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">			if (rethrow) {</span>
<span class="nc" id="L459">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
			}
<span class="nc" id="L461">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L462">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L463">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L464">		} catch (JdmoException e) {</span>
<span class="nc" id="L465">			handleException(e);</span>
<span class="nc" id="L466">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L467">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L468">			handleException(e);</span>
<span class="nc" id="L469">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L471">			methodFinish();</span>
<span class="nc" id="L472">		}</span>
<span class="nc" id="L473">	}</span>

	/**
	 * Approve a PayPeriod, ignoring the version, used by &quot;Approve PayPeriod&quot;
	 *
	 * @param Collection
	 *            , Employee ID
	 * @param ID
	 *            , remarker ID
	 * @param ID
	 *            , PayPeriod ID
	 * @param boolean, vote
	 */
	public void approveTimeRecord(Collection workResourceID, String approver, ID payPeriodID, boolean vote)
			throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L488">		methodStart(&quot;approveTimeRecord&quot;, workResourceID, payPeriodID, JdmoParam.getObject(vote));</span>
<span class="nc" id="L489">		Jdmo jdmo = null;</span>
		try {
			// cache current time for modification time stamp
<span class="nc" id="L492">			Date curTime = new Date();</span>
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L494" title="All 2 branches missed.">			if (approver == null)</span>
<span class="nc" id="L495">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			// Need rethrow at the end flag
<span class="nc" id="L497">			boolean rethrow = false;</span>
<span class="nc" id="L498">			int overlap = getConfigData(OVERLAP);</span>
<span class="nc" id="L499">			PayPeriodTypeManager pptm = BbmManagerFactory.getPayPeriodTypeManager();</span>
<span class="nc" id="L500">			PayPeriod pp = pptm.getPayPeriod(payPeriodID);</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">			if (pp != null) {</span>
<span class="nc" id="L502">				int size = workResourceID.size();</span>
<span class="nc" id="L503">				HashMap wrMap = new HashMap(size);</span>
<span class="nc" id="L504">				HashMap wrppMap = new HashMap(size);</span>
<span class="nc" id="L505">				HashMap ppMap = new HashMap(1);</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L507">					ID wrID = (ID) it.next();</span>
<span class="nc" id="L508">					Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(wrID, pp.getStartDate(),</span>
<span class="nc" id="L509">							pp.getEndDate());</span>
<span class="nc" id="L510">					wrMap.put(wrID, wraCol);</span>
<span class="nc" id="L511">					Collection wrppCol = m_WorkResourceManager.getValidWorkResourcePayPolicies(wrID, pp.getStartDate(),</span>
<span class="nc" id="L512">							pp.getEndDate());</span>
<span class="nc" id="L513">					wrppMap.put(wrID, wrppCol);</span>
<span class="nc" id="L514">					Iterator itPP = wrppCol.iterator();</span>
					// Cache the PayPolicies for all employees in m_PayPolicy
<span class="nc bnc" id="L516" title="All 2 branches missed.">					while (itPP.hasNext()) {</span>
<span class="nc" id="L517">						WorkResourcePayPolicy wrpp = (WorkResourcePayPolicy) itPP.next();</span>
<span class="nc" id="L518">						ID policyID = wrpp.getPayPolicyID();</span>
<span class="nc" id="L519">					}</span>
<span class="nc" id="L520">				}</span>
<span class="nc" id="L521">				LocalDate start = pp.getStartDate();</span>
<span class="nc" id="L522">				LocalDate end = pp.getEndDate();</span>
<span class="nc" id="L523">				start.add(Calendar.DATE, -1);</span>
<span class="nc" id="L524">				end.add(Calendar.DATE, 1);</span>
<span class="nc" id="L525">				HashMap trMap = null;</span>
				// Maybe the extra timerecords has overlap, or whatever
				try {
<span class="nc" id="L528">					trMap = getValidEventsForWorkResource(workResourceID, start.getTime(TimeZoneUtil.GMT_TIMEZONE),</span>
<span class="nc" id="L529">							end.getTime(TimeZoneUtil.GMT_TIMEZONE));</span>
<span class="nc" id="L530">				} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L531">					trMap = (HashMap) e.getContent();</span>
<span class="nc" id="L532">				}</span>
<span class="nc" id="L533">				start.add(Calendar.DATE, 1);</span>
<span class="nc" id="L534">				end.add(Calendar.DATE, -1);</span>
<span class="nc" id="L535">				jdmo = new Jdmo();</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L537">					ID wrID = (ID) it.next();</span>
					// Retrieve the TimeRecord, if there is no such record, skip
<span class="nc" id="L539">					Collection trCol = (Collection) trMap.get(wrID);</span>
<span class="nc bnc" id="L540" title="All 4 branches missed.">					if (trCol == null || trCol.isEmpty()) {</span>
<span class="nc" id="L541">						continue;</span>
					}
					// If there is timerecord, get the splitted time window
<span class="nc" id="L544">					Collection wraCol = (Collection) wrMap.get(wrID);</span>
<span class="nc" id="L545">					Collection wrppCol = (Collection) wrppMap.get(wrID);</span>
<span class="nc" id="L546">					Collection tsCol = TimeSpanNarrower.payrollNarrower(wraCol, wrppCol, ppMap, null, null,</span>
<span class="nc" id="L547">							pp.getPayPeriodTypeID());</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">					for (Iterator tsIT = tsCol.iterator(); tsIT.hasNext();) {</span>
<span class="nc" id="L549">						RulesTimeSpan wra = (RulesTimeSpan) tsIT.next();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">						for (Iterator itTR = trCol.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L551">							TimeRecord tr = (TimeRecord) itTR.next();</span>
							// check TimeRecord is in peirod or not
<span class="nc bnc" id="L553" title="All 2 branches missed.">							if (StateChange.isInPeriod(tr, wra.getStartDate(), wra.getEndDate(), overlap)) {</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">								if (!tr.isLocked() &amp;&amp; tr.getApprove() != vote) {</span>
<span class="nc bnc" id="L555" title="All 6 branches missed.">									if (tr.validate(true) &amp;&amp; !tr.getOverlap() &amp;&amp; !tr.isOpenShift()) {</span>
<span class="nc" id="L556">										tr.setApprove(vote);</span>
<span class="nc" id="L557">										tr.setLastModifiedTime(curTime);</span>
										// ingore version control, lock tr from
										// TC
<span class="nc" id="L560">										TimeRecordDAO.approveTimeRecord(tr, approver, vote, jdmo);</span>
									} else
<span class="nc" id="L562">										rethrow = true;</span>
								}
							}
<span class="nc" id="L565">						}</span>
<span class="nc" id="L566">					}</span>
<span class="nc" id="L567">				}</span>
			}
<span class="nc bnc" id="L569" title="All 2 branches missed.">			if (rethrow)</span>
<span class="nc" id="L570">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
<span class="nc" id="L571">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L572">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L573">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L574">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L575">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L576">			throw e;</span>
<span class="nc" id="L577">		} catch (Exception e) {</span>
<span class="nc" id="L578">			handleException(e);</span>
<span class="nc" id="L579">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L581">			jdmo.cleanUp();</span>
<span class="nc" id="L582">			methodFinish();</span>
<span class="nc" id="L583">		}</span>
<span class="nc" id="L584">	}</span>

	/**
	 * find TimeRecords in a Day period(Defined by LocalDate time window) and
	 * aggregate them according to (ActivityType, IsPaid) attributes comb.
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param LocalDate
	 *            , start date
	 * @param LocalDate
	 *            , end date
	 * @return Pair, [Day lock for PayPeriod in Boolean, TimeRecord (incl
	 *         TimeRecordEntry, TimeInterval)]
	 * @throw BbmTimeRecordOverlapException, if timerecord overlap with other
	 *        existing timerecord
	 * @throw BbmFinderException, if there are any exception for find process
	 * @throw BbmTimeRecordException, if there are no orgnization/paypolicy
	 *        association
	 */
	public Pair findAggregatedTimeRecord(ID workresourceID, LocalDate dayStart, LocalDate dayEnd)
			throws BbmFinderException, BbmTimeRecordException {
<span class="nc" id="L606">		methodStart(&quot;findAggregatedTimeRecord&quot;, workresourceID, dayStart.toLogString(), dayEnd.toLogString());</span>
<span class="nc" id="L607">		boolean rethrow = false;</span>
		try {
<span class="nc" id="L609">			int overlap = getConfigData(OVERLAP);</span>
<span class="nc" id="L610">			Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(workresourceID, dayStart, dayEnd);</span>
			// If there is the user doesn't belong to any org
			// To be enhanced, will throw exception
<span class="nc bnc" id="L613" title="All 2 branches missed.">			if (wraCol.isEmpty()) {</span>
<span class="nc" id="L614">				BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG);</span>
<span class="nc" id="L615">				throw btre;</span>
			}
			// Do a batch load first, expand the time window
<span class="nc" id="L618">			dayStart.add(Calendar.DATE, -1);</span>
<span class="nc" id="L619">			dayEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L620">			TimeZone gmtTZ = TimeZoneUtil.GMT_TIMEZONE;</span>
<span class="nc" id="L621">			Collection timeRecords = null;</span>
			try {
<span class="nc" id="L623">				timeRecords = getValidEventsForWorkResource(workresourceID, dayStart.getTime(gmtTZ),</span>
<span class="nc" id="L624">						dayEnd.getTime(gmtTZ));</span>
<span class="nc" id="L625">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L626">				timeRecords = (Collection) ((HashMap) e.getContent()).get(workresourceID);</span>
<span class="nc" id="L627">			}</span>
<span class="nc" id="L628">			dayStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L629">			dayEnd.add(Calendar.DATE, -1);</span>
<span class="nc" id="L630">			Pair resultPair = new Pair();</span>
<span class="nc" id="L631">			resultPair.setFirst(Boolean.FALSE);</span>
<span class="nc bnc" id="L632" title="All 4 branches missed.">			if (timeRecords == null || timeRecords.isEmpty()) {</span>
<span class="nc" id="L633">				resultPair.setSecond(Collections.EMPTY_LIST);</span>
<span class="nc" id="L634">				return resultPair;</span>
			}
<span class="nc" id="L636">			ArrayList fallsInTR = new ArrayList(timeRecords.size());</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">			for (Iterator it = wraCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L638">				WorkResourceAssignment rts = (WorkResourceAssignment) it.next();</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">				for (Iterator itTR = timeRecords.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L640">					TimeRecord tr = (TimeRecord) itTR.next();</span>
					// Check TimeRecord is in peirod or not
					// This is based on raw time, not the rounded time
					// or it is cyclical to determine the PayPolicy
<span class="nc bnc" id="L644" title="All 2 branches missed.">					if (StateChange.isInPeriod(tr, rts.getStartTime(), rts.getEndTime(), overlap)) {</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">						if (tr.getOverlap())</span>
<span class="nc" id="L646">							rethrow = true;</span>
<span class="nc" id="L647">						tr.setOrgName(rts.getOrgName());</span>
<span class="nc" id="L648">						tr.setOrgID(rts.getOrganizationID());</span>
<span class="nc" id="L649">						tr.setTimeZone(rts.getTimeZone());</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">						if (tr.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
<span class="nc" id="L651">							tr.setType(TimeRecord.AGG_TIMEENTRY);</span>
<span class="nc" id="L652">							ArrayList entries = tr.getChild();</span>
<span class="nc" id="L653">							LinkedList newChild = new LinkedList();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">							for (Iterator itTRE = entries.iterator(); itTRE.hasNext();) {</span>
<span class="nc" id="L655">								TimeRecordEntry tre = (TimeRecordEntry) itTRE.next();</span>
<span class="nc" id="L656">								ID actID = tre.getActivityCategoryID();</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">								if (!newChild.isEmpty()) {</span>
<span class="nc" id="L658">									TimeRecordEntry treLast = (TimeRecordEntry) newChild.getLast();</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">									if (treLast.getActivityCategoryID().equals(actID)</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">											&amp;&amp; treLast.getPaid() == tre.getPaid()) {</span>
<span class="nc" id="L661">										treLast.setEndTime(tre.getEndTime());</span>
<span class="nc" id="L662">										treLast.addNumOfEntries();</span>
										// UI will display multi creators
										// involved in the aggregated view
<span class="nc bnc" id="L665" title="All 2 branches missed.">										if (treLast.getTimeSourceCode() != tre.getTimeSourceCode())</span>
<span class="nc" id="L666">											treLast.setTimeSourceCode(TimeEntrySourceCode.MULTI);</span>
									} else {
<span class="nc" id="L668">										newChild.add(tre);</span>
									}
<span class="nc" id="L670">								} else {</span>
<span class="nc" id="L671">									newChild.add(tre);</span>
								}
<span class="nc" id="L673">							}</span>
<span class="nc" id="L674">							tr.replaceChild(new ArrayList(newChild));</span>
						}
						// Add TimeInteral directly
<span class="nc" id="L677">						fallsInTR.add(tr);</span>
					}
<span class="nc" id="L679">				}</span>
<span class="nc" id="L680">			}</span>
			// Set TimeRecord with User Name for auditing trace
<span class="nc" id="L682">			setUserName(fallsInTR);</span>
<span class="nc" id="L683">			resultPair.setSecond(fallsInTR);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">			if (!rethrow) {</span>
<span class="nc" id="L685">				return resultPair;</span>
			}
<span class="nc" id="L687">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException();</span>
<span class="nc" id="L688">			e.setContent(resultPair);</span>
<span class="nc" id="L689">			throw e;</span>
<span class="nc" id="L690">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L691">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L692">			throw e;</span>
<span class="nc" id="L693">		} catch (BbmFinderException e) {</span>
			// Don't set tx rollback
<span class="nc" id="L695">			handleException(e, false);</span>
<span class="nc" id="L696">			throw e;</span>
<span class="nc" id="L697">		} catch (Exception e) {</span>
<span class="nc" id="L698">			handleException(e, false);</span>
<span class="nc" id="L699">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L701">			methodFinish();</span>
		}
	}

	/**
	 * find TimeRecords in a Day period(Defined by LocalDate time window) and
	 * round the TimeRecordEntry according to the rounding method/minute in the
	 * PayPolicy in that period
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param LocalDate
	 *            , start date
	 * @param LocalDate
	 *            , end date
	 * @return Collection, TimeRecord (incl TimeRecordEntry, TimeInterval)
	 * @throw BbmTimeRecordOverlapException, if timerecord overlap with other
	 *        existing timerecord
	 * @throw BbmFinderException, if there are any exception for find process
	 * @throw BbmTimeRecordException, if there are no orgnization/paypolicy
	 *        association
	 */
	public Collection findRoundedTimeRecord(ID workresourceID, LocalDate dayStart, LocalDate dayEnd)
			throws BbmFinderException, BbmTimeRecordException {
<span class="nc" id="L725">		methodStart(&quot;findRoundedTimeRecord&quot;, workresourceID, dayStart.toLogString(), dayEnd.toLogString());</span>
<span class="nc" id="L726">		boolean rethrow = false;</span>
		try {
<span class="nc" id="L728">			Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(workresourceID, dayStart, dayEnd);</span>
<span class="nc" id="L729">			Collection wppCol = m_WorkResourceManager.getValidWorkResourcePayPolicies(workresourceID, dayStart, dayEnd);</span>
<span class="nc" id="L730">			HashMap payPolicyMap = new HashMap(1);</span>
<span class="nc" id="L731">			int overlap = getConfigData(OVERLAP);</span>
			// Cache the PayPolicies for employees in m_PayPolicy
<span class="nc bnc" id="L733" title="All 2 branches missed.">			for (Iterator it = wppCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L734">				WorkResourcePayPolicy wrpp = (WorkResourcePayPolicy) it.next();</span>
<span class="nc" id="L735">				ID policyID = wrpp.getPayPolicyID();</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">				if (!payPolicyMap.containsKey(policyID)) {</span>
					// PayPolicy
					// policy=m_PayPolicyManager.getPayPolicyByID(policyID);
					// payPolicyMap.put(policyID, policy);
				}
<span class="nc" id="L741">			}</span>
			// If there is the user doesn't belong to any org, paypolicy
			// To be enhanced, will throw exception
<span class="nc bnc" id="L744" title="All 4 branches missed.">			if (wraCol.isEmpty() || wppCol.isEmpty()) {</span>
<span class="nc bnc" id="L745" title="All 4 branches missed.">				if (wraCol.isEmpty() &amp;&amp; wppCol.isEmpty()) {</span>
<span class="nc" id="L746">					BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG_PAYPOLICY);</span>
<span class="nc" id="L747">					throw btre;</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">				} else if (wraCol.isEmpty()) {</span>
<span class="nc" id="L749">					BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG);</span>
<span class="nc" id="L750">					throw btre;</span>
				} else {
<span class="nc" id="L752">					BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_PAYPOLICY);</span>
<span class="nc" id="L753">					throw btre;</span>
				}
			}
			// Get new breakdowns of TimeSpans
<span class="nc" id="L757">			Collection rulesTS = TimeSpanNarrower.payrollNarrower(wraCol, wppCol, payPolicyMap, null, null, null);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">			if (rulesTS.isEmpty()) {</span>
<span class="nc" id="L759">				BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG_PAYPOLICY);</span>
<span class="nc" id="L760">				throw btre;</span>
			}
			// Do a batch load first, expand the time window
<span class="nc" id="L763">			dayStart.add(Calendar.DATE, -1);</span>
<span class="nc" id="L764">			dayEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L765">			TimeZone gmtTZ = TimeZoneUtil.GMT_TIMEZONE;</span>
<span class="nc" id="L766">			Collection timeRecords = null;</span>
			try {
<span class="nc" id="L768">				timeRecords = getValidEventsForWorkResource(workresourceID, dayStart.getTime(gmtTZ),</span>
<span class="nc" id="L769">						dayEnd.getTime(gmtTZ));</span>
<span class="nc" id="L770">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L771">				timeRecords = (Collection) ((HashMap) e.getContent()).get(workresourceID);</span>
<span class="nc" id="L772">			}</span>
<span class="nc" id="L773">			dayStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L774">			dayEnd.add(Calendar.DATE, -1);</span>
<span class="nc bnc" id="L775" title="All 4 branches missed.">			if (timeRecords == null || timeRecords.isEmpty()) {</span>
<span class="nc" id="L776">				return Collections.EMPTY_LIST;</span>
			}
<span class="nc" id="L778">			ArrayList fallsInTR = new ArrayList(timeRecords.size());</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">			for (Iterator it = rulesTS.iterator(); it.hasNext();) {</span>
<span class="nc" id="L780">				RulesTimeSpan rts = (RulesTimeSpan) it.next();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">				for (Iterator itTR = timeRecords.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L782">					TimeRecord tr = (TimeRecord) itTR.next();</span>
					// Check TimeRecord is in peirod or not
					// This is based on raw time, not the rounded time
					// or it is cyclical to determine the PayPolicy
<span class="nc bnc" id="L786" title="All 2 branches missed.">					if (StateChange.isInPeriod(tr, rts.getStartDate(), rts.getEndDate(), overlap)) {</span>
<span class="nc" id="L787">						tr.setOrgName(rts.getOrgName());</span>
<span class="nc" id="L788">						tr.setOrgID(rts.getOrgID());</span>
<span class="nc" id="L789">						tr.setTimeZone(rts.getTimeZoneName());</span>
						// Adjust the time of TimeRecordEntry with rounding rule
<span class="nc bnc" id="L791" title="All 2 branches missed.">						if (tr.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
							// Adjust TimeRecordEntries, so set TimeRecord recal
<span class="nc" id="L793">							tr.setNeedCal();</span>
<span class="nc" id="L794">							PayPolicy pp = (PayPolicy) payPolicyMap.get(rts.getPayPolicyID());</span>
							// If no rounding is defined;
<span class="nc bnc" id="L796" title="All 4 branches missed.">							if (pp == null || pp.getRoundingMinutes() &lt;= 1) {</span>
<span class="nc" id="L797">								continue;</span>
							}
<span class="nc" id="L799">							Collection entryCol = tr.getChildren();</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">							for (Iterator entryIt = entryCol.iterator(); entryIt.hasNext();) {</span>
<span class="nc" id="L801">								TimeRecordEntry entry = (TimeRecordEntry) entryIt.next();</span>
<span class="nc" id="L802">								entry.adjustTime(pp.getRoundingMethod(), pp.getRoundingMinutes());</span>
<span class="nc" id="L803">							}</span>
							// After adjustment check if TimeRecord belongs to
							// the period or not
<span class="nc bnc" id="L806" title="All 2 branches missed.">							if (StateChange.isInPeriod(tr, rts.getStartDate(), rts.getEndDate(), overlap)) {</span>
<span class="nc" id="L807">								fallsInTR.add(tr);</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">								if (tr.getOverlap())</span>
<span class="nc" id="L809">									rethrow = true;</span>
							}
<span class="nc" id="L811">						} else {</span>
							// Add TimeInteral directly
<span class="nc" id="L813">							fallsInTR.add(tr);</span>
						}
					}
<span class="nc" id="L816">				}</span>
<span class="nc" id="L817">			}</span>
			// Set TimeRecord with User Name for auditing trace
<span class="nc" id="L819">			setUserName(fallsInTR);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">			if (!rethrow)</span>
<span class="nc" id="L821">				return fallsInTR;</span>
<span class="nc" id="L822">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException();</span>
<span class="nc" id="L823">			e.setContent(fallsInTR);</span>
<span class="nc" id="L824">			throw e;</span>
<span class="nc" id="L825">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L826">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L827">			throw e;</span>
<span class="nc" id="L828">		} catch (BbmFinderException e) {</span>
			// Don't set tx rollback
<span class="nc" id="L830">			handleException(e, false);</span>
<span class="nc" id="L831">			throw e;</span>
<span class="nc" id="L832">		} catch (Exception e) {</span>
<span class="nc" id="L833">			handleException(e, false);</span>
<span class="nc" id="L834">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L836">			methodFinish();</span>
		}
	}

	/**
	 * find TimeRecords in a Day period(Defined by LocalDate time window)
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param LocalDate
	 *            , start date
	 * @param LocalDate
	 *            , end date
	 * @return Collection, TimeRecord (incl TimeRecordEntry, TimeInterval)
	 */
	public Pair findTimeRecord(ID workresourceID, LocalDate dayStart, LocalDate dayEnd) throws BbmFinderException {
<span class="fc" id="L852">		methodStart(&quot;findTimeRecord&quot;, workresourceID, dayStart.toLogString(), dayEnd.toLogString());</span>
<span class="fc" id="L853">		boolean rethrow = false;</span>
		try {
<span class="fc" id="L855">			Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(workresourceID, dayStart, dayEnd);</span>
<span class="fc" id="L856">			int overlap = getConfigData(OVERLAP);</span>
			// If there is the user doesn't belong to any org
			// To be enhanced, will throw exception
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">			if (wraCol.isEmpty()) {</span>
<span class="nc" id="L860">				BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG);</span>
<span class="nc" id="L861">				throw btre;</span>
			}
			// Do a batch load first, expand the time window
<span class="fc" id="L864">			dayStart.add(Calendar.DATE, -1);</span>
<span class="fc" id="L865">			dayEnd.add(Calendar.DATE, 1);</span>
<span class="fc" id="L866">			TimeZone gmtTZ = TimeZoneUtil.GMT_TIMEZONE;</span>
<span class="fc" id="L867">			Collection timeRecords = null;</span>
			try {
<span class="fc" id="L869">				timeRecords = getValidEventsForWorkResource(workresourceID, dayStart.getTime(gmtTZ),</span>
<span class="fc" id="L870">						dayEnd.getTime(gmtTZ));</span>
<span class="nc" id="L871">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L872">				timeRecords = (Collection) ((HashMap) e.getContent()).get(workresourceID);</span>
<span class="fc" id="L873">			}</span>
<span class="fc" id="L874">			dayStart.add(Calendar.DATE, 1);</span>
<span class="fc" id="L875">			dayEnd.add(Calendar.DATE, -1);</span>
			// Now check PayrollLock status
<span class="fc" id="L877">			Pair resultPair = new Pair();</span>
<span class="fc" id="L878">			resultPair.setFirst(Boolean.FALSE);</span>
<span class="pc bpc" id="L879" title="1 of 4 branches missed.">			if (timeRecords == null || timeRecords.isEmpty()) {</span>
<span class="fc" id="L880">				resultPair.setSecond(Collections.EMPTY_LIST);</span>
<span class="fc" id="L881">				return resultPair;</span>
			}
<span class="fc" id="L883">			ArrayList fallsInTR = new ArrayList(timeRecords.size());</span>
<span class="fc" id="L884">			int dayBoundaryOffset = 0;</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">			for (Iterator it = wraCol.iterator(); it.hasNext();) {</span>
<span class="fc" id="L886">				WorkResourceAssignment wra = (WorkResourceAssignment) it.next();</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">				for (Iterator itTR = timeRecords.iterator(); itTR.hasNext();) {</span>
<span class="fc" id="L888">					TimeRecord tr = (TimeRecord) itTR.next();</span>
					// check TimeRecord is in peirod or not
<span class="fc bfc" id="L890" title="All 2 branches covered.">					if (StateChange.isInPeriod(tr, wra.getStartTime(), wra.getEndTime(), overlap)) {</span>
<span class="fc" id="L891">						tr.setOrgName(wra.getOrgName());</span>
<span class="fc" id="L892">						tr.setOrgID(wra.getOrganizationID());</span>
<span class="fc" id="L893">						tr.setTimeZone(wra.getTimeZone());</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">						dayBoundaryOffset = dayBoundaryOffset == 0 ? wra.getDayBoundaryOffset() : dayBoundaryOffset;</span>
<span class="fc" id="L895">						tr.setDayBoundaryOffset(wra.getDayBoundaryOffset());</span>
<span class="fc" id="L896">						fallsInTR.add(tr);</span>
<span class="pc bpc" id="L897" title="1 of 2 branches missed.">						if (tr.getOverlap())</span>
<span class="nc" id="L898">							rethrow = true;</span>
					}
<span class="fc" id="L900">				}</span>
<span class="fc" id="L901">			}</span>
			// If there is DayBoundaryOffset defined on the organization,
			// we need recheck the offseted day falls in PayPeriod or not
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">			if (dayBoundaryOffset != 0) {</span>
<span class="nc" id="L905">				dayStart.add(Calendar.MINUTE, dayBoundaryOffset);</span>
<span class="nc" id="L906">				dayEnd.add(Calendar.MINUTE, dayBoundaryOffset);</span>
<span class="nc" id="L907">				resultPair.setFirst(Boolean.FALSE);</span>
			}
			// Set TimeRecord with User Name for auditing trace
<span class="fc" id="L910">			setUserName(fallsInTR);</span>
<span class="fc" id="L911">			resultPair.setSecond(fallsInTR);</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">			if (!rethrow) {</span>
<span class="fc" id="L913">				return resultPair;</span>
			}
<span class="nc" id="L915">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException();</span>
<span class="nc" id="L916">			e.setContent(resultPair);</span>
<span class="nc" id="L917">			throw e;</span>
<span class="nc" id="L918">		} catch (BbmFinderException e) {</span>
			// Don't set tx rollback
<span class="nc" id="L920">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L921">			throw e;</span>
<span class="nc" id="L922">		} catch (Exception e) {</span>
<span class="nc" id="L923">			handleException(e, false);</span>
<span class="nc" id="L924">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L926">			methodFinish();</span>
		}
	}

	/**
	 * Close any Open Shift in the whole system
	 */
	public void closeOpenShift(int lookBackDays) throws BbmCreateException {
<span class="nc" id="L934">		methodStart(&quot;closeOpenShift&quot;, new Long(lookBackDays));</span>

<span class="nc" id="L936">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L938">			Date now = new Date();</span>
<span class="nc" id="L939">			long currentMilli = now.getTime();</span>

<span class="nc" id="L941">			long startMilli = 0;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">			if (lookBackDays &gt; 0) {</span>
<span class="nc" id="L943">				long millis = (lookBackDays) * 86400000L;</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">				if (millis &lt; currentMilli) {</span>
<span class="nc" id="L945">					startMilli = currentMilli - millis;</span>
				}
			}

<span class="nc bnc" id="L949" title="All 2 branches missed.">			if (m_DebugEnabled) {</span>
<span class="nc" id="L950">				m_cat.debug(&quot;In closeOpenShift, start Millis=&quot; + startMilli + &quot; end Millis=&quot; + currentMilli);</span>
			}

<span class="nc" id="L953">			StringBuffer pStmt = new StringBuffer(300);</span>
<span class="nc" id="L954">			String tempTable = &quot;emplatest&quot;;</span>
			// From JDMO get real temp table name
<span class="nc" id="L956">			String realTempTable = jdmo.getNativeTemptableName(tempTable);</span>
			// Drop temp first
			try {
<span class="nc" id="L959">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L960">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L962">					m_cat.debug(e);</span>
				}
<span class="nc" id="L964">			}</span>
			// Create a new temp table
<span class="nc" id="L966">			StringBuffer strSQLCreate = new StringBuffer();</span>
<span class="nc" id="L967">			strSQLCreate.append(realTempTable);</span>
<span class="nc" id="L968">			strSQLCreate.append(&quot; (UPDATETIMESTAMP decimal(17,0), EMPLOYEEID int)&quot;);</span>
<span class="nc" id="L969">			jdmo.createTempTable(strSQLCreate.toString());</span>
			// Insert data into temp table
<span class="nc" id="L971">			StringBuffer pInsert = new StringBuffer(&quot;insert into &quot;);</span>
<span class="nc" id="L972">			pInsert.append(realTempTable).append(&quot; select MAX(updatetimestamp),&quot;);</span>
<span class="nc" id="L973">			pInsert.append(&quot;b2.employeeid FROM timeentryevent b2&quot;);</span>
<span class="nc" id="L974">			pInsert.append(&quot; WHERE b2.updatetimestamp &gt;= &quot;).append(startMilli);</span>
<span class="nc" id="L975">			pInsert.append(&quot; AND b2.updatetimestamp&lt;=&quot;).append(currentMilli);</span>

<span class="nc" id="L977">			pInsert.append(&quot; GROUP BY b2.employeeid&quot;);</span>
<span class="nc" id="L978">			jdmo.executeCommand(pInsert.toString());</span>
			// now select again
<span class="nc" id="L980">			pStmt.append(&quot;select b.EMPLOYEEID, b.TIMERECORDID, b.UPDATETIMESTAMP&quot;).append(&quot; from &quot;)</span>
<span class="nc" id="L981">					.append(realTempTable).append(&quot; t, TIMEENTRYEVENT b where t.EMPLOYEEID=b.EMPLOYEEID and&quot;)</span>
<span class="nc" id="L982">					.append(&quot; b.UPDATETIMESTAMP=t.UPDATETIMESTAMP and b.ACTIVITYID!=-4001 and b.UPDATETIMESTAMP&lt;=&quot;)</span>
<span class="nc" id="L983">					.append((long) (currentMilli - AutoCloseTimeoutInMillis));</span>
<span class="nc" id="L984">			JdmoRowset rs = jdmo.createRowset(pStmt.toString(), Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L985">			ArrayList entryList = new ArrayList(1000);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">			while (rs.next()) {</span>
				// construct new End Shift
<span class="nc" id="L988">				TimeRecordEntry entry = new TimeRecordEntry(Activity.ACTIVITY_NONE, new Date(rs.getLong(3)</span>
						+ TimeZoneUtil.MINUTE_IN_MILLISECONDS), null, TimeEntrySourceCode.AUTO_CLOSE, false, null);
<span class="nc" id="L990">				entry.setEmployeeID(rs.getID(1));</span>
<span class="nc" id="L991">				entry.setParentID(rs.getID(2));</span>
<span class="nc" id="L992">				addModTimestamp(entry);</span>
<span class="nc" id="L993">				entryList.add(entry);</span>
<span class="nc" id="L994">			}</span>
			// create in DB
<span class="nc" id="L996">			TimeRecordDAO.createTimeRecordEntry(entryList, m_ResetImmidiateToLastActivity);</span>
			// refresh Cache
<span class="nc bnc" id="L998" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">				for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1000">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1001">					TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
<span class="nc" id="L1002">				}</span>
			}
<span class="nc bnc" id="L1004" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1005">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1006">				updateLastEntryCache(entry);</span>
<span class="nc" id="L1007">			}</span>
			// create AuditTrail
<span class="nc bnc" id="L1009" title="All 2 branches missed.">			if (!entryList.isEmpty()) {</span>
<span class="nc" id="L1010">				ArrayList auditList = new ArrayList(entryList.size());</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">				for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1012">					TimeRecordEntry tre = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1013">					AuditTrailEntry entry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L1014">							AuditTrailEntry.ACTION_DELETE_OBJECT, tre.getEmployeeID(),</span>
<span class="nc" id="L1015">							getEmployeeName(tre.getEmployeeID()), tre.getSortTime(), now);</span>
<span class="nc" id="L1016">					entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L1017">							String.valueOf(Event.EVENT_TYPE_TIME_RECORD), &quot;-1&quot;, false);</span>
<span class="nc" id="L1018">					entry.setWho(&quot;autoclose&quot;);</span>
<span class="nc" id="L1019">					auditList.add(entry);</span>
<span class="nc" id="L1020">				}</span>
<span class="nc" id="L1021">				m_EventAuditTrailManager.createAuditEntry(auditList);</span>
			}
<span class="nc" id="L1023">		} catch (JdmoException e) {</span>
<span class="nc" id="L1024">			handleException(e);</span>
<span class="nc" id="L1025">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1026">		} catch (Exception e) {</span>
<span class="nc" id="L1027">			handleException(e);</span>
<span class="nc" id="L1028">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1030">			jdmo.cleanUp();</span>
<span class="nc" id="L1031">			methodFinish();</span>
<span class="nc" id="L1032">		}</span>
<span class="nc" id="L1033">	}</span>

	/**
	 * Close any Open Shift in the whole system
	 */
	public void closeOpenShift() throws BbmCreateException {
<span class="nc" id="L1039">		closeOpenShift(0);</span>
<span class="nc" id="L1040">	}</span>

	/**
	 * Used by the UI to create TimeInterval, which will creat a new TimeRecord
	 * 
	 * @param TimeRecord
	 * @return ID
	 */
	public ID createTimeInterval(TimeRecord timeRecord) throws BbmCreateException {
<span class="nc" id="L1049">		methodStart(&quot;createTimeInterval&quot;, timeRecord);</span>
		try {
<span class="nc" id="L1051">			return TimeRecordDAO.createTimeInterval(timeRecord);</span>
<span class="nc" id="L1052">		} catch (JdmoException e) {</span>
<span class="nc" id="L1053">			handleException(e);</span>
<span class="nc" id="L1054">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1055">		} catch (Exception e) {</span>
<span class="nc" id="L1056">			handleException(e);</span>
<span class="nc" id="L1057">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1059">			methodFinish();</span>
		}
	} // createTimeInterval

	/**
	 * create a new TimeRecord, which will invoke createTimeRecordEntry Cannot
	 * succeed if there is an open shift just before the current TimeRecord
	 * 
	 * @param TimeRecord
	 * @return ID
	 * @throws BbmTimeRecordException
	 *             , TR_INVALID, if TimeRecord is invalid, getContent() returns
	 *             TimeRecord itselft TR_PRV_OPEN_SHIFT, if there is an open
	 *             shift just before this TimeRecord, getContent() returns the
	 *             last Entry of the open shift
	 */
	public ID createTimeRecord(TimeRecord timeRecord) throws BbmCreateException, BbmTimeRecordException {
<span class="fc" id="L1076">		methodStart(&quot;createTimeRecord&quot;, timeRecord);</span>
		// Check if there are any existing TimeRecordEntry during this period
<span class="pc bpc" id="L1078" title="2 of 4 branches missed.">		if (timeRecord == null || !timeRecord.validate(true)) {</span>
<span class="nc" id="L1079">			BbmTimeRecordException e = new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
<span class="nc" id="L1080">			e.setContent(timeRecord);</span>
<span class="nc" id="L1081">			throw e;</span>
		}
<span class="fc" id="L1083">		Jdmo jdmo = null;</span>
<span class="fc" id="L1084">		Collection col = null;</span>
		try {
			// TimeCollection will create an empty TimeRecord as container
<span class="fc bfc" id="L1087" title="All 2 branches covered.">			if (timeRecord.getStartTime() != null) {</span>
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">				if (timeRecord.getType() == TimeRecord.TIMEENTRY) {</span>
<span class="fc" id="L1089">					col = getEventsForWorkResource(timeRecord.getEmployeeID(), timeRecord.getStartTime(),</span>
<span class="fc" id="L1090">							timeRecord.getEndTime());</span>
<span class="pc bpc" id="L1091" title="3 of 4 branches missed.">					if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1092">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
					}
<span class="fc" id="L1094">					TimeRecordEntry lastEntry = TimeRecordDAO.findLastTimeEntry(timeRecord.getEmployeeID(),</span>
<span class="fc" id="L1095">							TimeZoneUtil.toTimestamp(timeRecord.getStartTime()));</span>
					// If the last Entry is not EndShift, further check must be
					// done
<span class="pc bpc" id="L1098" title="3 of 4 branches missed.">					if (lastEntry != null &amp;&amp; lastEntry.getActivityID() != Activity.ACTIVITY_NONE) {</span>
						// If the last Entry TimeRecord is still open, throw
						// exception saying it should be closed
<span class="nc bnc" id="L1101" title="All 2 branches missed.">						if (TimeRecordDAO.isOpenShift(lastEntry.getParentID(),</span>
<span class="nc" id="L1102">								TimeZoneUtil.toTimestamp(timeRecord.getStartTime()))) {</span>
<span class="nc" id="L1103">							BbmTimeRecordException e = new BbmTimeRecordException(</span>
									BbmTimeRecordException.TR_PRV_OPEN_SHIFT);
<span class="nc" id="L1105">							e.setContent(lastEntry);</span>
<span class="nc" id="L1106">							throw e;</span>
						}
						// Or it will overlap with that TimeRecord for sure
<span class="nc" id="L1109">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
					}
				}
			}
<span class="fc" id="L1113">			jdmo = new Jdmo();</span>
<span class="fc" id="L1114">			HashMap map = new HashMap();</span>
<span class="fc" id="L1115">			map.put(&quot;EMPLOYEEID&quot;, timeRecord.getEmployeeID());</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">			if (timeRecord.getRemarkEmployeeID() != null) {</span>
<span class="fc" id="L1117">				map.put(TimeRecordDAO.REMAKERCOLNAME, timeRecord.getRemarkEmployeeID());</span>
			}
<span class="fc" id="L1119">			map.put(&quot;LASTMODIFIEDAT&quot;, TimeZoneUtil.toTimestamp(new Date()));</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">			if (timeRecord.getDescription() != null) {</span>
<span class="fc" id="L1121">				map.put(&quot;REMARK&quot;, timeRecord.getDescription());</span>
			}
<span class="fc bfc" id="L1123" title="All 2 branches covered.">			if (timeRecord.getApprove()) {</span>
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">				if (timeRecord.getApproverName() == null) {</span>
<span class="fc" id="L1125">					map.put(TimeRecordDAO.APPROVERCOLNAME, m_sessionContext.getCallerPrincipal().getName());</span>
				} else {
<span class="nc" id="L1127">					map.put(TimeRecordDAO.APPROVERCOLNAME, timeRecord.getApproverName());</span>
				}
<span class="fc" id="L1129">				map.put(TimeRecordDAO.APPROVETIMECOLNAME, timeRecord.getApproveTime());</span>
			}
<span class="fc" id="L1131">			map.put(&quot;ISAPPROVED&quot;, JdmoParam.getObject(timeRecord.getApprove()));</span>
<span class="fc" id="L1132">			map.put(&quot;ISPOSTED&quot;, JdmoParam.getObject(timeRecord.isLocked()));</span>
<span class="fc" id="L1133">			map.put(&quot;CHANGECOUNTER&quot;, new Long(timeRecord.getVersion()));</span>
<span class="fc" id="L1134">			map.put(&quot;CHANGESTATUS&quot;, new Short(timeRecord.getSyncStatus()));</span>
<span class="fc" id="L1135">			ID id = jdmo.addBatchInsert(&quot;TIMERECORD&quot;, map);</span>
<span class="fc" id="L1136">			jdmo.executeBatch();</span>
<span class="fc" id="L1137">			timeRecord.setID(id);</span>
<span class="fc" id="L1138">			ArrayList list = timeRecord.getChild();</span>
<span class="pc bpc" id="L1139" title="1 of 4 branches missed.">			if (list == null || list.isEmpty()) {</span>
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">				if (cacheUsed()) {</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">					if (timeRecord.getType() == TimeRecord.TIMEENTRY) {</span>
						// Cleanest way is to reload timerecord from DB, then
						// add the record into cache
<span class="fc" id="L1144">						TimeRecordCacheUtil.createInCache(m_TimeRecordCache, timeRecord);</span>
					}
				}
<span class="fc" id="L1147">				return id;</span>
			}
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">			if (timeRecord.getType() == TimeRecord.TIMEENTRY) {</span>
<span class="fc" id="L1150">				int size = list.size();</span>
<span class="fc" id="L1151">				int lastPos = 0;</span>
<span class="fc" id="L1152">				ArrayList insertEntry = new ArrayList();</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">				for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1154">					TimeRecordEntry entry = (TimeRecordEntry) list.get(i);</span>
<span class="pc bpc" id="L1155" title="1 of 2 branches missed.">					if (!entry.isDeleted()) {</span>
<span class="fc" id="L1156">						entry.setEmployeeID(timeRecord.getEmployeeID());</span>
<span class="fc" id="L1157">						entry.setParentID(id);</span>
<span class="fc" id="L1158">						insertEntry.add(entry);</span>
<span class="fc" id="L1159">						lastPos++;</span>
					}
				}
				// Batch insert
<span class="fc" id="L1163">				TimeRecordDAO.createTimeRecordEntry(insertEntry, m_ResetImmidiateToLastActivity);</span>
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">				if (cacheUsed()) {</span>
					// We may need put this record into cache
<span class="fc" id="L1166">					Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
<span class="pc bpc" id="L1167" title="1 of 2 branches missed.">					if (TimeRecordCacheUtil.fitsInCache(timeRecord, cacheWindow[0], cacheWindow[1])) {</span>
						// Cleanest way is to reload timerecord from DB
<span class="nc" id="L1169">						TimeRecordCacheUtil.createInCache(m_TimeRecordCache, getTimeRecordByID(id));</span>
					}
				}
				// create lastEntry
<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">				if (m_LastEntryCache != null) {</span>
<span class="fc" id="L1174">					Collections.sort(insertEntry);</span>
<span class="fc" id="L1175">					updateLastEntryCache((TimeRecordEntry) insertEntry.get(lastPos - 1));</span>
				}
				// create AuditTrail
<span class="fc" id="L1178">				AuditTrailEntry entry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="fc" id="L1179">						AuditTrailEntry.ACTION_CREATE_OBJECT, timeRecord.getEmployeeID(),</span>
<span class="fc" id="L1180">						getEmployeeName(timeRecord.getEmployeeID()), timeRecord.getStartTime(), timeRecord.getEndTime());</span>
<span class="fc" id="L1181">				entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD),</span>
						&quot;-1&quot;, false);
<span class="fc" id="L1183">				m_EventAuditTrailManager.createAuditEntry(entry);</span>
<span class="fc" id="L1184">			} else {</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">				for (int i = list.size(); --i &gt;= 0;) {</span>
<span class="nc" id="L1186">					TimeInterval entry = (TimeInterval) list.get(i);</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">					if (!entry.isDeleted()) {</span>
<span class="nc" id="L1188">						TimeRecordDAO.createTimeInterval(entry);</span>
					}
<span class="nc" id="L1190">				}</span>
			}
<span class="fc" id="L1192">			return id;</span>
<span class="nc" id="L1193">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1194">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L1195">			BbmCreateException bce = new BbmCreateException(e);</span>
<span class="nc" id="L1196">			bce.setContent(timeRecord);</span>
<span class="nc" id="L1197">			throw bce;</span>
<span class="nc" id="L1198">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L1199">			handleException(Priority.INFO, e);</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">			if (e.getContent() != null) {</span>
<span class="nc" id="L1201">				throw e;</span>
			}
<span class="nc bnc" id="L1203" title="All 4 branches missed.">			if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1204">				e.setContent(col);</span>
			} else {
<span class="nc" id="L1206">				e.setContent(timeRecord);</span>
			}
<span class="nc" id="L1208">			throw e;</span>
<span class="nc" id="L1209">		} catch (JdmoException e) {</span>
<span class="nc" id="L1210">			handleException(e);</span>
<span class="nc" id="L1211">			BbmCreateException bce = new BbmCreateException(e);</span>
<span class="nc" id="L1212">			bce.setContent(timeRecord);</span>
<span class="nc" id="L1213">			throw bce;</span>
<span class="nc" id="L1214">		} catch (Exception e) {</span>
<span class="nc" id="L1215">			handleException(e);</span>
<span class="nc" id="L1216">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc bpc" id="L1218" title="4 of 6 branches missed.">			if (jdmo != null) {</span>
<span class="pc" id="L1219">				jdmo.cleanUp();</span>
			}
<span class="pc" id="L1221">			methodFinish();</span>
		}
	} // createTimeRecord

	/**
	 * For the creation of a new TimeRecordEntry from the UI only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param int, pos
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Long
	 *            , version
	 * @return TimeRecord
	 */
	public TimeRecord createTimeRecordEntry(ID timeRecordID, int pos, TimeRecordEntry entry, long version)
			throws BbmCreateException, BbmTimeRecordException {
<span class="nc" id="L1239">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, NumberFactory.newInteger(pos), entry, new Long(version));</span>
<span class="nc" id="L1240">		Collection col = null;</span>
<span class="nc" id="L1241">		TimeRecord tr = null;</span>
		try {
			// Try to obtain TimeRecord based on version
<span class="nc" id="L1244">			tr = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID, version, false);</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">			if (tr == null) {</span>
				// TimeRecord is null, can be two reasons:
				// 1. Version is incorrect
				// 2. TimeRecord has no entries, so retry
<span class="nc" id="L1249">				tr = TimeRecordDAO.getTimeRecordForUpdateOnly(timeRecordID);</span>
<span class="nc bnc" id="L1250" title="All 4 branches missed.">				if (tr == null || tr.getVersion() != version) {</span>
					// Really an obsolete problem
<span class="nc" id="L1252">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
			}
<span class="nc bnc" id="L1255" title="All 2 branches missed.">			if (tr.getType() == TimeRecord.TIMEENTRY) {</span>
<span class="nc bnc" id="L1256" title="All 2 branches missed.">				if (tr.isLocked()) {</span>
<span class="nc" id="L1257">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
				}
<span class="nc" id="L1259">				entry.setEmployeeID(tr.getEmployeeID());</span>
<span class="nc" id="L1260">				tr.addEntry(entry, pos);</span>
				// Check within the TimeRecord
<span class="nc bnc" id="L1262" title="All 2 branches missed.">				if (tr.validate(true)) {</span>
					// Check with other TimeRecords, acquire the locks
					// If the TimeRecord has only one entry, it will null
					// So just update
<span class="nc bnc" id="L1266" title="All 2 branches missed.">					if (!tr.getStartTime().equals(tr.getEndTime())) {</span>
<span class="nc" id="L1267">						col = getEventsForWorkResource(tr.getEmployeeID(), tr.getStartTime(), tr.getEndTime());</span>
					}
					// TimeCollection rounding starttime up, so the scope is not
					// precise
					// This is prominent in TimeRecord with only one entry,
					// which may fail to find TR
					// Just update the timerecord in the special case
<span class="nc bnc" id="L1274" title="All 4 branches missed.">					if (col == null || col.size() == 1) {</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">						if (col != null) {</span>
<span class="nc" id="L1276">							Iterator it = col.iterator();</span>
<span class="nc" id="L1277">							TimeRecord same = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">							if (!same.getID().equals(timeRecordID)) {</span>
<span class="nc" id="L1279">								throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
							}
						}
<span class="nc bnc" id="L1282" title="All 2 branches missed.">						if (entry.getRemarkerID() != null) {</span>
<span class="nc" id="L1283">							tr.setRemarkEmployeeID(entry.getRemarkerID());</span>
						}
<span class="nc" id="L1285">						updateTimeRecordEntry(tr, true);</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">						if (cacheUsed()) {</span>
<span class="nc" id="L1287">							TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, tr);</span>
						}
<span class="nc" id="L1289">						updateLastEntryCache(tr.getLastEntry());</span>
<span class="nc" id="L1290">						AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L1291">								AuditTrailEntry.ACTION_CREATE_OBJECT, tr.getEmployeeID(),</span>
<span class="nc" id="L1292">								getEmployeeName(tr.getEmployeeID()), entry.getStartTime(),</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">								(entry.getEndTime() == null) ? (new Date()) : entry.getEndTime());</span>
<span class="nc" id="L1294">						auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L1295">								String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc" id="L1296">						m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L1297">						return tr;</span>
					}
<span class="nc" id="L1299">					Iterator it = col.iterator();</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">					while (it.hasNext()) {</span>
<span class="nc" id="L1301">						((TimeRecord) it.next()).setOverlap(true);</span>
					}
<span class="nc" id="L1303">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
				}
				// invalid
<span class="nc" id="L1306">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
			}
<span class="nc" id="L1308">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID_TYPE);</span>
<span class="nc" id="L1309">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1310">			Object[] param = new Object[3];</span>
<span class="nc" id="L1311">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1312">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1313">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1314">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1315">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1316">		} catch (JdmoException e) {</span>
<span class="nc" id="L1317">			handleException(e);</span>
<span class="nc" id="L1318">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1319">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1320">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L1321">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1322">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1323">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L1324">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1325">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L1326">			handleException(Priority.INFO, e);</span>
<span class="nc bnc" id="L1327" title="All 4 branches missed.">			if (col == null || col.isEmpty()) {</span>
<span class="nc" id="L1328">				e.setContent(tr);</span>
			} else {
<span class="nc" id="L1330">				e.setContent(col);</span>
			}
<span class="nc" id="L1332">			throw e;</span>
<span class="nc" id="L1333">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1334">			handleException(e);</span>
<span class="nc" id="L1335">			throw e;</span>
<span class="nc" id="L1336">		} catch (Exception e) {</span>
<span class="nc" id="L1337">			handleException(e);</span>
<span class="nc" id="L1338">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1340">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @return ID, TimeRecordEntry ID
	 * @throws BbmTimeRecordException
	 *             , if it violates some validation check, or SyncStatus Check
	 */
	public ID createTimeRecordEntry(ID timeRecordID, TimeRecordEntry entry) throws BbmCreateException {
<span class="fc" id="L1358">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, entry);</span>
		try {
			// Then create a new TimeRecordEntry
<span class="fc" id="L1361">			entry.setParentID(timeRecordID);</span>
<span class="fc" id="L1362">			addModTimestamp(entry);</span>
<span class="fc" id="L1363">			TimeRecordDAO.createTimeRecordEntry(entry, m_ResetImmidiateToLastActivity);</span>
<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">			if (cacheUsed()) {</span>
				// Cache Task
<span class="fc" id="L1366">				TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
			}
<span class="fc" id="L1368">			updateLastEntryCache(entry);</span>
<span class="fc" id="L1369">			return entry.getID();</span>
<span class="nc" id="L1370">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1371">			Object[] param = new Object[3];</span>
<span class="nc" id="L1372">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1373">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1374">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1375">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1376">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1377">		} catch (JdmoException e) {</span>
<span class="nc" id="L1378">			handleException(e);</span>
<span class="nc" id="L1379">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1381">			methodFinish();</span>
		}
	}

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param ArrayList
	 *            , TimeRecordEntry List
	 * @return ArrayList, TimeRecordEntry ID List
	 */
	public ArrayList createTimeRecordEntry(ID timeRecordID, ArrayList entryList) throws BbmCreateException {
<span class="nc" id="L1397">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, entryList);</span>
		try {
			// Then create a new TimeRecordEntry
<span class="nc" id="L1400">			Collections.sort(entryList);</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1402">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1403">				entry.setParentID(timeRecordID);</span>
<span class="nc" id="L1404">				addModTimestamp(entry);</span>
<span class="nc" id="L1405">			}</span>
<span class="nc" id="L1406">			ArrayList idList = TimeRecordDAO.createTimeRecordEntry(entryList, m_ResetImmidiateToLastActivity);</span>
<span class="nc bnc" id="L1407" title="All 4 branches missed.">			if (cacheUsed() &amp;&amp; !entryList.isEmpty()) {</span>
<span class="nc" id="L1408">				ID empID = ((TimeRecordEntry) entryList.get(0)).getEmployeeID();</span>
<span class="nc" id="L1409">				TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entryList, empID, timeRecordID);</span>
			}
<span class="nc" id="L1411">			updateLastEntryCache((TimeRecordEntry) entryList.get(entryList.size() - 1));</span>
<span class="nc" id="L1412">			return idList;</span>
<span class="nc" id="L1413">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1414">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1415">		} catch (JdmoException e) {</span>
<span class="nc" id="L1416">			handleException(e);</span>
<span class="nc" id="L1417">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1419">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * TimeRecordEntry is from difference employee
	 * 
	 * @param ArrayList
	 *            , TimeRecordEntry List
	 * @return ArrayList, TimeRecordEntry ID List
	 */
	public ArrayList createTimeRecordEntry(ArrayList entryList) throws BbmCreateException {
<span class="nc" id="L1432">		methodStart(&quot;createTimeRecordEntry&quot;, entryList);</span>
		try {
<span class="nc bnc" id="L1434" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1435">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1436">				addModTimestamp(entry);</span>
<span class="nc" id="L1437">			}</span>
<span class="nc" id="L1438">			ArrayList idList = TimeRecordDAO.createTimeRecordEntry(entryList, m_ResetImmidiateToLastActivity);</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">			if (cacheUsed()) {</span>
				// Cache Task
<span class="nc bnc" id="L1441" title="All 2 branches missed.">				for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1442">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1443">					TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
<span class="nc" id="L1444">				}</span>
			}
<span class="nc bnc" id="L1446" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1447">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1448">				updateLastEntryCache(entry);</span>
<span class="nc" id="L1449">			}</span>
<span class="nc" id="L1450">			return idList;</span>
<span class="nc" id="L1451">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1452">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1453">		} catch (JdmoException e) {</span>
<span class="nc" id="L1454">			handleException(e);</span>
<span class="nc" id="L1455">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1457">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @return ID, TimeRecordEntry ID
	 */
	public ID createTimeRecordEntry(ID timeRecordID, TimeRecordEntry entry, boolean historical)
			throws BbmCreateException {
<span class="nc" id="L1474">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, entry, JdmoParam.getObject(historical));</span>
		try {
			// Then create a new TimeRecordEntry
<span class="nc" id="L1477">			entry.setParentID(timeRecordID);</span>
<span class="nc" id="L1478">			addModTimestamp(entry);</span>
<span class="nc" id="L1479">			entry.setID(TimeRecordDAO.createTimeRecordEntry(entry, m_ResetImmidiateToLastActivity));</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc" id="L1481">				TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
			}
<span class="nc" id="L1483">			updateLastEntryCache(entry);</span>
<span class="nc" id="L1484">			return entry.getID();</span>
<span class="nc" id="L1485">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1486">			Object[] param = new Object[3];</span>
<span class="nc" id="L1487">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1488">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1489">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1490">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1491">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1492">		} catch (JdmoException e) {</span>
<span class="nc" id="L1493">			handleException(e);</span>
<span class="nc" id="L1494">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1496">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * And for Merge is to determine if need replace the existing TimeRecord
	 * ENDSHIFT to a given Activity, and append the new TimeRecordEntry after
	 * that To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Date
	 *            , the last activity start date to be updated for last EndShift
	 * @return ID, TimeRecordEntry ID
	 * @throws BbmTimeRecordException
	 *             , if it violates some validation check, or SyncStatus Check
	 */
	public ID createTimeRecordEntryForMerge(ID timeRecordID, TimeRecordEntry entry, Date lastActivityStart)
			throws BbmCreateException {
<span class="nc" id="L1519">		methodStart(&quot;createTimeRecordEntryForMerge&quot;, timeRecordID, entry, lastActivityStart);</span>
		try {
			// Acquire a read lock
<span class="nc" id="L1522">			TimeRecord candidate = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID);</span>
			// If TimeRecord is gone, throw BbmCreateException
<span class="nc bnc" id="L1524" title="All 2 branches missed.">			if (candidate == null) {</span>
				// Enhancement here, if TimeRecord has no entries, should just
				// create
<span class="nc" id="L1527">				candidate = TimeRecordDAO.getTimeRecordForUpdateOnly(timeRecordID);</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">				if (candidate == null) {</span>
<span class="nc" id="L1529">					throw new BbmCreateException(new BbmObjectNotFoundException());</span>
				}
			}
			// If timerecord doesn't have any timerecordentry, then just add it.
<span class="nc" id="L1533">			TimeRecordEntry lastEntry = candidate.getLastEntry();</span>
<span class="nc bnc" id="L1534" title="All 4 branches missed.">			if (lastEntry != null &amp;&amp; lastEntry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1535">				lastEntry.setActivityID(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1536">				lastEntry.setPaid((m_ActivityManager.findActivityById(Activity.ACTIVITY_MERGE)).isPaid());</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">				if (lastActivityStart != null) {</span>
<span class="nc" id="L1538">					lastEntry.setStartTime(lastActivityStart);</span>
				}
				// We need to specify the TimeSourceCode to Auto_Merge
<span class="nc" id="L1541">				lastEntry.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1542">				addModTimestamp(lastEntry);</span>
<span class="nc" id="L1543">				TimeRecordDAO.updateTimeRecordEntry(lastEntry, m_ResetImmidiateToLastActivity);</span>
<span class="nc" id="L1544">				updateLastEntryCache(lastEntry);</span>
				// now create audit trail for this change
<span class="nc" id="L1546">				AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L1547">						AuditTrailEntry.ACTION_CREATE_OBJECT, candidate.getEmployeeID(),</span>
<span class="nc" id="L1548">						getEmployeeName(lastEntry.getEmployeeID()), lastEntry.getStartTime(), entry.getStartTime());</span>
<span class="nc" id="L1549">				auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L1550">						String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc" id="L1551">				m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
			}
			// TimeCollection shouldn't have Remarker ID, but for Manual
			// EndShift it will pass this information
			// So we need upate TimeRecord if it is approved initially, or there
			// is specific remarker.
<span class="nc bnc" id="L1557" title="All 4 branches missed.">			if (candidate.getApprove() || entry.getRemarkerID() != null) {</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">				if (entry.getRemarkerID() != null) {</span>
<span class="nc" id="L1559">					candidate.setRemarkEmployeeID(entry.getRemarkerID());</span>
				}
<span class="nc" id="L1561">				candidate.setApprove(false);</span>
<span class="nc" id="L1562">				TimeRecordDAO.updateTimeRecord(candidate, false, false);</span>
			}
			// Add the new entry
<span class="nc" id="L1565">			entry.setParentID(timeRecordID);</span>
<span class="nc" id="L1566">			addModTimestamp(entry);</span>
<span class="nc" id="L1567">			entry.setID(TimeRecordDAO.createTimeRecordEntry(entry, m_ResetImmidiateToLastActivity));</span>
<span class="nc bnc" id="L1568" title="All 4 branches missed.">			if (cacheUsed() &amp;&amp; TimeRecordCacheUtil.fitsInCache(candidate)) {</span>
				// CachTask: Add to Cache
				// Add entry to candidate first, then update the whole entry
<span class="nc" id="L1571">				candidate.addEntry(entry);</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L1573">					m_cat.debug(&quot;In createTimeRecordEntryForMerge, new TimeRecord is &quot; + candidate</span>
							+ &quot; , added new entry is &quot; + entry);
				}
<span class="nc" id="L1576">				TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, candidate);</span>
			}
<span class="nc" id="L1578">			updateLastEntryCache(entry);</span>
<span class="nc" id="L1579">			return entry.getID();</span>
<span class="nc" id="L1580">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1581">			Object[] param = new Object[3];</span>
<span class="nc" id="L1582">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1583">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1584">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1585">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1586">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1587">		} catch (JdmoException e) {</span>
<span class="nc" id="L1588">			handleException(e);</span>
<span class="nc" id="L1589">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1590">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1591">			handleException(e);</span>
<span class="nc" id="L1592">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1593">		} catch (Exception e) {</span>
<span class="nc" id="L1594">			handleException(e);</span>
<span class="nc" id="L1595">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1597">			methodFinish();</span>
		}
	}

	/**
	 * Simply update an entry to be ready for Merge
	 * 
	 * @param entryID
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntryForMerge(ID entryID) throws BbmUpdateException {
<span class="nc" id="L1609">		methodStart(&quot;updateTimeRecordEntryForMerge&quot;, entryID);</span>
<span class="nc" id="L1610">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1612">			String pStmt = &quot;update TIMEENTRYEVENT set ACTIVITYID=-4005, TIMESOURCECODE=4 where ID=?&quot;;</span>
<span class="nc" id="L1613">			jdmo.executePCommand(pStmt, new Object[] { entryID });</span>
<span class="nc" id="L1614">		} catch (JdmoException e) {</span>
<span class="nc" id="L1615">			handleException(e);</span>
<span class="nc" id="L1616">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L1618">			methodFinish();</span>
<span class="nc" id="L1619">		}</span>

<span class="nc" id="L1621">	}</span>

	/**
	 * Add modification timestamp and user name information to an
	 * TimeRecordEntry
	 * 
	 * @param entry
	 */
	private void addModTimestamp(TimeRecordEntry entry) {
<span class="fc" id="L1630">		entry.setLastModifiedTime(new Date());</span>
<span class="fc" id="L1631">		entry.setModifier(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="fc" id="L1632">	}</span>

	/**
	 * Returns TimeIntervals of a given time period
	 *
	 * @param Collection
	 *            , WorkResourceID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @return HashMap
	 */
	public HashMap getTimeIntervals(Collection workResourceID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L1646">		methodStart(&quot;getTimeIntervals&quot;, workResourceID, start, end);</span>
		try {
<span class="nc" id="L1648">			return TimeRecordDAO.findTimeIntervals(workResourceID, TimeZoneUtil.toTimestamp(start),</span>
<span class="nc" id="L1649">					TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L1650">		} catch (Exception e) {</span>
<span class="nc" id="L1651">			handleException(e, false);</span>
<span class="nc" id="L1652">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1654">			methodFinish();</span>
		}
	} // getTimeIntervals

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 * without close any openshift
	 *
	 * @param Collection
	 *            of workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResourceWithOpenShift(Collection workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="nc" id="L1671">		HashMap timeRecords = new HashMap(workResourceID.size());</span>
<span class="nc" id="L1672">		Timestamp endTime = DateAdjustmentUtil.adjustEndTimeForDemo(dtEnd, m_ignoreFutureData);</span>
<span class="nc" id="L1673">		Jdmo jdmo = null;</span>
<span class="nc" id="L1674">		JdmoRowset rs = null;</span>
<span class="nc" id="L1675">		long threadID = Thread.currentThread().getId();</span>
<span class="nc" id="L1676">		String tempTable = &quot;EMP&quot; + threadID;</span>
<span class="nc" id="L1677">		String empIDTempTable = &quot;TIMERECORDEMPID&quot; + threadID;</span>
		try {
<span class="nc" id="L1679">			jdmo = new Jdmo();</span>
			// From JDMO get real temp table name
<span class="nc" id="L1681">			String realTempTable = jdmo.getNativeTemptableName(tempTable);</span>
<span class="nc" id="L1682">			String realEmpIDTempTable = jdmo.getNativeTemptableName(empIDTempTable);</span>
			// Drop temp first
			try {
<span class="nc" id="L1685">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L1686">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L1687">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1689">					m_cat.debug(e);</span>
<span class="nc" id="L1690">			}</span>
			// Create a new temp table
<span class="nc" id="L1692">			StringBuffer strSQLCreate = new StringBuffer();</span>
<span class="nc" id="L1693">			strSQLCreate.append(realTempTable);</span>
<span class="nc" id="L1694">			strSQLCreate.append(&quot; (ID int)&quot;);</span>
<span class="nc" id="L1695">			jdmo.createTempTable(strSQLCreate.toString());</span>
			/*
			 * CreateUniqueindex Temp_indexon #147446128568416158(ID) insertinto
			 * #EMP selectdistinct A2.ID from TIMERECORD A2 InnerJoin
			 * TIMEENTRYEVENT B2 on A2.ID=B2.TIMERECORDID Innerjoin
			 * #147446128568416158 Ton T.ID=B2.EmployeeID where
			 * B2.UPDATETIMESTAMP&lt;1474461283288 and
			 * B2.UPDATETIMESTAMP&gt;=1474346083288
			 */
			// Prepare the employee ID query portion
<span class="nc" id="L1705">			createTempTableForUniqueIntIDs(empIDTempTable, jdmo, workResourceID);</span>
<span class="nc" id="L1706">			StringBuffer pInsert = composeTimeRecordQuery(dtStart, endTime, realTempTable, realEmpIDTempTable);</span>
<span class="nc" id="L1707">			jdmo.executeCommand(pInsert.toString());</span>
<span class="nc" id="L1708">			StringBuffer pStmt1 = new StringBuffer(&quot;select A.ID, B.ID, A.EMPLOYEEID, A.LASTMODIFIEDAT, &quot;)</span>
<span class="nc" id="L1709">					.append(TimeRecordDAO.APPROVERCOLSTR).append(&quot;A.REMARK, A.&quot;).append(TimeRecordDAO.REMAKERCOLNAME)</span>
<span class="nc" id="L1710">					.append(&quot;, A.ISPOSTED, A.CHANGECOUNTER, A.ISAPPROVED, A.CHANGESTATUS, RAWTIMEENTRYID, &quot;)</span>
<span class="nc" id="L1711">					.append(&quot;ACTIVITYID, STARTTIME, UPDATETIMESTAMP, TIMESOURCECODE, ISPAID, DATASOURCEID, &quot;)</span>
<span class="nc" id="L1712">					.append(&quot;DESCRIPTION from TIMERECORD A, TIMEENTRYEVENT B, &quot;).append(realTempTable)</span>
<span class="nc" id="L1713">					.append(&quot; E where A.ID=B.TIMERECORDID and A.ID = E.ID&quot;);</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">			if (m_ignoreFutureData) {</span>
<span class="nc" id="L1715">				pStmt1.append(&quot; and UPDATETIMESTAMP&lt;&quot;).append(endTime.getTime());</span>
			}
<span class="nc" id="L1717">			pStmt1.append(&quot; order by A.EMPLOYEEID, A.ID, B.UPDATETIMESTAMP asc&quot;);</span>
<span class="nc" id="L1718">			JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1719">			rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1720">			ArrayList trArray = null;</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1722">				ID empID = rs.getID(&quot;EMPLOYEEID&quot;);</span>
<span class="nc" id="L1723">				trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L1724" title="All 2 branches missed.">				if (trArray == null)</span>
<span class="nc" id="L1725">					trArray = new ArrayList();</span>
<span class="nc" id="L1726">				ID key = rs.getID(1);</span>
<span class="nc" id="L1727">				TimeRecord parent = null;</span>
<span class="nc" id="L1728">				TimeRecord previous = null;</span>
<span class="nc" id="L1729">				int last = trArray.size();</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">				if (last == 0) {</span>
<span class="nc" id="L1731">					parent = new TimeRecord(key, empID, rs.getID(TimeRecordDAO.REMAKERCOLNAME),</span>
<span class="nc" id="L1732">							TimeZoneUtil.toDate(rs.getTimestamp(&quot;LASTMODIFIEDAT&quot;)),</span>
<span class="nc" id="L1733">							rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L1734">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L1735">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L1736">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L1737">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc" id="L1738">					trArray.add(parent);</span>
<span class="nc" id="L1739">					previous = parent;</span>
				} else
<span class="nc" id="L1741">					previous = (TimeRecord) trArray.get(last - 1);</span>
				// if it is a new timerecord
<span class="nc bnc" id="L1743" title="All 2 branches missed.">				if (!previous.getID().equals(key)) {</span>
<span class="nc" id="L1744">					parent = new TimeRecord(key, empID, rs.getID(TimeRecordDAO.REMAKERCOLNAME),</span>
<span class="nc" id="L1745">							TimeZoneUtil.toDate(rs.getTimestamp(&quot;LASTMODIFIEDAT&quot;)),</span>
<span class="nc" id="L1746">							rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L1747">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L1748">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L1749">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L1750">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc" id="L1751">					trArray.add(parent);</span>
				} else {
					// if it is not a new timerecord
<span class="nc" id="L1754">					parent = previous;</span>
				}
<span class="nc" id="L1756">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L1757">				TimeRecordEntry entry = new TimeRecordEntry(rs.getID(2), rs.getID(&quot;RAWTIMEENTRYID&quot;),</span>
<span class="nc" id="L1758">						rs.getID(&quot;ACTIVITYID&quot;), rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart,</span>
<span class="nc" id="L1759">						new Date(rs.getLong(&quot;UPDATETIMESTAMP&quot;)), rs.getInt(&quot;TIMESOURCECODE&quot;), rs.getBoolean(&quot;ISPAID&quot;),</span>
<span class="nc" id="L1760">						rs.getString(&quot;DESCRIPTION&quot;), parent);</span>
<span class="nc" id="L1761">				ArrayList temp = parent.getChild();</span>
				// need to set the previous entry's endtime
<span class="nc bnc" id="L1763" title="All 2 branches missed.">				if (!temp.isEmpty()) {</span>
<span class="nc" id="L1764">					TimeRecordEntry lastEntry = (TimeRecordEntry) temp.get(temp.size() - 1);</span>
<span class="nc" id="L1765">					lastEntry.setEndTime(entryStart);</span>
				}
				// add the new entry directly
<span class="nc" id="L1768">				parent.getChild().add(entry);</span>
				// last step is to put it in the hashmap
<span class="nc" id="L1770">				timeRecords.put(empID, trArray);</span>
<span class="nc" id="L1771">			}</span>
			// Last step is to sort the TimeRecord Array, the query honors
			// TimeRecordID sequence before Start Time
<span class="nc bnc" id="L1774" title="All 2 branches missed.">			for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1775">				ID empID = (ID) it.next();</span>
<span class="nc" id="L1776">				ArrayList trList = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">				if (trList != null) {</span>
<span class="nc" id="L1778">					Collections.sort(trList);</span>
<span class="nc" id="L1779">					timeRecords.put(empID, trList);</span>
				}
<span class="nc" id="L1781">			}</span>
<span class="nc" id="L1782">			return timeRecords;</span>
<span class="nc" id="L1783">		} catch (JdmoException e) {</span>
<span class="nc" id="L1784">			handleException(e, false);</span>
<span class="nc" id="L1785">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1787" title="All 4 branches missed.">			if (rs != null)</span>
				try {
<span class="nc" id="L1789">					rs.close();</span>
<span class="nc" id="L1790">				} catch (Exception e) {</span>
<span class="nc bnc" id="L1791" title="All 4 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1792">						m_cat.debug(e);</span>
<span class="nc" id="L1793">				}</span>
			try {
<span class="nc" id="L1795">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L1796">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L1797">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L1798" title="All 4 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1799">					m_cat.debug(e);</span>
<span class="nc" id="L1800">			}</span>
<span class="nc bnc" id="L1801" title="All 4 branches missed.">			if (jdmo != null)</span>
<span class="nc" id="L1802">				jdmo.cleanUp();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Return all changes since dateLastQuery in TimeRange format Will query
	 * EventAuditTrail, also check Cache version/DB(RealTime feed won't create
	 * AuditTrail)
	 * 
	 * @param Collection
	 *            , colEmployeeIDs, collection of employee ID objects to return
	 *            data for
	 * @param Date
	 *            , dateStart
	 * @param Date
	 *            , dateEnd
	 * @param Date
	 *            , dateLastQuery
	 * @return HashMap
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @return HashMap (EmployeeID, ArrayList of TimeRange, if TimeRange end
	 *         time is null, it means current time)
	 */
	public HashMap getPublishedChangedIntervalsForWorkResource(Collection colEmployeeIDs, Date dateStart, Date dateEnd,
			Date dateLastQuery) throws BbmFinderException {
<span class="nc" id="L1828">		methodStart(&quot;getPublishedChangedIntervalsForWorkResource&quot;, colEmployeeIDs, dateStart, dateEnd, dateLastQuery);</span>
<span class="nc" id="L1829">		Jdmo jdmo = null;</span>
		try {
			// First query EventAuditTrail for changes
<span class="nc" id="L1832">			HashMap auditMap = m_EventAuditTrailManager.getChangedIntervalsForWorkResource(colEmployeeIDs,</span>
					AuditTrailEntry.MODULE_TIMERECORD, AuditTrailEntry.ACTION_ALL, dateStart, dateEnd, dateLastQuery,
					null, m_ignoreFutureData);
<span class="nc bnc" id="L1835" title="All 2 branches missed.">			if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1836">				m_cat.debug(&quot;From AuditTrailManager &quot; + auditMap);</span>
			// HashMap to hold window from TimeRecord itself (from real time
			// feed)
<span class="nc" id="L1839">			HashMap eventMap = new HashMap(colEmployeeIDs.size());</span>
			// Result TimeRange HashMap
<span class="nc" id="L1841">			HashMap trMap = new HashMap(colEmployeeIDs.size());</span>
			// ask for changes from Cache and potentially DB
<span class="nc" id="L1843">			Date dbStart = null;</span>
<span class="nc" id="L1844">			Date dbEnd = null;</span>
<span class="nc bnc" id="L1845" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc" id="L1846">				Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
<span class="nc" id="L1847">				Date cacheStart = null;</span>
<span class="nc" id="L1848">				Date cacheEnd = null;</span>
				// if query window is within cache window, hit cache
<span class="nc bnc" id="L1850" title="All 2 branches missed.">				if (dateStart.after(cacheWindow[0])) {</span>
<span class="nc" id="L1851">					cacheStart = dateStart;</span>
<span class="nc" id="L1852">					cacheEnd = dateEnd;</span>
				} else {
					// if window falls before cache start, split into two parts
<span class="nc" id="L1855">					dbStart = dateStart;</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">					if (dateEnd.after(cacheWindow[0])) {</span>
<span class="nc" id="L1857">						cacheStart = cacheWindow[0];</span>
<span class="nc" id="L1858">						cacheEnd = dateEnd;</span>
<span class="nc" id="L1859">						dbEnd = cacheStart;</span>
					} else {
<span class="nc" id="L1861">						dbEnd = dateEnd;</span>
					}
				}
<span class="nc bnc" id="L1864" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1865">					m_cat.debug(&quot;Using cache from &quot; + cacheStart + &quot; to &quot; + cacheEnd);</span>
<span class="nc bnc" id="L1866" title="All 4 branches missed.">				if (cacheStart != null &amp;&amp; cacheEnd != null) {</span>
<span class="nc" id="L1867">					HashMap timeRecordMap = getEventsForWorkResourceFromCache(colEmployeeIDs, cacheStart, cacheEnd,</span>
							true);
<span class="nc bnc" id="L1869" title="All 2 branches missed.">					for (Iterator it = colEmployeeIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1870">						ID empID = (ID) it.next();</span>
<span class="nc" id="L1871">						ArrayList recordCol = (ArrayList) timeRecordMap.get(empID);</span>
						// convert cached changed entry to TimeRange
<span class="nc" id="L1873">						ArrayList affectedWindowCol = new ArrayList();</span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">						if (recordCol != null) {</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">							for (Iterator recordIt = recordCol.iterator(); recordIt.hasNext();) {</span>
<span class="nc" id="L1876">								TimeRecord record = (TimeRecord) recordIt.next();</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">								for (Iterator entryIt = record.getChild().iterator(); entryIt.hasNext();) {</span>
<span class="nc" id="L1878">									TimeRecordEntry entry = (TimeRecordEntry) entryIt.next();</span>
									// if entry ends after lastQuery, which
									// means it is open in last check
<span class="nc bnc" id="L1881" title="All 2 branches missed.">									if (entry.getStartTime().before(dateLastQuery)</span>
<span class="nc bnc" id="L1882" title="All 4 branches missed.">											&amp;&amp; (entry.getEndTime() == null || entry.getEndTime().after(dateLastQuery))) {</span>
<span class="nc" id="L1883">										TimeRange tr = new TimeRange(dateLastQuery,</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">												entry.getEndTime() == null ? new Date() : entry.getEndTime());</span>
<span class="nc" id="L1885">										affectedWindowCol.add(tr);</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">										if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1887">											m_cat.debug(&quot;Find entry &quot; + entry + &quot; starts before &quot; + dateLastQuery</span>
<span class="nc" id="L1888">													+ &quot; ends after &quot; + entry.getEndTime() + &quot; create TR &quot; + tr);</span>
										}
<span class="nc bnc" id="L1890" title="All 2 branches missed.">									} else if (entry.getStartTime().after(dateLastQuery)</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">											|| (entry.getLastModifiedTime() != null &amp;&amp; entry.getLastModifiedTime()</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">													.after(dateLastQuery))) {</span>
										// if entry created or modified after,
										// add the time range
<span class="nc bnc" id="L1895" title="All 2 branches missed.">										Date end = entry.getEndTime() == null ? new Date() : entry.getEndTime();</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">										if (end.before(entry.getStartTime())) {</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">											if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1898">												m_cat.debug(&quot;Abnormal case handling when entry starts &quot;</span>
<span class="nc" id="L1899">														+ entry.getStartTime() + &quot; after end time &quot; + end);</span>
											}
<span class="nc" id="L1901">											end = new Date(entry.getStartTime().getTime()</span>
													+ TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);
										}
<span class="nc" id="L1904">										TimeRange tr = new TimeRange(entry.getStartTime(), end);</span>
<span class="nc" id="L1905">										affectedWindowCol.add(tr);</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">										if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1907">											m_cat.debug(&quot;Find entry &quot; + entry + &quot; starts after &quot; + dateLastQuery</span>
													+ &quot; create TR &quot; + tr);
										}
									}
<span class="nc" id="L1911">								}</span>
<span class="nc" id="L1912">							}</span>
						}
<span class="nc" id="L1914">						eventMap.put(empID, affectedWindowCol);</span>
<span class="nc" id="L1915">					}</span>
				}
<span class="nc" id="L1917">			} else {</span>
<span class="nc" id="L1918">				dbStart = dateStart;</span>
<span class="nc" id="L1919">				dbEnd = DateAdjustmentUtil.adjustEndDateForDemo(dateEnd, m_ignoreFutureData);</span>
			}
			// Track employees has no entries from DB, if they are not logged
			// in, we won't return changed interval
<span class="nc" id="L1923">			HashSet empSet = new HashSet(colEmployeeIDs.size());</span>
			// if need access DB to figure out changed window, we will just
			// query TimeRecord window size
			// this is mostly to query real time aderence record, which hasn't
			// been touched by manager
			// HAA data is already reflected through event audit trail
			// No need consider AutoClose(3), as if there is autoclose, an
			// eventaudittrail will be created
			// No need consider HAA entries(6), an eventaudittrail will be
			// created covering the window
			// No need consider manual edit(1)
			// So consider RawEntry, MyTime, Schedule and AutoMerge
<span class="nc bnc" id="L1935" title="All 4 branches missed.">			if (dbStart != null &amp;&amp; dbEnd != null) {</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1937">					m_cat.debug(&quot;Load from DB from &quot; + dbStart + &quot; to &quot; + dbEnd);</span>
				}
<span class="nc" id="L1939">				jdmo = new Jdmo();</span>
<span class="nc" id="L1940">				String empInClause = jdmo.createInClause(colEmployeeIDs);</span>
<span class="nc" id="L1941">				StringBuffer pStmt1 = new StringBuffer(&quot;select EMPLOYEEID, ACTIVITYID, STARTTIME&quot;)</span>
<span class="nc" id="L1942">						.append(&quot; from TIMEENTRYEVENT where EMPLOYEEID in &quot;).append(empInClause)</span>
<span class="nc" id="L1943">						.append(&quot; and TIMESOURCECODE not in (1,3,6) and UPDATETIMESTAMP&gt;=&quot;).append(dbStart.getTime())</span>
<span class="nc" id="L1944">						.append(&quot; and UPDATETIMESTAMP&lt;=&quot;).append(dbEnd.getTime()).append(&quot; and (LASTMODIFIEDAT&gt;'&quot;)</span>
<span class="nc" id="L1945">						.append(JdmoUtil.formatDBString(dateLastQuery))</span>
<span class="nc" id="L1946">						.append(&quot;' or LASTMODIFIEDAT is null) order by EMPLOYEEID, UPDATETIMESTAMP asc&quot;);</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1948">					m_cat.debug(&quot;Load changed entries by &quot; + pStmt1);</span>
				}
<span class="nc" id="L1950">				JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1951">				JdmoRowset rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
				// First fetch all entries
<span class="nc" id="L1953">				HashMap entryMap = new HashMap(colEmployeeIDs.size());</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">				while (rs.next()) {</span>
<span class="nc" id="L1955">					ID empID = rs.getID(&quot;EMPLOYEEID&quot;);</span>
<span class="nc" id="L1956">					ArrayList entryCol = (ArrayList) entryMap.get(empID);</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">					if (entryCol == null) {</span>
<span class="nc" id="L1958">						entryCol = new ArrayList();</span>
					}
<span class="nc" id="L1960">					TimeRecordEntry entry = new TimeRecordEntry(rs.getID(&quot;ACTIVITYID&quot;), TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L1961">							.getTimestamp(&quot;STARTTIME&quot;)), null, 0, false, null);</span>
<span class="nc" id="L1962">					entryCol.add(entry);</span>
<span class="nc" id="L1963">					entryMap.put(empID, entryCol);</span>
<span class="nc" id="L1964">				}</span>
				// iterate the HashMap, convert modified entries to just one
				// TimeRange
<span class="nc bnc" id="L1967" title="All 2 branches missed.">				for (Iterator empIt = colEmployeeIDs.iterator(); empIt.hasNext();) {</span>
<span class="nc" id="L1968">					ID empID = (ID) empIt.next();</span>
<span class="nc" id="L1969">					ArrayList entryCol = (ArrayList) entryMap.get(empID);</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">					if (entryCol == null) {</span>
<span class="nc" id="L1971">						empSet.add(empID);</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1973">							m_cat.debug(&quot;Find no change for an employee, will check in/out status later, empID &quot;</span>
									+ empID);
						}
						continue;
					}
<span class="nc" id="L1978">					Iterator teIt = entryCol.iterator();</span>
<span class="nc" id="L1979">					TimeRecordEntry entry = (TimeRecordEntry) teIt.next();</span>
<span class="nc" id="L1980">					Date rangeStart = entry.getStartTime();</span>
<span class="nc" id="L1981">					Date rangeEnd = entry.getStartTime();</span>
<span class="nc" id="L1982">					ID lastEntryActID = entry.getActivityID();</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">					while (teIt.hasNext()) {</span>
<span class="nc" id="L1984">						TimeRecordEntry nextEntry = (TimeRecordEntry) teIt.next();</span>
<span class="nc" id="L1985">						rangeEnd = nextEntry.getStartTime();</span>
<span class="nc" id="L1986">						lastEntryActID = nextEntry.getActivityID();</span>
<span class="nc" id="L1987">					}</span>
					// if last entry is end shift, cannot determine the effected
					// window directly
					// so specify null as end time, adherence will load all
					// entries to narrow down
					// THERE is a potential bug, case like, lastcheck happens at
					// 8:05, now it is 8:20
					// entry 1 8:00
					// entry 2 8:10
					// entry 1 ends at 8:05, but we may report 8:10 to 8:20 only
					// 8:05 to 8:10 is not reported, to solve this system has to
					// look back for the last entry before 8:05
					// but if we have cache enabled, this routine only happens
					// on historical data, which is fine
<span class="nc bnc" id="L2001" title="All 2 branches missed.">					if (lastEntryActID.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L2002">						rangeEnd = null;</span>
					} else {
						// else Add one minute to start time of the last entry
						// to serve as end window
<span class="nc" id="L2006">						rangeEnd.setTime(rangeEnd.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);</span>
					}
<span class="nc bnc" id="L2008" title="All 2 branches missed.">					if (rangeEnd == null) {</span>
<span class="nc" id="L2009">						rangeEnd = new Date();</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">						if (rangeStart.after(rangeEnd)) {</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2012">								m_cat.debug(&quot;Abnormal case in deciding the TimeRange, start &quot; + rangeStart</span>
										+ &quot; is after cur time &quot; + rangeEnd);
							}
<span class="nc" id="L2015">							rangeEnd = new Date(rangeStart.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);</span>
						}
					}
<span class="nc" id="L2018">					TimeRange tr = new TimeRange(rangeStart, rangeEnd);</span>
<span class="nc" id="L2019">					ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L2020">					list.add(tr);</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2022">						m_cat.debug(&quot;Converted entries to &quot; + tr);</span>
					}
<span class="nc" id="L2024">					eventMap.put(empID, list);</span>
<span class="nc" id="L2025">				}</span>
			}
			// check employees without entries in/out status, for in employee,
			// guess a range
<span class="nc bnc" id="L2029" title="All 2 branches missed.">			if (!empSet.isEmpty()) {</span>
<span class="nc" id="L2030">				Collection inEmp = whoIsIn(empSet, false);</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">				for (Iterator it = inEmp.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2032">					ID empID = (ID) it.next();</span>
					// Cannot determine the change window just add last Query to
					// curDate
<span class="nc" id="L2035">					TimeRange tr = new TimeRange(dateLastQuery, new Date());</span>
<span class="nc" id="L2036">					ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L2037">					list.add(tr);</span>
<span class="nc" id="L2038">					eventMap.put(empID, list);</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2040">						m_cat.debug(&quot;Find no change for a logged in employee, guess a tr &quot; + tr);</span>
					}
<span class="nc" id="L2042">				}</span>
			}
			// last step merge two TimeRange collection from EventAuditTrail and
			// Entry
<span class="nc bnc" id="L2046" title="All 2 branches missed.">			for (Iterator it = colEmployeeIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2047">				ID empID = (ID) it.next();</span>
				// result of merge
<span class="nc" id="L2049">				ArrayList timeRangeCol = new ArrayList();</span>
				// container to merge two lists of Time Range
<span class="nc" id="L2051">				ArrayList timeWindowCol = new ArrayList();</span>
<span class="nc" id="L2052">				ArrayList auditWindowCol = (ArrayList) auditMap.get(empID);</span>
<span class="nc bnc" id="L2053" title="All 2 branches missed.">				if (auditWindowCol != null) {</span>
<span class="nc" id="L2054">					timeWindowCol.addAll(auditWindowCol);</span>
				}
<span class="nc" id="L2056">				ArrayList affectedWindowCol = (ArrayList) eventMap.get(empID);</span>
<span class="nc bnc" id="L2057" title="All 2 branches missed.">				if (affectedWindowCol != null) {</span>
<span class="nc" id="L2058">					timeWindowCol.addAll(affectedWindowCol);</span>
				}
<span class="nc bnc" id="L2060" title="All 2 branches missed.">				if (timeWindowCol.isEmpty()) {</span>
<span class="nc" id="L2061">					continue;</span>
				}
				// sort both ranges
<span class="nc" id="L2064">				Collections.sort(timeWindowCol);</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2066">					m_cat.debug(&quot;Merged tr &quot; + timeWindowCol);</span>
				// iterate the collection
<span class="nc" id="L2068">				Iterator li = timeWindowCol.iterator();</span>
<span class="nc" id="L2069">				TimeRange entry = (TimeRange) li.next();</span>
<span class="nc" id="L2070">				Date windowStart = entry.getStartDate();</span>
<span class="nc" id="L2071">				Date windowEnd = entry.getEndDate();</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">				while (li.hasNext()) {</span>
					// get next entry
<span class="nc" id="L2074">					entry = (TimeRange) li.next();</span>
					// if existing window ends before current entry start,
					// create a range
<span class="nc bnc" id="L2077" title="All 4 branches missed.">					if (windowEnd != null &amp;&amp; windowEnd.before(entry.getStartDate())) {</span>
<span class="nc" id="L2078">						TimeRange tr = new TimeRange(windowStart, windowEnd);</span>
<span class="nc" id="L2079">						timeRangeCol.add(tr);</span>
<span class="nc" id="L2080">						windowStart = entry.getStartDate();</span>
<span class="nc" id="L2081">						windowEnd = entry.getEndDate();</span>
<span class="nc" id="L2082">					} else {</span>
						// there is overlap, if new entry end time is null, set
						// window end to null
<span class="nc bnc" id="L2085" title="All 2 branches missed.">						if (entry.getEndDate() == null) {</span>
<span class="nc" id="L2086">							windowEnd = null;</span>
						} else {
							// if window end is not null, new entry ends after
							// window end, set value
<span class="nc bnc" id="L2090" title="All 4 branches missed.">							if (windowEnd != null &amp;&amp; entry.getEndDate().after(windowEnd)) {</span>
<span class="nc" id="L2091">								windowEnd = entry.getEndDate();</span>
							}
						}
					}
				}
				// Add last window
<span class="nc bnc" id="L2097" title="All 2 branches missed.">				if (windowEnd == null) {</span>
<span class="nc" id="L2098">					windowEnd = new Date();</span>
				}
<span class="nc" id="L2100">				TimeRange tr = new TimeRange(windowStart, windowEnd);</span>
<span class="nc" id="L2101">				timeRangeCol.add(tr);</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2103">					m_cat.debug(&quot;final merged tr &quot; + timeRangeCol);</span>
				}
<span class="nc" id="L2105">				trMap.put(empID, timeRangeCol);</span>
<span class="nc" id="L2106">			}</span>
<span class="nc" id="L2107">			return trMap;</span>
<span class="nc" id="L2108">		} catch (JdmoException e) {</span>
<span class="nc" id="L2109">			handleException(e);</span>
<span class="nc" id="L2110">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2111">		} catch (RemoteException e) {</span>
<span class="nc" id="L2112">			handleException(e);</span>
<span class="nc" id="L2113">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2115" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L2116">				jdmo.cleanUp();</span>
			}
<span class="nc" id="L2118">			methodFinish();</span>
		}
	}

	/**
	 * Get the events from TimeRecord and TimeEntryEvent table Depend on
	 * needOpenShift to retrieve an open shift even before the given period It
	 * will look forward for any shift just before the starting point, even if
	 * it is an Open Shift scenario 1/2 00:00 - 1/3 00:00 if a shift starts at
	 * 2pm, with several activities happened just before 1/2 00:00 and there is
	 * no end shift yet, we will pick it up To speed up, we will push backward
	 * the Starting time of 24 hours
	 *
	 * @param Collection
	 *            , workResourceID
	 * @param Date
	 *            , dtStart
	 * @param Date
	 *            , dtEnd
	 * @param boolean, needOpenShift
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResourceFromCache(Collection workResourceIDCol, Date dtStart, Date dtEnd,
			boolean needOpenShift) throws BbmFinderException {
<span class="nc" id="L2143">		methodStart(&quot;getEventsForWorkResourceFromCache&quot;, workResourceIDCol, dtStart, dtEnd,</span>
<span class="nc" id="L2144">				JdmoParam.getObject(needOpenShift));</span>
		try {
			// First check the time window falls before oldest cached content
			// start time or not, if true, it won't hit any cache at all
			// just access DB directly
<span class="nc" id="L2149">			Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
			// If request starts after cached window, just return empty result
<span class="nc bnc" id="L2151" title="All 2 branches missed.">			if (dtStart.after(cacheWindow[1])) {</span>
<span class="nc" id="L2152">				return new HashMap(1);</span>
			}
			// If request ends before cached window, need retrieve directly from
			// DB
			// If cache is disabled, go to DB directly
<span class="nc bnc" id="L2157" title="All 4 branches missed.">			if (!cacheUsed() || dtEnd.before(cacheWindow[0])) {</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L2159">					m_cat.debug(&quot;Requested timewindow from &quot; + dtStart + &quot; to &quot; + dtEnd</span>
							+ &quot; is either way before cache window &quot; + cacheWindow[0] + &quot; or Cache is not used.&quot;);
				}
<span class="nc" id="L2162">				return getEventsForWorkResource(workResourceIDCol, dtStart, dtEnd, needOpenShift);</span>
			}
			// HashMap to hold TimeRecord for each workresource
<span class="nc" id="L2165">			HashMap empTRMap = new HashMap(workResourceIDCol.size());</span>
			// Track who is not in cache
<span class="nc" id="L2167">			ArrayList empMissedCol = new ArrayList();</span>
			// Track DB lookup timewindow
<span class="nc" id="L2169">			Date reloadStart = cacheWindow[0];</span>
			// Track end shift close date
<span class="nc" id="L2171">			Date curTime = new Date();</span>
<span class="nc bnc" id="L2172" title="All 2 branches missed.">			Date lastEntryCloseDate = curTime.after(dtEnd) ? dtEnd : curTime;</span>
			// Request time window falls in the cache window, hit cache first
			// This execution path is the most used one, especially from
			// Adherence backend
			// no need to check dtEnd.before(cacheWindow[1]) after we assume
			// there is no record in the future
<span class="nc bnc" id="L2178" title="All 2 branches missed.">			if (dtStart.after(cacheWindow[0])) {</span>
<span class="nc bnc" id="L2179" title="All 2 branches missed.">				for (Iterator it = workResourceIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2180">					ID empID = (ID) it.next();</span>
<span class="nc" id="L2181">					TimeRecord[] records = (TimeRecord[]) m_TimeRecordCache.get(empID);</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">					if (records == null) {</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2184">							m_cat.debug(&quot;Cache missed for workresource id &quot; + empID + &quot; from &quot; + dtStart + &quot; to &quot;</span>
									+ dtEnd);
						}
<span class="nc" id="L2187">						empMissedCol.add(empID);</span>
					} else {
<span class="nc" id="L2189">						ArrayList trCol = TimeRecordCacheUtil.convertToArrayList(records);</span>
<span class="nc bnc" id="L2190" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2191">							m_cat.debug(&quot;Cache contains following records &quot; + trCol + &quot; for workresource id &quot; + empID);</span>
						}
<span class="nc" id="L2193">						int curSize = records.length;</span>
<span class="nc" id="L2194">						ArrayList updateCache = TimeRecordCacheUtil.filterTimeRecords(trCol, cacheWindow[0], true);</span>
<span class="nc" id="L2195">						int filteredSize = updateCache.size();</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">						if (curSize != filteredSize) {</span>
							// We enhance here, to purge very old timerecords
							// from cache
							// Algorithm is like: find the timerecord cross
							// starttime of
							// the cache, put back this one and records newer
							// than it into cache
							// If all timerecords are before cache startime,
							// just put back the newest record
							// This is a cache cleanup routine for TimeRecord
							// cache
							// So there is always at least one record in the
							// cache, which
							// represents last timerecord of the employee in the
							// system
							// If there is no records in cache, it implies this
							// user has
							// never been loaded.
							// 1. Filtered out obsolete records based on cache
							// window
<span class="nc" id="L2216">							TimeRecordCacheUtil.purgeCache(m_TimeRecordCache, empID, cacheWindow[0]);</span>
						}
<span class="nc bnc" id="L2218" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2219">							m_cat.debug(&quot;Put back records &quot; + updateCache + &quot; to cache for workresource id &quot; + empID);</span>
						}
						// 2. Filtered by request window, and also close open
						// time records
<span class="nc" id="L2223">						ArrayList returnedCache = TimeRecordCacheUtil.closeOpenTimeRecords(</span>
<span class="nc" id="L2224">								TimeRecordCacheUtil.filterTimeRecords(trCol, dtStart, false), lastEntryCloseDate);</span>
<span class="nc" id="L2225">						empTRMap.put(empID, returnedCache);</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2227">							m_cat.debug(&quot;Return records &quot; + returnedCache + &quot; for workresource id &quot; + empID);</span>
						}
					}
<span class="nc" id="L2230">				}</span>
			} else {
				// Last scenario is start window is before cache start, we will
				// just reload full cache
<span class="nc" id="L2234">				empMissedCol = new ArrayList(workResourceIDCol);</span>
<span class="nc" id="L2235">				reloadStart = dtStart;</span>
			}
<span class="nc bnc" id="L2237" title="All 2 branches missed.">			if (!empMissedCol.isEmpty()) {</span>
<span class="nc bnc" id="L2238" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L2239">					m_cat.debug(&quot;Need load timerecords for &quot; + empMissedCol + &quot; from &quot; + reloadStart + &quot; to &quot;</span>
							+ cacheWindow[1]);
				}
				// Now we load bigger timewindow
<span class="nc" id="L2243">				Timestamp startFrom = TimeZoneUtil</span>
<span class="nc" id="L2244">						.toTimestamp(new Date(reloadStart.getTime() - getConfigData(LOOKBACK)));</span>
<span class="nc" id="L2245">				HashMap missedTRMap = getEventsForWorkResourceWithOpenShift(empMissedCol, startFrom,</span>
<span class="nc" id="L2246">						TimeZoneUtil.toTimestamp(cacheWindow[1]));</span>
<span class="nc bnc" id="L2247" title="All 2 branches missed.">				for (Iterator it = empMissedCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2248">					ID empID = (ID) it.next();</span>
<span class="nc" id="L2249">					ArrayList trCol = (ArrayList) missedTRMap.get(empID);</span>
<span class="nc bnc" id="L2250" title="All 4 branches missed.">					if (trCol == null || trCol.isEmpty()) {</span>
						// put a dummy timerecord into cache, to avoid reload
						// it will be removed in any valid add timerecord
						// operation
<span class="nc bnc" id="L2254" title="All 2 branches missed.">						if (trCol == null) {</span>
<span class="nc" id="L2255">							trCol = new ArrayList(1);</span>
						}
<span class="nc" id="L2257">						trCol.add(new TimeRecord(empID));</span>
						// return empty collection
<span class="nc" id="L2259">						empTRMap.put(empID, new ArrayList(1));</span>
					} else {
						// filter out records not in request time window
<span class="nc" id="L2262">						empTRMap.put(empID, TimeRecordCacheUtil.closeOpenTimeRecords(</span>
<span class="nc" id="L2263">								TimeRecordCacheUtil.filterTimeRecords(trCol, dtStart, false), lastEntryCloseDate));</span>
					}
					// put back into cache
<span class="nc" id="L2266">					m_TimeRecordCache.put(empID, TimeRecordCacheUtil.convertToArray(TimeRecordCacheUtil</span>
<span class="nc" id="L2267">							.filterTimeRecords(trCol, cacheWindow[0], true)));</span>
<span class="nc" id="L2268">				}</span>
<span class="nc" id="L2269">			} else {</span>
<span class="nc" id="L2270">				return empTRMap;</span>
			}
<span class="nc" id="L2272">			return empTRMap;</span>
<span class="nc" id="L2273">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2274">			handleException(e, false);</span>
<span class="nc" id="L2275">			throw e;</span>
<span class="nc" id="L2276">		} catch (Exception e) {</span>
<span class="nc" id="L2277">			handleException(e, false);</span>
<span class="nc" id="L2278">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2280">			methodFinish();</span>
		}
	}

	/**
	 * Explicitly refresh cache for one user
	 * 
	 * @param Collection
	 *            , WorkResourceID
	 */
	public void refreshCacheForWorkResource(Collection workResourceIDCol) throws BbmFinderException {
<span class="nc" id="L2291">		methodStart(&quot;refreshCacheForWorkResource&quot;, workResourceIDCol);</span>
<span class="nc bnc" id="L2292" title="All 2 branches missed.">		if (cacheUsed()) {</span>
			try {
<span class="nc bnc" id="L2294" title="All 2 branches missed.">				if (m_TimeRecordCache != null) {</span>
					// Now we load bigger timewindow
<span class="nc" id="L2296">					Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
<span class="nc" id="L2297">					Timestamp startFrom = TimeZoneUtil.toTimestamp(new Date(cacheWindow[0].getTime()</span>
<span class="nc" id="L2298">							- getConfigData(LOOKBACK)));</span>
<span class="nc" id="L2299">					HashMap trMap = getEventsForWorkResourceWithOpenShift(workResourceIDCol, startFrom,</span>
<span class="nc" id="L2300">							TimeZoneUtil.toTimestamp(cacheWindow[1]));</span>
<span class="nc bnc" id="L2301" title="All 2 branches missed.">					for (Iterator it = workResourceIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2302">						ID workResourceID = (ID) it.next();</span>
<span class="nc" id="L2303">						ArrayList trCol = (ArrayList) trMap.get(workResourceID);</span>
<span class="nc bnc" id="L2304" title="All 4 branches missed.">						if (trCol == null || trCol.isEmpty()) {</span>
							// put a dummy timerecord into cache, to avoid
							// reload
							// it will be removed in any valid add timerecord
							// operation
<span class="nc bnc" id="L2309" title="All 2 branches missed.">							if (trCol == null) {</span>
<span class="nc" id="L2310">								trCol = new ArrayList(1);</span>
							}
<span class="nc" id="L2312">							trCol.add(new TimeRecord(workResourceID));</span>
						}
						// put back into cache
<span class="nc" id="L2315">						m_TimeRecordCache.put(workResourceID, TimeRecordCacheUtil.convertToArray(TimeRecordCacheUtil</span>
<span class="nc" id="L2316">								.filterTimeRecords(trCol, cacheWindow[0], true)));</span>
<span class="nc" id="L2317">					}</span>
				}
<span class="nc bnc" id="L2319" title="All 2 branches missed.">				if (m_LastEntryCache != null) {</span>
<span class="nc" id="L2320">					Collection entryCol = TimeRecordDAO.findLastEntry(workResourceIDCol, new Date(),</span>
							m_LookBackTimeEntryDays);
<span class="nc bnc" id="L2322" title="All 2 branches missed.">					for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2323">						TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L2324">						m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
<span class="nc" id="L2325">						workResourceIDCol.remove(entry.getEmployeeID());</span>
<span class="nc" id="L2326">					}</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">					for (Iterator it = workResourceIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2328">						ID empID = (ID) it.next();</span>
<span class="nc" id="L2329">						m_LastEntryCache.put(empID, new TimeRecordEntry());</span>
<span class="nc" id="L2330">					}</span>
				}
<span class="nc" id="L2332">			} catch (JdmoException e) {</span>
<span class="nc" id="L2333">				handleException(e, false);</span>
<span class="nc" id="L2334">				throw new BbmFinderException(e);</span>
			} finally {
<span class="nc" id="L2336">				methodFinish();</span>
<span class="nc" id="L2337">			}</span>
		}
<span class="nc" id="L2339">	}</span>

	/**
	 * Get the events from TimeRecord and TimeEntryEvent table Depend on
	 * needOpenShift to retrieve an open shift even before the given period It
	 * will look forward for any shift just before the starting point, even if
	 * it is an Open Shift scenario 1/2 00:00 - 1/3 00:00 if a shift starts at
	 * 2pm, with several activities happened just before 1/2 00:00 and there is
	 * no end shift yet, we will pick it up To speed up, we will push backward
	 * the Starting time of 24 hours
	 *
	 * @param Collection
	 *            , workResourceID
	 * @param Date
	 *            , dtStart
	 * @param Date
	 *            , dtEnd
	 * @param boolean, needOpenShift
	 * @return HashMap
	 * @exception BbmFinderException
	 * @deprecated
	 */
	public HashMap getEventsForWorkResource(Collection workResourceID, Date dtStart, Date dtEnd, boolean needOpenShift)
			throws BbmFinderException {
<span class="nc" id="L2363">		methodStart(&quot;getEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd, JdmoParam.getObject(needOpenShift));</span>
		try {
<span class="nc bnc" id="L2365" title="All 2 branches missed.">			if (!needOpenShift) {</span>
<span class="nc" id="L2366">				return getEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2367">						TimeZoneUtil.toTimestamp(dtEnd));</span>
			}

			// We expand window 24 hours earlier
<span class="nc" id="L2371">			HashMap map = getEventsForWorkResource(workResourceID,</span>
<span class="nc" id="L2372">					TimeZoneUtil.toTimestamp(new Date(dtStart.getTime() - getConfigData(LOOKBACK))),</span>
<span class="nc" id="L2373">					TimeZoneUtil.toTimestamp(dtEnd));</span>
			// for 1/2 00:00 - 1/3 00:00, the window is 1/1 00:00 - 1/3 00:00
			// and remove those shifts will end before 1/2 00:00
			// If there is 1/1 7am-8am-9am open shift, 1/1 10pm-11pm-1/2 1am end
			// shift
			// the first open shift will still be removed,
			// coz the second is the closest cross boundary shift
<span class="nc" id="L2380">			Date curTime = new Date();</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">			Date lastEntryCloseDate = curTime.after(dtEnd) ? dtEnd : curTime;</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">			for (Iterator itWR = workResourceID.iterator(); itWR.hasNext();) {</span>
<span class="nc" id="L2383">				ID empID = (ID) itWR.next();</span>
<span class="nc" id="L2384">				ArrayList trCol = (ArrayList) map.get(empID);</span>
				// it doesn't care about the latest timerecord if it is totally
				// out of the timewindow
				try {
<span class="nc" id="L2388">					map.put(empID,</span>
<span class="nc" id="L2389">							TimeRecordCacheUtil.closeOpenTimeRecords(</span>
<span class="nc" id="L2390">									TimeRecordCacheUtil.filterTimeRecords(trCol, dtStart, false), lastEntryCloseDate));</span>
<span class="nc" id="L2391">				} catch (Exception e) {</span>
<span class="nc" id="L2392">					m_cat.debug(e);</span>
<span class="nc" id="L2393">				}</span>
<span class="nc" id="L2394">			}</span>
<span class="nc" id="L2395">			return map;</span>
		} finally {
<span class="nc" id="L2397">			methodFinish();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param Collection
	 *            of workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResource(Collection workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2413">		return getEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2414">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param Collection
	 *            of workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResource(Collection workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="fc" id="L2429">		methodStart(&quot;getEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd);</span>
<span class="fc" id="L2430">		Jdmo jdmo = null;</span>
<span class="fc" id="L2431">		JdmoRowset rs = null;</span>
		try {
<span class="pc bpc" id="L2433" title="4 of 8 branches missed.">			if (workResourceID == null || workResourceID.isEmpty() || dtStart == null || dtEnd == null)</span>
<span class="nc" id="L2434">				return new HashMap(0);</span>
<span class="fc" id="L2435">			Timestamp endTime = DateAdjustmentUtil.adjustEndTimeForDemo(dtEnd, m_ignoreFutureData);</span>
<span class="fc" id="L2436">			HashMap timeRecords = new HashMap(workResourceID.size());</span>
<span class="fc" id="L2437">			jdmo = new Jdmo();</span>
<span class="fc" id="L2438">			String empInClause = jdmo.createInClause(workResourceID);</span>
<span class="fc" id="L2439">			StringBuffer pStmt1 = new StringBuffer(</span>
					&quot;select B.TIMERECORDID, B.ID, B.EMPLOYEEID, B.DATASOURCEID, ISPAID, ACTIVITYID, STARTTIME, &quot;)
<span class="fc" id="L2441">					.append(&quot;UPDATETIMESTAMP from &quot;).append(&quot;TIMEENTRYEVENT B where B.EMPLOYEEID in &quot;)</span>
<span class="fc" id="L2442">					.append(empInClause).append(&quot; and B.UPDATETIMESTAMP&lt;=&quot;).append(endTime.getTime())</span>
<span class="fc" id="L2443">					.append(&quot; and B.UPDATETIMESTAMP&gt;=&quot;).append(dtStart.getTime())</span>
<span class="fc" id="L2444">					.append(&quot; order by B.EMPLOYEEID, B.TIMERECORDID, B.UPDATETIMESTAMP asc&quot;);</span>
<span class="fc" id="L2445">			JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L2446">			rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L2447">			ArrayList trArray = null;</span>
<span class="pc bpc" id="L2448" title="1 of 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2449">				ID empID = rs.getID(&quot;EMPLOYEEID&quot;);</span>
<span class="nc" id="L2450">				trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L2451" title="All 2 branches missed.">				if (trArray == null)</span>
<span class="nc" id="L2452">					trArray = new ArrayList();</span>
<span class="nc" id="L2453">				ID key = rs.getID(1);</span>
<span class="nc" id="L2454">				TimeRecord parent = null;</span>
<span class="nc" id="L2455">				TimeRecord previous = null;</span>
<span class="nc" id="L2456">				int last = trArray.size();</span>
<span class="nc bnc" id="L2457" title="All 2 branches missed.">				if (last == 0) {</span>
<span class="nc" id="L2458">					parent = new TimeRecord(key, empID, null, null, null, null, null, false, false);</span>
<span class="nc" id="L2459">					trArray.add(parent);</span>
<span class="nc" id="L2460">					previous = parent;</span>
				} else {
<span class="nc" id="L2462">					previous = (TimeRecord) trArray.get(last - 1);</span>
				}
				// if it is a new timerecord
<span class="nc bnc" id="L2465" title="All 2 branches missed.">				if (!previous.getID().equals(key)) {</span>
<span class="nc" id="L2466">					parent = new TimeRecord(key, empID, null, null, null, null, null, false, false);</span>
<span class="nc" id="L2467">					trArray.add(parent);</span>
				} else {
					// if it is not a new timerecord
<span class="nc" id="L2470">					parent = previous;</span>
				}
<span class="nc" id="L2472">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L2473">				TimeRecordEntry entry = new TimeRecordEntry(rs.getID(2), null, rs.getID(&quot;ACTIVITYID&quot;),</span>
<span class="nc" id="L2474">						rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart, new Date(rs.getLong(&quot;UPDATETIMESTAMP&quot;)),</span>
<span class="nc" id="L2475">						TimeRecordEntry.RAWPUNCH, rs.getBoolean(&quot;ISPAID&quot;), null, parent);</span>
				// do this explicitly to overcome WLS serilization bug
<span class="nc" id="L2477">				entry.setEmployeeID(empID);</span>
<span class="nc" id="L2478">				ArrayList temp = parent.getChild();</span>
				// need to set the previous entry's endtime
<span class="nc bnc" id="L2480" title="All 2 branches missed.">				if (!temp.isEmpty()) {</span>
<span class="nc" id="L2481">					TimeRecordEntry lastEntry = (TimeRecordEntry) temp.get(temp.size() - 1);</span>
<span class="nc" id="L2482">					lastEntry.setEndTime(entryStart);</span>
				}
				// add the new entry directly
<span class="nc" id="L2485">				parent.getChild().add(entry);</span>
				// last step is to put it in the hashmap
<span class="nc" id="L2487">				timeRecords.put(empID, trArray);</span>
<span class="nc" id="L2488">			}</span>
			// Last step is to iterate the TimeRecordEntries to set the open
			// shift
<span class="fc" id="L2491">			Date currentTime = new Date();</span>
<span class="fc" id="L2492">			Date closerEnd = currentTime;</span>
<span class="pc bpc" id="L2493" title="1 of 2 branches missed.">			if (currentTime.after(endTime)) {</span>
<span class="fc" id="L2494">				closerEnd = TimeZoneUtil.toDate(endTime);</span>
			}
<span class="fc bfc" id="L2496" title="All 2 branches covered.">			for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="fc" id="L2497">				ArrayList records = (ArrayList) timeRecords.get(it.next());</span>
<span class="pc bpc" id="L2498" title="3 of 4 branches missed.">				if (records != null &amp;&amp; !records.isEmpty()) {</span>
					// In-Memory sort is a MUST step to gurantee Open-Shift
					// closure
<span class="nc" id="L2501">					Collections.sort(records);</span>
<span class="nc" id="L2502">					TimeRecordEntry candidate = null;</span>
<span class="nc bnc" id="L2503" title="All 2 branches missed.">					for (Iterator itTR = records.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L2504">						TimeRecord tr = (TimeRecord) itTR.next();</span>
<span class="nc bnc" id="L2505" title="All 2 branches missed.">						if (candidate != null) {</span>
							// Prevention check, shouldn't adjust it to the time
							// before start time
							// This might happen if the timerecords have overlap
<span class="nc bnc" id="L2509" title="All 2 branches missed.">							if (candidate.getStartTime().before(tr.getStartTime())) {</span>
<span class="nc" id="L2510">								candidate.setEndTime(tr.getStartTime());</span>
							}
<span class="nc" id="L2512">							candidate = null;</span>
						}
<span class="nc" id="L2514">						ArrayList entries = tr.getChild();</span>
<span class="nc bnc" id="L2515" title="All 4 branches missed.">						if (entries == null || entries.isEmpty()) {</span>
<span class="nc" id="L2516">							continue;</span>
						}
						// Get last entry
<span class="nc" id="L2519">						TimeRecordEntry entry = (TimeRecordEntry) entries.get(entries.size() - 1);</span>
<span class="nc bnc" id="L2520" title="All 2 branches missed.">						if (entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L2521">							continue;</span>
						}
<span class="nc" id="L2523">						candidate = entry;</span>
<span class="nc" id="L2524">						tr.setNeedCal();</span>
<span class="nc" id="L2525">					}</span>
					// If there is an open shift, with no new shift after it
					// Adjust it to the time window's end time
<span class="nc bnc" id="L2528" title="All 2 branches missed.">					if (candidate != null) {</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">						if (candidate.getStartTime().before(closerEnd)) {</span>
<span class="nc" id="L2530">							candidate.setEndTime(closerEnd);</span>
						}
					}
				}
<span class="fc" id="L2534">			}</span>
<span class="fc" id="L2535">			return timeRecords;</span>
<span class="nc" id="L2536">		} catch (JdmoException e) {</span>
<span class="nc" id="L2537">			handleException(e, false);</span>
<span class="nc" id="L2538">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L2540" title="5 of 6 branches missed.">			if (rs != null)</span>
				try {
<span class="pc" id="L2542">					rs.close();</span>
<span class="nc" id="L2543">				} catch (Exception e) {</span>
<span class="nc bnc" id="L2544" title="All 6 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2545">						m_cat.debug(e);</span>
<span class="pc" id="L2546">				}</span>
<span class="pc bpc" id="L2547" title="5 of 6 branches missed.">			if (jdmo != null)</span>
<span class="pc" id="L2548">				jdmo.cleanUp();</span>
<span class="pc" id="L2549">			methodFinish();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getEventsForWorkResource(ID workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="fc" id="L2564">		methodStart(&quot;getEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd);</span>
<span class="pc bpc" id="L2565" title="3 of 6 branches missed.">		if (workResourceID == null || dtStart == null || dtEnd == null)</span>
<span class="nc" id="L2566">			return Collections.EMPTY_LIST;</span>
		try {
<span class="fc" id="L2568">			ArrayList array = new ArrayList(1);</span>
<span class="fc" id="L2569">			array.add(workResourceID);</span>
<span class="fc" id="L2570">			HashMap map = getEventsForWorkResource(array, dtStart, dtEnd);</span>
<span class="fc" id="L2571">			return (Collection) map.get(workResourceID);</span>
		} finally {
<span class="pc" id="L2573">			methodFinish();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L2587">		return getEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="fc" id="L2588">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	} // getEventsForWorkResource

	/**
	 * Returns TimeRecord objects given its ID
	 *
	 * @param ID
	 *            timeRecordID
	 * @return TimeRecord
	 * @exception BbmObjectNotFoundException
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public TimeRecord getTimeRecordByID(ID timeRecordID) throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L2602">		methodStart(&quot;getTimeRecordByID&quot;, timeRecordID);</span>
		try {
<span class="nc" id="L2604">			TimeRecord record = TimeRecordDAO.getTimeRecordByID(timeRecordID);</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">			if (record != null)</span>
<span class="nc" id="L2606">				record.isOpenShift();</span>
<span class="nc" id="L2607">			return record;</span>
<span class="nc" id="L2608">		} catch (JdmoException e) {</span>
<span class="nc" id="L2609">			handleException(e, false);</span>
<span class="nc" id="L2610">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2612">			methodFinish();</span>
		}
	} // getTimeRecordByID

	/**
	 * Returns TimeRecordEntry objects given an employee ID, note the duration
	 * is always 0
	 *
	 * @param timeRecordEntryID
	 * @return TimeRecordEntry
	 * @exception BbmObjectNotFoundException
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public TimeRecordEntry getTimeRecordEntryByID(ID timeRecordEntryID) throws BbmObjectNotFoundException,
			BbmFinderException {
<span class="nc" id="L2628">		methodStart(&quot;getTimeRecordEntryByID&quot;, timeRecordEntryID);</span>
<span class="nc" id="L2629">		Jdmo jdmo = null;</span>
<span class="nc" id="L2630">		JdmoRowset rs = null;</span>
		try {
<span class="nc" id="L2632">			jdmo = new Jdmo();</span>
<span class="nc" id="L2633">			StringBuffer sb = new StringBuffer(</span>
					&quot;select A.ISPAID, A.DESCRIPTION, C.NAME, D.ID, D.NAME, RAWTIMEENTRYID, ACTIVITYID, TIMERECORDID, TIMESOURCECODE, STARTTIME, UPDATETIMESTAMP, DATASOURCEID FROM TIMEENTRYEVENT A, ACTIVITY C, ACTIVITYCATEGORY D WHERE A.ACTIVITYID = C.ID and D.ID&quot;);
<span class="nc" id="L2635">			sb.append(jdmo.getOuterJoin());</span>
<span class="nc" id="L2636">			sb.append(&quot; C.ACTIVITYCATEGORYID and A.ID=&quot;);</span>
<span class="nc" id="L2637">			sb.append(timeRecordEntryID);</span>
<span class="nc" id="L2638">			rs = jdmo.createRowset(sb.toString());</span>
<span class="nc" id="L2639">			TimeRecordEntry entry = null;</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L2641">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L2642">				entry = new TimeRecordEntry(timeRecordEntryID, rs.getID(&quot;RAWTIMEENTRYID&quot;), rs.getID(&quot;ACTIVITYID&quot;),</span>
<span class="nc" id="L2643">						rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart, new Date(rs.getBigDecimal(&quot;UPDATETIMESTAMP&quot;)</span>
<span class="nc" id="L2644">								.longValue()), rs.getInt(&quot;TIMESOURCECODE&quot;), rs.getBoolean(1), rs.getString(2),</span>
<span class="nc" id="L2645">						getTimeRecordByID(rs.getID(&quot;TIMERECORDID&quot;)));</span>
<span class="nc" id="L2646">				entry.setActivityName(rs.getString(3));</span>
<span class="nc" id="L2647">				entry.setActivityCategoryID(rs.getID(4));</span>
<span class="nc" id="L2648">				entry.setActivityCategoryName(rs.getString(5));</span>
			}
<span class="nc" id="L2650">			return entry;</span>
<span class="nc" id="L2651">		} catch (JdmoException e) {</span>
<span class="nc" id="L2652">			handleException(e, false);</span>
<span class="nc" id="L2653">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2655" title="All 4 branches missed.">			if (rs != null)</span>
				try {
<span class="nc" id="L2657">					rs.close();</span>
<span class="nc" id="L2658">				} catch (Exception e) {</span>
<span class="nc bnc" id="L2659" title="All 4 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2660">						m_cat.debug(e);</span>
<span class="nc" id="L2661">				}</span>
<span class="nc bnc" id="L2662" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L2663">				jdmo.cleanUp();</span>
			}
<span class="nc" id="L2665">			methodFinish();</span>
		}
	} // getTimeRecordEntryByID

	/**
	 * Gets the Valid full TimeRecords for TimeRecord Export
	 *
	 * @param Collection
	 *            workResourceID collection
	 * @param Date
	 *            dtStart
	 * @param Date
	 *            dtEnd
	 * @param boolean, need aggregate timerecord
	 * @param int, how to handle overlap
	 * @return HashMap, Keyed by WorkResourceID and associated collection of
	 *         timerecords
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public HashMap getValidEventsForTRE(Collection workResourceIDCol, Date dtStart, Date dtEnd, boolean aggregate,
			int overlap) throws BbmFinderException {
<span class="nc bnc" id="L2687" title="All 2 branches missed.">		methodStart(&quot;getValidEventsForTRE&quot;, workResourceIDCol, dtStart, dtEnd,</span>
<span class="nc" id="L2688">				aggregate ? Boolean.TRUE : Boolean.FALSE, NumberFactory.newInteger(overlap));</span>
<span class="nc" id="L2689">		HashMap trMap = null;</span>
		try {
<span class="nc" id="L2691">			trMap = getValidEventsForWorkResource(workResourceIDCol, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2692">					TimeZoneUtil.toTimestamp(dtEnd));</span>

<span class="nc" id="L2694">		} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L2695">			trMap = (HashMap) e.getContent();</span>
<span class="nc" id="L2696">		}</span>
		try {
<span class="nc bnc" id="L2698" title="All 2 branches missed.">			for (Iterator wrIt = workResourceIDCol.iterator(); wrIt.hasNext();) {</span>
<span class="nc" id="L2699">				ID wrID = (ID) wrIt.next();</span>
<span class="nc" id="L2700">				Collection trCol = (Collection) trMap.get(wrID);</span>
<span class="nc bnc" id="L2701" title="All 4 branches missed.">				if (trCol != null &amp;&amp; !trCol.isEmpty()) {</span>
<span class="nc bnc" id="L2702" title="All 2 branches missed.">					for (Iterator trIt = trCol.iterator(); trIt.hasNext();) {</span>
<span class="nc" id="L2703">						TimeRecord tr = (TimeRecord) trIt.next();</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">						if (StateChange.isInPeriod(tr, dtStart, dtEnd, overlap)) {</span>
							// if no need split TR and falls in the window based
							// on overlap rule keep the tr
<span class="nc bnc" id="L2707" title="All 2 branches missed.">							if (aggregate) {</span>
								// if need aggregate timerecord, then do it
<span class="nc" id="L2709">								tr.setType(TimeRecord.AGG_TIMEENTRY);</span>
<span class="nc" id="L2710">								ArrayList entries = tr.getChild();</span>
<span class="nc" id="L2711">								LinkedList newChild = new LinkedList();</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">								for (Iterator itTRE = entries.iterator(); itTRE.hasNext();) {</span>
<span class="nc" id="L2713">									TimeRecordEntry tre = (TimeRecordEntry) itTRE.next();</span>
<span class="nc" id="L2714">									ID actID = tre.getActivityCategoryID();</span>
<span class="nc bnc" id="L2715" title="All 2 branches missed.">									if (!newChild.isEmpty()) {</span>
<span class="nc" id="L2716">										TimeRecordEntry treLast = (TimeRecordEntry) newChild.getLast();</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">										if (treLast.getActivityCategoryID().equals(actID)</span>
<span class="nc bnc" id="L2718" title="All 2 branches missed.">												&amp;&amp; treLast.getPaid() == tre.getPaid()) {</span>
<span class="nc" id="L2719">											treLast.setEndTime(tre.getEndTime());</span>
<span class="nc" id="L2720">											treLast.addNumOfEntries();</span>
											// UI will display multi creators
											// involved in the aggregated view
<span class="nc bnc" id="L2723" title="All 2 branches missed.">											if (treLast.getTimeSourceCode() != tre.getTimeSourceCode()) {</span>
<span class="nc" id="L2724">												treLast.setTimeSourceCode(TimeEntrySourceCode.MULTI);</span>
											}
										} else {
<span class="nc" id="L2727">											newChild.add(tre);</span>
										}
<span class="nc" id="L2729">									} else {</span>
<span class="nc" id="L2730">										newChild.add(tre);</span>
									}
<span class="nc" id="L2732">								}</span>
<span class="nc" id="L2733">								tr.replaceChild(new ArrayList(newChild));</span>
<span class="nc" id="L2734">							}</span>
							continue;
						}
<span class="nc" id="L2737">						trIt.remove();</span>
<span class="nc" id="L2738">					}</span>
				}
<span class="nc" id="L2740">			}</span>
<span class="nc" id="L2741">			return trMap;</span>
		} finally {
<span class="nc" id="L2743">			methodFinish();</span>
		}
	}

	/**
	 * Gets the Valid TimeRecords for workResource
	 *
	 * @param Collection
	 *            workResourceID collection
	 * @param Date
	 *            dtStart
	 * @param Date
	 *            dtEnd
	 * @return HashMap, Keyed by WorkResourceID and associated collection of
	 *         timerecords
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public HashMap getValidEventsForWorkResource(Collection workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2763">		return getValidEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2764">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	}

	/**
	 * Gets the Valid TimeRecords for workResource
	 *
	 * @param Collection
	 *            workResourceID collection
	 * @param Timestamp
	 *            dtStart
	 * @param Timestamp
	 *            dtEnd
	 * @return HashMap, Keyed by WorkResourceID and associated collection of
	 *         timerecords
	 * @exception BbmFinderException
	 * @exception RemoteException
	 *                If there is such records, order by timerecordid,
	 *                starttime, which complains 202 overlap 204, wrong! 204
	 *                4/15 9:45pm 204 4/15 9:55pm 202 4/15 8:00am 202 4/15
	 *                9:00pm 203 4/15 7:00pm 203 4/15 9:30pm It shouldn't
	 *                retreive as, order by starttime, timerecordid 202 4/15
	 *                8:00am 203 4/15 7:00pm 202 4/15 9:00pm 203 4/15 9:30pm 204
	 *                4/15 9:45pm 204 4/15 9:55pm The routine has to retrieve
	 *                timerecord in group first, then sort on starttime in
	 *                memory to detect overlap.
	 */
	public HashMap getValidEventsForWorkResource(Collection workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="fc" id="L2792">		methodStart(&quot;getValidEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd);</span>
<span class="fc" id="L2793">		Jdmo jdmo = null;</span>
<span class="fc" id="L2794">		JdmoRowset rs = null;</span>
<span class="fc" id="L2795">		boolean valid = true;</span>
<span class="fc" id="L2796">		long threadID = Thread.currentThread().getId();</span>
<span class="fc" id="L2797">		String tempTable = &quot;EMP&quot; + threadID;</span>
<span class="fc" id="L2798">		String empIDTempTable = &quot;TIMERECORDEMPID&quot; + threadID;</span>
<span class="fc" id="L2799">		ArrayList overlappedTimeRecord = new ArrayList();</span>
<span class="fc" id="L2800">		Timestamp endTime = DateAdjustmentUtil.adjustEndTimeForDemo(dtEnd, m_ignoreFutureData);</span>
		try {
<span class="pc bpc" id="L2802" title="3 of 6 branches missed.">			if (workResourceID == null || dtStart == null || endTime == null)</span>
<span class="nc" id="L2803">				return null;</span>
			// Fetch Employee Name first
<span class="fc" id="L2805">			HashMap mapEmpNames = m_WorkResourceManager.getEmployeeNamesByIDs(workResourceID);</span>
<span class="fc" id="L2806">			HashMap timeRecords = new HashMap(workResourceID.size());</span>
<span class="fc" id="L2807">			jdmo = new Jdmo();</span>
			// From JDMO get real temp table name
<span class="fc" id="L2809">			String realTempTable = jdmo.getNativeTemptableName(tempTable);</span>
<span class="fc" id="L2810">			String realEmpIDTempTable = jdmo.getNativeTemptableName(empIDTempTable);</span>
			// Drop temp first
			try {
<span class="fc" id="L2813">				jdmo.dropTempTable(tempTable);</span>
<span class="fc" id="L2814">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L2815">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L2816" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2817">					m_cat.debug(e);</span>
<span class="fc" id="L2818">			}</span>
			// Create a new temp table
<span class="fc" id="L2820">			StringBuffer strSQLCreate = new StringBuffer();</span>
<span class="fc" id="L2821">			strSQLCreate.append(realTempTable).append(&quot; (ID int)&quot;);</span>
<span class="fc" id="L2822">			jdmo.createTempTable(strSQLCreate.toString());</span>
			/*
			 * CreateUniqueindex Temp_indexon #147446128568416158(ID) insertinto
			 * #EMP selectdistinct A2.ID from TIMERECORD A2 InnerJoin
			 * TIMEENTRYEVENT B2 on A2.ID=B2.TIMERECORDID Innerjoin
			 * #147446128568416158 Ton T.ID=B2.EmployeeID where
			 * B2.UPDATETIMESTAMP&lt;1474461283288 and
			 * B2.UPDATETIMESTAMP&gt;=1474346083288
			 */
			// Prepare the employee ID query portion
<span class="fc" id="L2832">			createTempTableForUniqueIntIDs(empIDTempTable, jdmo, workResourceID);</span>
<span class="fc" id="L2833">			StringBuffer pInsert = composeTimeRecordQuery(dtStart, endTime, realTempTable, realEmpIDTempTable);</span>
<span class="fc" id="L2834">			jdmo.executeCommand(pInsert.toString());</span>
<span class="fc" id="L2835">			StringBuffer pStmt1 = new StringBuffer(200);</span>
<span class="fc" id="L2836">			pStmt1.append(&quot;select A.ID, B.ID, C.NAME, D.ID, D.NAME, B.ISPAID, &quot;).append(&quot;B.DESCRIPTION, A.EMPLOYEEID, &quot;)</span>
<span class="fc" id="L2837">					.append(TimeRecordDAO.APPROVERCOLSTR).append(&quot;A.&quot;).append(TimeRecordDAO.REMAKERCOLNAME)</span>
<span class="fc" id="L2838">					.append(&quot;, A.CHANGECOUNTER, A.LASTMODIFIEDAT, REMARK, ISAPPROVED, ISPOSTED, &quot;)</span>
<span class="fc" id="L2839">					.append(&quot;CHANGESTATUS, RAWTIMEENTRYID, ACTIVITYID, B.STARTTIME, &quot;)</span>
<span class="fc" id="L2840">					.append(&quot;UPDATETIMESTAMP, TIMESOURCECODE, B.DATASOURCEID FROM TIMERECORD A, &quot;)</span>
<span class="fc" id="L2841">					.append(&quot;TIMEENTRYEVENT B, ACTIVITY C, ACTIVITYCATEGORY D, &quot;).append(realTempTable)</span>
<span class="fc" id="L2842">					.append(&quot; E where A.ID=B.TIMERECORDID and B.ACTIVITYID=C.ID and &quot;)</span>
<span class="fc" id="L2843">					.append(&quot;D.ID = C.ACTIVITYCATEGORYID and A.ID=E.ID&quot;);</span>
<span class="pc bpc" id="L2844" title="1 of 2 branches missed.">			if (m_ignoreFutureData) {</span>
<span class="nc" id="L2845">				pStmt1.append(&quot; and UPDATETIMESTAMP&lt;&quot;).append(endTime.getTime());</span>
			}
<span class="fc" id="L2847">			pStmt1.append(&quot; order by A.EMPLOYEEID, A.ID, B.UPDATETIMESTAMP asc&quot;);</span>
<span class="fc" id="L2848">			JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L2849">			rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc bfc" id="L2850" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L2851">				ID empID = rs.getID(8);</span>
<span class="fc" id="L2852">				ArrayList trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="fc bfc" id="L2853" title="All 2 branches covered.">				if (trArray == null)</span>
<span class="fc" id="L2854">					trArray = new ArrayList();</span>
<span class="fc" id="L2855">				ID key = rs.getID(1);</span>
<span class="fc" id="L2856">				TimeRecord parent = null;</span>
<span class="fc" id="L2857">				TimeRecord previous = null;</span>
<span class="fc" id="L2858">				int last = trArray.size();</span>
<span class="fc bfc" id="L2859" title="All 2 branches covered.">				if (last == 0) {</span>
<span class="fc" id="L2860">					ID remarkerID = rs.getID(TimeRecordDAO.REMAKERCOLNAME);</span>
<span class="fc" id="L2861">					parent = new TimeRecord(key, empID, remarkerID,</span>
<span class="fc" id="L2862">							TimeZoneUtil.toDate(rs.getTimestamp(&quot;LASTMODIFIEDAT&quot;)),</span>
<span class="fc" id="L2863">							rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="fc" id="L2864">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="fc" id="L2865">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="fc" id="L2866">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="fc" id="L2867">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="fc bfc" id="L2868" title="All 2 branches covered.">					if (remarkerID != null) {</span>
<span class="fc" id="L2869">						String remarkerName = getRemarkerName(remarkerID, jdmo);</span>
<span class="fc" id="L2870">						parent.setRemarkEmployeeName(remarkerName);</span>
					}
<span class="fc" id="L2872">					trArray.add(parent);</span>
<span class="fc" id="L2873">					previous = parent;</span>
<span class="fc" id="L2874">				} else</span>
<span class="fc" id="L2875">					previous = (TimeRecord) trArray.get(last - 1);</span>
				// if it is a new timerecord
<span class="fc bfc" id="L2877" title="All 2 branches covered.">				if (!previous.getID().equals(key)) {</span>
<span class="fc" id="L2878">					ID remarkerID = rs.getID(TimeRecordDAO.REMAKERCOLNAME);</span>
<span class="fc" id="L2879">					parent = new TimeRecord(key, empID, remarkerID,</span>
<span class="fc" id="L2880">							TimeZoneUtil.toDate(rs.getTimestamp(&quot;LASTMODIFIEDAT&quot;)),</span>
<span class="fc" id="L2881">							rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="fc" id="L2882">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="fc" id="L2883">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="fc" id="L2884">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="fc" id="L2885">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="pc bpc" id="L2886" title="1 of 2 branches missed.">					if (remarkerID != null) {</span>
<span class="fc" id="L2887">						String remarkerName = getRemarkerName(remarkerID, jdmo);</span>
<span class="fc" id="L2888">						parent.setRemarkEmployeeName(remarkerName);</span>
					}
<span class="fc" id="L2890">					trArray.add(parent);</span>
<span class="fc" id="L2891">				} else {</span>
					// if it is not a new timerecord
<span class="fc" id="L2893">					parent = previous;</span>
				}
<span class="fc" id="L2895">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="fc" id="L2896">				TimeRecordEntry entry = new TimeRecordEntry(rs.getID(2), rs.getID(&quot;RAWTIMEENTRYID&quot;),</span>
<span class="fc" id="L2897">						rs.getID(&quot;ACTIVITYID&quot;), rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart,</span>
<span class="fc" id="L2898">						new Date(rs.getBigDecimal(&quot;UPDATETIMESTAMP&quot;).longValue()), rs.getInt(&quot;TIMESOURCECODE&quot;),</span>
<span class="fc" id="L2899">						rs.getBoolean(&quot;ISPAID&quot;), rs.getString(7), parent);</span>
<span class="fc" id="L2900">				entry.setActivityName(rs.getString(3));</span>
<span class="fc" id="L2901">				entry.setActivityCategoryID(rs.getID(4));</span>
<span class="fc" id="L2902">				entry.setActivityCategoryName(rs.getString(5));</span>
<span class="fc" id="L2903">				ArrayList temp = parent.getChild();</span>
				// need to set the previous entry's endtime
<span class="fc bfc" id="L2905" title="All 2 branches covered.">				if (!temp.isEmpty())</span>
<span class="fc" id="L2906">					((TimeRecordEntry) temp.get(temp.size() - 1)).setEndTime(entryStart);</span>
				// add the new entry directly
<span class="fc" id="L2908">				parent.getChild().add(entry);</span>
				// last step is to put it in the hashmap
<span class="fc" id="L2910">				timeRecords.put(empID, trArray);</span>
<span class="fc" id="L2911">			}</span>
<span class="pc bpc" id="L2912" title="1 of 2 branches missed.">			if (rs != null)</span>
<span class="fc" id="L2913">				rs.close();</span>
			// Additional step to validate timerecords the TimeRecord list
<span class="pc bpc" id="L2915" title="1 of 2 branches missed.">			if (!workResourceID.isEmpty()) {</span>
<span class="fc bfc" id="L2916" title="All 2 branches covered.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
					// Get TimeRecord for each employee
<span class="fc" id="L2918">					ArrayList trCol = (ArrayList) timeRecords.get(it.next());</span>
					// If there are many(&gt;1) timerecords, should check overlap
<span class="fc bfc" id="L2920" title="All 4 branches covered.">					if (trCol != null &amp;&amp; trCol.size() &gt; 1) {</span>
						// First resort timerecord
<span class="fc" id="L2922">						Collections.sort(trCol);</span>
						// Iterate TimeRecord Collections
<span class="fc bfc" id="L2924" title="All 2 branches covered.">						for (ListIterator trIT = trCol.listIterator(); trIT.hasNext();) {</span>
<span class="fc" id="L2925">							int index = trIT.previousIndex();</span>
<span class="fc" id="L2926">							TimeRecord current = (TimeRecord) trIT.next();</span>
<span class="fc" id="L2927">							long newVal = current.getStartTime().getTime();</span>
<span class="fc bfc" id="L2928" title="All 2 branches covered.">							while (index &gt;= 0) {</span>
<span class="fc" id="L2929">								TimeRecord previous = (TimeRecord) trCol.get(index--);</span>
<span class="fc" id="L2930">								long existVal = previous.getEndTime().getTime();</span>
								// check if the entry is before the last tr's
								// endtime
<span class="pc bpc" id="L2933" title="1 of 2 branches missed.">								if (existVal - newVal &gt;= 0) {</span>
<span class="nc" id="L2934">									current.setOverlap(true);</span>
<span class="nc" id="L2935">									previous.setOverlap(true);</span>
<span class="nc" id="L2936">									overlappedTimeRecord.add(current);</span>
<span class="nc" id="L2937">									valid = false;</span>
								} else {
									// only if the last entry is an clean one,
									// and quit the loop
<span class="pc bpc" id="L2941" title="1 of 2 branches missed.">									if (!previous.getOverlap())</span>
<span class="fc" id="L2942">										break;</span>
								}
<span class="nc" id="L2944">							}</span>
<span class="fc" id="L2945">						}</span>
					}
<span class="fc" id="L2947">				}</span>
			}
			// then load the TimeIntervals
<span class="fc" id="L2950">			StringBuffer pStmt2 = new StringBuffer(200);</span>
<span class="fc" id="L2951">			pStmt2.append(</span>
					&quot;select A.ID, B.ID, C.NAME, D.ID, D.NAME, B.ISPAID, B.DESCRIPTION, A.EMPLOYEEID, B.STARTTIME, B.ENDTIME, FIRSTNAME, LASTNAME, &quot;);
<span class="fc" id="L2953">			pStmt2.append(TimeRecordDAO.APPROVERCOLSTR).append(TimeRecordDAO.REMAKERCOLNAME).append(</span>
					&quot;, A.LASTMODIFIEDAT, REMARK, ISAPPROVED, ISPOSTED, A.CHANGECOUNTER, CHANGESTATUS, ACTIVITYID, COUNTTOWARDSMINUTES, &quot;);
<span class="fc" id="L2955">			pStmt2.append(</span>
					&quot;TIMESOURCECODE FROM TIMERECORD A, TIMERECORDADJUSTMENT B, ACTIVITY C, ACTIVITYCATEGORY D, EMPLOYEEAM E, PERSON F where A.ID=B.TIMERECORDID and &quot;);
<span class="fc" id="L2957">			pStmt2.append(</span>
					&quot;B.ACTIVITYID=C.ID and A.EMPLOYEEID = E.ID and E.PERSONID = F.ID and D.ID=C.ACTIVITYCATEGORYID and A.ID in &quot;);
<span class="fc" id="L2959">			pStmt2.append(&quot;(select distinct A.ID from TIMERECORD A &quot;);</span>
<span class="fc" id="L2960">			pStmt2.append(&quot; Inner Join TIMERECORDADJUSTMENT B on A.ID=B.TIMERECORDID &quot;);</span>
<span class="fc" id="L2961">			pStmt2.append(&quot; Inner Join &quot;).append(realEmpIDTempTable).append(&quot; T on T.ID = A.EMPLOYEEID &quot;);</span>
<span class="fc" id="L2962">			pStmt2.append(&quot; where B.STARTTIME&lt;? and B.ENDTIME&gt;=?) order by A.EMPLOYEEID, A.ID, B.STARTTIME asc&quot;);</span>
<span class="fc" id="L2963">			JdmoQuery jQuery2 = jdmo.createQuery(pStmt2.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L2964">			jQuery2.setParTimestamp(1, endTime);</span>
<span class="fc" id="L2965">			jQuery2.setParTimestamp(2, dtStart);</span>
<span class="fc" id="L2966">			rs = jdmo.createRowset(jQuery2, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
			// Track employeeid that has new TimeInterval, need resort these
			// timerecords
<span class="fc" id="L2969">			HashSet empSort = new HashSet(10);</span>
			// used to identify first timerecord for timeinterval
<span class="pc bpc" id="L2971" title="1 of 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2972">				ID empID = rs.getID(8);</span>
<span class="nc" id="L2973">				ArrayList trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L2974" title="All 2 branches missed.">				if (trArray == null)</span>
<span class="nc" id="L2975">					trArray = new ArrayList();</span>
<span class="nc" id="L2976">				ID key = rs.getID(1);</span>
<span class="nc" id="L2977">				TimeRecord parent = null;</span>
<span class="nc" id="L2978">				boolean needNew = true;</span>
<span class="nc" id="L2979">				int index = 0;</span>
<span class="nc bnc" id="L2980" title="All 2 branches missed.">				for (int i = trArray.size(); --i &gt;= 0;) {</span>
<span class="nc bnc" id="L2981" title="All 2 branches missed.">					if (key.equals(((TimeRecord) trArray.get(i)).getID())) {</span>
<span class="nc" id="L2982">						needNew = false;</span>
<span class="nc" id="L2983">						index = i;</span>
<span class="nc" id="L2984">						break;</span>
					}
				}
<span class="nc bnc" id="L2987" title="All 2 branches missed.">				if (needNew) {</span>
<span class="nc" id="L2988">					ID remarkerID = rs.getID(TimeRecordDAO.REMAKERCOLNAME);</span>
<span class="nc" id="L2989">					parent = new TimeRecord(key, empID, remarkerID,</span>
<span class="nc" id="L2990">							TimeZoneUtil.toDate(rs.getTimestamp(&quot;LASTMODIFIEDAT&quot;)),</span>
<span class="nc" id="L2991">							rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L2992">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L2993">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L2994">					parent.setEmpFirstName(rs.getString(&quot;FIRSTNAME&quot;));</span>
<span class="nc" id="L2995">					parent.setEmpLastName(rs.getString(&quot;LASTNAME&quot;));</span>
<span class="nc" id="L2996">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L2997">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc" id="L2998">					parent.setType(TimeRecord.TIMEINTERVAL);</span>
<span class="nc bnc" id="L2999" title="All 2 branches missed.">					if (remarkerID != null) {</span>
<span class="nc" id="L3000">						String remarkerName = getRemarkerName(remarkerID, jdmo);</span>
<span class="nc" id="L3001">						parent.setRemarkEmployeeName(remarkerName);</span>
					}
<span class="nc" id="L3003">					trArray.add(parent);</span>
<span class="nc" id="L3004">				} else {</span>
<span class="nc" id="L3005">					parent = (TimeRecord) trArray.get(index);</span>
					// the following validation allows
					// More than one TimeInterval per TimeRecord
					// if it is invalid, only if it already contains TimeEntry
<span class="nc bnc" id="L3009" title="All 2 branches missed.">					if (parent.getType() != TimeRecord.TIMEINTERVAL)</span>
<span class="nc" id="L3010">						valid = false;</span>
				}
<span class="nc" id="L3012">				TimeInterval entry = new TimeInterval(rs.getID(2), rs.getID(&quot;ACTIVITYID&quot;),</span>
<span class="nc" id="L3013">						TimeZoneUtil.toDate(rs.getTimestamp(9)), TimeZoneUtil.toDate(rs.getTimestamp(10)),</span>
<span class="nc" id="L3014">						rs.getInt(&quot;COUNTTOWARDSMINUTES&quot;), rs.getInt(&quot;TIMESOURCECODE&quot;), rs.getBoolean(6),</span>
<span class="nc" id="L3015">						rs.getString(7), parent);</span>
<span class="nc" id="L3016">				entry.setActivityName(rs.getString(3));</span>
<span class="nc" id="L3017">				entry.setActivityCategoryID(rs.getID(4));</span>
<span class="nc" id="L3018">				entry.setActivityCategoryName(rs.getString(5));</span>
<span class="nc" id="L3019">				parent.getChild().add(entry);</span>
				// Put back the TimeRecord to the HashMap
<span class="nc" id="L3021">				timeRecords.put(empID, trArray);</span>
				// Track employee that has TimeInterval
<span class="nc" id="L3023">				empSort.add(empID);</span>
<span class="nc" id="L3024">			}</span>
			// Additional step to resort the TimeRecord list
<span class="pc bpc" id="L3026" title="1 of 2 branches missed.">			if (!empSort.isEmpty()) {</span>
<span class="nc bnc" id="L3027" title="All 2 branches missed.">				for (Iterator it = empSort.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3028">					ArrayList trCol = (ArrayList) timeRecords.get(it.next());</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">					if (trCol != null) {</span>
<span class="nc" id="L3030">						Collections.sort(trCol);</span>
					}
<span class="nc" id="L3032">				}</span>
			}
			// Set TimeRecord Employee names
<span class="fc bfc" id="L3035" title="All 2 branches covered.">			for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="fc" id="L3036">				ID empID = (ID) it.next();</span>
<span class="fc" id="L3037">				EmployeeName eName = (EmployeeName) mapEmpNames.get(empID);</span>
<span class="fc" id="L3038">				Collection timeRecordCol = (Collection) timeRecords.get(empID);</span>
<span class="pc bpc" id="L3039" title="1 of 4 branches missed.">				if (eName == null || timeRecordCol == null)</span>
<span class="fc" id="L3040">					continue;</span>
<span class="fc bfc" id="L3041" title="All 2 branches covered.">				for (Iterator it2 = timeRecordCol.iterator(); it2.hasNext();) {</span>
<span class="fc" id="L3042">					TimeRecord tr = (TimeRecord) it2.next();</span>
<span class="fc" id="L3043">					tr.setEmpFirstName(eName.getFirstName());</span>
<span class="fc" id="L3044">					tr.setEmpLastName(eName.getLastName());</span>
<span class="fc" id="L3045">				}</span>
<span class="fc" id="L3046">			}</span>
			// if no timerecords violate the validation rule, return it
<span class="pc bpc" id="L3048" title="1 of 2 branches missed.">			if (valid)</span>
<span class="fc" id="L3049">				return timeRecords;</span>
			// create the string of overlapping time record to display message
			// error
<span class="nc" id="L3052">			String strTimeRecordID = &quot;&quot;;</span>
<span class="nc" id="L3053">			int count = 0;</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">			for (int i = 0; i &lt; overlappedTimeRecord.size(); i++) {</span>
<span class="nc" id="L3055">				TimeRecord objTimeRecord = (TimeRecord) overlappedTimeRecord.get(i);</span>
<span class="nc" id="L3056">				strTimeRecordID += objTimeRecord.getID().toString();</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">				if (count &lt; overlappedTimeRecord.size() - 1)</span>
<span class="nc" id="L3058">					strTimeRecordID += &quot;, &quot;;</span>
<span class="nc" id="L3059">				count++;</span>
			}
<span class="nc" id="L3061">			Object[] args = new Object[1];</span>
<span class="nc" id="L3062">			args[0] = strTimeRecordID;</span>
<span class="nc" id="L3063">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException(BbmEjbLogBundleKey.TIME_RECORD_OVERLAP,</span>
					args);
<span class="nc" id="L3065">			e.setContent(timeRecords);</span>
<span class="nc" id="L3066">			throw e;</span>
<span class="nc" id="L3067">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3068">			handleException(e, false);</span>
<span class="nc" id="L3069">			throw e;</span>
<span class="nc" id="L3070">		} catch (Exception e) {</span>
<span class="nc" id="L3071">			handleException(e, false);</span>
<span class="nc" id="L3072">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L3074" title="5 of 6 branches missed.">			if (rs != null)</span>
				try {
<span class="pc" id="L3076">					rs.close();</span>
<span class="nc" id="L3077">				} catch (Exception e) {</span>
<span class="nc bnc" id="L3078" title="All 6 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L3079">						m_cat.debug(e);</span>
<span class="pc" id="L3080">				}</span>
			try {
<span class="pc" id="L3082">				jdmo.dropTempTable(tempTable);</span>
<span class="pc" id="L3083">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L3084">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L3085" title="All 6 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L3086">					m_cat.debug(e);</span>
<span class="pc" id="L3087">			}</span>
<span class="pc bpc" id="L3088" title="5 of 6 branches missed.">			if (jdmo != null)</span>
<span class="pc" id="L3089">				jdmo.cleanUp();</span>
<span class="pc" id="L3090">			methodFinish();</span>
		}
	}

	private StringBuffer composeTimeRecordQuery(Timestamp dtStart, Timestamp endTime, String realTempTable,
			String realEmpTempTable) {
		// Insert data into temp table
<span class="fc" id="L3097">		StringBuffer pInsert = new StringBuffer(&quot;insert into &quot;);</span>
<span class="fc" id="L3098">		pInsert.append(realTempTable);</span>
<span class="fc" id="L3099">		pInsert.append(&quot; select distinct A2.ID from TIMERECORD A2 &quot;);</span>
<span class="fc" id="L3100">		pInsert.append(&quot; Inner Join TIMEENTRYEVENT B2 on A2.ID=B2.TIMERECORDID&quot;);</span>
<span class="fc" id="L3101">		pInsert.append(&quot; Inner Join &quot;).append(realEmpTempTable).append(&quot; T on T.ID=B2.EmployeeID&quot;);</span>
<span class="fc" id="L3102">		pInsert.append(&quot; where B2.UPDATETIMESTAMP&lt;&quot;).append(endTime.getTime()).append(&quot; and B2.UPDATETIMESTAMP&gt;=&quot;)</span>
<span class="fc" id="L3103">				.append(dtStart.getTime());</span>
<span class="fc" id="L3104">		return pInsert;</span>
	}

	/**
	 * Gets all timeentries/timeintervals for a workresourceID
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getValidEventsForWorkResource(ID workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="pc bpc" id="L3118" title="3 of 6 branches missed.">		if (workResourceID != null &amp;&amp; dtStart != null &amp;&amp; dtEnd != null) {</span>
<span class="fc" id="L3119">			ArrayList array = new ArrayList(1);</span>
<span class="fc" id="L3120">			array.add(workResourceID);</span>
<span class="fc" id="L3121">			HashMap map = getValidEventsForWorkResource(array, dtStart, dtEnd);</span>
<span class="pc bpc" id="L3122" title="1 of 4 branches missed.">			if (map != null &amp;&amp; !map.isEmpty()) {</span>
<span class="fc" id="L3123">				return (Collection) map.get(workResourceID);</span>
			}
		}
<span class="fc" id="L3126">		return Collections.EMPTY_LIST;</span>
	}

	/**
	 * Gets all timeentries/timeintervals for a workresourceID
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getValidEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L3140">		return getValidEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="fc" id="L3141">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	}

	/**
	 * for TimeCollection merge TimeRecord operaion the logic is to check if the
	 * TimeRecord is still in raw status or modified by manager(including
	 * manager create end shift)
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @return boolean
	 * @exception BbmObjectNotFoundException
	 *                , subclass of BbmFinderException
	 * @exception BbmFinderException
	 *                , won't rollback any transaction
	 */
	public boolean isTimeRecordModified(ID timeRecordID) throws BbmFinderException {
<span class="nc" id="L3158">		methodStart(&quot;isTimeRecordModified&quot;, timeRecordID);</span>
		try {
<span class="nc" id="L3160">			return TimeRecordDAO.isTimeRecordModified(timeRecordID);</span>
<span class="nc" id="L3161">		} catch (JdmoException e) {</span>
<span class="nc" id="L3162">			handleException(e, false);</span>
<span class="nc" id="L3163">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3165">			methodFinish();</span>
		}
	}

	/**
	 * to update a TimeRecordEntry
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param int, pos
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Long
	 *            , version
	 * @return TimeRecord
	 */
	public TimeRecord updateTimeRecordEntry(ID timeRecordID, int pos, TimeRecordEntry entry, long version)
			throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L3183">		methodStart(&quot;updateTimeRecordEntry&quot;, timeRecordID, NumberFactory.newInteger(pos), entry, new Long(version));</span>
<span class="nc" id="L3184">		Collection col = null;</span>
<span class="nc" id="L3185">		TimeRecord tr = null;</span>
<span class="nc" id="L3186">		ArrayList auditList = new ArrayList(2);</span>
		// To fix update on a zero duration entry, like EndShift, we need define
		// new window
<span class="nc" id="L3189">		long miliEndTime = (long) entry.getEndTime().getTime() / (MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR);</span>
<span class="nc" id="L3190">		entry.setEndTime(new Date(miliEndTime * MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR));</span>
<span class="nc" id="L3191">		Date oldStart = null;</span>
		try {
<span class="nc" id="L3193">			tr = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID, version, false);</span>
<span class="nc bnc" id="L3194" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
				// Check if it TimeEntry type, rarely throws this Exception
<span class="nc bnc" id="L3196" title="All 2 branches missed.">				if (tr.getType() != TimeRecord.TIMEENTRY) {</span>
<span class="nc" id="L3197">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID_TYPE);</span>
				}
<span class="nc" id="L3199">				TimeRecordEntry oldEntry = (TimeRecordEntry) tr.getChild().get(pos - 1);</span>
<span class="nc bnc" id="L3200" title="All 4 branches missed.">				if (oldEntry.getDuration() == TimeRecordEntry.ENDSHIFT_DURATION || oldEntry.getDuration() == 0) {</span>
<span class="nc" id="L3201">					oldStart = oldEntry.getStartTime();</span>
				}
<span class="nc" id="L3203">				AuditTrailEntry auditOldEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3204">						AuditTrailEntry.ACTION_DELETE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc" id="L3205">						oldEntry.getStartTime(), oldEntry.getEndTime());</span>
<span class="nc" id="L3206">				auditOldEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L3207">						String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc bnc" id="L3208" title="All 2 branches missed.">				if (oldStart == null) {</span>
<span class="nc" id="L3209">					auditList.add(auditOldEntry);</span>
				}
<span class="nc" id="L3211">				entry.setLastModifiedTime(new Date());</span>
<span class="nc" id="L3212">				entry.setModifier(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L3213">				tr.updateEntry(entry, pos);</span>
				// Check within the TimeRecord
<span class="nc bnc" id="L3215" title="All 2 branches missed.">				if (tr.validate(true)) {</span>
					// Check with other TimeRecords,
					// but as there is no locking on all other records
					// (performance reason), it is guaranteed there will be no
					// overlap timerecords
<span class="nc bnc" id="L3220" title="All 2 branches missed.">					if (!tr.getStartTime().equals(tr.getEndTime())) {</span>
<span class="nc" id="L3221">						col = getEventsForWorkResource(tr.getEmployeeID(), tr.getStartTime(), tr.getEndTime());</span>
<span class="nc bnc" id="L3222" title="All 4 branches missed.">						if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc bnc" id="L3223" title="All 2 branches missed.">							if (col.size() == 1) {</span>
<span class="nc" id="L3224">								Iterator it = col.iterator();</span>
<span class="nc" id="L3225">								TimeRecord same = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L3226" title="All 2 branches missed.">								if (!same.getID().equals(timeRecordID)) {</span>
									// Rarelly happend, but this implies the
									// TimeRecord is replaced by another one
<span class="nc" id="L3229">									throw new BbmTimeRecordException(BbmTimeRecordException.TR_REMOVED);</span>
								}
<span class="nc" id="L3231">							} else {</span>
								// There are overlapping TimeRecords
<span class="nc" id="L3233">								Iterator it = col.iterator();</span>
<span class="nc bnc" id="L3234" title="All 2 branches missed.">								while (it.hasNext()) {</span>
<span class="nc" id="L3235">									((TimeRecord) it.next()).setOverlap(true);</span>
								}
<span class="nc" id="L3237">								throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
							}
						}
					}
					// TimeRecord only has one entry without EndShift
<span class="nc bnc" id="L3242" title="All 2 branches missed.">					if (entry.getRemarkerID() != null) {</span>
<span class="nc" id="L3243">						tr.setRemarkEmployeeID(entry.getRemarkerID());</span>
					}
<span class="nc" id="L3245">					updateTimeRecordEntry(tr, true);</span>
				} else {
					// invalid
<span class="nc" id="L3248">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
				}
<span class="nc" id="L3250">			} else {</span>
<span class="nc bnc" id="L3251" title="All 2 branches missed.">				if (tr == null) {</span>
<span class="nc" id="L3252">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
<span class="nc" id="L3254">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
			}
			// cache task
<span class="nc bnc" id="L3257" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc" id="L3258">				TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, tr);</span>
			}
			// update lastEntry
<span class="nc" id="L3261">			updateLastEntryCache(tr.getLastEntry());</span>
			// prepare audit trail
<span class="nc" id="L3263">			AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3264">					AuditTrailEntry.ACTION_UPDATE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc" id="L3265">					entry.getStartTime(), entry.getEndTime());</span>
<span class="nc" id="L3266">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_ENTRY),</span>
					&quot;-1&quot;, false);
<span class="nc bnc" id="L3268" title="All 2 branches missed.">			if (oldStart != null) {</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">				if (auditEntry.getImpactStart().before(oldStart))</span>
<span class="nc" id="L3270">					auditEntry.setImpactEnd(oldStart);</span>
				else
<span class="nc" id="L3272">					auditEntry.setImpactStart(oldStart);</span>
			}
<span class="nc" id="L3274">			auditList.add(auditEntry);</span>
<span class="nc" id="L3275">			m_EventAuditTrailManager.createAuditEntry(auditList);</span>
<span class="nc" id="L3276">			return tr;</span>
<span class="nc" id="L3277">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3278">			Object[] param = new Object[3];</span>
<span class="nc" id="L3279">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L3280">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L3281">			param[2] = entry.getParentID();</span>
<span class="nc" id="L3282">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L3283">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3284">		} catch (JdmoException e) {</span>
<span class="nc" id="L3285">			handleException(e);</span>
<span class="nc" id="L3286">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3287">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3288">			handleException(e);</span>
<span class="nc" id="L3289">			throw e;</span>
<span class="nc" id="L3290">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3291">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3292">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3293">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3294">			handleException(e);</span>
<span class="nc" id="L3295">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3296">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L3297">			handleException(Priority.INFO, e);</span>
<span class="nc bnc" id="L3298" title="All 4 branches missed.">			if (col == null || col.isEmpty())</span>
<span class="nc" id="L3299">				e.setContent(tr);</span>
			else
<span class="nc" id="L3301">				e.setContent(col);</span>
<span class="nc" id="L3302">			throw e;</span>
<span class="nc" id="L3303">		} catch (Exception e) {</span>
<span class="nc" id="L3304">			handleException(e);</span>
<span class="nc" id="L3305">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3307">			methodFinish();</span>
		}
	} // updateTimeRecordEntry

	/**
	 * to update a TimeRecordEntry from backend
	 * 
	 * @param ID
	 *            , timeRecordID
	 * @param TimeRecordEntry
	 *            , a new entry
	 */
	public void updateTimeRecordEntry(ID timeRecordID, TimeRecordEntry entry) throws BbmUpdateException {
<span class="nc" id="L3320">		methodStart(&quot;updateTimeRecordEntry&quot;, timeRecordID, entry);</span>
		try {
<span class="nc" id="L3322">			entry.setParentID(timeRecordID);</span>
<span class="nc" id="L3323">			entry.setLastModifiedTime(new Date());</span>
<span class="nc" id="L3324">			entry.setModifier(m_sessionContext.getCallerPrincipal().getName());</span>
			// Continue only if the SyncStatus is 0
<span class="nc bnc" id="L3326" title="All 2 branches missed.">			if (TimeRecordDAO.updateTimeRecordEntry(entry, m_ResetImmidiateToLastActivity) != 0) {</span>
				// Cache Task
<span class="nc bnc" id="L3328" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc" id="L3329">					TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, entry);</span>
				}
<span class="nc" id="L3331">				updateLastEntryCache(entry);</span>
			}
<span class="nc" id="L3333">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3334">			Object[] param = new Object[3];</span>
<span class="nc" id="L3335">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L3336">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L3337">			param[2] = entry.getParentID();</span>
<span class="nc" id="L3338">			handleException(BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L3339">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3340">		} catch (JdmoException e) {</span>
<span class="nc" id="L3341">			handleException(e);</span>
<span class="nc" id="L3342">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3344">			methodFinish();</span>
<span class="nc" id="L3345">		}</span>
<span class="nc" id="L3346">	}</span>

	/**
	 * to update a TimeRecordEntry from backend
	 * 
	 * @param TimeRecordEntry
	 *            , an entry to be updated
	 */
	public void updateTimeRecordEntry(TimeRecordEntry entry) throws BbmUpdateException {
<span class="nc" id="L3355">		methodStart(&quot;updateTimeRecordEntry&quot;, entry);</span>
		try {
<span class="nc bnc" id="L3357" title="All 4 branches missed.">			if (entry.getParentID() == null || entry.getID() == null) {</span>
<span class="nc" id="L3358">				return;</span>
			}
			// Continue only if the SyncStatus is 0
<span class="nc bnc" id="L3361" title="All 2 branches missed.">			if (TimeRecordDAO.updateTimeRecordEntry(entry, m_ResetImmidiateToLastActivity) != 0) {</span>
				// Cache Task
<span class="nc bnc" id="L3363" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc" id="L3364">					TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, entry);</span>
				}
<span class="nc" id="L3366">				updateLastEntryCache(entry);</span>
			}
<span class="nc" id="L3368">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3369">			Object[] param = new Object[3];</span>
<span class="nc" id="L3370">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L3371">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L3372">			param[2] = entry.getParentID();</span>
<span class="nc" id="L3373">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L3374">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3375">		} catch (JdmoException e) {</span>
<span class="nc" id="L3376">			handleException(e);</span>
<span class="nc" id="L3377">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3379">			methodFinish();</span>
<span class="nc" id="L3380">		}</span>
<span class="nc" id="L3381">	} // updateTimeRecordEntry</span>

	/**
	 * update time record entry with a new time record ID
	 * 
	 * @param timeRecordID
	 * @param entryIDCol
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntry(ID timeRecordID, Collection entryIDCol) throws BbmUpdateException {
<span class="nc" id="L3392">		methodStart(&quot;updateTimeRecordEntry&quot;, timeRecordID, entryIDCol);</span>
<span class="nc" id="L3393">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3395">			StringBuffer pStmt = new StringBuffer(&quot;update TIMEENTRYEVENT set TIMERECORDID=&quot;);</span>
<span class="nc" id="L3396">			pStmt.append(timeRecordID).append(&quot;, TIMESOURCECODE=&quot;).append(TimeEntrySourceCode.HAAFEED)</span>
<span class="nc" id="L3397">					.append(&quot; where ID in &quot;).append(jdmo.createInClause(entryIDCol));</span>
<span class="nc" id="L3398">			jdmo.executeCommand(pStmt.toString());</span>
<span class="nc" id="L3399">		} catch (JdmoException e) {</span>
<span class="nc" id="L3400">			handleException(e);</span>
<span class="nc" id="L3401">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3403">			jdmo.cleanUp();</span>
<span class="nc" id="L3404">			methodFinish();</span>
<span class="nc" id="L3405">		}</span>
<span class="nc" id="L3406">	}</span>

	/**
	 * update time record entry with a new time record ID and change the
	 * Activity ID accordingly (most for Auto Merge)
	 * 
	 * @param timeRecordID
	 * @param entryCol
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntryActivity(ID timeRecordID, Collection entryCol) throws BbmUpdateException {
<span class="nc" id="L3418">		methodStart(&quot;updateTimeRecordEntryActivity&quot;, timeRecordID, entryCol);</span>
<span class="nc" id="L3419">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L3421" title="All 2 branches missed.">			for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3422">				TimeRecordEntry tre = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L3423">				StringBuffer pStmt = new StringBuffer(&quot;update TIMEENTRYEVENT set ACTIVITYID=&quot;);</span>
<span class="nc" id="L3424">				pStmt.append(tre.getActivityID()).append(&quot;, TIMERECORDID=&quot;).append(timeRecordID);</span>
<span class="nc" id="L3425">				pStmt.append(&quot;, TIMESOURCECODE=&quot;).append(TimeEntrySourceCode.HAAFEED).append(&quot; where ID=&quot;)</span>
<span class="nc" id="L3426">						.append(tre.getID());</span>
<span class="nc" id="L3427">				jdmo.addBatch(pStmt.toString());</span>
<span class="nc" id="L3428">			}</span>
<span class="nc" id="L3429">			jdmo.executeBatch();</span>
<span class="nc" id="L3430">		} catch (JdmoException e) {</span>
<span class="nc" id="L3431">			handleException(e);</span>
<span class="nc" id="L3432">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3434">			jdmo.cleanUp();</span>
<span class="nc" id="L3435">			methodFinish();</span>
<span class="nc" id="L3436">		}</span>
<span class="nc" id="L3437">	}</span>

	/**
	 * update time record entry with a new time record ID
	 * 
	 * @param ID
	 *            old Record ID
	 * @param ID
	 *            new Record ID
	 * @param Date
	 *            entry starts later than this date will be affected
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntry(ID oldRecordID, ID newRecordID, Date entryStart) throws BbmUpdateException {
<span class="nc" id="L3452">		methodStart(&quot;updateTimeRecordEntry&quot;, oldRecordID, newRecordID, entryStart);</span>
<span class="nc" id="L3453">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3455">			String pStmt = &quot;update TIMEENTRYEVENT set TIMERECORDID=? where TIMERECORDID=?&quot;;</span>
<span class="nc" id="L3456">			Object[] params = new Object[2];</span>
<span class="nc bnc" id="L3457" title="All 2 branches missed.">			if (entryStart != null) {</span>
<span class="nc" id="L3458">				pStmt += &quot; and STARTTIME&gt;=?&quot;;</span>
<span class="nc" id="L3459">				params = new Object[3];</span>
<span class="nc" id="L3460">				params[2] = entryStart;</span>
			}
<span class="nc" id="L3462">			params[0] = newRecordID;</span>
<span class="nc" id="L3463">			params[1] = oldRecordID;</span>
<span class="nc" id="L3464">			jdmo.executePCommand(pStmt, params);</span>
<span class="nc" id="L3465">		} catch (JdmoException e) {</span>
<span class="nc" id="L3466">			handleException(e);</span>
<span class="nc" id="L3467">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3469">			jdmo.cleanUp();</span>
<span class="nc" id="L3470">			methodFinish();</span>
<span class="nc" id="L3471">		}</span>
<span class="nc" id="L3472">	}</span>

	/**
	 * to update a TimeRecordEntry from backend supporting BPX quick update
	 * 
	 * @param TimeRecordEntry
	 *            , only updates ActivityID and ISPaid info
	 */
	public void quickUpdateTimeRecordEntry(TimeRecordEntry entry) throws BbmUpdateException {
<span class="nc" id="L3481">		methodStart(&quot;quickUpdateTimeRecordEntry&quot;, entry);</span>
		try {
<span class="nc bnc" id="L3483" title="All 2 branches missed.">			if (TimeRecordDAO.quickUpdateTimeRecordEntry(entry) != 0) {</span>
				// Cache Task
<span class="nc bnc" id="L3485" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc bnc" id="L3486" title="All 2 branches missed.">					if (m_DebugEnabled) {</span>
<span class="nc" id="L3487">						m_cat.debug(&quot;In quickUpdateTimeRecordEntry, new TimeEnry is &quot; + entry);</span>
					}
<span class="nc" id="L3489">					TimeRecordCacheUtil.refreshInCache(m_TimeRecordCache, entry);</span>
				}
<span class="nc" id="L3491">				updateLastEntryCache(entry);</span>
			}
<span class="nc" id="L3493">		} catch (JdmoException e) {</span>
<span class="nc" id="L3494">			handleException(e);</span>
<span class="nc" id="L3495">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3497">			methodFinish();</span>
<span class="nc" id="L3498">		}</span>
<span class="nc" id="L3499">	}</span>

	/**
	 * to update a TimeRecordEntry from backend supporting BPX quick update
	 * 
	 * @param TimeRecordEntry
	 *            , only updates ActivityID and ISPaid info
	 */
	public void quickUpdateTimeRecordEntry(Collection entryCol) throws BbmUpdateException {
<span class="nc" id="L3508">		methodStart(&quot;quickUpdateTimeRecordEntry&quot;, entryCol);</span>
<span class="nc" id="L3509">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L3511" title="All 2 branches missed.">			for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3512">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L3513" title="All 2 branches missed.">				if (TimeRecordDAO.quickUpdateTimeRecordEntry(entry) != 0) {</span>
					// Cache Task
<span class="nc bnc" id="L3515" title="All 2 branches missed.">					if (cacheUsed()) {</span>
<span class="nc bnc" id="L3516" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L3517">							m_cat.debug(&quot;In quickUpdateTimeRecordEntry, new TimeEnry Collection are &quot; + entryCol);</span>
						}
<span class="nc" id="L3519">						TimeRecordCacheUtil.refreshInCache(m_TimeRecordCache, entry);</span>
					}
<span class="nc" id="L3521">					updateLastEntryCache(entry);</span>
				}
<span class="nc" id="L3523">			}</span>
<span class="nc" id="L3524">		} catch (JdmoException e) {</span>
<span class="nc" id="L3525">			handleException(e);</span>
<span class="nc" id="L3526">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3528">			jdmo.cleanUp();</span>
<span class="nc" id="L3529">			methodFinish();</span>
<span class="nc" id="L3530">		}</span>
<span class="nc" id="L3531">	}</span>

	/**
	 * delete TimeRecord, which deletes all TimeRecordEntries first and remove
	 * the timerecord brutally
	 * 
	 * @param ID
	 */
	public void removeTimeRecord(ID id) throws BbmRemoveException {
<span class="nc" id="L3540">		methodStart(&quot;removeTimeRecod&quot;, id);</span>
<span class="nc" id="L3541">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Load TimeRecord, check if the PayPeriod is locked or not
<span class="nc" id="L3544">			TimeRecord tr = TimeRecordDAO.getTimeRecordByID(id);</span>
<span class="nc bnc" id="L3545" title="All 2 branches missed.">			if (tr == null) {</span>
<span class="nc" id="L3546">				return;</span>
			}
<span class="nc bnc" id="L3548" title="All 2 branches missed.">			if (tr.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
				// refresh cache
<span class="nc bnc" id="L3550" title="All 2 branches missed.">				if (cacheUsed()) {</span>
					// Cache Task, replace the existing record with new version
<span class="nc" id="L3552">					TimeRecordCacheUtil.removeInCache(m_TimeRecordCache, tr.getEmployeeID(), id);</span>
				}
<span class="nc" id="L3554">				removeLastEntryCache(tr.getEmployeeID(), id);</span>
			}
			// Force deletion
<span class="nc" id="L3557">			ArrayList idCol = new ArrayList(1);</span>
<span class="nc" id="L3558">			idCol.add(id);</span>
<span class="nc" id="L3559">			DAOUtil.deleteObjects(jdmo, &quot;TIMERECORD&quot;, idCol);</span>
			// Create AuditTrail
<span class="nc" id="L3561">			Date trEnd = tr.getEndTime();</span>
<span class="nc bnc" id="L3562" title="All 2 branches missed.">			if (tr.isOpenShift()) {</span>
<span class="nc" id="L3563">				trEnd = new Date();</span>
			}
<span class="nc" id="L3565">			AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3566">					AuditTrailEntry.ACTION_DELETE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc" id="L3567">					tr.getStartTime(), trEnd);</span>
<span class="nc" id="L3568">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD),</span>
					&quot;-1&quot;, false);
<span class="nc" id="L3570">			m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L3571">		} catch (JdmoException e) {</span>
<span class="nc" id="L3572">			handleException(e);</span>
<span class="nc" id="L3573">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3574">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3575">			handleException(e);</span>
<span class="nc" id="L3576">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3577">		} catch (Exception e) {</span>
<span class="nc" id="L3578">			handleException(e);</span>
<span class="nc" id="L3579">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3581">			jdmo.cleanUp();</span>
<span class="nc" id="L3582">			methodFinish();</span>
<span class="nc" id="L3583">		}</span>
<span class="nc" id="L3584">	} // removeTimeRecord</span>

	/**
	 * for the creation of a new TimeRecordEntry
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param ID
	 *            , remarker ID
	 * @param int, pos
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Long
	 *            , version
	 * @return TimeRecord
	 */
	public TimeRecord removeTimeRecordEntry(ID timeRecordID, ID remakerID, int pos, boolean direction, long version)
			throws BbmRemoveException {
<span class="nc" id="L3602">		methodStart(&quot;removeTimeRecordEntry&quot;, timeRecordID, NumberFactory.newInteger(pos),</span>
<span class="nc" id="L3603">				JdmoParam.getObject(direction), new Long(version));</span>
<span class="nc" id="L3604">		TimeRecord tr = null;</span>
		try {
<span class="nc" id="L3606">			tr = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID, version, false);</span>
<span class="nc bnc" id="L3607" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc" id="L3608">				TimeRecordEntry entry = (TimeRecordEntry) tr.getChild().get(pos - 1);</span>
<span class="nc" id="L3609">				tr.removeEntry(pos, direction);</span>
<span class="nc bnc" id="L3610" title="All 2 branches missed.">				if (remakerID != null) {</span>
<span class="nc" id="L3611">					tr.setRemarkEmployeeID(remakerID);</span>
				}
<span class="nc" id="L3613">				updateTimeRecordEntry(tr, true);</span>
<span class="nc bnc" id="L3614" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc" id="L3615">					tr.compactChild();</span>
<span class="nc" id="L3616">					TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, tr);</span>
				}
<span class="nc" id="L3618">				removeLastEntryCache(entry);</span>
<span class="nc" id="L3619">				AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3620">						AuditTrailEntry.ACTION_DELETE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">						entry.getStartTime(), (entry.getEndTime() == null) ? (new Date()) : entry.getEndTime());</span>
<span class="nc" id="L3622">				auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L3623">						String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc" id="L3624">				m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L3625">			} else {</span>
<span class="nc bnc" id="L3626" title="All 2 branches missed.">				if (tr == null) {</span>
<span class="nc" id="L3627">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
<span class="nc" id="L3629">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
			}
<span class="nc" id="L3631">			return tr;</span>
<span class="nc" id="L3632">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3633">			handleException(e);</span>
<span class="nc" id="L3634">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3635">		} catch (JdmoException e) {</span>
<span class="nc" id="L3636">			handleException(e);</span>
<span class="nc" id="L3637">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3638">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3639">			handleException(e);</span>
<span class="nc" id="L3640">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3641">		} catch (Exception e) {</span>
<span class="nc" id="L3642">			handleException(e);</span>
<span class="nc" id="L3643">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3645">			methodFinish();</span>
		}
	} // removeTimeRecordEntry

	/**
	 * for the remove of a new TimeRecordEntry
	 * 
	 * @param Collection
	 *            , TimeRecordEntry ID List
	 */
	public void removeTimeRecordEntry(Collection timeEntryIDList) throws BbmRemoveException {
<span class="nc" id="L3656">		methodStart(&quot;removeTimeRecordEntry&quot;, timeEntryIDList);</span>
<span class="nc" id="L3657">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3659">			DAOUtil.deleteObjects(jdmo, &quot;TIMEENTRYEVENT&quot;, timeEntryIDList);</span>
<span class="nc" id="L3660">		} catch (JdmoException e) {</span>
<span class="nc" id="L3661">			handleException(e);</span>
<span class="nc" id="L3662">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3664">			jdmo.cleanUp();</span>
<span class="nc" id="L3665">			methodFinish();</span>
<span class="nc" id="L3666">		}</span>
<span class="nc" id="L3667">	}</span>

	/**
	 * for the remove of unknown events for a given window for a collection of
	 * employee
	 * 
	 * @param Collection
	 *            , employee ID List
	 * @param start
	 * @param end
	 */
	public void removeUnknownTimeRecordEntry(Collection empIDList, Date start, Date end) throws BbmRemoveException {
<span class="nc" id="L3679">		methodStart(&quot;removeTimeRecordEntry&quot;, empIDList, start, end);</span>
<span class="nc" id="L3680">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3682">			StringBuffer remove = new StringBuffer(&quot;delete TIMEENTRYEVENT where EMPLOYEEID in &quot;).append(jdmo</span>
<span class="nc" id="L3683">					.createInClause(empIDList));</span>
<span class="nc" id="L3684">			remove.append(&quot; and STARTTIME&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;' and STARTTIME&gt;='&quot;)</span>
<span class="nc" id="L3685">					.append(JdmoUtil.formatDBString(start));</span>
<span class="nc" id="L3686">			remove.append(&quot;' and ACTIVITYID=&quot;).append(Activity.ACTIVITY_UNKNOWN);</span>
<span class="nc" id="L3687">			jdmo.executeCommand(remove.toString());</span>
<span class="nc" id="L3688">		} catch (JdmoException e) {</span>
<span class="nc" id="L3689">			handleException(e);</span>
<span class="nc" id="L3690">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3692">			jdmo.cleanUp();</span>
<span class="nc" id="L3693">			methodFinish();</span>
<span class="nc" id="L3694">		}</span>
<span class="nc" id="L3695">	}</span>

	/**
	 * updateTimeRecordEntry, which will invoke updateTimeRecordOnly, used by UI
	 * routine then invoke
	 * updateTimeRecordEntry/insertTimeRecordEntry/deleteTimeRecordEntry
	 * 
	 * @param TimeRecord
	 * @param boolean, if Operation need lockTR from TC, for EndShift, Approval
	 */
	private void updateTimeRecordEntry(TimeRecord timeRecord, boolean lockTR) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc bnc" id="L3707" title="All 2 branches missed.">		if (!timeRecord.isLocked()) {</span>
			try {
<span class="nc" id="L3709">				ArrayList array = timeRecord.getChild();</span>
<span class="nc bnc" id="L3710" title="All 2 branches missed.">				if (array.isEmpty()) {</span>
<span class="nc" id="L3711">					return;</span>
				}
<span class="nc" id="L3713">				int size = array.size();</span>
				// No matter if it is dirty or not, must update the timerecord
				// 1. In order to set the correct Sync Status;
				// 2. Increase the version
<span class="nc" id="L3717">				TimeRecordDAO.updateTimeRecord(timeRecord, true, lockTR);</span>
<span class="nc bnc" id="L3718" title="All 2 branches missed.">				if (timeRecord.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
<span class="nc bnc" id="L3719" title="All 2 branches missed.">					for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L3720">						TimeRecordEntry entry = (TimeRecordEntry) array.get(i);</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">						if (entry.getDirty()) {</span>
<span class="nc" id="L3722">							addModTimestamp(entry);</span>
<span class="nc bnc" id="L3723" title="All 2 branches missed.">							if (entry.isDeleted()) {</span>
<span class="nc bnc" id="L3724" title="All 2 branches missed.">								if (entry.isFromDB()) {</span>
<span class="nc" id="L3725">									TimeRecordDAO.removeTimeRecordEntry(entry.getID());</span>
								}
							} else {
<span class="nc bnc" id="L3728" title="All 2 branches missed.">								if (entry.isFromDB()) {</span>
<span class="nc" id="L3729">									TimeRecordDAO.updateTimeRecordEntry(entry, m_ResetImmidiateToLastActivity);</span>
								} else {
<span class="nc" id="L3731">									entry.setID(TimeRecordDAO.createTimeRecordEntry(entry,</span>
											m_ResetImmidiateToLastActivity));
								}
							}
						}
					}
				}
<span class="nc" id="L3738">			} catch (SPMultiUserException e) {</span>
<span class="nc" id="L3739">				handleException(Priority.INFO, e);</span>
<span class="nc" id="L3740">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L3741">			} catch (Exception e) {</span>
<span class="nc" id="L3742">				handleException(e);</span>
<span class="nc" id="L3743">				BbmUpdateException bue = new BbmUpdateException(e);</span>
<span class="nc" id="L3744">				bue.setContent(timeRecord);</span>
<span class="nc" id="L3745">				throw bue;</span>
<span class="nc" id="L3746">			}</span>
		}
<span class="nc" id="L3748">	}</span>

	/**
	 * Used By UI routine, new feature to refresh the whole TimeRecord
	 * 
	 * @param TimeRecord
	 *            , timeRecord
	 */
	public void updateTimeRecord(TimeRecord timeRecord) throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L3757">		methodStart(&quot;updateTimeRecord&quot;, timeRecord);</span>
		try {
			// Check within the TimeRecord
<span class="nc bnc" id="L3760" title="All 2 branches missed.">			if (timeRecord.validate(true)) {</span>
				// Check with other TimeRecords,
				// but as there is no locking on all other records
				// (performance reason), it is guaranteed there will be no
				// overlap timerecords
<span class="nc" id="L3765">				Collection col = null;</span>
<span class="nc bnc" id="L3766" title="All 2 branches missed.">				if (!timeRecord.getStartTime().equals(timeRecord.getEndTime())) {</span>
<span class="nc" id="L3767">					col = getEventsForWorkResource(timeRecord.getEmployeeID(), timeRecord.getStartTime(),</span>
<span class="nc" id="L3768">							timeRecord.getEndTime());</span>
<span class="nc bnc" id="L3769" title="All 4 branches missed.">					if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc bnc" id="L3770" title="All 2 branches missed.">						if (col.size() == 1) {</span>
<span class="nc" id="L3771">							Iterator it = col.iterator();</span>
<span class="nc" id="L3772">							TimeRecord same = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L3773" title="All 2 branches missed.">							if (!same.getID().equals(timeRecord.getID())) {</span>
								// Rarelly happend, but this implies the
								// TimeRecord is replaced by another one
<span class="nc" id="L3776">								throw new BbmTimeRecordException(BbmTimeRecordException.TR_REMOVED);</span>
							}
<span class="nc" id="L3778">						} else {</span>
							// There are overlapping TimeRecords
<span class="nc" id="L3780">							Iterator it = col.iterator();</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">							while (it.hasNext()) {</span>
<span class="nc" id="L3782">								((TimeRecord) it.next()).setOverlap(true);</span>
							}
<span class="nc" id="L3784">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
						}
					} else {
						// the TimeRecord is adjusted to a new period
<span class="nc" id="L3788">						TimeRecordEntry lastEntry = TimeRecordDAO.findLastTimeEntry(timeRecord.getEmployeeID(),</span>
<span class="nc" id="L3789">								TimeZoneUtil.toTimestamp(timeRecord.getStartTime()));</span>
						// If the last Entry is not EndShift, further check must
						// be done
<span class="nc bnc" id="L3792" title="All 4 branches missed.">						if (lastEntry != null &amp;&amp; lastEntry.getActivityID() != Activity.ACTIVITY_NONE) {</span>
							// If the last Entry TimeRecord is still open, throw
							// exception saying it should be closed
<span class="nc bnc" id="L3795" title="All 2 branches missed.">							if (TimeRecordDAO.isOpenShift(lastEntry.getParentID(),</span>
<span class="nc" id="L3796">									TimeZoneUtil.toTimestamp(timeRecord.getStartTime()))) {</span>
<span class="nc" id="L3797">								BbmTimeRecordException e = new BbmTimeRecordException(</span>
										BbmTimeRecordException.TR_PRV_OPEN_SHIFT);
<span class="nc" id="L3799">								e.setContent(lastEntry);</span>
<span class="nc" id="L3800">								throw e;</span>
							}
							// Or it will overlap with that TimeRecord for sure
<span class="nc" id="L3803">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
						}
					}
				}
<span class="nc" id="L3807">			} else {</span>
				// invalid
<span class="nc" id="L3809">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
			}
			// First refresh the TimeRecord
<span class="nc" id="L3812">			TimeRecordDAO.refreshTimeRecord(timeRecord);</span>
			// Last step is to update timerecord, for escalate syncstatus,
			// remarker employee id
<span class="nc" id="L3815">			TimeRecordDAO.updateTimeRecord(timeRecord, true, true);</span>
			// Cache Task
<span class="nc bnc" id="L3817" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc bnc" id="L3818" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L3819">					m_cat.debug(&quot;In updateTimeRecord, new TimeRecord is &quot; + timeRecord);</span>
				}
<span class="nc" id="L3821">				TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, timeRecord);</span>
			}
<span class="nc" id="L3823">			updateLastEntryCache(timeRecord.getLastEntry());</span>
<span class="nc" id="L3824">			AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3825">					AuditTrailEntry.ACTION_UPDATE_OBJECT, timeRecord.getEmployeeID(),</span>
<span class="nc" id="L3826">					getEmployeeName(timeRecord.getEmployeeID()), timeRecord.getStartTime(), timeRecord.getEndTime());</span>
<span class="nc" id="L3827">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD),</span>
					&quot;-1&quot;, false);
<span class="nc" id="L3829">			m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L3830">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L3831">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3832">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L3833">		} catch (JdmoException e) {</span>
<span class="nc" id="L3834">			handleException(e);</span>
<span class="nc" id="L3835">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3836">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3837">			handleException(e);</span>
<span class="nc" id="L3838">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3839">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3840">			handleException(e);</span>
<span class="nc" id="L3841">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3842">		} catch (Exception e) {</span>
<span class="nc" id="L3843">			handleException(e);</span>
<span class="nc" id="L3844">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3846">			methodFinish();</span>
<span class="nc" id="L3847">		}</span>
<span class="nc" id="L3848">	}</span>

	/**
	 * Used By UI routine, only update TimeRecord information
	 * 
	 * @param TimeRecord
	 *            , timeRecord
	 */
	public void updateTimeRecordOnly(TimeRecord timeRecord) throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L3857">		methodStart(&quot;updateTimeRecordOnly&quot;, timeRecord);</span>
		try {
<span class="nc bnc" id="L3859" title="All 2 branches missed.">			if (TimeRecordDAO.updateTimeRecord(timeRecord, true, false) != 0) {</span>
<span class="nc bnc" id="L3860" title="All 2 branches missed.">				if (cacheUsed()) {</span>
					// Cache task
<span class="nc bnc" id="L3862" title="All 2 branches missed.">					if (m_DebugEnabled)</span>
<span class="nc" id="L3863">						m_cat.debug(&quot;In updateTimeRecordOnly, new TimeRecord is &quot; + timeRecord);</span>
<span class="nc" id="L3864">					TimeRecordCacheUtil.refreshInCache(m_TimeRecordCache, timeRecord);</span>
				}
			}
<span class="nc" id="L3867">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L3868">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3869">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L3870">		} catch (JdmoException e) {</span>
<span class="nc" id="L3871">			handleException(e);</span>
<span class="nc" id="L3872">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3873">		} catch (Exception e) {</span>
<span class="nc" id="L3874">			handleException(e);</span>
<span class="nc" id="L3875">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3877">			methodFinish();</span>
<span class="nc" id="L3878">		}</span>
<span class="nc" id="L3879">	}</span>

	/**
	 * to update a TimeInterval from UI
	 * 
	 * @param ID
	 *            TimeRecord ID
	 * @param TimeInterval
	 *            to-be-updated TimeInterval
	 */
	public void updateTimeInterval(ID timeRecordID, TimeInterval interval) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc" id="L3891">		methodStart(&quot;updateTimeInterval&quot;, timeRecordID, interval);</span>
		try {
<span class="nc" id="L3893">			TimeRecord tr = TimeRecordDAO.getTimeRecordByID(timeRecordID);</span>
			// Here use pessimistic lock, acquire the TimeReocrd before update
			// Coz, for TimeInterval, only one interval for one TimeRecord
<span class="nc" id="L3896">			tr = TimeRecordDAO.getTimeRecordForUpdateOnly(timeRecordID);</span>
<span class="nc bnc" id="L3897" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc" id="L3898">				interval.setParentID(tr);</span>
				// Copy the remarker ID to TimeRecord for update
<span class="nc bnc" id="L3900" title="All 2 branches missed.">				if (interval.getRemarkerID() != null) {</span>
<span class="nc" id="L3901">					tr.setRemarkEmployeeID(interval.getRemarkerID());</span>
				}
<span class="nc" id="L3903">				tr.setApprove(false);</span>
<span class="nc" id="L3904">				TimeRecordDAO.updateTimeRecord(tr, false, false);</span>
<span class="nc" id="L3905">				TimeRecordDAO.updateTimeIntervalOnly(interval);</span>
			} else {
<span class="nc bnc" id="L3907" title="All 2 branches missed.">				if (tr == null) {</span>
<span class="nc" id="L3908">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_REMOVED);</span>
				}
<span class="nc" id="L3910">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
			}
<span class="nc" id="L3912">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3913">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3914">			throw new BbmUpdateDuplicateKeyException(e);</span>
<span class="nc" id="L3915">		} catch (JdmoException e) {</span>
<span class="nc" id="L3916">			handleException(e);</span>
<span class="nc" id="L3917">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3918">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L3919">			handleException(e);</span>
<span class="nc" id="L3920">			throw e;</span>
<span class="nc" id="L3921">		} catch (Exception e) {</span>
<span class="nc" id="L3922">			handleException(e);</span>
<span class="nc" id="L3923">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3925">			methodFinish();</span>
<span class="nc" id="L3926">		}</span>
<span class="nc" id="L3927">	}</span>

	/**
	 * Get Agent whose shift is in Open Status, which means he/she &quot;is IN&quot;
	 * 
	 * @param Collection
	 *            empCol
	 * @return Collection empCol
	 */
	public Collection whoIsIn(Collection empCol) throws BbmFinderException {
<span class="nc" id="L3937">		methodStart(&quot;whoIsIn&quot;);</span>
		try {
<span class="nc" id="L3939">			return whoIsIn(empCol, true);</span>
<span class="nc" id="L3940">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3941">			handleException(e, false);</span>
<span class="nc" id="L3942">			throw e;</span>
		} finally {
<span class="nc" id="L3944">			methodFinish();</span>
		}
	}

	private Collection whoIsIn(Collection empCol, boolean checkActivity) throws BbmFinderException {
		try {
<span class="nc bnc" id="L3950" title="All 4 branches missed.">			if (empCol == null || empCol.isEmpty()) {</span>
<span class="nc" id="L3951">				return Collections.EMPTY_LIST;</span>
			}
<span class="nc bnc" id="L3953" title="All 2 branches missed.">			if (m_DebugEnabled) {</span>
<span class="nc" id="L3954">				m_cat.debug(&quot;In WhoIsIn, we are checking &quot; + empCol);</span>
			}
			// Track who is in
<span class="nc" id="L3957">			ArrayList empInCol = new ArrayList(empCol.size());</span>
			// Track who is not in cache
<span class="nc" id="L3959">			ArrayList empMissedCol = new ArrayList();</span>
<span class="nc" id="L3960">			HashMap empActMap = new HashMap(empCol.size());</span>
<span class="nc" id="L3961">			long lastDayTime = System.currentTimeMillis() - m_LookBackMinutes;</span>
<span class="nc bnc" id="L3962" title="All 4 branches missed.">			if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="nc bnc" id="L3963" title="All 2 branches missed.">				for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3964">					ID empID = (ID) it.next();</span>
<span class="nc" id="L3965">					TimeRecordEntry entry = (TimeRecordEntry) m_LastEntryCache.get(empID);</span>
<span class="nc bnc" id="L3966" title="All 2 branches missed.">					if (entry == null) {</span>
<span class="nc" id="L3967">						empMissedCol.add(empID);</span>
<span class="nc bnc" id="L3968" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L3969">							m_cat.debug(&quot;In WhoIsIn, failed to hit cache for employee &quot; + empID);</span>
						}
					} else {
<span class="nc bnc" id="L3972" title="All 4 branches missed.">						if (entry.getID() != null &amp;&amp; !entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
							// if entry starts earlier than 24 hours of curTime,
							// ignore it
<span class="nc bnc" id="L3975" title="All 2 branches missed.">							if (entry.getSortTime().getTime() &lt; lastDayTime) {</span>
<span class="nc bnc" id="L3976" title="All 2 branches missed.">								if (m_DebugEnabled) {</span>
<span class="nc" id="L3977">									m_cat.debug(&quot;In WhoIsIn, employee &quot; + empID</span>
<span class="nc" id="L3978">											+ &quot; starts 24 hours earlier than now at &quot; + entry.getSortTime());</span>
								}
								continue;
							}
							// if not end shift, need further check activity
							// in/out attribute
<span class="nc" id="L3984">							empActMap.put(empID, entry.getActivityID());</span>
<span class="nc bnc" id="L3985" title="All 2 branches missed.">							if (m_DebugEnabled) {</span>
<span class="nc" id="L3986">								m_cat.debug(&quot;In WhoIsIn, employee &quot; + empID + &quot; has open shift&quot;);</span>
							}
						}
					}
<span class="nc" id="L3990">				}</span>
			} else {
<span class="nc" id="L3992">				empMissedCol = new ArrayList(empCol);</span>
			}
			// If there are employee not in cache yet, hit DB to find info
<span class="nc bnc" id="L3995" title="All 2 branches missed.">			if (!empMissedCol.isEmpty()) {</span>
<span class="nc" id="L3996">				Collection entryCol = TimeRecordDAO.findLastEntry(empMissedCol, null, m_LookBackTimeEntryDays);</span>
<span class="nc bnc" id="L3997" title="All 2 branches missed.">				for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3998">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L3999" title="All 4 branches missed.">					if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="nc" id="L4000">						m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
					}
<span class="nc bnc" id="L4002" title="All 2 branches missed.">					if (!entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc bnc" id="L4003" title="All 2 branches missed.">						if (entry.getSortTime().getTime() &lt; lastDayTime) {</span>
<span class="nc bnc" id="L4004" title="All 2 branches missed.">							if (m_DebugEnabled) {</span>
<span class="nc" id="L4005">								m_cat.debug(&quot;In WhoIsIn, employee &quot; + entry.getEmployeeID()</span>
<span class="nc" id="L4006">										+ &quot; starts 24 hours earlier than now at &quot; + entry.getSortTime());</span>
							}
							continue;
						}
						// if not end shift, need further check activity in/out
						// attribute
<span class="nc" id="L4012">						empActMap.put(entry.getEmployeeID(), entry.getActivityID());</span>
					}
<span class="nc" id="L4014">					empMissedCol.remove(entry.getEmployeeID());</span>
<span class="nc" id="L4015">				}</span>
				// if there is still employee without entry, add dump entry
<span class="nc bnc" id="L4017" title="All 6 branches missed.">				if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; !empMissedCol.isEmpty()) {</span>
<span class="nc bnc" id="L4018" title="All 2 branches missed.">					for (Iterator it = empMissedCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4019">						ID empID = (ID) it.next();</span>
<span class="nc" id="L4020">						TimeRecordEntry dumpEntry = new TimeRecordEntry();</span>
<span class="nc" id="L4021">						m_LastEntryCache.put(empID, dumpEntry);</span>
<span class="nc" id="L4022">					}</span>
				}
			}
<span class="nc bnc" id="L4025" title="All 2 branches missed.">			if (checkActivity) {</span>
				// now check Activity attributes
<span class="nc" id="L4027">				HashSet actIDSet = new HashSet(empActMap.keySet().size());</span>
<span class="nc" id="L4028">				actIDSet.addAll(empActMap.values());</span>
<span class="nc" id="L4029">				Collection actCol = m_ActivityManager.findActivities(actIDSet);</span>
<span class="nc" id="L4030">				HashMap actMap = new HashMap(actCol.size());</span>
				// convert collection to map
<span class="nc bnc" id="L4032" title="All 2 branches missed.">				for (Iterator it = actCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4033">					Activity act = (Activity) it.next();</span>
<span class="nc bnc" id="L4034" title="All 2 branches missed.">					actMap.put(act.getID(), act.isOut() ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="nc" id="L4035">				}</span>
				// now check employee's activity
<span class="nc bnc" id="L4037" title="All 2 branches missed.">				for (Iterator it = empActMap.keySet().iterator(); it.hasNext();) {</span>
<span class="nc" id="L4038">					ID empID = (ID) it.next();</span>
<span class="nc" id="L4039">					ID actID = (ID) empActMap.get(empID);</span>
<span class="nc" id="L4040">					Boolean isIn = (Boolean) actMap.get(actID);</span>
<span class="nc bnc" id="L4041" title="All 4 branches missed.">					if (isIn != null &amp;&amp; !isIn.booleanValue()) {</span>
<span class="nc" id="L4042">						empInCol.add(empID);</span>
					}
<span class="nc" id="L4044">				}</span>
<span class="nc" id="L4045">			} else {</span>
<span class="nc" id="L4046">				empInCol.addAll(empActMap.keySet());</span>
			}
<span class="nc" id="L4048">			return empInCol;</span>
<span class="nc" id="L4049">		} catch (JdmoException e) {</span>
<span class="nc" id="L4050">			throw new BbmFinderException(e);</span>
<span class="nc" id="L4051">		} catch (RemoteException e) {</span>
<span class="nc" id="L4052">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Find last Entry for a given Employee, before a given Date
	 * 
	 * @param ID
	 *            , empID
	 * @param Date
	 *            , date
	 * @return TimeRecordEntry
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public TimeRecordEntry getLastEntry(ID empID, Date date) throws BbmFinderException, RemoteException {
<span class="fc" id="L4068">		methodStart(&quot;getLastEntry&quot;, empID, date);</span>
		try {
<span class="fc" id="L4070">			ArrayList empIDCol = new ArrayList(1);</span>
<span class="fc" id="L4071">			empIDCol.add(empID);</span>
<span class="fc" id="L4072">			HashMap entryMap = getLastEntries(empIDCol, date);</span>
<span class="fc" id="L4073">			return (TimeRecordEntry) entryMap.get(empID);</span>
		} finally {
<span class="pc" id="L4075">			methodFinish();</span>
		}
	}

	/**
	 * Find last Entry for a given Employee, before a given Date
	 * 
	 * @param Collection
	 *            , empID Collection
	 * @param Date
	 *            , date
	 * @return TimeRecordEntry
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public HashMap getLastEntries(Collection empIDCol, Date date) throws BbmFinderException, RemoteException {
<span class="fc" id="L4091">		methodStart(&quot;getLastEntries&quot;, empIDCol, date);</span>
		try {
<span class="fc" id="L4093">			HashMap entryMap = new HashMap(empIDCol.size());</span>
<span class="fc" id="L4094">			ArrayList empCol = new ArrayList(empIDCol.size());</span>
<span class="pc bpc" id="L4095" title="2 of 4 branches missed.">			if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="fc bfc" id="L4096" title="All 2 branches covered.">				for (Iterator it = empIDCol.iterator(); it.hasNext();) {</span>
<span class="fc" id="L4097">					ID empID = (ID) it.next();</span>
<span class="fc" id="L4098">					TimeRecordEntry entry = (TimeRecordEntry) m_LastEntryCache.get(empID);</span>
<span class="fc bfc" id="L4099" title="All 2 branches covered.">					if (entry != null) {</span>
<span class="fc bfc" id="L4100" title="All 2 branches covered.">						if (date == null) {</span>
							// if a dummy entry is found, it implies no entry
							// for employee at all
<span class="fc bfc" id="L4103" title="All 2 branches covered.">							if (entry.getID() != null) {</span>
<span class="fc" id="L4104">								entryMap.put(empID, entry);</span>
							}
						} else {
							// if a date is given, need check if the last Entry
							// is before that date
							// if not, need refetch from DB
<span class="fc bfc" id="L4110" title="All 2 branches covered.">							if (entry.getID() != null) {</span>
<span class="pc bpc" id="L4111" title="1 of 2 branches missed.">								if (entry.getStartTime().before(date)) {</span>
<span class="fc" id="L4112">									entryMap.put(empID, entry);</span>
								} else {
<span class="nc" id="L4114">									empCol.add(empID);</span>
								}
							}
						}
					} else {
<span class="fc" id="L4119">						empCol.add(empID);</span>
					}
<span class="fc" id="L4121">				}</span>
			} else {
<span class="nc" id="L4123">				empCol.addAll(empIDCol);</span>
			}
<span class="fc" id="L4125">			ArrayList empBakCol = new ArrayList();</span>
			// Need Hit DB, try load cache
<span class="pc bpc" id="L4127" title="2 of 6 branches missed.">			if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; !empCol.isEmpty()) {</span>
				// Load from current moment
<span class="fc" id="L4129">				Collection entryCol = TimeRecordDAO.findLastEntry(empCol, null, m_LookBackTimeEntryDays);</span>
<span class="pc bpc" id="L4130" title="1 of 2 branches missed.">				for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4131">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L4132">					entryMap.put(entry.getEmployeeID(), entry);</span>
<span class="nc bnc" id="L4133" title="All 4 branches missed.">					if (date != null &amp;&amp; !entry.getStartTime().before(date)) {</span>
						// if last entry is after given date, need reload
<span class="nc" id="L4135">						empBakCol.add(entry.getEmployeeID());</span>
					}
<span class="nc" id="L4137">				}</span>
				// if there is still employee without entry, add dummy entry
<span class="fc bfc" id="L4139" title="All 2 branches covered.">				for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="fc" id="L4140">					ID empID = (ID) it.next();</span>
<span class="fc" id="L4141">					Object entry = entryMap.get(empID);</span>
<span class="pc bpc" id="L4142" title="1 of 2 branches missed.">					if (entry != null) {</span>
<span class="nc" id="L4143">						m_LastEntryCache.put(empID, entry);</span>
					} else {
<span class="fc" id="L4145">						m_LastEntryCache.put(empID, new TimeRecordEntry());</span>
					}
<span class="fc" id="L4147">				}</span>
<span class="pc bpc" id="L4148" title="3 of 4 branches missed.">				if (empBakCol.isEmpty() || date == null) {</span>
<span class="fc" id="L4149">					return entryMap;</span>
				}
<span class="nc" id="L4151">			} else {</span>
<span class="fc" id="L4152">				empBakCol = empCol;</span>
			}
			// load entries before given date
<span class="pc bpc" id="L4155" title="1 of 2 branches missed.">			if (!empBakCol.isEmpty()) {</span>
<span class="nc" id="L4156">				Collection entryCol = TimeRecordDAO.findLastEntry(empBakCol, date);</span>
<span class="nc bnc" id="L4157" title="All 2 branches missed.">				for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4158">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L4159">					entryMap.put(entry.getEmployeeID(), entry);</span>
<span class="nc" id="L4160">					empBakCol.remove(entry.getEmployeeID());</span>
<span class="nc" id="L4161">				}</span>
				// in case some entries are in map, but not exist before the
				// given date, remove them
<span class="nc bnc" id="L4164" title="All 2 branches missed.">				for (Iterator it = empBakCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4165">					entryMap.remove(it.next());</span>
				}
			}
<span class="fc" id="L4168">			return entryMap;</span>
<span class="nc" id="L4169">		} catch (JdmoException e) {</span>
<span class="nc" id="L4170">			handleException(e, false);</span>
<span class="nc bnc" id="L4171" title="All 2 branches missed.">			if (e.isConnectivityException())</span>
<span class="nc" id="L4172">				throw new ConnectException(e.getMessage(), e);</span>
<span class="nc" id="L4173">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L4175">			methodFinish();</span>
		}
	}

	/**
	 * Return last entry for each employee in the system, if it is created from
	 * a managed datasource or not from any datasource
	 * 
	 * @return Collection, Time Record Entry
	 * @throws BbmFinderException
	 */
	public Collection findLastEntries() throws BbmFinderException {
<span class="nc" id="L4187">		methodStart(&quot;findLastEntries&quot;);</span>
		try {
<span class="nc" id="L4189">			return TimeRecordDAO.findLastEntries();</span>
<span class="nc" id="L4190">		} catch (JdmoException e) {</span>
<span class="nc" id="L4191">			handleException(e, false);</span>
<span class="nc" id="L4192">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4194">			methodFinish();</span>
		}
	}

	/**
	 * Return last entry for given employee in the system, if it is created from
	 * a given datasource before a given date
	 * 
	 * @param Collection
	 *            , employee ID collection
	 * @param ID
	 *            , DataSource ID
	 * @param Date
	 *            , date
	 * @return Collection, Time Record Entry
	 * @throws BbmFinderException
	 */
	public Collection findLastEntries(Collection empIDCol, ID dataSourceID, Date date) throws BbmFinderException {
<span class="nc" id="L4212">		methodStart(&quot;findLastEntries&quot;, empIDCol, dataSourceID, date);</span>
		try {
<span class="nc" id="L4214">			return TimeRecordDAO.findLastEntries();</span>
<span class="nc" id="L4215">		} catch (JdmoException e) {</span>
<span class="nc" id="L4216">			handleException(e, false);</span>
<span class="nc" id="L4217">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4219">			methodFinish();</span>
		}
	}

	// for create entry or update entry, if there is no entry, it won't load
	// cache, defer loading
	private void updateLastEntryCache(TimeRecordEntry entry) {
<span class="pc bpc" id="L4226" title="4 of 8 branches missed.">		if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; entry != null &amp;&amp; entry.getEmployeeID() != null) {</span>
<span class="fc" id="L4227">			TimeRecordEntry lastEntry = (TimeRecordEntry) m_LastEntryCache.get(entry.getEmployeeID());</span>
			// defer last entry loading
<span class="fc bfc" id="L4229" title="All 2 branches covered.">			if (lastEntry == null) {</span>
<span class="fc" id="L4230">				return;</span>
			}
<span class="fc bfc" id="L4232" title="All 2 branches covered.">			if (lastEntry.getID() == null) {</span>
<span class="fc" id="L4233">				m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
			} else {
<span class="pc bpc" id="L4235" title="1 of 2 branches missed.">				if (entry.getID().equals(lastEntry.getID())) {</span>
<span class="nc" id="L4236">					lastEntry.refresh(entry);</span>
<span class="nc" id="L4237">					lastEntry.setStartTime(entry.getStartTime());</span>
<span class="nc" id="L4238">					lastEntry.setSortTime(entry.getSortTime());</span>
<span class="nc" id="L4239">					m_LastEntryCache.put(entry.getEmployeeID(), lastEntry);</span>
<span class="pc bpc" id="L4240" title="1 of 2 branches missed.">				} else if (entry.getSortTime().after(lastEntry.getSortTime())</span>
<span class="nc bnc" id="L4241" title="All 2 branches missed.">						|| entry.getSortTime().equals(lastEntry.getSortTime())) {</span>
<span class="fc" id="L4242">					m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
				}
			}
		}
<span class="fc" id="L4246">	}</span>

	// if need remove an entry, won't do fetch for the new lastEntry, defer the
	// loading
	private void removeLastEntryCache(TimeRecordEntry entry) {
<span class="nc bnc" id="L4251" title="All 8 branches missed.">		if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; entry != null &amp;&amp; entry.getEmployeeID() != null</span>
<span class="nc bnc" id="L4252" title="All 2 branches missed.">				&amp;&amp; entry.getID() != null) {</span>
<span class="nc" id="L4253">			TimeRecordEntry lastEntry = (TimeRecordEntry) m_LastEntryCache.get(entry.getEmployeeID());</span>
<span class="nc bnc" id="L4254" title="All 6 branches missed.">			if (lastEntry != null &amp;&amp; lastEntry.getID() != null &amp;&amp; entry.getID().equals(lastEntry.getID())) {</span>
<span class="nc" id="L4255">				m_LastEntryCache.remove(entry.getEmployeeID());</span>
			}
		}
<span class="nc" id="L4258">	}</span>

	// if need remove an entry, won't do fetch for the new lastEntry, defer the
	// loading
	private void removeLastEntryCache(ID empID, ID trID) {
<span class="nc bnc" id="L4263" title="All 4 branches missed.">		if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="nc" id="L4264">			TimeRecordEntry lastEntry = (TimeRecordEntry) m_LastEntryCache.get(empID);</span>
<span class="nc bnc" id="L4265" title="All 6 branches missed.">			if ((lastEntry != null) &amp;&amp; lastEntry.getID() != null &amp;&amp; trID.equals(lastEntry.getTimeRecordID())) {</span>
<span class="nc" id="L4266">				m_LastEntryCache.remove(empID);</span>
			}
		}
<span class="nc" id="L4269">	}</span>

	/**
	 * internal routine to featch all user's name for day detail
	 * 
	 * @param Collection
	 *            timeRecords
	 */
	private void setUserName(Collection timeRecordCol) {
		try {
<span class="fc" id="L4279">			HashSet userID = new HashSet(10);</span>
			// First get all user ID
<span class="fc bfc" id="L4281" title="All 2 branches covered.">			for (Iterator it = timeRecordCol.iterator(); it.hasNext();) {</span>
<span class="fc" id="L4282">				TimeRecord tr = (TimeRecord) it.next();</span>
<span class="fc bfc" id="L4283" title="All 2 branches covered.">				if (tr.getRemarkEmployeeID() != null) {</span>
<span class="fc" id="L4284">					userID.add(tr.getRemarkEmployeeID());</span>
				}
<span class="fc" id="L4286">			}</span>
<span class="fc" id="L4287">			HashMap userName = m_UserManager.getUserNamesByUserIDs(userID);</span>
<span class="fc bfc" id="L4288" title="All 2 branches covered.">			for (Iterator it = timeRecordCol.iterator(); it.hasNext();) {</span>
<span class="fc" id="L4289">				TimeRecord tr = (TimeRecord) it.next();</span>
<span class="fc bfc" id="L4290" title="All 2 branches covered.">				if (tr.getRemarkEmployeeID() != null) {</span>
<span class="fc" id="L4291">					tr.setRemarkEmployeeName((String) userName.get(tr.getRemarkEmployeeID()));</span>
				}
<span class="fc" id="L4293">			}</span>
<span class="nc" id="L4294">		} catch (Exception e) {</span>
<span class="nc bnc" id="L4295" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L4296">				m_cat.debug(e);</span>
			}
<span class="fc" id="L4298">		}</span>
<span class="fc" id="L4299">	}</span>

	private String getEmployeeName(ID empID) throws Exception {
<span class="fc" id="L4302">		return m_WorkResourceManager.getEmployeeNameByID(empID).getDisplayName(</span>
<span class="fc" id="L4303">				DefaultLocalizationManager.getDefaultInstance().getLocalizer());</span>
	}

	private String getRemarkerName(ID modifierID, Jdmo jdmo) {
<span class="fc" id="L4307">		String strRet = &quot;&quot;;</span>
		try {
<span class="pc bpc" id="L4309" title="1 of 2 branches missed.">			if (modifierID != null) {</span>
<span class="fc" id="L4310">				UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="fc" id="L4311">				User remarker = userMgr.getUserByID(modifierID);</span>
<span class="fc" id="L4312">				ID employeeID = remarker.getEmployeeID();</span>
<span class="pc bpc" id="L4313" title="1 of 2 branches missed.">				if (employeeID != null) {</span>
<span class="nc" id="L4314">					Employee emp = m_WorkResourceManager.getEmployeeByID(employeeID);</span>
<span class="nc" id="L4315">					strRet = emp.getFirstName() + &quot; &quot; + emp.getLastName();</span>
				}
			}
<span class="nc" id="L4318">		} catch (Exception ex) {</span>
<span class="nc" id="L4319">			return &quot;&quot;;</span>
<span class="fc" id="L4320">		}</span>

<span class="fc" id="L4322">		return strRet;</span>
	}

	private void createTempTableForUniqueIntIDs(String empTempTableName, Jdmo jdmo, Collection&lt;ID&gt; uniqueIDs) throws JdmoException {
		try {	
<span class="fc" id="L4327">				String strTemptableName = jdmo.getNativeTemptableName(empTempTableName);</span>
<span class="fc" id="L4328">				jdmo.createTempTable(strTemptableName + &quot; (ID int)&quot;);</span>
<span class="fc" id="L4329">				jdmo.execute(&quot;Create Unique clustered index &quot; + empTempTableName + &quot;_index &quot; + &quot; ON &quot; + strTemptableName + &quot; (ID)&quot;);</span>
				
				//for oracle and sql server, preparedStatement is more faster than Statement.
<span class="fc" id="L4332">				JdmoPCommand pc = jdmo.createPCommand(&quot;insert into &quot;+strTemptableName+&quot; values(?)&quot;);</span>
<span class="fc" id="L4333">				HashMap param = new HashMap();</span>
<span class="fc" id="L4334">				int ix = 0;</span>
<span class="fc bfc" id="L4335" title="All 2 branches covered.">				for (ID id : uniqueIDs) {</span>
<span class="fc" id="L4336">					param.clear();</span>
<span class="fc" id="L4337">					param.put(new Integer(1), new Integer(id.toInt()));	</span>
<span class="fc" id="L4338">					pc.setParams(param);</span>
<span class="fc" id="L4339">					pc.addBatch();</span>
<span class="fc" id="L4340">				}</span>
<span class="fc" id="L4341">				jdmo.executeBatchPCommand(pc);</span>
			
<span class="nc" id="L4343">		} catch(SQLException e) {</span>
<span class="nc" id="L4344">			throw new JdmoException(e);</span>
<span class="fc" id="L4345">		}</span>
<span class="fc" id="L4346">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>