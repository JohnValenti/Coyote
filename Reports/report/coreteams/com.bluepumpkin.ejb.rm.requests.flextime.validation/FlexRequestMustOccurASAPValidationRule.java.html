<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FlexRequestMustOccurASAPValidationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.flextime.validation</a> &gt; <span class="el_source">FlexRequestMustOccurASAPValidationRule.java</span></div><h1>FlexRequestMustOccurASAPValidationRule.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.flextime.validation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validator;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.setup.validation.ejb.ValidationRuleManager;
import com.bluepumpkin.ejb.rm.util.DateUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;

<span class="nc" id="L35">public class FlexRequestMustOccurASAPValidationRule implements Validator {</span>

	public static final String MUST_OCCUR_ASAP_MAX_DAYS = &quot;MUST_OCCUR_ASAP_MAX_DAYS&quot;;

<span class="nc" id="L39">	public static final ID RULE_ID = new ID(-194062);</span>

<span class="nc" id="L41">	private static final String CLASS_NAME = FlexRequestMustOccurASAPValidationRule.class.getName();</span>
<span class="nc" id="L42">	private static final Category LOG = Log.initCategory(CLASS_NAME);</span>

	@Override
	public ValidationResult validate(Validatable validatable) throws Exception {
		ValidationResult result;
<span class="nc" id="L47">		LOG.debug(RmUtil.dumpEnterMethod(&quot;validate&quot;, validatable));</span>

<span class="nc" id="L49">		TORequest tor = (TORequest) validatable;</span>

<span class="nc bnc" id="L51" title="All 2 branches missed.">		if (DateUtil.isBeforeOrEqual(getLatestMakeupStartDate(tor), getTimeOffEndDate(tor))) {</span>
			// all makeup blocks happen before or right after time off duration
<span class="nc" id="L53">			result = null;</span>

		} else {
			// some makeup blocks happen after time off

			// check all makeup blocks happen in N-day duration from time off end time
<span class="nc" id="L59">			result = validateAllMakeupHappenBeforeLatestAllowedDate(RULE_ID, tor);</span>

			// if we can find a big enough available block which agent didn't use, then rule is violated
<span class="nc bnc" id="L62" title="All 2 branches missed.">			if (result == null) {</span>
<span class="nc" id="L63">				result = validateAllMakeupHappenNotLaterThanFirstAvailableBlock(RULE_ID, tor);</span>
			}

		}

<span class="nc" id="L68">		LOG.debug(RmUtil.dumpExitMethod(&quot;validate&quot;, result));</span>
<span class="nc" id="L69">		return result;</span>
	}

	private ValidationResult validateAllMakeupHappenBeforeLatestAllowedDate(ID ruleId, TORequest tor) throws Exception {
		ValidationResult result;

<span class="nc" id="L75">		Map&lt;String, Integer&gt; ruleParams = getValidationRuleManager().getValidationRuleParams(getOrgID(tor), ruleId);</span>
<span class="nc" id="L76">		int maxAllowedDayNum = ruleParams.get(MUST_OCCUR_ASAP_MAX_DAYS);</span>

<span class="nc" id="L78">		Date latestAllowedDate = DateTimeUtil.getDateForDaysAfter(getTimeOffEndDate(tor), maxAllowedDayNum, getTimeZone(tor));</span>

<span class="nc" id="L80">		Date latestMakeupStartDate = getLatestMakeupStartDate(tor);</span>

<span class="nc bnc" id="L82" title="All 2 branches missed.">		if (DateUtil.isBeforeOrEqual(latestMakeupStartDate, latestAllowedDate)) {</span>
<span class="nc" id="L83">			result = null;</span>
		} else {
<span class="nc" id="L85">			result = ValidationUtil.setSoftValidationResult(tor, RmEjbBundleKey.FLEX_REQ_ASAP_MAKEUP_NOT_IN_DURATION, latestAllowedDate, maxAllowedDayNum, CLASS_NAME);</span>
		}
<span class="nc" id="L87">		return result;</span>
	}


	private ValidationResult validateAllMakeupHappenNotLaterThanFirstAvailableBlock(ID ruleId, TORequest tor) throws Exception {

		// If we can find some slot which can fit the all makeup time minutes
		// between time off end date and the latest (makeup+gap)'s start date
		// then the rule is violated. Also consider below exceptions:
		// Exceptions:
		//       1. Time Off end time = shift end time, IGNORE this (AFTER) OT when checking availability (both for this flex time off and existing calendar time off)
		//       2. (Makeup + gap)'s start time = shift end time, ignore this AFTER OT (because if this OT fits, request is still valid)
		//       3. (Makeup + gap)'s end time = shift start time, ignore this BEFORE OT (because if it fits, request is still valid)
		//
		// For AFTER OTs, check the first available duration from shift end time to first event start time (or HOO end time if no event)
		// For BEFOTE OTs, check the first available duration from shift start time backward to last event end time (or HOO start time if no event)

		// The block (if any) will be between end date of time off -&gt; start date of latest (makeup+gap)
<span class="nc" id="L105">		TimeRange latestMakeupAndGapExtension = getLatestMakeupAndGapExtension(tor);</span>
<span class="nc" id="L106">		TimeRange limitDuration = new TimeRange(getTimeOffEndDate(tor), latestMakeupAndGapExtension.getStartDate());</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">		if (limitDuration.isInstant()) {</span>
			// if the latest makeup duration (with gap time) starts right after the time off duration, request is valid
<span class="nc" id="L109">			return null;</span>
		}

		// find calendar events and shift events between  start date of time off -&gt; start date of latest (makeup+gap)
		// if time off ends at shift end, make sure we also IGNORE this AFTER OT at shift end - so using Time Off End Date to avoid &quot;seeing&quot; the shift -
		// when finding shift events. And we also exclude the OT block which contains last makeup block - so using last makeup start date
<span class="nc" id="L115">		Collection&lt;ShiftAssignment&gt; pubShifts = getPublishedShiftAssignments(tor, new TimeRange(getTimeOffEndDate(tor), latestMakeupAndGapExtension.getStartDate()));</span>
<span class="nc" id="L116">		TimeRange eventsDuration = new TimeRange(getTimeOffStartDate(tor), latestMakeupAndGapExtension.getStartDate());</span>
<span class="nc" id="L117">		Collection&lt;CalendarEventAssignment&gt; calendarEvents = getPublishedCalendarEvents(tor, eventsDuration);</span>
<span class="nc" id="L118">		Collection&lt;OrganizationHOO&gt; organizationHOOs = getHOOs(tor, eventsDuration);</span>
<span class="nc" id="L119">		int totalMakeupMinutes = getTotalMakeupMinutes(tor);</span>
<span class="nc" id="L120">		TimeZone tz = getTimeZone(tor);</span>
<span class="nc" id="L121">		TimeRange availableBlock = null;</span>
<span class="nc" id="L122">		OrganizationSetting orgSettings = getFTValidationCache(tor).getOrgSettingForOrgID(getOrgID(tor));</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">		for (ShiftAssignment currentShift : pubShifts) {</span>

			// we don't consider overtime shifts
<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (EventUtils.isOTShift(currentShift)) {</span>
<span class="nc" id="L128">				continue;</span>
			}

<span class="nc" id="L131">			TimeRange hoo = findHOO(tz, currentShift.getStartTime(), organizationHOOs);</span>

			// we don't consider shifts which violating org HOO
<span class="nc bnc" id="L134" title="All 4 branches missed.">			if (hoo == null || !(new TimeRange(currentShift.getStartTime(), currentShift.getEndTime()).isInside(hoo))) {</span>
<span class="nc" id="L135">				continue;</span>
			}

			// Check Before
<span class="nc bnc" id="L139" title="All 2 branches missed.">			if (isExtBeforeShiftAvailable(tor, orgSettings, currentShift)</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">					&amp;&amp; !getTimeOffStartDate(tor).equals(currentShift.getStartTime())</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">					&amp;&amp; !latestMakeupAndGapExtension.getEndDate().equals(currentShift.getStartTime())) {</span>
<span class="nc" id="L142">				availableBlock = findAvailableBlockInBeforeExtension(limitDuration, currentShift, pubShifts, calendarEvents, hoo, totalMakeupMinutes, tz);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">				if (availableBlock != null) {</span>
<span class="nc" id="L144">					break;</span>
				}
			}

			// Check gaps
<span class="nc bnc" id="L149" title="All 2 branches missed.">			if (isExtInGapAvailable(orgSettings)) {</span>
<span class="nc" id="L150">				availableBlock = findAvailableBlockInGaps(getTimeOffEndDate(tor), limitDuration, currentShift, calendarEvents, totalMakeupMinutes);</span>
			}
<span class="nc bnc" id="L152" title="All 2 branches missed.">			if (availableBlock != null) {</span>
<span class="nc" id="L153">				break;</span>
			}

			// Check After
<span class="nc bnc" id="L157" title="All 2 branches missed.">			if (isExtAfterShiftAvailable(tor, orgSettings, currentShift)</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">					&amp;&amp; !getTimeOffEndDate(tor).equals(currentShift.getEndTime())</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">					&amp;&amp; !latestMakeupAndGapExtension.getStartDate().equals(currentShift.getEndTime())) {</span>
<span class="nc" id="L160">				availableBlock = findAvailableBlockInAfterExtension(limitDuration, currentShift, pubShifts, calendarEvents, hoo, totalMakeupMinutes, tz);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">				if (availableBlock != null) {</span>
<span class="nc" id="L162">					break;</span>
				}
			}
<span class="nc" id="L165">		}</span>

		ValidationResult result;
<span class="nc bnc" id="L168" title="All 2 branches missed.">		if (availableBlock != null) {</span>
<span class="nc" id="L169">			result = ValidationUtil.setSoftValidationResult(tor, RmEjbBundleKey.FLEX_REQ_ASAP_AVAILABLE_BLOCK_IN_DURATION, availableBlock.getStartDate(), availableBlock.getEndDate(), CLASS_NAME);</span>
		} else {
<span class="nc" id="L171">			result = null;</span>
		}

<span class="nc" id="L174">		return result;</span>
	}


	/**
	 * Check if BEFORE OT extension is available (Request Management settings for the organization allows extensions before shift and the shift does not have Before OT)
	 */
	private boolean isExtBeforeShiftAvailable(TORequest tor,
			OrganizationSetting orgSettings, ShiftAssignment shiftAssignment) throws Exception {
<span class="nc bnc" id="L183" title="All 2 branches missed.">		return orgSettings.getAllowMakeupBeforeShift() &amp;&amp;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">				shiftAssignment.getOTExtensionBeforeID() == null &amp;&amp;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">				shiftAssignment.getOTExtensionBeforeActivityID() == null;</span>
	}

	/**
	 * Check if gap extension is available (Request Management settings for the organization allows extensions in gap)
	 */
	private boolean isExtInGapAvailable(OrganizationSetting orgSettings) throws Exception {
<span class="nc" id="L192">		return orgSettings.getAllowMakeupInGap();</span>
	}

	/**
	 * Check if AFTER OT extension is available (Request Management settings for the organization allows extensions after shift and the shift does not have After OT)
	 */
	private boolean isExtAfterShiftAvailable(TORequest tor,
			OrganizationSetting orgSettings, ShiftAssignment shiftAssignment) throws Exception {
<span class="nc bnc" id="L200" title="All 2 branches missed.">		return orgSettings.getAllowMakeupAfterShift() &amp;&amp;</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">				shiftAssignment.getOTExtensionAfterID() == null &amp;&amp;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">				shiftAssignment.getOTExtensionAfterActivityID() == null;</span>
	}

	private TimeRange findAvailableBlockInBeforeExtension(TimeRange limitDuration, ShiftAssignment shiftAssignment,
			Collection&lt;ShiftAssignment&gt; pubShifts, Collection&lt;CalendarEventAssignment&gt; calendarEvents, TimeRange hoo, int totalMakeupMinutes, TimeZone tz) throws Exception {

		// find available blocks in the limit duration and not including event time
<span class="nc" id="L209">		Collection&lt;TimeRange&gt; availableBlocks = findAvailableBlocks(hoo.getStartDate(), shiftAssignment.getStartTime(), pubShifts, calendarEvents, limitDuration);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (!availableBlocks.isEmpty()) {</span>
			// the block must end at shift start time and big enough and has no adjacent time off or unavailability after it
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L213">			TimeRange nearestAvailableBlock = Collections.max(availableBlocks);</span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">			if (nearestAvailableBlock.getEndDate().equals(shiftAssignment.getStartTime()) &amp;&amp; nearestAvailableBlock.getDurationMin() &gt;= totalMakeupMinutes</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">					&amp;&amp; !hasAdjacentTimeOffEvents(nearestAvailableBlock, calendarEvents, TimeRange.ADJACENT_AFTER)) {</span>
<span class="nc" id="L216">				return nearestAvailableBlock;</span>
			}
		}

<span class="nc" id="L220">		return null;</span>
	}


	private TimeRange findAvailableBlockInGaps(Date latestTimeOffEndDate, TimeRange limitDuration, ShiftAssignment shift,
			Collection&lt;CalendarEventAssignment&gt; calendarEvents, int totalMakeupMinutes) throws Exception {
<span class="nc" id="L226">		TimeRange availableBlock = null;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">		for (TimeRange gap : new FTValidationCache(new TORequest(RequestDetailLevel.DL_BASIC)).getAllGaps(shift, new ArrayList&lt;Event&gt;(calendarEvents))) {</span>
<span class="nc bnc" id="L228" title="All 4 branches missed.">			if (gap.isInside(limitDuration) &amp;&amp; !latestTimeOffEndDate.equals(gap.getStartDate())) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">				if ((gap.getDurationMin() &gt;= totalMakeupMinutes)</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">						&amp;&amp; !hasAdjacentTimeOffEvents(gap, calendarEvents, TimeRange.ADJACENT_BEFORE)</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">						&amp;&amp; !hasAdjacentTimeOffEvents(gap, calendarEvents, TimeRange.ADJACENT_AFTER)) {</span>
<span class="nc" id="L232">					availableBlock = gap;</span>
<span class="nc" id="L233">					break;</span>
				}
			}
<span class="nc" id="L236">		}</span>
<span class="nc" id="L237">		return availableBlock;</span>
	}

	private TimeRange findAvailableBlockInAfterExtension(TimeRange limitDuration, ShiftAssignment shiftAssignment,
			Collection&lt;ShiftAssignment&gt; pubShifts, Collection&lt;CalendarEventAssignment&gt; calendarEvents, TimeRange hoo, int totalMakeupMinutes, TimeZone tz) throws Exception {

		// find available blocks in the limit duration and not including event time
<span class="nc" id="L244">		Collection&lt;TimeRange&gt; availableBlocks = findAvailableBlocks(shiftAssignment.getEndTime(), hoo.getEndDate(), pubShifts, calendarEvents, limitDuration);</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">		if (!availableBlocks.isEmpty()) {</span>
			// the block must start at shift end time and big enough and has no adjacent time off or unavailability before it
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L248">			TimeRange nearestAvailableBlock = Collections.min(availableBlocks);</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">			if (nearestAvailableBlock.getStartDate().equals(shiftAssignment.getEndTime()) &amp;&amp; nearestAvailableBlock.getDurationMin() &gt;= totalMakeupMinutes</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">					&amp;&amp; !hasAdjacentTimeOffEvents(nearestAvailableBlock, calendarEvents, TimeRange.ADJACENT_BEFORE)) {</span>
<span class="nc" id="L251">				return nearestAvailableBlock;</span>
			}
		}

<span class="nc" id="L255">		return null;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private TimeRange getLatestMakeupAndGapExtension(TORequest tor) throws Exception {
<span class="nc" id="L260">		return Collections.max(getFTValidationCache(tor).getMakeupAndGapDurations());</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private Collection&lt;TimeRange&gt; findAvailableBlocks(Date start, Date end, Collection&lt;ShiftAssignment&gt; pubShifts, Collection&lt;CalendarEventAssignment&gt; calendarEvents, TimeRange limitDuration) {
<span class="nc" id="L265">		Collection&lt;TimeRange&gt; availableBlocks = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">		if (start.before(end)) {</span>
<span class="nc" id="L267">			TimeRange overlappingRange = new TimeRange(start, end).getOverlapInterval(limitDuration);</span>
<span class="nc bnc" id="L268" title="All 4 branches missed.">			if (overlappingRange != null &amp;&amp; !overlappingRange.isInstant()) {</span>
<span class="nc" id="L269">				availableBlocks.add(overlappingRange);</span>
				// remove event time
<span class="nc bnc" id="L271" title="All 2 branches missed.">				for (CalendarEventAssignment event : calendarEvents) {</span>
<span class="nc" id="L272">					Collection&lt;TimeRange&gt; newAvailableBlocks = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">					for (TimeRange availableBlock : availableBlocks) {</span>
<span class="nc" id="L274">						newAvailableBlocks.addAll(availableBlock.splitOrTrim(new TimeRange(event.getStartTime(), event.getEndTime())));</span>
<span class="nc" id="L275">					}</span>
<span class="nc" id="L276">					availableBlocks = newAvailableBlocks;</span>
<span class="nc" id="L277">				}</span>
				// remove shift assignment time (in case a shift crossing HOO boundaries and is close to the next shift)
<span class="nc bnc" id="L279" title="All 2 branches missed.">				for (ShiftAssignment shift : pubShifts) {</span>
<span class="nc" id="L280">					Collection&lt;TimeRange&gt; newAvailableBlocks = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">					for (TimeRange availableBlock : availableBlocks) {</span>
<span class="nc" id="L282">						newAvailableBlocks.addAll(availableBlock.splitOrTrim(new TimeRange(shift.getStartTime(), shift.getEndTime())));</span>
<span class="nc" id="L283">					}</span>
<span class="nc" id="L284">					availableBlocks = newAvailableBlocks;</span>
<span class="nc" id="L285">				}</span>
			}
		}

<span class="nc" id="L289">		return availableBlocks;</span>
	}

	private TimeRange findHOO(TimeZone tz, Date date, Collection&lt;OrganizationHOO&gt; organizationHOOs) {
<span class="nc" id="L293">		TimeRange result = null;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">		for (OrganizationHOO hoo : organizationHOOs) {</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">			if (hoo.isActive() &amp;&amp; RequestUtil.isDateBetween(date, hoo.getStartTime(), hoo.getEndTime())) {</span>
<span class="nc" id="L296">				Date open = hoo.getDayOpen(date, tz);</span>
<span class="nc" id="L297">				Date close = hoo.getDayClose(date, tz);</span>
<span class="nc bnc" id="L298" title="All 4 branches missed.">				if (open != null &amp;&amp; close != null) {</span>
<span class="nc" id="L299">					result = new TimeRange(open, close);</span>
				}
			}
<span class="nc" id="L302">		}</span>
<span class="nc" id="L303">		return result;</span>
	}
	// adjacentBeforeOrAfter = TimeRange.ADJACENT_BEFORE or TimeRange.ADJACENT_AFTER
	private boolean hasAdjacentTimeOffEvents(TimeRange block, Collection&lt;CalendarEventAssignment&gt; calendarEvents, int adjacentBeforeOrAfter) {
<span class="nc bnc" id="L307" title="All 2 branches missed.">		for (CalendarEventAssignment event : calendarEvents) {</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">			if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF || event.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc" id="L309">				TimeRange eventBlock = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L310">				int eventLocation = eventBlock.getAdjacency(block);</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">				if (eventLocation == adjacentBeforeOrAfter) {</span>
<span class="nc" id="L312">					return true;</span>
				}
			}
<span class="nc" id="L315">		}</span>
<span class="nc" id="L316">		return false;</span>
	}

	private Date getTimeOffEndDate(TORequest tor) {
<span class="nc" id="L320">		return tor.getFirstTOChoice().getEndDate();</span>
	}

	private Date getTimeOffStartDate(TORequest tor) {
<span class="nc" id="L324">		return tor.getFirstTOChoice().getStartDate();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private Date getLatestMakeupStartDate(TORequest tor) throws Exception {
<span class="nc" id="L329">		return Collections.max(getFTValidationCache(tor).getMakeupDurations()).getStartDate();</span>
	}

	private int getTotalMakeupMinutes(TORequest tor) {
<span class="nc" id="L333">		return getFTValidationCache(tor).getTotalMakeupMinutes(tor);</span>
	}

	private ID getOrgID(TORequest tor) throws Exception {
<span class="nc" id="L337">		return getFTValidationCache(tor).getOrg().getID();</span>
	}

	private TimeZone getTimeZone(TORequest tor) throws Exception {
<span class="nc" id="L341">		return getFTValidationCache(tor).getOrg().getTimeZone();</span>
	}

	private Collection&lt;OrganizationHOO&gt; getHOOs(TORequest tor, TimeRange eventsDuration) throws Exception {
<span class="nc" id="L345">		return getFTValidationCache(tor).getHOOAssignmentsDuringPeriod(eventsDuration);</span>
	}

	private Collection&lt;ShiftAssignment&gt; getPublishedShiftAssignments(TORequest tor, TimeRange eventsDuration) throws Exception {
<span class="nc" id="L349">		return getFTValidationCache(tor).getPublishedShiftAssignments(eventsDuration);</span>
	}

	private Collection&lt;CalendarEventAssignment&gt; getPublishedCalendarEvents(TORequest tor, TimeRange eventsDuration) throws Exception {
<span class="nc" id="L353">		return getFTValidationCache(tor).getPublishedCalendarEvents(eventsDuration);</span>
	}

	protected FTValidationCache getFTValidationCache(TORequest toRequest) {
<span class="nc" id="L357">		return (FTValidationCache) toRequest.getCache();</span>
	}

	protected ValidationRuleManager getValidationRuleManager() throws BbmCreateException {
<span class="nc" id="L361">		return RmManagerFactory.getInstance().getValidationRuleManager();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>