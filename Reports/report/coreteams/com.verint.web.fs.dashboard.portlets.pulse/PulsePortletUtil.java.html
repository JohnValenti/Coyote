<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PulsePortletUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.web.fs.dashboard.portlets.pulse</a> &gt; <span class="el_source">PulsePortletUtil.java</span></div><h1>PulsePortletUtil.java</h1><pre class="source lang-java linenums">package com.verint.web.fs.dashboard.portlets.pulse;

import java.rmi.RemoteException;
import java.text.DateFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.TimeZone;

import com.bluepumpkin.common.base.Log;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.pulse.ejb.TrackingManager;
import com.bluepumpkin.ejb.bbm.pulse.model.TraceChart;
import com.bluepumpkin.ejb.bbm.pulse.model.TrackingView;
import com.bluepumpkin.ejb.bbm.pulse.util.PulseUtil;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.AggrForecastedTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.AggrRequiredTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.web.bbm.campaign.CampaignModelHandler;
import com.bluepumpkin.web.bbm.campaign.MediaUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.verint.web.fs.dashboard.portlets.pulse.util.Constants;
import com.witness.web.uif.l10n.UIFWebBundleKey;
import com.witness.web.uif.system.RequestContext;

<span class="nc" id="L49">public class PulsePortletUtil {</span>
<span class="nc" id="L50">	private static Category cat = Log.initCategory(PulsePortletUtil.class.getName());</span>
<span class="nc" id="L51">	private static Integer actualTotal = Trace.TRACENA;</span>
<span class="nc" id="L52">	private static Integer forecastTotal = Trace.TRACENA;</span>
<span class="nc" id="L53">	private static Integer requiredTotal = Trace.TRACENA;</span>

	/**
	 * Returns a map of {@code UserTraceCubes} for the given campaign queue for
	 * the statistic type between the start and the end dates. If the queue ID
	 * for which the user trace cubes are to be retrieved is null, the combined
	 * trace cubes for the whole campaign (combined combined) are retrieved. If
	 * the combined trace cubes for a specific media are to be retrieved, pass
	 * the media ID for the queue.
	 * &lt;p/&gt;
	 * 
	 * @param campaignID
	 *            a campaign ID
	 * @param queueID
	 *            a queue ID
	 * @param startDate
	 *            a start date
	 * @param endDate
	 *            an end date
	 * @param type
	 *            a statistic type
	 *            &lt;p/&gt;
	 * @return
	 */
	public static HashMap&lt;ID, TraceCube[]&gt; getUserTraceCubes(ID campaignID, ID queueID, Date startDate, Date endDate,
			StatisticType type) {
		try {
<span class="nc" id="L80">			TrackingManager manager = getTrackingManager();</span>
<span class="nc bnc" id="L81" title="All 10 branches missed.">			if (manager != null &amp;&amp; campaignID != null &amp;&amp; startDate != null &amp;&amp; endDate != null &amp;&amp; type != null) {</span>
<span class="nc" id="L82">				TrackingView view = createTrackingView(type);</span>

				HashMap&lt;ID, TraceCube[]&gt; traceCubes;
<span class="nc bnc" id="L85" title="All 2 branches missed.">				if (queueID == null) {</span>
					// combined combined queues trace cubes
<span class="nc" id="L87">					traceCubes = manager.getCombineTraceCubesByTrackingView(view, campaignID, null, startDate, endDate); // TODO:</span>
																															// if
																															// this
																															// ever
																															// needs
																															// to
																															// be
																															// supported,
																															// some
																															// refactoring
																															// will
																															// need
																															// to
																															// be
																															// done
				} else {
<span class="nc" id="L103">					ID mediaID = null;</span>
					// check if it's a regular queue
					try {
<span class="nc" id="L106">						Queue queue = getWorkLoadManager().getQueueByID(queueID);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">						if (queue == null) {</span>
							// if it's not, set the mediaId
<span class="nc" id="L109">							mediaID = queueID;</span>
						}
<span class="nc" id="L111">					} catch (BbmFinderException e) {</span>
						// ignore it, it must be a media
<span class="nc" id="L113">						mediaID = queueID;</span>
<span class="nc" id="L114">					}</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">					if (mediaID == null) {</span>
<span class="nc" id="L117">						ArrayList&lt;ID&gt; queueIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L118">						queueIDs.add(queueID);</span>
						// plain old queue trace cube
<span class="nc" id="L120">						traceCubes = manager</span>
<span class="nc" id="L121">								.getTraceCubesByTrackingView(view, campaignID, queueIDs, startDate, endDate);</span>
<span class="nc" id="L122">					} else {</span>
						// combined queues trace cubes
<span class="nc" id="L124">						traceCubes = manager.getCombineTraceCubesByTrackingView(view, campaignID, mediaID, startDate,</span>
								endDate);
<span class="nc" id="L126">						HashMap&lt;ID, TraceCube[]&gt; combinedQueueTraceCubes = new HashMap&lt;ID, TraceCube[]&gt;();</span>
<span class="nc" id="L127">						combinedQueueTraceCubes.put(mediaID, traceCubes.get(new ID(-1)));</span>
<span class="nc" id="L128">						traceCubes = new HashMap&lt;ID, TraceCube[]&gt;(combinedQueueTraceCubes);</span>
					}
				}
<span class="nc bnc" id="L131" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; it = traceCubes.keySet().iterator(); it.hasNext();) {</span>
<span class="nc" id="L132">					ID queueId = it.next();</span>
<span class="nc" id="L133">					TraceCube[] backendCubes = traceCubes.get(queueId);</span>
<span class="nc" id="L134">					TraceCube[] uitraceCubes = PulseUtil.createUICubes(view, queueId, startDate, endDate);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">					if (uitraceCubes != null) {</span>
						// initialize the &quot;actual&quot; TraceCube
<span class="nc" id="L137">						PulseUtil.initTraceCube(uitraceCubes[0]);</span>
					}
<span class="nc" id="L139">					PulseUtil.mergeTraceCubes(uitraceCubes, backendCubes);</span>
					// overwrite the back end cubes with the ui cubes.
<span class="nc" id="L141">					traceCubes.put(queueId, uitraceCubes);</span>
<span class="nc" id="L142">				}</span>
<span class="nc" id="L143">				return traceCubes;</span>
			}
<span class="nc" id="L145">		} catch (Exception any) {</span>
<span class="nc" id="L146">			cat.error(&quot;error gettting trace cubes &quot;, any);</span>
<span class="nc" id="L147">		}</span>
<span class="nc" id="L148">		return null;</span>
	}

	/**
	 * Returns forecasted, actual, and required {@code DayDetailData} for the
	 * statistic type at 15 minutes intervals from the user trace cubes.
	 * &lt;p/&gt;
	 * 
	 * @param traceCubes
	 *            the map of trace cubes which need to be combined and a
	 *            consolidated day detail need to be got
	 * @param queueID
	 *            the ID of the queue to retrieve data for
	 * @param startDate
	 *            the start date for which the day detail is to be returned
	 * @param endDate
	 *            the end date for which the day detail is to be returned
	 * @param type
	 *            the type of the statistic
	 *            &lt;p/&gt;
	 * @return the day details for the date, or null if the traceCubes is null
	 */
	public static DayDetailData getDayDetail(HashMap&lt;ID, TraceCube[]&gt; traceCubes, ID queueID, Date startDate,
			Date endDate, StatisticType type) {
<span class="nc" id="L172">		DayDetailData details = new DayDetailData(startDate);</span>

<span class="nc" id="L174">		List&lt;ActualTraceCube&gt; actualTraceCubes = new ArrayList&lt;ActualTraceCube&gt;();</span>
<span class="nc" id="L175">		List&lt;AggrForecastedTraceCube&gt; aggrForecastedTraceCube = new ArrayList&lt;AggrForecastedTraceCube&gt;();</span>
<span class="nc" id="L176">		List&lt;AggrRequiredTraceCube&gt; aggRequiredTraceCubes = new ArrayList&lt;AggrRequiredTraceCube&gt;();</span>
<span class="nc" id="L177">		Map&lt;ID, ID&gt; queueIDToMediaIDMap = new HashMap&lt;ID, ID&gt;();</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">		if (traceCubes != null) {</span>
			try {
<span class="nc" id="L181">				segregateTraceCubeTypes(traceCubes, queueID, actualTraceCubes, aggrForecastedTraceCube,</span>
						aggRequiredTraceCubes, queueIDToMediaIDMap);

<span class="nc bnc" id="L184" title="All 4 branches missed.">				if (type.supportsActual() &amp;&amp; !actualTraceCubes.isEmpty()</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">						&amp;&amp; isTypeSupported(ActualTraceCube.TYPES, type.getId())) {</span>
					// TODO: this isn't needed unless we'll be supporting
					// multi-select in the future
<span class="nc" id="L188">					TraceCube actualTraceCube = actualTraceCubes.get(0); // this</span>
																			// list
																			// should
																			// always
																			// be
																			// of
																			// size
																			// 1
																			// since
																			// multi-select
																			// isn't
																			// supported
					// TraceOperator.combineQueue(actualTraceCubes.toArray(new
					// ActualTraceCube[0]), true, queueIDToMediaIDMap);

<span class="nc bnc" id="L203" title="All 2 branches missed.">					if (actualTraceCube != null) {</span>
<span class="nc" id="L204">						double[] traceValues = actualTraceCube.getTraceValueD((short) type.getId(), startDate, endDate);</span>
<span class="nc" id="L205">						Integer[] dayDetails = new Integer[traceValues.length];</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">						if (traceValues != null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">							for (int k = 0; k &lt; traceValues.length; k++) {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">								if (traceValues[k] &gt; Trace.TRACEINCOMP) {</span>
<span class="nc" id="L209">									dayDetails[k] = TraceUtil.roundDouble(traceValues[k]);</span>
								} else {
									// passing back null so holes can be
									// supported in cases where the value is
									// incomplete or invalid
<span class="nc" id="L214">									dayDetails[k] = null;</span>
								}
							}
						}
<span class="nc" id="L218">						details.setActual(dayDetails);</span>
					}
				}

<span class="nc bnc" id="L222" title="All 4 branches missed.">				if (type.supportsForecast() &amp;&amp; aggrForecastedTraceCube.size() &gt; 0</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">						&amp;&amp; isTypeSupported(AggrForecastedTraceCube.TYPES, type.getId())) {</span>
					// TODO: this isn't needed unless we'll be supporting
					// multi-select in the future
<span class="nc" id="L226">					TraceCube forecastedTraceCube = aggrForecastedTraceCube.get(0); // this</span>
																					// list
																					// should
																					// always
																					// be
																					// of
																					// size
																					// 1
																					// since
																					// multi-select
																					// isn't
																					// supported
					// TraceOperator.combineQueue(aggrForecastedTraceCube.toArray(new
					// AggrForecastedTraceCube[0]), true, queueIDToMediaIDMap);

<span class="nc bnc" id="L241" title="All 2 branches missed.">					if (forecastedTraceCube != null) {</span>
<span class="nc" id="L242">						double[] traceValues = forecastedTraceCube.getTraceValueD((short) type.getId(), startDate,</span>
								endDate);
<span class="nc" id="L244">						Integer[] dayDetails = new Integer[traceValues.length];</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">						if (traceValues != null) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">							for (int k = 0; k &lt; traceValues.length; k++) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">								if (traceValues[k] &gt; Trace.TRACEINCOMP) {</span>
<span class="nc" id="L248">									dayDetails[k] = TraceUtil.roundDouble(traceValues[k]);</span>
								} else {
									// passing back null so holes can be
									// supported in cases where the value is
									// incomplete or invalid
<span class="nc" id="L253">									dayDetails[k] = null;</span>
								}
							}
						}
<span class="nc" id="L257">						details.setForecasted(dayDetails);</span>
					}
				}

<span class="nc bnc" id="L261" title="All 4 branches missed.">				if (type.supportsRequired() &amp;&amp; aggRequiredTraceCubes.size() &gt; 0</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">						&amp;&amp; isTypeSupported(AggrRequiredTraceCube.TYPES, type.getId())) {</span>
					// TODO: this isn't needed unless we'll be supporting
					// multi-select in the future
<span class="nc" id="L265">					TraceCube requiredTraceCube = aggRequiredTraceCubes.get(0); // this</span>
																				// list
																				// should
																				// always
																				// be
																				// of
																				// size
																				// 1
																				// since
																				// multi-select
																				// isn't
																				// supported
					// TraceOperator.combineQueue(aggRequiredTraceCubes.toArray(new
					// AggrRequiredTraceCube[0]), true, queueIDToMediaIDMap);

<span class="nc bnc" id="L280" title="All 2 branches missed.">					if (requiredTraceCube != null) {</span>
<span class="nc" id="L281">						double[] traceValues = requiredTraceCube.getTraceValueD((short) type.getId(), startDate,</span>
								endDate);
<span class="nc" id="L283">						Integer[] dayDetails = new Integer[traceValues.length];</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">						if (traceValues != null) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">							for (int k = 0; k &lt; traceValues.length; k++) {</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">								if (traceValues[k] &gt; Trace.TRACEINCOMP) {</span>
<span class="nc" id="L287">									dayDetails[k] = TraceUtil.roundDouble(traceValues[k]);</span>
								} else {
									// passing back null so holes can be
									// supported in cases where the value is
									// incomplete or invalid
<span class="nc" id="L292">									dayDetails[k] = null;</span>
								}
							}
						}
<span class="nc" id="L296">						details.setRequired(dayDetails);</span>
					}
				}
<span class="nc" id="L299">			} catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L300">				cat.error(&quot;Error getting the queues &quot;, e);</span>
<span class="nc" id="L301">			} catch (BbmFinderException e) {</span>
<span class="nc" id="L302">				cat.error(&quot;Error getting the queues &quot;, e);</span>
<span class="nc" id="L303">			} catch (RemoteException e) {</span>
<span class="nc" id="L304">				cat.error(&quot;Error getting the queues &quot;, e);</span>
<span class="nc" id="L305">			} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L306">				cat.error(&quot;Exception getting teh work load manager &quot;, e);</span>
<span class="nc" id="L307">			}</span>
<span class="nc" id="L308">			return details;</span>
		}
<span class="nc" id="L310">		return null;</span>
	}

	/**
	 * Returns the summary data for each day between the start date and the end
	 * date for the given StatisticType.
	 * 
	 * @param traceCubes
	 * @param queueID the ID of the queue to retrieve data for
	 * @param startDate
	 * @param endDate
	 * @param campaignTimeZone the timezone of the campaign associated with the data in traceCubes
	 * @param type
	 */
	public static SummaryData[] getSummaryData(HashMap&lt;ID, TraceCube[]&gt; traceCubes, ID queueID, Date startDate,
			Date endDate, TimeZone campaignTimeZone, StatisticType type) {
<span class="nc" id="L326">		List&lt;Date&gt; dates = new ArrayList&lt;Date&gt;();</span>

<span class="nc" id="L328">		Calendar cal = Calendar.getInstance(campaignTimeZone);</span>
<span class="nc" id="L329">		cal.clear();</span>
<span class="nc" id="L330">		cal.setTime(startDate);</span>
		// not including the endDate
<span class="nc bnc" id="L332" title="All 2 branches missed.">		while (cal.getTime().before(endDate)) {</span>
<span class="nc" id="L333">			dates.add(cal.getTime());</span>
<span class="nc" id="L334">			cal.add(Calendar.DATE, 1);</span>
		}

<span class="nc" id="L337">		List&lt;ActualTraceCube&gt; actualTraceCubes = new ArrayList&lt;ActualTraceCube&gt;();</span>
<span class="nc" id="L338">		List&lt;AggrForecastedTraceCube&gt; aggrForecastedTraceCube = new ArrayList&lt;AggrForecastedTraceCube&gt;();</span>
<span class="nc" id="L339">		List&lt;AggrRequiredTraceCube&gt; aggRequiredTraceCubes = new ArrayList&lt;AggrRequiredTraceCube&gt;();</span>
<span class="nc" id="L340">		Map&lt;ID, ID&gt; queueIDToMediaIDMap = new HashMap&lt;ID, ID&gt;();</span>

<span class="nc" id="L342">		int[] forecasted = new int[dates.size()];</span>
<span class="nc" id="L343">		initializeArray(forecasted, Trace.TRACENA);</span>

<span class="nc" id="L345">		int[] actual = new int[dates.size()];</span>
<span class="nc" id="L346">		initializeArray(actual, Trace.TRACENA);</span>

<span class="nc" id="L348">		int[] required = new int[dates.size()];</span>
<span class="nc" id="L349">		initializeArray(required, Trace.TRACENA);</span>

<span class="nc bnc" id="L351" title="All 2 branches missed.">		if (traceCubes != null) {</span>
			/*
			 * ActualTraceCube AggrForecastedTraceCube -&gt; ForecastTraceCube &amp;
			 * PredictTraceCube AggrRequiredTraceCube -&gt; ForecastTraceCube &amp;
			 * RequireTraceCube &amp; ServiceGoalTraceCube
			 */
			try {
<span class="nc" id="L358">				segregateTraceCubeTypes(traceCubes, queueID, actualTraceCubes, aggrForecastedTraceCube,</span>
						aggRequiredTraceCubes, queueIDToMediaIDMap);
<span class="nc" id="L360">				ID mediaID = queueIDToMediaIDMap.get(queueID);</span>

<span class="nc" id="L362">				calculateActuals(endDate, type, dates, actualTraceCubes, actual, mediaID);</span>
<span class="nc" id="L363">				calculateForecasted(endDate, type, dates, aggrForecastedTraceCube, forecasted);</span>
<span class="nc" id="L364">				calculateRequired(endDate, type, dates, aggRequiredTraceCubes, required);</span>

<span class="nc" id="L366">				ArrayList&lt;SummaryData&gt; summaryRows = new ArrayList&lt;SummaryData&gt;();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">				for (int i = 0; i &lt; dates.size(); i++) {</span>
<span class="nc" id="L368">					summaryRows.add(new SummaryData(dates.get(i), forecasted[i], actual[i], required[i]));</span>
				}
<span class="nc" id="L370">				return summaryRows.toArray(new SummaryData[0]);</span>
<span class="nc" id="L371">			} catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L372">				cat.error(&quot;Error getting the queues &quot;, e);</span>
<span class="nc" id="L373">			} catch (BbmFinderException e) {</span>
<span class="nc" id="L374">				cat.error(&quot;Error getting the queues &quot;, e);</span>
<span class="nc" id="L375">			} catch (RemoteException e) {</span>
<span class="nc" id="L376">				cat.error(&quot;Error getting the queues &quot;, e);</span>
<span class="nc" id="L377">			} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L378">				cat.error(&quot;Exception getting the work load manager &quot;, e);</span>
<span class="nc" id="L379">			}</span>
		}
<span class="nc" id="L381">		return null;</span>
	}

	/**
	 * Calculate the required data aggregations per day and store in the required param, and calculate
	 * total for the entire period, and store in the requiredTotal member variable.
	 * @param endDate - absolute end of date range
	 * @param type - the StatisticType to calculate
	 * @param dates - all of the dates in the range
	 * @param aggRequiredTraceCubes - raw trace cube data (contains 15-minute values per trace type)
	 * @param required - array to store the required data aggregations per day
	 */
	protected static void calculateRequired(Date endDate, StatisticType type, List&lt;Date&gt; dates,
			List&lt;AggrRequiredTraceCube&gt; aggRequiredTraceCubes, int[] required) {
<span class="nc bnc" id="L395" title="All 4 branches missed.">		if (type.supportsRequired() &amp;&amp; !aggRequiredTraceCubes.isEmpty()</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">				&amp;&amp; isTypeSupported(AggrRequiredTraceCube.TYPES, type.getId())) {</span>
			// TODO: this isn't needed unless we'll be supporting multi-select in the future
			// this list should always be of size 1 since multi-select isn't supported
<span class="nc" id="L399">			TraceCube requireTraceCube = aggRequiredTraceCubes.get(0);</span>
<span class="nc" id="L400">			requiredTotal = Trace.TRACENA;</span>

<span class="nc bnc" id="L402" title="All 2 branches missed.">			if (requireTraceCube != null) {</span>
<span class="nc" id="L403">				int firstStartIndex = 0;</span>
<span class="nc" id="L404">				int lastEndIndex = 0;</span>

<span class="nc bnc" id="L406" title="All 2 branches missed.">				for (int i = 0; i &lt; dates.size(); i++) {</span>
<span class="nc" id="L407">					Date startTime = dates.get(i);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">					Date endTime = (i + 1 &gt;= dates.size() ? endDate : dates.get(i + 1));</span>
<span class="nc" id="L409">					int startIndex = requireTraceCube.getTimeOffset(startTime);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">					if (i == 0) {</span>
<span class="nc" id="L411">						firstStartIndex = startIndex;</span>
					}
<span class="nc" id="L413">					int endIndex = requireTraceCube.getTimeOffset(endTime);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">					if (i == dates.size() - 1) {</span>
<span class="nc" id="L415">						lastEndIndex = endIndex;</span>
					}
<span class="nc bnc" id="L417" title="All 4 branches missed.">					if (startIndex != 1 &amp;&amp; endIndex != -1) {</span>
<span class="nc" id="L418">						double val = TraceOperator.aggregatePeriod(requireTraceCube, (short) type.getId(),</span>
								startIndex, endIndex);
<span class="nc" id="L420">						required[i] = TraceUtil.roundDouble(val);</span>
					}
				}
				// calculate the total for the Period summary
<span class="nc" id="L424">				double totalVal = TraceOperator.aggregatePeriod(requireTraceCube, (short) type.getId(),</span>
						firstStartIndex, lastEndIndex);
<span class="nc" id="L426">				requiredTotal = TraceUtil.roundDouble(totalVal);</span>
			}
		}
<span class="nc" id="L429">	}</span>

	/**
	 * Calculate the forecasted data aggregations per day and store in the forecasted param, and calculate
	 * total for the entire period, and store in the forecastTotal member variable.
	 * @param endDate - absolute end of date range
	 * @param type - the StatisticType to calculate
	 * @param dates - all of the dates in the range
	 * @param aggrForecastedTraceCube - raw trace cube data (contains 15-minute values per trace type)
	 * @param forecasted - array to store the forecasted data aggregations per day
	 */
	protected static void calculateForecasted(Date endDate, StatisticType type, List&lt;Date&gt; dates,
			List&lt;AggrForecastedTraceCube&gt; aggrForecastedTraceCube, int[] forecasted) {
<span class="nc bnc" id="L442" title="All 4 branches missed.">		if (type.supportsForecast() &amp;&amp; !aggrForecastedTraceCube.isEmpty()</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">				&amp;&amp; isTypeSupported(AggrForecastedTraceCube.TYPES, type.getId())) {</span>
			// TODO: this isn't needed unless we'll be supporting multi-select in the future
			// this list should always be of size 1 since multi-select isn't supported
<span class="nc" id="L446">			TraceCube forecastTraceCube = aggrForecastedTraceCube.get(0);</span>
<span class="nc" id="L447">			forecastTotal = Trace.TRACENA;</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">			if (forecastTraceCube != null) {</span>
<span class="nc" id="L450">				int firstStartIndex = 0;</span>
<span class="nc" id="L451">				int lastEndIndex = 0;</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">				for (int i = 0; i &lt; dates.size(); i++) {</span>
<span class="nc" id="L453">					Date startTime = dates.get(i);</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">					Date endTime = (i + 1 &gt;= dates.size() ? endDate : dates.get(i + 1));</span>
<span class="nc" id="L455">					int startIndex = forecastTraceCube.getTimeOffset(startTime);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">					if (i == 0) {</span>
<span class="nc" id="L457">						firstStartIndex = startIndex;</span>
					}
<span class="nc" id="L459">					int endIndex = forecastTraceCube.getTimeOffset(endTime);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">					if (i == dates.size() - 1) {</span>
<span class="nc" id="L461">						lastEndIndex = endIndex;</span>
					}
<span class="nc bnc" id="L463" title="All 4 branches missed.">					if (startIndex != 1 &amp;&amp; endIndex != -1) {</span>
<span class="nc" id="L464">						double val = TraceOperator.aggregatePeriod(forecastTraceCube, (short) type.getId(),</span>
								startIndex, endIndex);
<span class="nc" id="L466">						forecasted[i] = TraceUtil.roundDouble(val);</span>
					}
				}

				// calculate the total for the Period summary
<span class="nc" id="L471">				double totalVal = TraceOperator.aggregatePeriod(forecastTraceCube, (short) type.getId(),</span>
						firstStartIndex, lastEndIndex);
<span class="nc" id="L473">				forecastTotal = TraceUtil.roundDouble(totalVal);</span>
			}
		}
<span class="nc" id="L476">	}</span>

	/**
	 * Calculate the actual data aggregations per day and store in the actual param, and calculate
	 * total for the entire period, and store in the actualTotal member variable.
	 * @param endDate - absolute end of date range
	 * @param type - the StatisticType to calculate
	 * @param dates - all of the dates in the range
	 * @param actualTraceCubes - raw trace cube data (contains 15-minute values per trace type)
	 * @param actual - array to store the actual data aggregations per day
	 */
	protected static void calculateActuals(Date endDate, StatisticType type, List&lt;Date&gt; dates,
			List&lt;ActualTraceCube&gt; actualTraceCubes, int[] actual, ID mediaID) {
<span class="nc bnc" id="L489" title="All 4 branches missed.">		if (type.supportsActual() &amp;&amp; !actualTraceCubes.isEmpty()</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">				&amp;&amp; isTypeSupported(ActualTraceCube.TYPES, type.getId())) {</span>
			// TODO: this isn't needed unless we'll be supporting multi-select in the future
			// this list should always be of size 1 since multi-select isn't supported
<span class="nc" id="L493">			TraceCube actualTraceCube = actualTraceCubes.get(0);</span>
<span class="nc" id="L494">			actualTotal = Trace.TRACENA;</span>

<span class="nc bnc" id="L496" title="All 2 branches missed.">			if (actualTraceCube != null) {</span>
<span class="nc" id="L497">				int firstStartIndex = 0;</span>
<span class="nc" id="L498">				int lastEndIndex = 0;</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">				for (int i = 0; i &lt; dates.size(); i++) {</span>
<span class="nc" id="L500">					Date startTime = dates.get(i);</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">					Date endTime = (i + 1 &gt;= dates.size() ? endDate : dates.get(i + 1));</span>
<span class="nc" id="L502">					int startIndex = actualTraceCube.getTimeOffset(startTime);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">					if (i == 0) {</span>
<span class="nc" id="L504">						firstStartIndex = startIndex;</span>
					}
<span class="nc" id="L506">					int endIndex = actualTraceCube.getTimeOffset(endTime);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">					if (i == dates.size() - 1) {</span>
<span class="nc" id="L508">						lastEndIndex = endIndex;</span>
					}
<span class="nc bnc" id="L510" title="All 4 branches missed.">					if (startIndex != 1 &amp;&amp; endIndex != -1) {</span>
<span class="nc" id="L511">						double val = TraceOperator.aggregatePeriod(actualTraceCube, (short) type.getId(),</span>
								startIndex, endIndex, null, mediaID, TraceChart.ACTUAL_LINE);
<span class="nc" id="L513">						actual[i] = TraceUtil.roundDouble(val);</span>
					}
				}

				// calculate the total for the Period summary
<span class="nc" id="L518">				double totalVal = TraceOperator.aggregatePeriod(actualTraceCube, (short) type.getId(),</span>
						firstStartIndex, lastEndIndex);
<span class="nc" id="L520">				actualTotal = TraceUtil.roundDouble(totalVal);</span>
			}
		}
<span class="nc" id="L523">	}</span>

	/**
	 * Returns the combined (or totals) for the whole period calculated in
	 * {@code getSummaryData}.
	 * &lt;p/&gt;
	 * 
	 * @return
	 */
	public static SummaryData getPeriodSummaryData() {
<span class="nc" id="L533">		return new SummaryData(null, forecastTotal.intValue(), actualTotal.intValue(), requiredTotal.intValue());</span>
	}

	/**
	 * Returns the ID from the string. Returns null if the idStr is null or
	 * empty.
	 * &lt;p/&gt;
	 * 
	 * @param idStr
	 *            &lt;p/&gt;
	 * @return
	 */
	public static ID getID(String idStr) {
<span class="nc bnc" id="L546" title="All 4 branches missed.">		if (idStr != null &amp;&amp; idStr.length() &gt; 0) {</span>
<span class="nc" id="L547">			return new ID(idStr);</span>
		}
<span class="nc" id="L549">		return null;</span>
	}

	/**
	 * Returns the ID from the string. The IDs are delimited by the
	 * {@link Constants#ID_DELIMITER}. Returns null if the idStr is null or
	 * empty.
	 * &lt;p/&gt;
	 * 
	 * @param idStr
	 *            &lt;p/&gt;
	 * @return
	 */
	public static List&lt;ID&gt; getIDs(String idStr) {
<span class="nc bnc" id="L563" title="All 4 branches missed.">		if (idStr != null &amp;&amp; idStr.length() &gt; 0) {</span>
<span class="nc" id="L564">			List&lt;ID&gt; ids = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L565">			StringTokenizer st = new StringTokenizer(idStr, Constants.ID_DELIMITER);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">			while (st.hasMoreTokens()) {</span>
<span class="nc" id="L567">				ids.add(new ID(st.nextToken()));</span>
			}
<span class="nc" id="L569">			return ids;</span>
		}
<span class="nc" id="L571">		return null;</span>
	}

	/**
	 * Returns the queue or the media name given Id. The localizer is used if
	 * the ID is a media. First a check is made to see if the D is a queue, else
	 * a check is made to see if the ID is a media.
	 * &lt;p/&gt;
	 * 
	 * @param id
	 * @param localizer
	 *            &lt;p/&gt;
	 * @return
	 */
	public static String getQueueOrMediaName(ID id, Localizer localizer) {
		try {
<span class="nc" id="L587">			String name = getWorkLoadManager().getQueueNameByID(id);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">			if (name != null) {</span>
<span class="nc" id="L589">				return name;</span>
			}
<span class="nc" id="L591">		} catch (BbmFinderException e) {</span>
			// ignore it might have been a media
<span class="nc" id="L593">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L594">			cat.error(&quot;Exception getting the Queue/Media by Id &quot; + id, e);</span>
<span class="nc" id="L595">		} catch (RemoteException e) {</span>
<span class="nc" id="L596">			cat.error(&quot;Exception getting the Queue/Media by Id &quot; + id, e);</span>
<span class="nc" id="L597">		}</span>

		try {
<span class="nc" id="L600">			Media media = getWorkLoadManager().getMediaByID(id);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">			if (media != null) {</span>
<span class="nc" id="L602">				return MediaUtil.getMediaNodeName(media.getName(), localizer);</span>
			}
<span class="nc" id="L604">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L605">			cat.error(&quot;Exception getting the Queue/Media by Id &quot; + id, e);</span>
<span class="nc" id="L606">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L607">			cat.error(&quot;Exception getting the Queue/Media by Id &quot; + id, e);</span>
<span class="nc" id="L608">		} catch (RemoteException e) {</span>
<span class="nc" id="L609">			cat.error(&quot;Exception getting the Queue/Media by Id &quot; + id, e);</span>
<span class="nc" id="L610">		}</span>
<span class="nc" id="L611">		return id.toString();</span>
	}

	/**
	 * Returns the Name of the campaign by the given ID.
	 * &lt;p/&gt;
	 * 
	 * @param campaignID
	 *            &lt;p/&gt;
	 * @return
	 */
	public static String getCampaignName(ID campaignID) {
		try {
<span class="nc" id="L624">			CampaignManager camManager = getCampaignManager();</span>
<span class="nc" id="L625">			Campaign campaign = camManager.getCampaignByID(campaignID);</span>
<span class="nc" id="L626">			return campaign.getName();</span>
<span class="nc" id="L627">		} catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L628">			cat.error(&quot;Exception gettting the CampaignManager &quot;, e);</span>
<span class="nc" id="L629">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L630">			cat.error(&quot;Exception finding the campaign by Id &quot; + campaignID, e);</span>
<span class="nc" id="L631">		} catch (RemoteException e) {</span>
<span class="nc" id="L632">			cat.error(&quot;Exception getting the campaign by Id &quot; + campaignID, e);</span>
<span class="nc" id="L633">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L634">			cat.error(&quot;Exception getting the campaign by Id &quot; + campaignID, e);</span>
<span class="nc" id="L635">		}</span>
<span class="nc" id="L636">		return campaignID.toString();</span>
	}

	/**
	 * Returns a {@code StatisticType} based on the given
	 * {@code statisticTypeStr}.
	 * &lt;p/&gt;
	 * 
	 * @param statisticTypeStr
	 *            &lt;p/&gt;
	 * @return
	 */
	public static StatisticType getStatisticType(String statisticTypeStr) {
<span class="nc bnc" id="L649" title="All 4 branches missed.">		if (statisticTypeStr != null &amp;&amp; statisticTypeStr.length() &gt; 0) {</span>
<span class="nc" id="L650">			return StatisticType.getStatisticType(Integer.parseInt(statisticTypeStr));</span>
		}
<span class="nc" id="L652">		return StatisticType.FTE;</span>
	}

	/**
	 * Returns a {@code Date} based on the given date string, or null if the
	 * dateStr is null or if there is a parsing error. This uses
	 * {@link DateFormat#FULL} for parsing.
	 * &lt;p/&gt;
	 * 
	 * @param dateStr
	 *            &lt;p/&gt;
	 * @return
	 */
	public static Date getDate(String dateStr) {
<span class="nc bnc" id="L666" title="All 2 branches missed.">		if (dateStr != null) {</span>
			try {
<span class="nc" id="L668">				return DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.FULL).parse(dateStr);</span>
<span class="nc" id="L669">			} catch (ParseException e) {</span>
<span class="nc" id="L670">				cat.error(e);</span>
			}
		}
<span class="nc" id="L673">		return null;</span>
	}

	/**
	 * Returns the date that is -periodicity (days) * numPeriods before today's
	 * day. The date returned is with regard to campaign time zone.
	 * &lt;p/&gt;
	 * 
	 * @param campaignID
	 * @param periodicity
	 * @param numPeriods
	 *            &lt;p/&gt;
	 * @return
	 */
	public static Date getStartDate(ID campaignID, int periodicity, int numPeriods) {
<span class="nc" id="L688">		TimeZone tz = getCampaignTimeZone(campaignID);</span>
<span class="nc" id="L689">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L690">		Calendar cal1 = Calendar.getInstance(tz);</span>
		// need to clear the time component
<span class="nc" id="L692">		cal.clear();</span>
<span class="nc" id="L693">		cal.set(Calendar.YEAR, cal1.get(Calendar.YEAR));</span>
<span class="nc" id="L694">		cal.set(Calendar.MONTH, cal1.get(Calendar.MONTH));</span>
<span class="nc" id="L695">		cal.set(Calendar.DATE, cal1.get(Calendar.DATE));</span>

<span class="nc bnc" id="L697" title="All 2 branches missed.">		if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_DAILY) {</span>
<span class="nc" id="L698">			cal.add(Calendar.DATE, -1 * numPeriods);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_WEEKLY) {</span>
<span class="nc" id="L700">			cal.add(Calendar.DATE, -7 * numPeriods);</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_MONTHLY) {</span>
<span class="nc" id="L702">			cal.add(Calendar.MONTH, -1 * numPeriods);</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_QUARTERLY) {</span>
<span class="nc" id="L704">			cal.add(Calendar.MONTH, -3 * numPeriods);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_YEARLY) {</span>
<span class="nc" id="L706">			cal.add(Calendar.YEAR, -1 * numPeriods);</span>
		}
<span class="nc" id="L708">		return cal.getTime();</span>
	}

	/**
	 * Returns today's date in campaign time zone.
	 * &lt;p/&gt;
	 * 
	 * @param campaignID
	 *            &lt;p/&gt;
	 * @return
	 */
	public static Date getTodayDate(ID campaignID) {
<span class="nc" id="L720">		TimeZone tz = getCampaignTimeZone(campaignID);</span>

<span class="nc" id="L722">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L723">		Calendar cal1 = Calendar.getInstance(tz);</span>
		// need to clear the time component
<span class="nc" id="L725">		cal.clear();</span>
<span class="nc" id="L726">		cal.set(Calendar.YEAR, cal1.get(Calendar.YEAR));</span>
<span class="nc" id="L727">		cal.set(Calendar.MONTH, cal1.get(Calendar.MONTH));</span>
<span class="nc" id="L728">		cal.set(Calendar.DATE, cal1.get(Calendar.DATE));</span>

<span class="nc" id="L730">		return cal.getTime();</span>
	}

	/**
	 * Returns true if the date picker type is type &quot;dateRange&quot;, returns false
	 * otherwise.
	 * &lt;p/&gt;
	 * 
	 * @param datePickerType
	 *            the date picker type to check
	 *            &lt;p/&gt;
	 * @return true if the date picker type is type &quot;dateRange&quot;, returns false
	 *         otherwise
	 */
	public static boolean isDateRangeType(String datePickerType) {
<span class="nc" id="L745">		return LastNPeriodPickerPC.PICKER_TYPE_DATE_RANGE.equals(datePickerType);</span>
	}

	public static boolean isLastNPeriodsType(String datePickerType) {
<span class="nc" id="L749">		return LastNPeriodPickerPC.PICKER_TYPE_LAST_PERIOD.equals(datePickerType);</span>
	}

	public static String getDatePeriodString(int periodicity, int period, Localizer localizer) {
<span class="nc bnc" id="L753" title="All 2 branches missed.">		String prefix = (period &lt; 0 ? localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.PERIOD_NEXT)</span>
<span class="nc" id="L754">				: localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.PERIOD_PREVIOUS));</span>
<span class="nc" id="L755">		int absPeriods = Math.abs(period);</span>
<span class="nc" id="L756">		StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L757">		sb.append(prefix);</span>
<span class="nc" id="L758">		sb.append(&quot; &quot;);</span>
<span class="nc" id="L759">		sb.append(absPeriods);</span>
<span class="nc" id="L760">		sb.append(&quot; &quot;);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">		if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_DAILY) {</span>
<span class="nc" id="L762">			sb.append(localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.PERIOD_DAYS));</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_WEEKLY) {</span>
<span class="nc" id="L764">			sb.append(localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.PERIOD_WEEKS));</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_MONTHLY) {</span>
<span class="nc" id="L766">			sb.append(localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.PERIOD_MONTHS));</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_QUARTERLY) {</span>
<span class="nc" id="L768">			sb.append(localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.PERIOD_QUARTERS));</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">		} else if (periodicity == LastNPeriodPickerPC.PERIOD_TYPE_YEARLY) {</span>
<span class="nc" id="L770">			sb.append(localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.PERIOD_YEARS));</span>
		}
<span class="nc" id="L772">		return sb.toString();</span>
	}

	public static String getDateRangeString(Date start, Date end, Locale locale) {
<span class="nc" id="L776">		return DateFormat.getDateInstance(DateFormat.DEFAULT, locale).format(start) + &quot; - &quot;</span>
<span class="nc" id="L777">				+ DateFormat.getDateInstance(DateFormat.DEFAULT, locale).format(end);</span>
	}

	public static String getDateRangeString(Date start, Date end, Locale locale, TimeZone tz) {
<span class="nc" id="L781">		DateFormat df = DateFormat.getDateInstance(DateFormat.DEFAULT, locale);</span>
<span class="nc" id="L782">		df.setTimeZone(tz);</span>
<span class="nc" id="L783">		return df.format(start) + &quot; - &quot; + df.format(end);</span>
	}

	/**
	 * This method will take a 24 hour time range that spans two dates and trim
	 * it back to encompass a single date. A date of 2Jun12 5:59:59 GMT
	 * processed with a time zone with an offset of -6 will return a value of
	 * 1Jun12 11:59:59. This is primarily being used to adjust the end date of a
	 * time range in the pulse portlet view mode.
	 * &lt;p/&gt;
	 * 
	 * @param date
	 * @param timeZone
	 *            &lt;p/&gt;
	 * @return
	 */
	public static Date trimDateToMidnight(Date date, TimeZone timeZone) {
<span class="nc" id="L800">		return new Date(date.getTime() + timeZone.getOffset(date.getTime()));</span>
	}

	/**
	 * Returns true if type is present in the supportedTypes, otherwise returns
	 * false.
	 * &lt;p/&gt;
	 * 
	 * @param supportedTypes
	 * @param type
	 *            &lt;p/&gt;
	 * @return
	 */
	public static boolean isTypeSupported(short[] supportedTypes, int type) {
<span class="nc bnc" id="L814" title="All 2 branches missed.">		if (supportedTypes != null) {</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">			for (int i = 0; i &lt; supportedTypes.length; i++) {</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">				if (supportedTypes[i] == type) {</span>
<span class="nc" id="L817">					return true;</span>
				}
			}
		}
<span class="nc" id="L821">		return false;</span>
	}

	/**
	 * Segregates the trace cubes and fills the list of forecasted, predicted,
	 * actual, required, and aggRequire trace cubes.
	 * &lt;p/&gt;
	 * 
	 * @param traceCubes
	 * @param forecastTraceCubes
	 * @param predictTraceCubes
	 * @param actualTraceCubes
	 * @param requireTraceCubes
	 * @param aggrRequiredTraceCubes
	 * @param queueIDToMediaIDMap
	 *            &lt;p/&gt;
	 * @throws BbmObjectNotFoundException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws BbmEJBCreateException
	 */
	private static void segregateTraceCubeTypes(HashMap&lt;ID, TraceCube[]&gt; traceCubes, ID queueID,
			List&lt;ActualTraceCube&gt; actualTraceCubes, List&lt;AggrForecastedTraceCube&gt; aggrForecastedTraceCube,
			List&lt;AggrRequiredTraceCube&gt; aggrRequiredTraceCubes, Map&lt;ID, ID&gt; queueIDToMediaIDMap)
			throws BbmObjectNotFoundException, BbmFinderException, RemoteException, BbmEJBCreateException {
<span class="nc bnc" id="L846" title="All 2 branches missed.">		if (traceCubes != null) {</span>
<span class="nc" id="L847">			WorkloadManager workloadManager = getWorkLoadManager();</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; it = traceCubes.keySet().iterator(); it.hasNext();) {</span>
<span class="nc" id="L849">				ID queueId = it.next();</span>

				// set media ID to the queue ID for combined case
<span class="nc" id="L852">				ID mediaID = queueID;</span>
<span class="nc" id="L853">				Queue queue = workloadManager.getQueueByID(queueId);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">				if (queue != null) {</span>
<span class="nc" id="L855">					mediaID = queue.getMediaID();</span>
				}
				// TODO: leaving this here for now in case multi-select is
				// needed in the near future, otherwise it isn't needed
<span class="nc" id="L859">				queueIDToMediaIDMap.put(queueId, mediaID);</span>
<span class="nc" id="L860">				TraceCube[] traceCubesForQueue = traceCubes.get(queueId);</span>

<span class="nc bnc" id="L862" title="All 2 branches missed.">				for (int i = 0; i &lt; traceCubesForQueue.length; i++) {</span>
<span class="nc" id="L863">					TraceCube cube = traceCubesForQueue[i];</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">					if (cube != null) {</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">						if (cube instanceof ActualTraceCube) {</span>
<span class="nc" id="L866">							cube.calcComputedTraceValues(mediaID);</span>
<span class="nc" id="L867">							actualTraceCubes.add((ActualTraceCube) cube);</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">						} else if (cube instanceof AggrRequiredTraceCube) {</span>
<span class="nc" id="L869">							cube.calcComputedTraceValues(mediaID);</span>
<span class="nc" id="L870">							aggrRequiredTraceCubes.add((AggrRequiredTraceCube) cube);</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">						} else if (cube instanceof AggrForecastedTraceCube) {</span>
<span class="nc" id="L872">							aggrForecastedTraceCube.add((AggrForecastedTraceCube) cube);</span>
						} else {
<span class="nc" id="L874">							cat.error(&quot;TraceCube type is not currently handled: &quot; + cube.getClass().getName());</span>
						}
					}
				}
<span class="nc" id="L878">			}</span>
		}
<span class="nc" id="L880">	}</span>

	/**
	 * Initializes each element of the given array with the given value.
	 * &lt;p/&gt;
	 * 
	 * @param values
	 * @param defaultValue
	 */
	private static void initializeArray(int[] values, int defaultValue) {
<span class="nc bnc" id="L890" title="All 2 branches missed.">		if (values != null) {</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">			for (int i = 0; i &lt; values.length; i++) {</span>
<span class="nc" id="L892">				values[i] = defaultValue;</span>
			}
		}
<span class="nc" id="L895">	}</span>

	/**
	 * Creates an in-memory {@code TrackingView} instance for the given
	 * statistic type.
	 * &lt;p/&gt;
	 * 
	 * @param type
	 *            &lt;p/&gt;
	 * @return
	 */
	private static TrackingView createTrackingView(StatisticType type) {
<span class="nc" id="L907">		TrackingView view = new TrackingView();</span>
<span class="nc" id="L908">		view.setTrending(true);</span>
<span class="nc" id="L909">		view.setViewName(type.getName());</span>
<span class="nc" id="L910">		List chartDefinitions = view.getChartDefinition();</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">		if (chartDefinitions == null) {</span>
<span class="nc" id="L912">			chartDefinitions = new ArrayList&lt;TraceChart&gt;();</span>
		}
<span class="nc" id="L914">		TraceChart chart = new TraceChart();</span>
<span class="nc" id="L915">		chartDefinitions.add(chart);</span>

<span class="nc bnc" id="L917" title="All 2 branches missed.">		if (type == StatisticType.FTE) {</span>
<span class="nc" id="L918">			chart.setTraceType(Trace.FTE);</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">		} else if (type == StatisticType.CV) {</span>
<span class="nc" id="L920">			chart.setTraceType(Trace.CV);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">		} else if (type == StatisticType.AHT) {</span>
<span class="nc" id="L922">			chart.setTraceType(Trace.AHT);</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">		} else if (type == StatisticType.PCA) {</span>
<span class="nc" id="L924">			chart.setTraceType(Trace.PCA);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">		} else if (type == StatisticType.ASA) {</span>
<span class="nc" id="L926">			chart.setTraceType(Trace.ASA);</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">		} else if (type == StatisticType.ABANDONMENT) {</span>
<span class="nc" id="L928">			chart.setTraceType(Trace.ABANDONMENT);</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">		} else if (type == StatisticType.BACKLOG) {</span>
<span class="nc" id="L930">			chart.setTraceType(Trace.BACKLOG);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">		} else if (type == StatisticType.STAFFING) {</span>
<span class="nc" id="L932">			chart.setTraceType(Trace.STAFFING);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">		} else if (type == StatisticType.OCCUPANCY) {</span>
<span class="nc" id="L934">			chart.setTraceType(Trace.OCCUPANCY);</span>
		}

		// add the dependant types as well
<span class="nc" id="L938">		short[] dependantTypes = com.bluepumpkin.web.fs.pulse.util.PulseUtil.getDependantTraceTypes(</span>
<span class="nc" id="L939">				chart.getTraceType(), false, false);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">		if (dependantTypes != null) {</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">			for (int i = 0; i &lt; dependantTypes.length; i++) {</span>
<span class="nc" id="L942">				TraceChart depChart = new TraceChart();</span>
<span class="nc" id="L943">				chartDefinitions.add(depChart);</span>
<span class="nc" id="L944">				depChart.setTraceType(dependantTypes[i]);</span>
<span class="nc" id="L945">				depChart.setLineType(TraceChart.LINE_TYPES_ARRAY, true);</span>
			}
		}
<span class="nc" id="L948">		chart.setLineType(TraceChart.LINE_TYPES_ARRAY, true);</span>
<span class="nc" id="L949">		view.setChartDefinition(chartDefinitions);</span>
<span class="nc" id="L950">		PulseUtil.addDependentLinesToView(view, false);</span>
<span class="nc" id="L951">		return view;</span>
	}

	/**
	 * This method will return the first campaign that the user has permission
	 * to view, based on the default sort ordering coming from the backend call to CampaignManager.
	 */
	static Campaign getDefaultCampaignForUser(RequestContext context) throws BbmException, RemoteException {
<span class="nc" id="L959">		Collection&lt;Campaign&gt; campaignList = CampaignModelHandler.getCampaignsForUser(context, context.getUser());</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">		if (!campaignList.isEmpty()) {</span>
<span class="nc" id="L961">			return new ArrayList&lt;&gt;(campaignList).get(0);</span>
		}
<span class="nc" id="L963">		return null;</span>
	}

	/**
	 * This method will return a date relative to the given date and offset with
	 * regard to the given campaign ID. If the date passed in were &quot;Thursday,
	 * June 21 02:12:00 GMT 2012&quot; and the campaign had a -4 hour offset from
	 * GMT, the returned date will be &quot;Wednesday, June 20 22:12:00 GMT 2012&quot;.
	 * &lt;p/&gt;
	 * 
	 * @param campaignID
	 * @param date
	 *            &lt;p/&gt;
	 * @return a date relative to the given date and offset with regard to the
	 *         given campaign ID
	 */
	public static Date getCampaignTZAdjustedDate(ID campaignID, Date date) {
		// adjust the given date according to the capaign timezone offset,
		// the DST for the timezone will be taken into account with this call
		// to getOffset
<span class="nc" id="L983">		return new Date(date.getTime() - getCampaignTimeZone(campaignID).getOffset(date.getTime()));</span>
	}

	/**
	 * This method will return the start of day for a given date with regard to
	 * the campaign.
	 * &lt;p/&gt;
	 * 
	 * @param campaignID
	 * @param date
	 *            &lt;p/&gt;
	 * @return the start of day for a given date with regard to the campaign
	 */
	public static Date getCampaignStartOfDay(ID campaignID, Date date) {
<span class="nc" id="L997">		Calendar campaignTZAdjustedDate = Calendar.getInstance();</span>
<span class="nc" id="L998">		campaignTZAdjustedDate.clear();</span>
		// set the calendar to the given date adjusted according to the capaign
		// timezone offset
<span class="nc" id="L1001">		campaignTZAdjustedDate.setTime(getCampaignTZAdjustedDate(campaignID, date));</span>
<span class="nc" id="L1002">		Calendar campaignStartOfDay = Calendar.getInstance();</span>
<span class="nc" id="L1003">		campaignStartOfDay.clear();</span>
<span class="nc" id="L1004">		campaignStartOfDay.setTimeZone(getCampaignTimeZone(campaignID));</span>
<span class="nc" id="L1005">		campaignStartOfDay.set(Calendar.YEAR, campaignTZAdjustedDate.get(Calendar.YEAR));</span>
<span class="nc" id="L1006">		campaignStartOfDay.set(Calendar.MONTH, campaignTZAdjustedDate.get(Calendar.MONTH));</span>
<span class="nc" id="L1007">		campaignStartOfDay.set(Calendar.DATE, campaignTZAdjustedDate.get(Calendar.DATE));</span>
<span class="nc" id="L1008">		return campaignStartOfDay.getTime();</span>
	}

	/**
	 * This method will return the end of day for a given date with regard to
	 * the campaign.
	 * &lt;p/&gt;
	 * 
	 * @param campaignID
	 * @param date
	 *            &lt;p/&gt;
	 * @return the end of day for a given date with regard to the campaign
	 */
	public static Date getCampaignEndOfDay(ID campaignID, Date date) {
<span class="nc" id="L1022">		Calendar campaignEndOfDay = Calendar.getInstance();</span>
<span class="nc" id="L1023">		campaignEndOfDay.clear();</span>
<span class="nc" id="L1024">		campaignEndOfDay.setTime(getCampaignStartOfDay(campaignID, date));</span>
<span class="nc" id="L1025">		campaignEndOfDay.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1026">		campaignEndOfDay.add(Calendar.MINUTE, -15);</span>

<span class="nc" id="L1028">		return campaignEndOfDay.getTime();</span>
	}

	public static Date getCampaignStartOfDayForDate(ID campaignID, Date date) {
<span class="nc" id="L1032">		return getCampaignTZAdjustedDate(campaignID, date);</span>
	}

	public static Date getCampaignEndOfDayForDate(ID campaignID, Date date) {
<span class="nc" id="L1036">		Calendar campaignEndOfDayForDate = Calendar.getInstance();</span>
<span class="nc" id="L1037">		campaignEndOfDayForDate.clear();</span>
<span class="nc" id="L1038">		campaignEndOfDayForDate.setTimeZone(getCampaignTimeZone(campaignID));</span>
<span class="nc" id="L1039">		campaignEndOfDayForDate.setTime(getCampaignStartOfDayForDate(campaignID, date));</span>
<span class="nc" id="L1040">		campaignEndOfDayForDate.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1041">		campaignEndOfDayForDate.add(Calendar.MINUTE, -15);</span>

<span class="nc" id="L1043">		return campaignEndOfDayForDate.getTime();</span>
	}

	public static TimeZone getCampaignTimeZone(ID campaignID) {
		try {
<span class="nc" id="L1048">			return getCampaignManager().getTimeZoneByCampaignID(campaignID);</span>
<span class="nc" id="L1049">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1050">			cat.error(&quot;Could not get campaign Time zone &quot;, e);</span>
<span class="nc" id="L1051">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L1052">			cat.error(&quot;Could not get campaign Time zone &quot;, e);</span>
<span class="nc" id="L1053">		} catch (RemoteException e) {</span>
<span class="nc" id="L1054">			cat.error(&quot;Could not get campaign Time zone&quot;, e);</span>
<span class="nc" id="L1055">		}</span>
<span class="nc" id="L1056">		return null;</span>
	}

	public static TrackingManager getTrackingManager() throws BbmEJBCreateException {
<span class="nc" id="L1060">		return WfmManagerFactory.getPulseTrackingManager();</span>
	}

	public static WorkloadManager getWorkLoadManager() throws BbmEJBCreateException {
<span class="nc" id="L1064">		return WfmManagerFactory.getWorkloadManager();</span>
	}

	public static CampaignManager getCampaignManager() throws BbmEJBCreateException {
<span class="nc" id="L1068">		return WfmManagerFactory.getCampaignManager();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>