<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AutoProcessingRuleChecker.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.validation</a> &gt; <span class="el_source">AutoProcessingRuleChecker.java</span></div><h1>AutoProcessingRuleChecker.java</h1><pre class="source lang-java linenums">/*
 * AutoProcessingRuleChecker.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */

package com.bluepumpkin.ejb.rm.requests.common.validation;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.cache.CacheUtilRM;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AvaliableHoursValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AvoidBlackoutsValidationRule;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule;
import com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingValidation;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;

/**
 * Responsible for running the specified autoProcessing rules against the given request.
 * The autoProcessing rules are dependent on the validation rules specified for the org
 * the request's employee is assoicated with.  This rule checker stores and uses the enabled
 * validation rules for running the autoProcessing.
 *
 * &lt;p&gt;Refer to {@link #autoProcess(Map, boolean, boolean) autoProcess(Map, boolean, boolean)}
 * for notes about the not so straightforward logic when processing autoProc rules of type
 * &quot;Deny requests violating rules: &quot;
 *
 * Title:        Blue Pumpkin Software Request Management Module
 * Copyright:    Copyright (c) 2001-2004
 * Company:      Blue Pumpkin Software, inc
 * @author       Raja Rajendran
 */
public class AutoProcessingRuleChecker {

    /**
     * Logger category
     */
<span class="fc" id="L57">    private static Category log = Log.initCategory( AutoProcessingRuleChecker.class.getName());</span>

    /**
     * Used to indicate that the evaluation of the autoprocessing rule's approval clause 
     * resulted in running one or more validators and none of the validators failed.
     */
    public static final int AUTOPROC_APPRCLAUSE_NO_VIOLATIONS = 1;
    
    /**
     * Used to indicate that the autoprocessing rule's approval clause specifies &quot;do not auto approve
     * any request&quot;
     */
    public static final int AUTOPROC_APPRCLAUSE_DONOT_APPROVE = 2;
    
    /**
     * Used to indicate that the evaluation of the autoprocessing rule's approval clause 
     * resulted in running one or more validators and one of the validators failed.
     */
    public static final int AUTOPROC_APPRCLAUSE_VIOLATIONS_FOUND = 3;
    
    /**
     * Used to indicate that the evaluation of the autoprocessing rule's denial clause 
     * resulted in the running of one or more validators and one of the validators failed.
     */
    public static final int AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND = 4;

    /**
     * Used to indicate that the autoProcessing rule's denial clause specifies &quot;do not auto deny
     * any request&quot;.
     */
    public static final int AUTOPROC_DENYCLAUSE_DONOT_DENY = 5;

    /**
     * Used to indicate that the evaluation of the autoprocessing rule's denial clause 
     * resulted in the running of one or more validators and none of the validators failed.
     */
    public static final int AUTOPROC_DENYCLAUSE_NO_VIOLATIONS = 6;

    /**
     * Used to indicate that the evaluation of the autoprocessing rule's WAITLIST  clause
     * resulted in running one or more validators and one of the validators failed.
     */
    public static final int AUTOPROC_WAITLIST_CLAUSE_VIOLATIONS_FOUND = 7;
    /**
     * Used to indicate that the autoprocessing rule's WAITLIST  clause specifies
     * &quot;do not auto WAITLIST any request&quot;
     */
    public static final int AUTOPROC_WAITLIST_CLAUSE_DONOT_WAITLIST = 8;
    /**
     * Used to indicate that the evaluation of the autoprocessing rule's WAITLIST  clause
     * resulted in running one or more validators and none of the validators failed.
     */
    public static final int AUTOPROC_WAITLIST_CLAUSE_NO_VIOLATIONS = 9;

	
    /**
     * The collection of auto processing rules used by this checker.
     */
<span class="fc" id="L115">    protected Collection m_autoprocessingRules = null;</span>

    /**
     * The collection of holidays germain to this checker.
     */
<span class="fc" id="L120">    protected Collection m_holidaysDuringRange = null;</span>

    /**
     * The timezone to use for this rule checker.  This comes from the
     * organization.
     */
<span class="fc" id="L126">    protected TimeZone m_tz = null;</span>

    /**
     * This is the list of enabled soft validators for the specified requestType and for an
     * organization (typically the orgID of the employee associated with this request).
     *
     * &lt;p&gt; Note that these valiation rules are different from the validators associated with
     * the auto processing rule itself..
     *
     * &lt;p&gt; Validation rules for an organization are set up in the UI
     * using: Organization Setup &gt; Request Management &gt; Validation.
     */
<span class="fc" id="L138">    protected Collection m_enabledValidatorsForOrg = null;</span>

    /**
     * The request to be auto processed.
     */
<span class="fc" id="L143">    protected Validatable m_request = null;</span>

    /**
     * The day boundary offset for the organization.
     * Offset in minutes from midnight, local time
     */
<span class="fc" id="L149">    int m_dayBoundaryOffset = 0;</span>
<span class="fc" id="L150">    private static String []ENABLED_VALIDATORS_FOR_WAITLIST= {AvaliableHoursValidationRule.class.getName(),</span>
<span class="fc" id="L151">                                                              AvoidBlackoutsValidationRule.class.getName()};</span>

   /**
    * Create a new auto processing rule checker.  The checker performs date-based
    * applicability tests and auto processing rule validations.  Therefore, the set of
    * rules for an organization, request type and activity type must be
    * determined and passed to this constructor.  See
    * the {@link AutoProcessingRuleCheckerHelper the helper class} for
    * convenience methods that invoke this constructor after being passed
    * higher level information.
    * @param autoProcessingRules the rules that will be used by this checker.  This is
    * a collection of {@link com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule AutoProcessingRule}
    * objects.
    * @param holidays the holidays for the organization.  This is a collection of
    * {@link com.bluepumpkin.ejb.bbm.holiday.model.Holiday Holiday} objects.
    * @param val the {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
    * (instance of {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validatable Validatable})
    * @param tz the timezone for the organization
    * @param dayBoundaryOffset the number of minutes offset set from midnight, local time,
    * that markes the start of an organization day.  This value is used to compute which
    * days a request covers.
    * @param enabledValidators the collection of validation rule class names used by this checker.
    */
    public AutoProcessingRuleChecker(Collection autoProcessingRules, Collection holidaysDuringRange,
                     Validatable val, TimeZone tz, int dayBoundaryOffset, Collection enabledValidators) {
<span class="fc" id="L176">        super();</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (autoProcessingRules == null) throw new IllegalArgumentException();</span>
<span class="fc" id="L178">        m_autoprocessingRules = autoProcessingRules;</span>

<span class="pc bpc" id="L180" title="1 of 2 branches missed.">        if (holidaysDuringRange == null)  throw new IllegalArgumentException();</span>
<span class="fc" id="L181">        m_holidaysDuringRange = holidaysDuringRange;</span>

<span class="pc bpc" id="L183" title="1 of 2 branches missed.">        if (val == null) throw new IllegalArgumentException();</span>
<span class="fc" id="L184">        m_request = val;</span>

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">        if (tz == null)  throw new IllegalArgumentException();</span>
<span class="fc" id="L187">        m_tz = tz;</span>

<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (enabledValidators == null) throw new IllegalArgumentException();</span>
<span class="fc" id="L190">        m_enabledValidatorsForOrg = enabledValidators;</span>

<span class="pc bpc" id="L192" title="2 of 4 branches missed.">        if (dayBoundaryOffset&lt;0 || dayBoundaryOffset&gt;=1440)</span>
<span class="nc" id="L193">            throw new IllegalArgumentException();</span>
<span class="fc" id="L194">        m_dayBoundaryOffset = dayBoundaryOffset;</span>
<span class="fc" id="L195">    }</span>


//    /**
//     * Runs auto processing approval and denial validations for the given request.
//     * The issues of organization, request type, and activity (if applicable)
//     * should have been resolved in the construction of the checker.
//     * @return an array of two booleans: the first item in the array denotes
//     * whether to auto-approve, the second item in the array denotes whether to
//     * auto-deny.
//     */
//    public int[] autoProcess(Collection[] apprDenyValResults)
//    throws Exception {
//        /** validation rules are only executed when they need to be.
//         * Map of rule class name to validation results from the rule.  This represents 
//         * the success or failure of the previous execution of that ValidationRule.
//         */
//        Map ruleNameToValResultsMap = new HashMap(19);
//        return autoProcess(ruleNameToValResultsMap, true, true, apprDenyValResults);
//    }
//
//    /**
//     * Runs auto processing approval and denial validations for the given request.
//     * The issues of organization, request type, and activity (if applicable)
//     * should have been resolved in the construction of the checker.
//     * @param ruleNameToValResultsMap map of rule class name to validation results from the rule.  This represents 
//     * the success or failure of the previous execution of that ValidationRule.
//     * @return an array of two booleans: the first item in the array denotes
//     * whether to auto-approve, the second item in the array denotes whether to
//     * auto-deny.
//     * @throws Exception
//     */
//    public int[] autoProcess(Map ruleNameToValResultsMap, Collection[] apprDenyValResults)
//    throws Exception {
//       return autoProcess(ruleNameToValResultsMap, true, true, apprDenyValResults);
//    }
//
   /**
    * Runs auto processing approval and/or denial validations for the given request.
    * Finds the auto processing rules in the global collection of rules that
    * apply to the given request based on the dates, and runs the auto approval and denial validations
    * which are configured for those auto processing rules. The issues of
    * organization, request type, and activity (if applicable) should have been
    * resolved in the construction of the checker. Each rule is checked to see
    * if it applies to the given request based on date checking. If the rule applies,
    * the auto approval and auto denial evaluation is performed.
    *
    * &lt;p&gt;Note: An autoProc rule of type &quot;Deny requests violating&quot; or &quot;approve requests violation only&quot;
    * has a list of selected validators.  For this rule not all these selected validtors are considered.
    * Instead only the validators enabled for the organization in this list are considered.
    * For example, if the autoProc rule has the validator
    * &quot;Request violates blackout date&quot; selected but if this validator is not enabled at the organization
    * level, the the validator is not considered.  The request will not be denied even if this
    * rule is violated.
    *
    * &lt;p&gt; See javadoc for {@link com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_autoProcess(RequestAggregate, String, boolean) _autoProcess() }
    * for the rules used for autoprocessing.
    * 
    * @param ruleNameToValResultsMap map of rule class name to validation results from the rule.  This represents 
    * the success or failure of the previous execution of that ValidationRule.
    * Boolean.FALSE for failure.
    * @param runApprove &lt;tt&gt;true&lt;/tt&gt; executes the auto-approval validations
    * @param runDeny &lt;tt&gt;true&lt;/tt&gt; executes the auto-denial validations
    * @return A two element collection array. The first element is the validation results from running autoProc rules
    * of type 'approval' while the second is the results from running autoProc rules of type 'denial'.  EAch element
    * may be 'null' if no validators were run.  Otherwise an empty or non-empty collection of validation 
    * results will be returned.
    * @throws Exception
    */
    public int[] autoProcess(TimeRange timeRange, Map ruleNameToValResultMap, boolean runApprove, boolean runDeny, 
        Collection[] apprDenyValResults,String requestType) throws Exception {
        
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        if (ruleNameToValResultMap == null) {</span>
<span class="nc" id="L268">           throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L271">        RequestAggregate reqAgg = (RequestAggregate) m_request;</span>

        // effective approve result
<span class="fc" id="L274">        int effecApprResult = AUTOPROC_APPRCLAUSE_VIOLATIONS_FOUND;</span>
        // effective deny result
<span class="fc" id="L276">        int effecDenyResult = AUTOPROC_DENYCLAUSE_NO_VIOLATIONS;</span>
        // effective waitlist result
<span class="fc" id="L278">	    int effecWaitlistResult = AUTOPROC_WAITLIST_CLAUSE_NO_VIOLATIONS;</span>

        /*
         * Map of validator name (fully qualified name) to validator instance (created using 
         * reflection).
         * 
         * The validator lookaside, store validator instances here to reduce use
         * of reflection and instance creation.  Initialize lazily. 
         */
<span class="fc" id="L287">        Map validatorsMap = new HashMap(19);</span>

        // some special cases to be handled:
        //    no autoProcessing rules apply for the req.
        //    one or more autoProc rules apply and 'approval criteria' is unchecked for all.
        //    one or more autoproc rules apply and 'denial criteria' is unchecked for all.
        //    one or more autoproc rules apply and 'do not autoProc approve any request' is specified for all.
        //    one or more autoproc rules apply and 'do not autoProc deny any request' is specified for all.
<span class="fc bfc" id="L295" title="All 2 branches covered.">        for (Iterator autoProcRulesIter=m_autoprocessingRules.iterator(); autoProcRulesIter.hasNext();) {</span>
<span class="fc" id="L296">            AutoProcessingRule apRule = (AutoProcessingRule)autoProcRulesIter.next();</span>
<span class="fc" id="L297">            log.debug(&quot;Processing autoProc rule: &quot; + apRule);</span>

            // Note: When an autoProcessingRuleChecker (this class) is instantiated, it is created only
            // with the APRules which apply to the given request's subType.  Thus this check is actually
            // redundant.
            //
            // check if request is of type 'time-off' and if so, if the activity id matches
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">            if (requestType.equals(Request.REQUESTTYPE_TIMEOFF)) {</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">                if (!reqAgg.getRequestSubType().equals(apRule.getActivityId())) {</span>
<span class="nc" id="L306">                    log.debug(&quot;Rule does not apply as TO request's acitivityID does not match rule's activityID: &quot; + apRule.getActivityId());</span>
<span class="nc" id="L307">                    continue;</span>
                }
            }
            // check if request is of type 'cust-shift' and if so, check if the sub type matches
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">            if (requestType.equals(Request.REQUESTTYPE_CUSTSHIFT)) {</span>
<span class="nc" id="L312">	            CustShiftReq custShiftReq = (CustShiftReq)reqAgg;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">	            if((apRule.getRequestSubType()&amp; custShiftReq.getSubType())==0){</span>
<span class="nc" id="L314">                    log.debug(&quot;Rule does not apply as Cust-Shift request's subtype does not match rule subtype: &quot; + apRule.getRequestSubType());</span>
<span class="nc" id="L315">                    continue;</span>
                }
            }
            // determine whether rule applies to the request based on dates
<span class="fc" id="L319">            Date reqRangeStartDate = timeRange.getStartDate();</span>
<span class="fc" id="L320">            Date reqRangeEndDate = timeRange.getEndDate();</span>

<span class="fc" id="L322">            log.debug(&quot;Checking if rule applies for reqTimeRange: &quot; + timeRange);</span>

            // Determine whether or not the range includes time on a holiday.
<span class="fc" id="L325">            boolean reqOverlapsWorkingHol = RuleScopeChecker.overlapsTimeOnAWorkingHoliday(</span>
                                         m_holidaysDuringRange, m_tz, reqRangeStartDate, reqRangeEndDate);

            // Build the map of days of the week that this range includes
<span class="fc" id="L329">            BitSet reqDaysOfWeek = RuleScopeChecker.buildDaysBitSet(</span>
                                reqRangeStartDate, reqRangeEndDate, m_tz, m_dayBoundaryOffset);

            // If this rule applies, set flag and break out of loop
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">            if (RuleScopeChecker.ruleApplies(apRule, reqRangeStartDate, reqOverlapsWorkingHol, reqDaysOfWeek )) {</span>
<span class="fc" id="L334">               log.debug(&quot;Rule applies for reqTimeRange: &quot; + timeRange);</span>
            } else {
<span class="nc" id="L336">                log.debug(&quot;Rule does not apply for any of the request's timerange&quot;);</span>
<span class="nc" id="L337">                continue;</span>
            }

<span class="fc" id="L340">            boolean ruleApprCriteriaEnabled = apRule.isApproval();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">            if (!ruleApprCriteriaEnabled) log.debug(&quot;Approval criteria for rule is not enabled.  Rule's approval evaluation not done&quot;);</span>

<span class="fc" id="L343">            boolean ruleDenialCriteriaEnabled = apRule.isDenial();</span>
<span class="fc bfc" id="L344" title="All 2 branches covered.">            if (!ruleDenialCriteriaEnabled) log.debug(&quot;Denial criteria for rule is not enabled.  Rule's denial evaluation not done&quot;);</span>

<span class="pc bpc" id="L346" title="3 of 4 branches missed.">            boolean ruleWaitlistCriteriaEnabled = apRule.isWaitlist()&amp;&amp; TORequestUtil.isTOWaitlistEnabled(reqAgg);</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">            if (!ruleWaitlistCriteriaEnabled) log.debug(&quot;Waitlist criteria for rule is not enabled.  Rule's Waitlist evaluation not done&quot;);</span>
            // transition matrix from old states (row headers) to new states (column headers)
            //             
            //                            DENYCLAUSE_DO_NOT_DENY     DENYCLAUSE_NO_VIOLATIONS   DENYCLAUSE_VIOLATIONS_FOUND
            // DENYCLAUSE_DO_NOT_DENY               No                          No                 No.
            // DENYCLAUSE_NO_VIOLATIONS             Yes                         Yes                Yes.
            // DENYCLAUSE_VIOLATIONS_FOUND          Yes                         No                 No.
            //
            // see javadoc for description of logic used for autoprocessing  
            
            // if an earlier autoProceRule did not specify &quot;do not auto deny any request&quot;
<span class="pc bpc" id="L358" title="1 of 4 branches missed.">            if ( ruleDenialCriteriaEnabled &amp;&amp; effecDenyResult != AUTOPROC_DENYCLAUSE_DONOT_DENY ) {</span>
<span class="fc" id="L359">               String denialType = apRule.getDenialType();</span>
               // if this autoProceRule specifies &quot;do not auto deny any request&quot;
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">               if (denialType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_NO)) {</span>
<span class="nc" id="L362">                   effecDenyResult = AUTOPROC_DENYCLAUSE_DONOT_DENY;</span>
               // if earlier auto proc rule evaluation did not result in &quot;deny request&quot;.
               } else {
<span class="pc bpc" id="L365" title="2 of 4 branches missed.">                   if ( runDeny &amp;&amp; effecDenyResult == AUTOPROC_DENYCLAUSE_NO_VIOLATIONS) {</span>
<span class="fc" id="L366">                      Collection denyValResults = doDenial(apRule, ruleNameToValResultMap, validatorsMap);</span>
                      // if autoproc rule evaluation results in validation rule errors
<span class="fc bfc" id="L368" title="All 2 branches covered.">                      if ( !denyValResults.isEmpty() ) {</span>
                          // set effective deny result (from autoProc rules evaluated so far) &quot;deny request&quot;.
<span class="fc" id="L370">                          effecDenyResult = AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND;</span>
                          // store validation results which led to the &quot;deny request&quot; decision.
<span class="fc" id="L372">                          apprDenyValResults[1] = denyValResults; </span>
                      }
                   }                   
               }
               
<span class="fc" id="L377">               log.debug(&quot;autoproc denial result (from autoProc rules evaluated so far) = &quot; + effecDenyResult);</span>
            }

			// if an earlier autoProc rule did not specify &quot;do not auto waitlist any request&quot;
<span class="pc bpc" id="L381" title="3 of 4 branches missed.">            if ( ruleWaitlistCriteriaEnabled &amp;&amp; effecWaitlistResult != AUTOPROC_WAITLIST_CLAUSE_DONOT_WAITLIST ) {</span>
<span class="nc" id="L382">               String waitlistType = apRule.getWaitlistType();</span>
               // if this autoProceRule specifies &quot;do not auto deny any request&quot;
<span class="nc bnc" id="L384" title="All 2 branches missed.">               if (waitlistType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_NO)) {</span>
<span class="nc" id="L385">                   effecWaitlistResult = AUTOPROC_WAITLIST_CLAUSE_DONOT_WAITLIST;</span>
               // if earlier auto proc rule evaluation did not result in &quot;deny request&quot;.
               } else {
<span class="nc bnc" id="L388" title="All 2 branches missed.">                   if (effecWaitlistResult == AUTOPROC_WAITLIST_CLAUSE_NO_VIOLATIONS) {</span>
<span class="nc" id="L389">                      Collection waitlistValResults = doWaitlist(apRule, ruleNameToValResultMap, validatorsMap);</span>
                      // if autoproc rule evaluation results in validation rule errors
<span class="nc bnc" id="L391" title="All 2 branches missed.">                      if ( !waitlistValResults.isEmpty() ) {</span>
                          // set effective deny result (from autoProc rules evaluated so far) &quot;deny request&quot;.
<span class="nc" id="L393">                          effecWaitlistResult = AUTOPROC_WAITLIST_CLAUSE_VIOLATIONS_FOUND;</span>
                          // store validation results which led to the &quot;deny request&quot; decision.
<span class="nc" id="L395">                          apprDenyValResults[2] = waitlistValResults;</span>
                      }
                   }
               }

<span class="nc" id="L400">               log.debug(&quot;autoproc waitlist result (from autoProc rules evaluated so far) = &quot; + effecWaitlistResult);</span>
            }
			
            // transition matrix from old states (row headers) to new states (column headers)
            //
            //                                 APPRCLAUSE_DONOT_APPR     APPRCLAUSE_VIOLATIONS_FOUND   APPRCLAUSE_NO_VIOLATIONS
            // APPRCLAUSE_DONOT_APPR                   No                              No                          No.
            // APPRCLAUSE_VIOLATIONS_FOUND             Yes                             Yes                         Yes.
            // APPRCLAUSE_NO_VIOLATIONS                Yes                             No                          No.
            // 
            // see javadoc for description of logic used for autoprocessing  
            
            // if an earlier autoProc rule did not specify &quot;do not auto approve any request&quot;
<span class="pc bpc" id="L413" title="1 of 4 branches missed.">            if ( ruleApprCriteriaEnabled &amp;&amp; effecApprResult != AUTOPROC_APPRCLAUSE_DONOT_APPROVE) {</span>
<span class="fc" id="L414">                String apprType = apRule.getApprovalType();</span>
                // if this autoProc rule specifies &quot;do not approve any request&quot;
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                if (apprType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_NO)) {</span>
<span class="nc" id="L417">                    effecApprResult = AUTOPROC_APPRCLAUSE_DONOT_APPROVE;</span>
                // if effective approval result from earlier auto proc rules evaluation is not &quot;approve request&quot; 
                } else {                    
<span class="pc bpc" id="L420" title="2 of 4 branches missed.">                    if ( runApprove &amp;&amp; effecApprResult == AUTOPROC_APPRCLAUSE_VIOLATIONS_FOUND) {</span>
<span class="fc" id="L421">                        Collection apprValResults = doApproval(apRule, ruleNameToValResultMap, validatorsMap);</span>
    
                        // if this autoProc rule evaluation has validation errors
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">                        if ( !apprValResults.isEmpty() ) {</span>
<span class="nc" id="L425">                            effecApprResult = AUTOPROC_APPRCLAUSE_VIOLATIONS_FOUND;</span>
<span class="nc" id="L426">                            apprDenyValResults[0] = apprValResults;</span>
                        // if this autoProc rule evaluation has no validation errors
                        } else {
                            // set effective approval result as &quot;approve request&quot;.
<span class="fc" id="L430">                            effecApprResult = AUTOPROC_APPRCLAUSE_NO_VIOLATIONS;</span>
                        }
                    }
                }

<span class="fc" id="L435">                log.debug(&quot;autoproc approval result (from autoProc rules evaluated so far) = &quot; + effecApprResult);</span>
            }
<span class="fc" id="L437">        } // for m_autoprocessingRules.iterator()</span>

<span class="fc" id="L439">        log.debug(RmUtil.dumpExitMethod(&quot;autoProcess&quot;, apprDenyValResults));</span>
        // Note: cannot use apprReq.getBoolean() since apprReq can be null.
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">        if(log.isDebugEnabled()){</span>
<span class="fc" id="L442">	        log.debug(&quot;reqAgg=&quot;+reqAgg+ &quot;\n, APPR Result=&quot;+effecApprResult+&quot;,Deny Result=&quot;+effecDenyResult+&quot;,Waitlist Result=&quot;+effecWaitlistResult);</span>
        }
<span class="fc" id="L444">        return new int[] {effecApprResult, effecDenyResult,effecWaitlistResult };</span>
    }

    /**
     * Determines whether to auto deny a request based on the configuration of
     * one {@link com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule AutoProcessingRule}.
     *
     * @param rule the {@link com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule AutoProcessingRule}
     * that is used to determine whether to auto deny this request.
     * @param ruleNameToValResultsMap map of rule class name to validation results from the rule.  This represents 
     * the success or failure of the previous execution of that ValidationRule.
     * @param validatorsMap stores Validator instances to reduce use of reflection and instance creation.
     * @return 'null' if no validators were run.  Otherwise an empty or non-empty collection of validation 
     * results if the validators were run.
     * @throws Exception
     */
    protected Collection doDenial(AutoProcessingRule rule, Map ruleNameToValResultsMap, Map validatorsMap)
        throws Exception {
        
<span class="fc" id="L463">        Collection valResults = null;</span>

<span class="fc" id="L465">        String denialType = rule.getDenialType();</span>

        // don't do auto denial
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (denialType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_NO)) {</span>
<span class="nc" id="L469">            log.debug(&quot;autoprocessing rule denial type: DONOT_DENY. Not running any validators&quot;);</span>
<span class="nc" id="L470">            return null;</span>
        
        } // if any soft validation for the org fails, auto deny 
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        else if (denialType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_YES)) {</span>
<span class="nc" id="L474">            log.debug(&quot;autoprocessing rule denial type: DENY_WITH_ANY_VIOLATION. Running vaidators&quot;);</span>
<span class="nc" id="L475">            valResults = runValidatorsAndCacheResult(m_enabledValidatorsForOrg, ruleNameToValResultsMap,</span>
                    validatorsMap);
        }
        // auto deny only for specific configured validation rules
        // the semantics is &quot;deny requests violating&quot;, so run only those
        // validators configured for this rule
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">        else if (denialType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_VIOLATION)) {</span>
<span class="fc" id="L482">            log.debug(&quot;autoprocessing rule denial type: DENY_VIOLATING_THESE_RULES. Running vaidators&quot;);</span>
            // get the class names of the validators configured in this rule for denial
<span class="fc" id="L484">            Collection validatorsIntersection = rule.getValidators(m_enabledValidatorsForOrg, AutoProcessingValidation.APPROVALSTATUS_DENY);</span>
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">            if (validatorsIntersection == null) {</span>
<span class="nc" id="L486">                log.debug(&quot;No validators run as the intersection of org validators and AP validators is empty&quot;);</span>
<span class="nc" id="L487">                return null;</span>
            }

<span class="fc" id="L490">            valResults = runValidatorsAndCacheResult(validatorsIntersection, ruleNameToValResultsMap, validatorsMap);</span>
        }

<span class="fc" id="L493">        log.debug(RmUtil.dumpExitMethod(&quot;doDenial&quot;, valResults));</span>
<span class="fc" id="L494">        return valResults;</span>
    }
    /**
     * Determines whether to auto Waitlist a request based on the configuration of
     * one {@link com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule AutoProcessingRule}.
     *
     * @param rule the {@link com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule AutoProcessingRule}
     * that is used to determine whether to auto deny this request.
     * @param ruleNameToValResultsMap map of rule class name to validation results from the rule.  This represents
     * the success or failure of the previous execution of that ValidationRule.
     * @param validatorsMap stores Validator instances to reduce use of reflection and instance creation.
     * @return 'null' if no validators were run.  Otherwise an empty or non-empty collection of validation
     * results if the validators were run.
     * @throws Exception
     */
    protected Collection doWaitlist(AutoProcessingRule rule, Map ruleNameToValResultsMap, Map validatorsMap)
        throws Exception {

<span class="nc" id="L512">        Collection valResults = null;</span>

<span class="nc" id="L514">        String waitlistType = rule.getWaitlistType();</span>

        // don't do auto waitlist
<span class="nc bnc" id="L517" title="All 2 branches missed.">        if (waitlistType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_NO)) {</span>
<span class="nc" id="L518">            log.debug(&quot;autoprocessing rule waitlist type: DONOT_WAITLIST. Not running any validators&quot;);</span>
<span class="nc" id="L519">            return null;</span>

        } // if any soft validation for the org fails, auto deny
        else {
            //TODO: Move this part to the database to get enabled validators for a status in addition to validators for ORG.
<span class="nc" id="L524">            Collection validatorsIntersectionForWaitlist = filterValidators(m_enabledValidatorsForOrg, ENABLED_VALIDATORS_FOR_WAITLIST);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (waitlistType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_YES)) {</span>
<span class="nc" id="L526">                log.debug(&quot;autoprocessing rule waitlist type: WAITLIST_WITH_ANY_VIOLATION. Running vaidators&quot;);</span>
<span class="nc" id="L527">                valResults = runValidatorsAndCacheResult(validatorsIntersectionForWaitlist, ruleNameToValResultsMap, validatorsMap);</span>
            }
            // auto deny only for specific configured validation rules
            // the semantics is &quot;deny requests violating&quot;, so run only those
            // validators configured for this rule
<span class="nc bnc" id="L532" title="All 2 branches missed.">            else if (waitlistType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_VIOLATION)) {</span>
<span class="nc" id="L533">                log.debug(&quot;autoprocessing rule waitlist type: WAITLIST_VIOLATING_THESE_RULES. Running vaidators&quot;);</span>
                // get the class names of the validators configured in this rule for waitlist
<span class="nc" id="L535">                Collection validatorsIntersection = rule.getValidators(validatorsIntersectionForWaitlist, AutoProcessingValidation.APPROVALSTATUS_WAITLIST);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                if (validatorsIntersection == null) {</span>
<span class="nc" id="L537">                    log.debug(&quot;No validators run as the intersection of org validators and AP validators is empty&quot;);</span>
<span class="nc" id="L538">                    return null;</span>
                }
<span class="nc" id="L540">                valResults = runValidatorsAndCacheResult(validatorsIntersection, ruleNameToValResultsMap, validatorsMap);</span>
            }
        }

<span class="nc" id="L544">        log.debug(RmUtil.dumpExitMethod(&quot;doWaitlist&quot;, valResults));</span>
<span class="nc" id="L545">        return valResults;</span>
    }
    /* filter validators based on the  Names in the collection*/
    public Collection filterValidators(Collection enabledOrgValidators, String[] enabledValidatorsForStatus) {
<span class="nc" id="L549">        ArrayList validatorIntersection = new ArrayList(10);</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">        if (enabledOrgValidators != null &amp;&amp; enabledValidatorsForStatus != null) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">            for (int i = 0; i &lt; enabledValidatorsForStatus.length; i++) {</span>
<span class="nc" id="L552">                String validatorForThisAPRule = enabledValidatorsForStatus[i];</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                if (enabledOrgValidators.contains(validatorForThisAPRule)) {</span>
<span class="nc" id="L554">                    validatorIntersection.add(validatorForThisAPRule);</span>
                }
            }
        }
<span class="nc" id="L558">        return validatorIntersection;</span>
    }

    /**
     * Determines whether to auto approve a request based on the configuration of
     * one {@link com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule AutoProcessingRule}.
     *
     * @param rule the {@link com.bluepumpkin.ejb.rm.setup.autoprocessing.model.AutoProcessingRule AutoProcessingRule}
     * that is used to determine whether to auto approve this request.
     * @param ruleNameToValResultsMap map of rule class name to validation results from the rule.  This represents 
     * the success or failure of the previous execution of that ValidationRule.
     * @param validatorsMap stores Validator instances to reduce use of reflection and instance creation.
     * @return 'null' if no validators were run.  Otherwise an empty or non-empty collection of validation 
     * results if the validators were run.
     * @throws Exception
     */
    protected Collection doApproval(AutoProcessingRule rule, Map ruleNameToValResultsMap, Map validatorsMap)
        throws Exception {
        
<span class="fc" id="L577">        Collection valResults = Collections.EMPTY_LIST;</span>

<span class="fc" id="L579">        String approvalType = rule.getApprovalType();</span>

        // don't do auto approval
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">        if (approvalType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_NO)) {</span>
<span class="nc" id="L583">            log.debug(&quot;autoprocessing rule approval type: DONOT_APPROVE_ANY.  not running vaidators&quot;);</span>
<span class="nc" id="L584">            return null;</span>
        }
        // if any soft validation for the org fails, do not auto approve
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">        else if (approvalType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_YES)) {</span>
<span class="nc" id="L588">            log.debug(&quot;autoprocessing rule approval type: APPROVE_WHEN_NO_VIOLATIONS.  Running vaidators&quot;);</span>
<span class="nc" id="L589">            valResults =</span>
<span class="nc" id="L590">                runValidatorsAndCacheResult(m_enabledValidatorsForOrg, ruleNameToValResultsMap, validatorsMap);</span>
        }
        // allow specific configured validation rules to fail
        // auto approve if all other validation rules pass
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">        else if (approvalType.equals(AutoProcessingRule.APPROVAL_DENIAL_TYPE_VIOLATION)) {</span>
<span class="fc" id="L595">            log.debug(&quot;autoprocessing rule approval type: APPROVE_WHEN_VIOLATING_ONLY.  Running vaidators&quot;);</span>
            // get the class names of those Validators that have been configured
            // in this auto processing rule for approval. the semantics here is
            // &quot;approve requests violation only:&quot;, so from the validators that
            // have been configured for the organization, remove those validators
            // configured in this rule for approval

            // restrict validators associated with the given autoProc rule to the subset of validators
            // enabled at the organization level.
<span class="fc" id="L604">            Collection intersectingAPRuleValidators = rule.getValidators(m_enabledValidatorsForOrg,AutoProcessingValidation.APPROVALSTATUS_APPROVE );</span>

<span class="fc" id="L606">            ArrayList orgValidators = new ArrayList(m_enabledValidatorsForOrg);</span>
            // The rules specified for &quot;approve requests violating only&quot; need not be run for autoapproval.
            // So remove these from the enabled rule list for the organization.
<span class="fc" id="L609">            orgValidators.removeAll(intersectingAPRuleValidators);</span>

<span class="fc" id="L611">            valResults = runValidatorsAndCacheResult(orgValidators, ruleNameToValResultsMap, validatorsMap);</span>
            // get class names of validators configured for denial for this auto proc rule
            // copy validationRules into new Collection and removeAll of the configured rules
            // result = runApproveDenyValidators(Boolean.TRUE, configuredRules, request,
            //                                   ruleStatus, validatorsMap);

        }

<span class="fc" id="L619">        log.debug(RmUtil.dumpExitMethod(&quot;doApproval&quot;, valResults));</span>
<span class="fc" id="L620">        return valResults;</span>
    }
    /**
     * Runs the specified validation rules against the stored request.  
     * &lt;li&gt; Stops after the first validation rule failure and returns the validation results.
     * &lt;li&gt; Caches the validation results after the first run of each validation rule.  
     * &lt;li&gt; Reuses the validation rusults for a validation rule after the first run.
     * &lt;li&gt; Validation rules are instantiated using the rule names and cached.   
     * 
     * @param validators a Collection of {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validator
     * Validator} class names
     * @param ruleNameToValResultsMap map of rule class name to validation results from the rule.  This represents 
     * the success or failure of the previous execution of that ValidationRule.
     * @param valNameToInstanceMap stores Validator instances to reduce use of reflection and instance creation.
     * @return validation results collection from running the validators: either an empty or non-empty list
     * of validation results.
     * @return An empty list of all validation rules are successful.  A non-empty list otherwise which represents the
     * validation results from the first failed validation rule.
     * @throws Exception
     */
    private Collection runValidatorsAndCacheResult(Collection validators,
       Map ruleNameToValResultsMap, Map valNameToInstanceMap) throws Exception {

<span class="fc" id="L643">       String methodName = &quot;runApproveDenyValidators&quot;;</span>
<span class="fc" id="L644">       log.debug(RmUtil.dumpEnterMethod(methodName));</span>
//       try {
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">           if (validators == null) throw new IllegalArgumentException();</span>
<span class="fc" id="L647">           Collection returnResults = new ArrayList(validators.size());</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">           for (Iterator it=validators.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L649">              String className = (String)it.next();</span>
<span class="fc" id="L650">              log.debug(&quot;Attempting to run validator for autoprocessing: &quot; + className);</span>

<span class="fc" id="L652">              Collection prevValResults = (Collection)ruleNameToValResultsMap.get(className);</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">              if (prevValResults == null) {</span>
                 // first clear the validation results since validation results accumulate.
<span class="fc" id="L655">                 m_request.clearValidationResults(true);</span>
                 
                 // validation rule has not been executed yet, so execute it now
                 // the return type of doValidation() and Validator.validate() should
                 // be changed to return the Collection - now the return value (valResult)
                 // could be null while valResults contains results.
<span class="fc" id="L661">                 ValidationUtil.doValidation(className, m_request, valNameToInstanceMap);</span>
                 
<span class="fc" id="L663">                 Collection valResults = m_request.getValidationResults(true);</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">                 if (valResults == null) {</span>
<span class="nc" id="L665">                     valResults = Collections.EMPTY_LIST;    </span>
                 } else {
                     //copy valiadation results to a new collection.  Otherwise the cached 
                     // collection reference and the collection reference inside m_request will point
                     // to the same collection.  any changes made to the collection by m_request will
                     // affect the cache as well.  
<span class="fc" id="L671">                     valResults = new ArrayList(valResults);</span>
                 }
                 
                 
<span class="fc bfc" id="L675" title="All 2 branches covered.">                 if (valResults.isEmpty()) {</span>
                    // passed the validation, so store TRUE
<span class="fc" id="L677">                    log.debug(&quot;Validator for autoprocessing successful: &quot; + className);</span>
<span class="fc" id="L678">                    ruleNameToValResultsMap.put(className, valResults);</span>
                 }
                 else {
<span class="fc" id="L681">                     log.debug(&quot;Validator for autoprocessing failed: &quot; + className);</span>

                     // validation failed if we have a ValidationResult
                     // store FALSE, set result = true (auto deny) and break
<span class="fc" id="L685">                     ruleNameToValResultsMap.put(className, valResults);</span>
                     // if auto approve, set result to false (do not auto approve)
                     // if auto denial, set result to true (auto deny)
<span class="fc" id="L688">                     log.l7dDebug(RmEjbLogBundleKey.VALIDATOR_FAILED,</span>
<span class="fc" id="L689">                                  new Object[] {m_request.getID(), className});</span>
<span class="fc" id="L690">                      returnResults.addAll(valResults); //add this to the return map</span>

                     //break; commenting this break since we need to do all validations for waitlist auto process
                 }
              // validation rule has previously been executed, and it failed validation                 
<span class="pc bnc" id="L695" title="All 2 branches missed.">              } else if (!prevValResults.isEmpty()) {</span>
<span class="nc" id="L696">                  log.debug(&quot;Validator was previously run and failed. using cached result of false: &quot; + className);</span>
                  // if auto approve, set result to false (do not auto approve)
                  // if auto denial, set result to true (auto deny)
<span class="nc" id="L699">                  log.l7dDebug(RmEjbLogBundleKey.VALIDATOR_FAILED,</span>
<span class="nc" id="L700">                               new Object[] {m_request.getID(), className});</span>
                   //add the previously validated results for this validator to the currently returned results.
<span class="nc" id="L702">                  returnResults.addAll(prevValResults);</span>

                 //break; commenting this break since we need to do all validations for waitlist auto process
              // else validation rule has previously been executed, and it passed validation
              } else {
<span class="nc" id="L707">                  log.debug(&quot;Validator was previously run and passed. using cached result of true: &quot; + className);</span>
                  //valResults = prevValResults; //commented for waitlist functionality
                  // do nothing; check next validation rule
              }
<span class="fc" id="L711">           }</span>

<span class="fc" id="L713">           log.debug(RmUtil.dumpExitMethod(methodName, returnResults));</span>
<span class="fc" id="L714">           return returnResults;</span>
//       } c_atch (Exception e) {
//           t_hrow RequestUtil.createValidationExceptionWrapper(e, log);
//       }
    }

//    /**
//     * log a debug message when a validation rule fails.
//     * if processing auto approval - this means request cannot be auto approved
//     * if processing auto denial   - request will be auto denied
//     * @param approval &lt;tt&gt;true&lt;/tt&gt; for auto approval; &lt;tt&gt;false&lt;/tt&gt; for auto denial
//     * @param className the class name of the validator class
//     */
//    private void logValidationFailure(boolean approval, ID id, String className) {
//    }
//
}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>