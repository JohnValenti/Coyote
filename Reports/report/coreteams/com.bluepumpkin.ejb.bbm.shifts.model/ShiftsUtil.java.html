<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftsUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.shifts.model</a> &gt; <span class="el_source">ShiftsUtil.java</span></div><h1>ShiftsUtil.java</h1><pre class="source lang-java linenums">/*
 * (c) 2001-2012 Verint Systems, Inc.
 */

package com.bluepumpkin.ejb.bbm.shifts.model;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.TimeZone;


import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.ImmutablePair;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeOfDay;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.config.model.Config;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.empworkrule.model.RuleAssignment;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceComplexWorkRule;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceMinMaxHour;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceMonthlyMinMaxHour;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceRotation;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPattern;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.vo.HOOPeriod;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workrules.model.Alert;
import com.bluepumpkin.ejb.bbm.workrules.model.CommonConflict;
import com.bluepumpkin.ejb.bbm.workrules.model.ComplexWorkRule;
import com.bluepumpkin.ejb.bbm.workrules.model.Rotation;
import com.bluepumpkin.ejb.bbm.workrules.model.Shift;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftEvent;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftOTExtension;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.ejb.bbm.workrules.model.TimeSpan;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRule;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleException;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleUtil;

/**
 * AJP: Why would a utility class with all static methods be Serializable?
 */
<span class="nc" id="L70">public class ShiftsUtil implements java.io.Serializable {</span>

    private static final long serialVersionUID = 1L;
    private static final float MILLIS_IN_DAY = 86400000f;
    private static final int DAYS_IN_WEEK = 7;
    private static final int MINUTES_IN_HOUR = 60;
<span class="nc" id="L76">    public static final ID VOLUNTARY_TIME_OFF = new ID(-4136);</span>
<span class="nc" id="L77">    public static final ID NONE_ACTIVITY = new ID(-4001);</span>

    public static Collection&lt;ShiftsConflict&gt; getShiftStartTimeConflicts(Collection&lt;? extends Event&gt; cEvents, Map&lt;ID, Shift&gt; hShifts, Date
            dtStart, Date dtEnd, Map&lt;ID, Organization&gt; hOrgs, TimeZone campaignTZ) {
<span class="nc" id="L81">        List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
        ShiftAssignment shiftAssignment;
<span class="nc" id="L83">        Calendar cCalendar = Calendar.getInstance();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        if (campaignTZ != null) {</span>
<span class="nc" id="L85">            cCalendar.setTimeZone(campaignTZ);</span>
        }
<span class="nc bnc" id="L87" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>

<span class="nc" id="L89">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L90" title="All 4 branches missed.">            if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT &amp;&amp; WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd,</span>
                    Config.STARTSIN)) {
<span class="nc" id="L92">                shiftAssignment = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L93">                ID idShift = shiftAssignment.getShiftID();</span>
<span class="nc" id="L94">                Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                if (pShift == null) {</span>
<span class="nc" id="L96">                    continue;</span>
                }
<span class="nc" id="L98">                TimeZone tz = campaignTZ;</span>
<span class="nc" id="L99">                Organization pOrg = null;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                if (pShift.getOrganizationID() != null) {</span>
<span class="nc" id="L101">                    pOrg = hOrgs.get(pShift.getOrganizationID());</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">					tz = pOrg!=null?pOrg.getTimeZone():campaignTZ;</span>
                }
<span class="nc" id="L104">                cCalendar.setTimeZone(tz);</span>

<span class="nc" id="L106">                cCalendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L107">                TimeOfDay tShiftStart = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY),</span>
<span class="nc" id="L108">                        cCalendar.get(Calendar.MINUTE));</span>

<span class="nc" id="L110">                cCalendar.setTime(pEvent.getEndTime());</span>
<span class="nc" id="L111">                TimeOfDay tShiftEnd = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY),</span>
<span class="nc" id="L112">                        cCalendar.get(Calendar.MINUTE));</span>
                // check cross org boundary
<span class="nc bnc" id="L114" title="All 4 branches missed.">                if (pOrg != null &amp;&amp; !pOrg.canCrossDayBoundary()) {</span>
<span class="nc" id="L115">                    TimeOfDay tDayBoundary = new TimeOfDay(pOrg.getDayBoundaryOffset());</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">                    if (tDayBoundary.intersects(tShiftStart, tShiftEnd)) {</span>
<span class="nc" id="L117">                        ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_CROSSORGDAY, &quot;&quot;,</span>
<span class="nc" id="L118">                                pEvent.getStartTime());</span>
<span class="nc" id="L119">                        llNewConflicts.add(cConflict);</span>
                    }
                }
                // check shift starts, have to consider ot before case
<span class="nc" id="L123">                tShiftStart = getRealShiftStartInHourAndMinute(shiftAssignment, cCalendar);</span>
                // consider day boundary offset
<span class="nc bnc" id="L125" title="All 4 branches missed.">                if (pOrg != null &amp;&amp; pOrg.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L126">                    tShiftStart = tShiftStart.addMinutes(-pOrg.getDayBoundaryOffset());</span>
                }

<span class="nc bnc" id="L129" title="All 4 branches missed.">                if (pShift.getStartTimes() != null &amp;&amp; !pShift.getStartTimes().contains(tShiftStart)) {</span>
                    // found a start time conflict...
<span class="nc" id="L131">                    ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_STARTTIME, pShift.getName(),</span>
<span class="nc" id="L132">                            pEvent.getStartTime());</span>
<span class="nc" id="L133">                    llNewConflicts.add(cConflict);</span>
                }
            }
<span class="nc" id="L136">        }</span>

<span class="nc" id="L138">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getShiftDurationConflicts(Collection&lt;? extends Event&gt; cEvents,
                                                                       Map&lt;ID, Shift&gt; hShifts, Date dtStart, Date dtEnd) {
<span class="nc" id="L143">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc bnc" id="L145" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L146">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L149">                    ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc" id="L150">                    Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                    if (pShift == null) {</span>
<span class="nc" id="L152">                        continue;</span>
                    }
                }
            }
<span class="nc" id="L156">        }</span>

<span class="nc" id="L158">        return llNewConflicts;</span>
    }

<span class="nc" id="L161">    static class StartTimeComparator implements Comparator&lt;Event&gt; {</span>
        @Override
        public int compare(Event o1, Event o2) {
<span class="nc" id="L164">            return o1.getStartTime().compareTo(o2.getStartTime());</span>
        }
    }

    private static boolean isPaddingEvent(ShiftAssignment shift, ShiftEventAssignment event) {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (event.getActivityID().equals(NONE_ACTIVITY)) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            if (shift.getStartTime().equals(event.getStartTime()) ||</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                    shift.getEndTime().equals(event.getEndTime())) {</span>
<span class="nc" id="L172">                return true;</span>
            }
        }
<span class="nc" id="L175">        return false;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getShiftEventSpacingConflicts(Collection&lt;? extends Event&gt; cEvents, Map&lt;ID, Shift&gt; hShifts,
            Date dtStart, Date dtEnd, Map&lt;ID, Activity&gt; activityMap) {
<span class="nc" id="L180">        List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc bnc" id="L182" title="All 2 branches missed.">        for (Event pEvent : cEvents) {</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">            if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT &amp;&amp; WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd,</span>
                    Config.STARTSIN)) {
<span class="nc" id="L185">                ShiftAssignment shift = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L186">                ID idShift = shift.getShiftID();</span>
<span class="nc" id="L187">                Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                if (pShift == null) {</span>
<span class="nc" id="L189">                    continue;</span>
                }

<span class="nc" id="L192">                List&lt;ShiftEventAssignment&gt; aShiftEvents = new ArrayList(shift.getChildren());</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                if (aShiftEvents.isEmpty()) {</span>
<span class="nc" id="L194">                    continue;</span>
                }

<span class="nc" id="L197">                long lMinSpacing = (long) pShift.getMinSpacing() * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>
<span class="nc" id="L198">                long lMaxSpacing = (long) pShift.getMaxSpacing() * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>

                // this is quite inefficient
<span class="nc" id="L201">                Collections.sort(aShiftEvents, new StartTimeComparator());</span>

<span class="nc" id="L203">                boolean isFirstShiftEvent = true;</span>
<span class="nc" id="L204">                Date dtPreviousEnd = null;</span>
<span class="nc" id="L205">                Event pPreviousEvent = null;</span>
<span class="nc" id="L206">                ShiftEventAssignment pShiftEvent = null;</span>
<span class="nc" id="L207">                ArrayList&lt;ID&gt; minSpacingConflictEventIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L208">                ArrayList&lt;ID&gt; maxSpacingConflictEventIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                for (Iterator&lt;ShiftEventAssignment&gt; j = aShiftEvents.iterator(); j.hasNext(); ) {</span>
                    // note assuming shift events are ordered by start time
<span class="nc" id="L211">                    pShiftEvent = j.next();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                    if (pShiftEvent.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                            || ((ShiftEventAssignment) pShiftEvent).getShiftEventID() == null || // QC66405</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">                            isWorkType((ShiftEventAssignment) pShiftEvent, activityMap)</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                            || isPaddingEvent(shift, pShiftEvent)) {</span>
<span class="nc" id="L216">                        continue;</span>
                    }
<span class="nc bnc" id="L218" title="All 2 branches missed.">                    if (isFirstShiftEvent) {</span>

<span class="nc" id="L220">                        long lSpacing = pShiftEvent.getStartTime().getTime() - pEvent.getStartTime().getTime();</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                        if (isViolatingMinSpacing(lMinSpacing, lSpacing)) {</span>
                            // found a min spacing conflict...
<span class="nc" id="L223">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L224">                                    (double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L225">                            llNewConflicts.add(cConflict);</span>
                        }

<span class="nc" id="L228">                        isFirstShiftEvent = false;</span>
<span class="nc" id="L229">                        pPreviousEvent = pShiftEvent;</span>
<span class="nc" id="L230">                        dtPreviousEnd = pShiftEvent.getEndTime();</span>
                        // first event has no min space problem.
<span class="nc" id="L232">                        continue;</span>
                    }
<span class="nc" id="L234">                    long lSpacing = pShiftEvent.getStartTime().getTime() - dtPreviousEnd.getTime();</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                    if (isViolatingMinSpacing(lMinSpacing, lSpacing)) {</span>
                        // found a min spacing conflict...
<span class="nc bnc" id="L237" title="All 4 branches missed.">                        if (pPreviousEvent != null &amp;&amp; !minSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L238">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L239">                                    (double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pPreviousEvent.getStartTime());</span>
<span class="nc" id="L240">                            minSpacingConflictEventIDs.add(pPreviousEvent.getID());</span>
<span class="nc" id="L241">                            llNewConflicts.add(cConflict);</span>
                        }

<span class="nc" id="L244">                        ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L245">                                (double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L246">                        llNewConflicts.add(cConflict);</span>
<span class="nc" id="L247">                        minSpacingConflictEventIDs.add(pShiftEvent.getID());</span>
                    }
<span class="nc bnc" id="L249" title="All 4 branches missed.">                    if (lMaxSpacing &gt; 0 &amp;&amp; lSpacing &gt; lMaxSpacing) {</span>
                        // found a max spacing conflict...
<span class="nc bnc" id="L251" title="All 4 branches missed.">                        if (pPreviousEvent != null &amp;&amp; !maxSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L252">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MAXSPACING,</span>
<span class="nc" id="L253">                                    (double) lMaxSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pPreviousEvent.getStartTime());</span>
<span class="nc" id="L254">                            maxSpacingConflictEventIDs.add(pPreviousEvent.getID());</span>
<span class="nc" id="L255">                            llNewConflicts.add(cConflict);</span>
                        }
<span class="nc" id="L257">                        ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MAXSPACING,</span>
<span class="nc" id="L258">                                (double) lMaxSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L259">                        llNewConflicts.add(cConflict);</span>
<span class="nc" id="L260">                        maxSpacingConflictEventIDs.add(pShiftEvent.getID());</span>
                    }
<span class="nc" id="L262">                    pPreviousEvent = pShiftEvent;</span>
<span class="nc" id="L263">                    dtPreviousEnd = pShiftEvent.getEndTime();</span>
<span class="nc" id="L264">                }</span>
                // check for spacing conflict at the end of the shift
<span class="nc bnc" id="L266" title="All 2 branches missed.">                if (dtPreviousEnd != null) {</span>
<span class="nc" id="L267">                    long lSpacing = pEvent.getEndTime().getTime() - dtPreviousEnd.getTime();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">                    if (isViolatingMinSpacing(lMinSpacing, lSpacing)) {</span>
                        // found a min spacing conflict...
<span class="nc bnc" id="L270" title="All 2 branches missed.">                        if (!minSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L271">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L272">                                    (double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L273">                            llNewConflicts.add(cConflict);</span>
                        }
                    }

<span class="nc bnc" id="L277" title="All 6 branches missed.">                    if (lSpacing &gt; 0 &amp;&amp; lMaxSpacing &gt; 0 &amp;&amp; lSpacing &gt; lMaxSpacing) {</span>
                        // found a max spacing conflict...
<span class="nc bnc" id="L279" title="All 2 branches missed.">                        if (!maxSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L280">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MAXSPACING,</span>
<span class="nc" id="L281">                                    (double) lMaxSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L282">                            llNewConflicts.add(cConflict);</span>
                        }
                    }
                }
            }
<span class="nc" id="L287">        }</span>

<span class="nc" id="L289">        return llNewConflicts;</span>
    }

    static boolean isViolatingMinSpacing(long lMinSpacing, long lSpacing) {
<span class="nc bnc" id="L293" title="All 4 branches missed.">        return lMinSpacing &gt; 0 &amp;&amp; lSpacing &lt; lMinSpacing;</span>
    }

    private static boolean isWorkType(ShiftEventAssignment shiftEvent, Map&lt;ID, Activity&gt; activityMap) {
<span class="nc" id="L297">        boolean isWorkType = false;</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        Activity activity = activityMap == null ? null : activityMap.get(shiftEvent.getActivityID());</span>
<span class="nc bnc" id="L299" title="All 4 branches missed.">        if (activity != null &amp;&amp; activity.isUsedInShift()) {</span>
<span class="nc" id="L300">            isWorkType = true;</span>
        }
<span class="nc" id="L302">        return isWorkType;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getShiftEventDurationConflicts(Collection&lt;? extends Event&gt; cEvents,
                                                                            Map&lt;ID, Shift&gt; hShifts, Date dtStart, Date dtEnd) {
<span class="nc" id="L307">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L310">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L313">                    ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc" id="L314">                    Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">                    if (pShift == null) {</span>
<span class="nc" id="L316">                        continue;</span>
                    }
<span class="nc" id="L318">                    Collection cShiftActivities = pShift.getShiftEvents();</span>
<span class="nc" id="L319">                    HashMap&lt;ID, ShiftEvent&gt; hShiftActivities = new HashMap&lt;ID, ShiftEvent&gt;();</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">                    for (Iterator j = cShiftActivities.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L321">                        ShiftEvent pShiftActivity = (ShiftEvent) j.next();</span>
<span class="nc" id="L322">                        hShiftActivities.put(pShiftActivity.getID(), pShiftActivity);</span>
<span class="nc" id="L323">                    }</span>

<span class="nc" id="L325">                    Collection cShiftEvents = pEvent.getChildren();</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                    for (Iterator j = cShiftEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L327">                        Event pSEvent = (Event) j.next();</span>
<span class="nc" id="L328">                        ShiftEventAssignment pSEA = (ShiftEventAssignment) pSEvent;</span>
<span class="nc" id="L329">                        ShiftEvent pShiftEvent = hShiftActivities.get(pSEA.getShiftEventID());</span>
<span class="nc" id="L330">                    }</span>
                }
            }
<span class="nc" id="L333">        }</span>

<span class="nc" id="L335">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getShiftEventStartTimeConflicts(Collection&lt;? extends Event&gt; cEvents, Map&lt;ID, Shift&gt; hShifts,
            Map&lt;ID, Organization&gt; hOrgs, Date dtStart, Date dtEnd, TimeZone campaignTZ) {
<span class="nc" id="L340">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc" id="L342">        ShiftAssignment shiftAssignment = null;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L344">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L347">                    shiftAssignment = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L348">                    ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc" id="L349">                    Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                    if (pShift == null) {</span>
<span class="nc" id="L351">                        continue;</span>
                    }

<span class="nc" id="L354">                    Collection cShiftActivities = pShift.getShiftEvents();</span>

<span class="nc" id="L356">                    int orgDayBoundary = 0;</span>
<span class="nc" id="L357">                    ID idOrganization = pShift.getOrganizationID();</span>
<span class="nc" id="L358">                    Calendar cCalendar = Calendar.getInstance();</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                    if (idOrganization != null) {</span>
<span class="nc" id="L360">                        Organization pOrg = hOrgs.get(idOrganization);</span>
<span class="nc" id="L361">                        orgDayBoundary = pOrg.getDayBoundaryOffset();</span>
<span class="nc" id="L362">                        cCalendar.setTimeZone(pOrg.getTimeZone());</span>
<span class="nc" id="L363">                    } else {</span>
<span class="nc" id="L364">                        cCalendar.setTimeZone(campaignTZ);</span>
                    }

<span class="nc" id="L367">                    HashMap&lt;ID, ShiftEvent&gt; hShiftActivities = new HashMap&lt;ID, ShiftEvent&gt;();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                    for (Iterator j = cShiftActivities.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L369">                        ShiftEvent pShiftActivity = (ShiftEvent) j.next();</span>
<span class="nc" id="L370">                        hShiftActivities.put(pShiftActivity.getID(), pShiftActivity);</span>
<span class="nc" id="L371">                    }</span>

<span class="nc" id="L373">                    Collection cShiftEvents = pEvent.getChildren();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    for (Iterator j = cShiftEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L375">                        Event pSEvent = (Event) j.next();</span>
<span class="nc" id="L376">                        ShiftEventAssignment pSEA = (ShiftEventAssignment) pSEvent;</span>
<span class="nc" id="L377">                        ShiftEvent pShiftEvent = hShiftActivities.get(pSEA.getShiftEventID());</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                        if (pShiftEvent != null) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">                            if (pShiftEvent.isAnyTime()) {</span>
<span class="nc" id="L380">                                continue;</span>
                            }

<span class="nc" id="L383">                            long lOffset = pSEvent.getStartTime().getTime() - pEvent.getStartTime().getTime();</span>
<span class="nc" id="L384">                            lOffset /= TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>
                            // check shift starts, have to consider ot before case
<span class="nc bnc" id="L386" title="All 2 branches missed.">                            if (shiftAssignment.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L387">                                lOffset -= shiftAssignment.getExtensionBefore();</span>
                            }

<span class="nc bnc" id="L390" title="All 2 branches missed.">                            if (pShiftEvent.isCafeteria()) {</span>
<span class="nc" id="L391">                                cCalendar.setTime(pSEvent.getStartTime());</span>
<span class="nc" id="L392">                                lOffset = cCalendar.get(Calendar.HOUR_OF_DAY) * 60 + cCalendar.get(Calendar.MINUTE);</span>
                                // even for absolute start time, the start/end minutes consider the day
                                // boundary offset before storing them in db. here, we have to take
                                // it out. QC98032
<span class="nc" id="L396">                                lOffset -= orgDayBoundary;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                                if (lOffset &lt; 0) {</span>
                                    //shift event crossing day
<span class="nc" id="L399">                                    lOffset += TimeZoneUtil.DAY_IN_MINUTES;</span>
                                }
                            }
<span class="nc bnc" id="L402" title="All 4 branches missed.">                            if (lOffset &lt; pShiftEvent.getStart() || lOffset &gt; pShiftEvent.getEnd()) {</span>
                                // 15 minutes tolerance: durtion + diff &lt;= 15,
                                // not consider as conflict
<span class="nc" id="L405">                                if (Math.min(Math.abs(lOffset - pShiftEvent.getStart()),</span>
<span class="nc" id="L406">                                        Math.abs(lOffset - pShiftEvent.getEnd()))</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                                        + pSEvent.getDuration() &gt; 15) {</span>
                                    // found a st conflict...
<span class="nc" id="L409">                                    ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_STARTTIME,</span>
<span class="nc" id="L410">                                            pShiftEvent.getName(), pSEvent.getStartTime());</span>
<span class="nc" id="L411">                                    llNewConflicts.add(cConflict);</span>
                                }
                            }
                        }
<span class="nc" id="L415">                    }</span>
                }
            }
<span class="nc" id="L418">        }</span>

<span class="nc" id="L420">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getHOOConflicts(Collection&lt;? extends Event&gt; cEvents, HOOPeriod pHoo,
                                                             Date dtStart, Date dtEnd, TimeZone tz, boolean bOrg, Organization org) {

<span class="nc" id="L426">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (pHoo == null) {</span>
<span class="nc" id="L428">            return llNewConflicts;</span>
        }

<span class="nc" id="L431">        int eType = ShiftsConflict.CAMPAIGN_HOO;</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (bOrg) {</span>
<span class="nc" id="L433">            eType = ShiftsConflict.ORG_HOO;</span>
        }
<span class="nc" id="L435">        Collection pClosedTimes = pHoo.getClosePeriods(dtStart, dtEnd);</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L438">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            for (Iterator j = pClosedTimes.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L440">                TimePeriod pClosed = (TimePeriod) j.next();</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">                if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                    if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>

<span class="nc bnc" id="L444" title="All 2 branches missed.">                        if (pEvent.getStartTime().before(pClosed.getEndTime())</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                                &amp;&amp; pEvent.getEndTime().after(pClosed.getStartTime())) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">                            if (!bOrg) {</span>
<span class="nc" id="L447">                                ShiftsConflict cConflict = new ShiftsConflict(eType, null, pEvent.getStartTime());</span>
<span class="nc" id="L448">                                llNewConflicts.add(cConflict);</span>
<span class="nc" id="L449">                            } else {</span>
                                // need org name for conflict message
<span class="nc" id="L451">                                ShiftsConflict cConflict = new ShiftsConflict(eType, org.getName(),</span>
<span class="nc" id="L452">                                        pEvent.getStartTime());</span>
<span class="nc" id="L453">                                llNewConflicts.add(cConflict);</span>
                            }
<span class="nc" id="L455">                            break;</span>
                        }
                    }
                }
<span class="nc" id="L459">            }</span>
<span class="nc" id="L460">        }</span>
<span class="nc" id="L461">        return llNewConflicts;</span>
    }

    /**
     * Returns min/max hour conflicts
     *
     * @param cEvents     collection of shift assignments for a single employee.
     * @param nMinMinutes minimum # of minutes / week for the above employee.
     * @param nMaxMinutes maximum # of minutes / week for the above employe.
     * @param dtStart     start of timeRange that includes all events in cEvents.
     * @param dtEnd       end of time range that includes all events in cEvents.
     * @param pOrg        organization the above employee belongs to.
     */
    public static Collection&lt;ShiftsConflict&gt; getMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents, int nMinMinutes, int
            nMaxMinutes, Date dtStart, Date dtEnd, Organization pOrg) {
<span class="nc" id="L476">        WorkResourceMinMaxHour minMax = new WorkResourceMinMaxHour();</span>
<span class="nc" id="L477">        minMax.setMinMinutes(nMinMinutes);</span>
<span class="nc" id="L478">        minMax.setMaxMinutes(nMaxMinutes);</span>
<span class="nc" id="L479">        return getMinMaxHourConflicts(cEvents, minMax, dtStart, dtEnd, pOrg, null);</span>
    }

    /**
     * Return the min max conflicts for weekly and daily hours for agents. This method is used in request
     * management code as well. This is a wrapper function which calls the main function always to run
     * assuming weekly SP.
     *
     * @param cEvents
     * @param minMax
     * @param dtStart
     * @param dtEnd
     * @param pOrg
     * @param shiftOTExtensions
     * @return
     */
    public static Collection&lt;ShiftsConflict&gt; getMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents, WorkResourceMinMaxHour minMax,
            Date dtStart, Date dtEnd, Organization pOrg, Map shiftOTExtensions) {
<span class="nc" id="L497">        Calendar endCal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L498">        endCal.setTime(dtEnd);</span>
<span class="nc" id="L499">        endCal.add(Calendar.SECOND, 1);</span>
<span class="nc" id="L500">        return getMinMaxHourConflicts(cEvents, minMax, dtStart, endCal.getTime(), pOrg, null, false);</span>
    }

    /**
     * Generates conflicts for weekly and daily min/max hours including OT and VTO hours set for agents.
     * Monthly SP also uses this code for daily min/max hour conflicts as well as
     * weekly OT and VTO hours conflicts till we have a separate monthly OT/VTO hours defined.
     *
     * @param cEvents
     * @param minMax
     * @param dtStart
     * @param dtEnd
     * @param pOrg
     * @param shiftOTExtensions
     * @param isMonthlySP
     * @return
     */
    public static Collection&lt;ShiftsConflict&gt; getMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents, WorkResourceMinMaxHour minMax,
            Date dtStart, Date dtEnd, Organization pOrg, Map shiftOTExtensions, boolean isMonthlySP) {
<span class="nc" id="L519">        List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

        // lets create the periods...
<span class="nc" id="L522">        List&lt;TimeSpan&gt; llTimeSpans = getOrgWeeklyTimeSpans(dtStart, dtEnd, pOrg, false);</span>
<span class="nc" id="L523">        Calendar cOrgDay = Calendar.getInstance(pOrg.getTimeZone());</span>

        // for each org week during the timeRange which encompasses (dtStart, dtEnd)
<span class="nc bnc" id="L526" title="All 2 branches missed.">        for (Iterator&lt;TimeSpan&gt; l = llTimeSpans.iterator(); l.hasNext(); ) {</span>
<span class="nc" id="L527">            TimeSpan pSpan = l.next();</span>
<span class="nc" id="L528">            Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; pair = getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, minMax, cOrgDay, shiftOTExtensions);</span>
<span class="nc" id="L529">            List&lt;ShiftsConflict&gt; dailyConflicts = pair.getFirst();</span>
<span class="nc" id="L530">            llNewConflicts.addAll(dailyConflicts);</span>

<span class="nc" id="L532">            long[] minuteArray = pair.getSecond();</span>
<span class="nc" id="L533">            long nMinutes = minuteArray[0];</span>

            // if weektotal violates min hours
<span class="nc" id="L536">            int nMinMinutes = minMax.getMinMinutes();</span>
<span class="nc bnc" id="L537" title="All 4 branches missed.">            if (nMinMinutes &gt; 0 &amp;&amp; nMinutes &lt; nMinMinutes) {</span>
<span class="nc" id="L538">                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MIN_HOURS, nMinMinutes - nMinutes,</span>
                        pSpan.dtSpanStart);
<span class="nc" id="L540">                cConflict.setDoubleTarget(nMinMinutes);</span>
<span class="nc" id="L541">                llNewConflicts.add(cConflict);</span>
            }
            // if weektotal violates max hours.
<span class="nc" id="L544">            int nMaxMinutes = minMax.getMaxMinutes();</span>
<span class="nc bnc" id="L545" title="All 4 branches missed.">            if (nMaxMinutes &gt; 0 &amp;&amp; nMinutes &gt; nMaxMinutes) {</span>
<span class="nc" id="L546">                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MAX_HOURS, nMinutes - nMaxMinutes,</span>
                        pSpan.dtSpanStart);
<span class="nc" id="L548">                cConflict.setDoubleTarget(nMaxMinutes);</span>
<span class="nc" id="L549">                llNewConflicts.add(cConflict);</span>
            }

            // check weekly OT
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (minuteArray[1] &gt; minMax.getMaxOTMinutesPerWeek()) {</span>
<span class="nc" id="L554">                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_OT_WEEKLY,</span>
<span class="nc" id="L555">                        minMax.getMaxOTMinutesPerWeek(), pSpan.dtSpanStart);</span>
<span class="nc" id="L556">                llNewConflicts.add(cConflict);</span>
            }
            // check weekly VTO minMax.getMaxVTOHoursPerWeek() returns VTO minutes, not hours
<span class="nc bnc" id="L559" title="All 2 branches missed.">            if (minuteArray[2] &gt; minMax.getMaxVTOHoursPerWeek()) {</span>
<span class="nc" id="L560">                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_VTO_WEEKLY,</span>
<span class="nc" id="L561">                        minMax.getMaxVTOHoursPerWeek(), pSpan.dtSpanStart);</span>
<span class="nc" id="L562">                llNewConflicts.add(cConflict);</span>
            }
<span class="nc" id="L564">        }</span>
<span class="nc" id="L565">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getMonthlyMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents,
            WorkResourceMonthlyMinMaxHour monthlyMinMax, Date dtStart, Date dtEnd, Organization pOrg, Map shiftOTExtensions) {
<span class="nc" id="L570">        List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc" id="L572">        Calendar cOrgDay = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L573">        TimeSpan pSpan = new TimeSpan(dtStart, dtEnd);</span>
<span class="nc" id="L574">        Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; pair = getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, null, cOrgDay, shiftOTExtensions);</span>

<span class="nc" id="L576">        long[] minuteArray = pair.getSecond();</span>
<span class="nc" id="L577">        long nMinutes = minuteArray[0];</span>

        // if month total violates min hours
<span class="nc bnc" id="L580" title="All 2 branches missed.">        int nMinMinutes = monthlyMinMax != null ? monthlyMinMax.getMinMinutes() : 0;</span>
<span class="nc bnc" id="L581" title="All 4 branches missed.">        if (nMinMinutes &gt; 0 &amp;&amp; nMinutes &lt; nMinMinutes) {</span>
<span class="nc" id="L582">            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MONTHLY_MIN_HOURS, nMinMinutes - nMinutes,</span>
                    pSpan.dtSpanStart);
<span class="nc" id="L584">            cConflict.setDoubleTarget(nMinMinutes);</span>
<span class="nc" id="L585">            llNewConflicts.add(cConflict);</span>
        }
        // if month total violates max hours.
<span class="nc bnc" id="L588" title="All 2 branches missed.">        int nMaxMinutes = monthlyMinMax != null ? monthlyMinMax.getMaxMinutes() : 0;</span>
<span class="nc bnc" id="L589" title="All 4 branches missed.">        if (nMaxMinutes &gt; 0 &amp;&amp; nMinutes &gt; nMaxMinutes) {</span>
<span class="nc" id="L590">            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MONTHLY_MAX_HOURS, nMinutes - nMaxMinutes,</span>
                    pSpan.dtSpanStart);
<span class="nc" id="L592">            cConflict.setDoubleTarget(nMaxMinutes);</span>
<span class="nc" id="L593">            llNewConflicts.add(cConflict);</span>
        }

<span class="nc" id="L596">        return llNewConflicts;</span>
    }

    /**
     * Returns weekly time spans for each of org weeks ending in the period dtStart - dtEnd
     *
     * @param dtStart                                start of period
     * @param dtEnd                                  end of period
     * @param pOrg                                   organization
     * @param includeOrgWeekPartiallyPresentInPeriod returns an extra last week even though the org week doesn't
     *                                               end during the period
     * @return list of time spans
     */
    public static List&lt;TimeSpan&gt; getOrgWeeklyTimeSpans(Date dtStart, Date dtEnd, Organization pOrg, boolean
            includeOrgWeekPartiallyPresentInPeriod) {
<span class="nc" id="L611">        List&lt;TimeSpan&gt; listTimeSpans = new LinkedList&lt;TimeSpan&gt;();</span>

<span class="nc" id="L613">        Calendar cal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L614">        cal.setTime(dtStart);</span>
<span class="nc" id="L615">        cal.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / MINUTES_IN_HOUR);</span>
<span class="nc" id="L616">        cal.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % MINUTES_IN_HOUR);</span>
<span class="nc" id="L617">        cal.set(Calendar.SECOND, 0);</span>

        //first find the start of the org week which is ending in the current sp week
        while (true) {
<span class="nc bnc" id="L621" title="All 2 branches missed.">            if (cal.get(Calendar.DAY_OF_WEEK) == pOrg.getWeekStartDate()) {</span>
<span class="nc" id="L622">                break;</span>
            }
<span class="nc" id="L624">            cal.add(Calendar.DATE, -1);</span>
        }

<span class="nc" id="L627">        Date start = cal.getTime();</span>
<span class="nc" id="L628">        cal.add(Calendar.DATE, DAYS_IN_WEEK);</span>
<span class="nc" id="L629">        Date end = cal.getTime();</span>

        //now loop through the entire sp to find out all the org weeks ending in the period
<span class="nc bnc" id="L632" title="All 2 branches missed.">        while (!end.after(dtEnd)) {</span>
<span class="nc" id="L633">            listTimeSpans.add(new TimeSpan(start, end));</span>
<span class="nc" id="L634">            start = end;</span>
<span class="nc" id="L635">            cal.add(Calendar.DATE, DAYS_IN_WEEK);</span>
<span class="nc" id="L636">            end = cal.getTime();</span>
        }

        //add last org week if required
<span class="nc bnc" id="L640" title="All 4 branches missed.">        if (includeOrgWeekPartiallyPresentInPeriod &amp;&amp; start.before(dtEnd)) {</span>
<span class="nc" id="L641">            listTimeSpans.add(new TimeSpan(start, end));</span>
        }
<span class="nc" id="L643">        return listTimeSpans;</span>
    }

    /**
     * @param cEvents
     * @param pSpan
     * @param cOrgDay
     * @param shiftOTExtensions
     * @return [0] The weekly scheduled minutes. [1] The weekly OT minutes. [2]
     * The weekly VTO minutes.
     */
    public static long[] getWeeklyMinutes(Collection&lt;? extends Event&gt; cEvents, TimeSpan pSpan, Calendar cOrgDay,
                                          Map shiftOTExtensions) {
<span class="nc" id="L656">        Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; pair = getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, null, cOrgDay, shiftOTExtensions);</span>
<span class="nc" id="L657">        return pair.getSecond();</span>
    }

    public static Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; getWeeklyMinutesAndDailyConflicts(Collection&lt;? extends Event&gt; cEvents, TimeSpan
            pSpan, WorkResourceMinMaxHour minMax, Calendar cOrgDay, Map shiftOTExtensions) {
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (minMax != null) {</span>
<span class="nc" id="L663">            return getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, cOrgDay, shiftOTExtensions, minMax.getMaxOTMinutesPerDay(), minMax</span>
<span class="nc" id="L664">                    .getMaxVTOHoursPerDay());</span>
        } else {
<span class="nc" id="L666">            return getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, cOrgDay, shiftOTExtensions, -1, -1);</span>
        }
    }

    /**
     * @param cEvents
     * @param pSpan
     * @param cOrgDay
     * @param shiftOTExtensions
     * @param maxOTMinutesPerDay value of maxOTMinutesPerDay for employee or -1 for NA
     * @param maxVTOHoursPerDay  value of maxVTOHourPerDay for employee or -1 for NA
     * @return Pair(LinkedList&lt;ShiftsConflict&gt; dailyConflicts, long[]: [0] The
     *weekly scheduled minutes. [1] The weekly OT minutes. [2] The
     *weekly VTO minutes.
     */
    public static Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; getWeeklyMinutesAndDailyConflicts(Collection&lt;? extends Event&gt; cEvents, TimeSpan
            pSpan, Calendar cOrgDay, Map shiftOTExtensions, int maxOTMinutesPerDay, int maxVTOHoursPerDay) {
<span class="nc" id="L683">        List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L684">        Map&lt;Integer, Integer&gt; hmDailyVTO = new HashMap&lt;Integer, Integer&gt;();</span>

<span class="nc" id="L686">        long nMinutes = 0;</span>
<span class="nc" id="L687">        int weeklyOTMinutes = 0;</span>
<span class="nc" id="L688">        int weeklyVTOMinutes = 0;</span>

<span class="nc bnc" id="L690" title="All 4 branches missed.">        if (cEvents == null || cEvents.isEmpty()) {</span>
<span class="nc" id="L691">            long[] returnValue = new long[3];</span>
<span class="nc" id="L692">            returnValue[0] = nMinutes;</span>
<span class="nc" id="L693">            returnValue[1] = weeklyOTMinutes;</span>
<span class="nc" id="L694">            returnValue[2] = weeklyVTOMinutes;</span>
<span class="nc" id="L695">            return new Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt;(llNewConflicts, returnValue);</span>
        }

        // iterate through shift assignments first time to see if any are just
        // being requested
<span class="nc" id="L700">        boolean hasRequestedShift = false;</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L702">            Event pEvent = i.next();</span>
            // if shift assignments starts in this org week.
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, pSpan.dtSpanStart, pSpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L706">                    ShiftAssignment shiftEvent = (ShiftAssignment) pEvent;</span>
                    // The flag !VALIDATION_CHECK is set at OrgWeekValiationRule.java
<span class="nc bnc" id="L708" title="All 2 branches missed.">                    boolean isRequestedShift = shiftEvent.getDescription() != null</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">                            &amp;&amp; (shiftEvent.getDescription().indexOf(&quot;!VALIDATION_CHECK&quot;) &gt; -1);</span>

<span class="nc bnc" id="L711" title="All 2 branches missed.">                    if (isRequestedShift) {</span>
<span class="nc" id="L712">                        hasRequestedShift = true;</span>
<span class="nc" id="L713">                        break;</span>
                    }
                }
            }
<span class="nc" id="L717">        }</span>

        // iterate thru' shift assignments
<span class="nc bnc" id="L720" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L721">            Event pEvent = i.next();</span>
            // if shift assignments starts in this org week.
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L724">                ShiftAssignment shiftEvent = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L725">                Date startTime = shiftEvent.getStartTime();</span>
<span class="nc bnc" id="L726" title="All 2 branches missed.">                if (shiftEvent.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L727">                    Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L728">                    cal.setTime(startTime);</span>
<span class="nc" id="L729">                    cal.add(Calendar.MINUTE, shiftEvent.getExtensionBefore());</span>
<span class="nc" id="L730">                    startTime = cal.getTime();</span>
                }
<span class="nc bnc" id="L732" title="All 2 branches missed.">                if (WorkRuleUtil.isInPeriod(startTime, shiftEvent.getEndTime(), pSpan.dtSpanStart, pSpan.dtSpanEnd,</span>
                        Config.STARTSIN)) {
<span class="nc bnc" id="L734" title="All 2 branches missed.">                    boolean isOTShift = shiftEvent.getDuration() == shiftEvent.getExtensionAfter();</span>
                    // The flag !VALIDATION_CHECK is set at OrgWeekValiationRule.java
<span class="nc bnc" id="L736" title="All 2 branches missed.">                    boolean isRequestedShift = shiftEvent.getDescription() != null</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                            &amp;&amp; (shiftEvent.getDescription().indexOf(&quot;!VALIDATION_CHECK&quot;) &gt; -1);</span>
<span class="nc" id="L738">                    int dailyOTMinutes = 0;</span>
<span class="nc" id="L739">                    int dailyShiftMinutes = 0;</span>

                    // compute the duration for the shift assignment
<span class="nc" id="L742">                    dailyShiftMinutes += pEvent.getDuration();</span>
<span class="nc" id="L743">                    Collection&lt;ShiftEventAssignment&gt; cShiftEvents = shiftEvent.getChildren();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">                    for (Iterator&lt;ShiftEventAssignment&gt; j = cShiftEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L745">                        ShiftEventAssignment pSEvent = j.next();</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">                        if (!isEventSameAsShiftAssignment(pSEvent, shiftEvent)) {</span>
                            // make sure we're not looking at the shiftAssignment,
                            // which is always paid
<span class="nc bnc" id="L749" title="All 4 branches missed.">                            if (pSEvent.getOverTimeGapType() == 1 || pSEvent.getOverTimeGapType() == 2</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">                                    || pSEvent.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)) {</span>
<span class="nc" id="L751">                                dailyShiftMinutes -= pSEvent.getDuration();</span>
                                // gap events are not counted as paid minutes for the conflict check
<span class="nc" id="L753">                                continue;</span>
                            }

<span class="nc bnc" id="L756" title="All 4 branches missed.">                            if (EventUtils.isOT(pSEvent) || isOTShiftEvent(shiftEvent, pSEvent)) {</span>
                                // will deal with OT events in the Daily OT Check section, below.
<span class="nc" id="L758">                                continue;</span>
                            }

<span class="nc bnc" id="L761" title="All 2 branches missed.">                            if (!pSEvent.getPaid()) {</span>
<span class="nc" id="L762">                                dailyShiftMinutes -= pSEvent.getDuration();</span>
                            }
                        }
<span class="nc" id="L765">                    }</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">                    if (isOTShift) {</span>
<span class="nc" id="L768">                        dailyOTMinutes = dailyShiftMinutes;</span>
                    } else {
<span class="nc" id="L770">                        nMinutes += dailyShiftMinutes;</span>

                        // Daily OT Check
                        ID extensionID;

<span class="nc bnc" id="L775" title="All 2 branches missed.">                        if (shiftEvent.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L776">                            dailyOTMinutes += shiftEvent.getExtensionBefore(); // overwrites</span>
                        } else {
<span class="nc" id="L778">                            extensionID = shiftEvent.getOTExtensionBeforeID();</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                            if (extensionID != null) {</span>
<span class="nc" id="L780">                                dailyOTMinutes += ((ShiftOTExtension) shiftOTExtensions.get(extensionID)).getDuration();</span>
                            }
                        }
<span class="nc bnc" id="L783" title="All 2 branches missed.">                        if (shiftEvent.getExtensionAfter() &gt; 0) {</span>
<span class="nc" id="L784">                            dailyOTMinutes += shiftEvent.getExtensionAfter(); // overwrites</span>
                        } else {
<span class="nc" id="L786">                            extensionID = shiftEvent.getOTExtensionAfterID();</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                            if (extensionID != null) {</span>
<span class="nc" id="L788">                                dailyOTMinutes += ((ShiftOTExtension) shiftOTExtensions.get(extensionID)).getDuration();</span>
                            }
                        }

                        // take out gap from ot minutes
<span class="nc" id="L793">                        Collection events = shiftEvent.getChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT);</span>
<span class="nc" id="L794">                        ShiftEventAssignment event = null;</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                        for (Iterator iInner = events.iterator(); iInner.hasNext(); ) {</span>
<span class="nc" id="L796">                            event = (ShiftEventAssignment) iInner.next();</span>
<span class="nc bnc" id="L797" title="All 4 branches missed.">                            if (isOTShiftEvent(shiftEvent, event) &amp;&amp; !event.getPaid() ||</span>
<span class="nc bnc" id="L798" title="All 4 branches missed.">                                    (event.getOverTimeGapType() == 1 || event.getOverTimeGapType() == 2) ||</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                                    (event.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP) &amp;&amp;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">                                            event.getOverTimeGapType() != 0)) {</span>
                                // QC 144403: The gap of Extension-Not OT extension( has TimeGap Type =0) was
                                // counted in dailyShiftMinutes then nMinutes already, 735,737,758
                                // So it should not count one more time for dailyOTMinutes since it will calculated
                                // in nMinutes at line 794 nMinutes -= dailyOTMinutes; one more time
<span class="nc" id="L805">                                dailyOTMinutes -= event.getDuration();</span>
                            }
                        }
<span class="nc" id="L808">                        nMinutes -= dailyOTMinutes;</span>
                    }

<span class="nc" id="L811">                    weeklyOTMinutes += dailyOTMinutes;</span>

<span class="nc bnc" id="L813" title="All 8 branches missed.">                    if (maxOTMinutesPerDay != -1 &amp;&amp; dailyOTMinutes &gt; maxOTMinutesPerDay</span>
                            &amp;&amp; (!hasRequestedShift || isRequestedShift)) {
<span class="nc" id="L815">                        ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_OT_DAILY,</span>
<span class="nc" id="L816">                                maxOTMinutesPerDay, pEvent.getStartTime());</span>
<span class="nc" id="L817">                        llNewConflicts.add(cConflict);</span>
                    }
                }
            }
<span class="nc bnc" id="L821" title="All 4 branches missed.">            if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_OFF &amp;&amp; pEvent.getActivityID().equals(VOLUNTARY_TIME_OFF)) {</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                if (WorkRuleUtil.isInPeriodAndApproved(pEvent, pSpan.dtSpanStart, pSpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc" id="L823">                    cOrgDay.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L824">                    int nDay = cOrgDay.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L825">                    Integer intDailyVTOMinutes = hmDailyVTO.get(new Integer(nDay));</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                    if (intDailyVTOMinutes == null) {</span>
<span class="nc" id="L827">                        hmDailyVTO.put(new Integer(nDay), new Integer(0));</span>
<span class="nc" id="L828">                        intDailyVTOMinutes = hmDailyVTO.get(new Integer(nDay));</span>
                    }

<span class="nc bnc" id="L831" title="All 2 branches missed.">                    if (intDailyVTOMinutes != -1) {</span>
<span class="nc" id="L832">                        intDailyVTOMinutes += pEvent.getDuration();</span>
<span class="nc bnc" id="L833" title="All 4 branches missed.">                        if (maxVTOHoursPerDay != -1 &amp;&amp; intDailyVTOMinutes &gt; maxVTOHoursPerDay) {</span>
<span class="nc" id="L834">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_VTO_DAILY,</span>
<span class="nc" id="L835">                                    maxVTOHoursPerDay, cOrgDay.getTime());</span>
<span class="nc" id="L836">                            llNewConflicts.add(cConflict);</span>
<span class="nc" id="L837">                            intDailyVTOMinutes = -1;</span>
                        }
                    }
<span class="nc" id="L840">                    weeklyVTOMinutes += pEvent.getDuration();</span>
                }
            }
<span class="nc" id="L843">        }</span>

<span class="nc" id="L845">        long[] returnValue = new long[3];</span>
<span class="nc" id="L846">        returnValue[0] = nMinutes;</span>
<span class="nc" id="L847">        returnValue[1] = weeklyOTMinutes;</span>
<span class="nc" id="L848">        returnValue[2] = weeklyVTOMinutes;</span>
<span class="nc" id="L849">        return new Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt;(llNewConflicts, returnValue);</span>
    }

    private static boolean isOTShiftEvent(ShiftAssignment sa, ShiftEventAssignment event) {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (sa.getExtensionBefore() &gt; 0</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                &amp;&amp; TimeZoneUtil.numberOfMinutes(sa.getStartTime(), event.getStartTime()) &lt; sa.getExtensionBefore()) {</span>
<span class="nc" id="L855">            return true;</span>
        }

<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (sa.getExtensionAfter() &gt; 0</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">                &amp;&amp; TimeZoneUtil.numberOfMinutes(event.getEndTime(), sa.getEndTime()) &lt; sa.getExtensionAfter()) {</span>
<span class="nc" id="L860">            return true;</span>
        }

<span class="nc" id="L863">        return false;</span>
    }

    private static boolean isEventSameAsShiftAssignment(Event event, ShiftAssignment sa) {
<span class="nc bnc" id="L867" title="All 2 branches missed.">        return sa.getStartTime().equals(event.getStartTime())</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">                &amp;&amp; sa.getDuration() == event.getDuration()</span>
<span class="nc bnc" id="L869" title="All 6 branches missed.">                &amp;&amp; ((sa.getActivityID() == null &amp;&amp; event.getActivityID() == null) || (sa.getActivityID() != null</span>
<span class="nc bnc" id="L870" title="All 4 branches missed.">                &amp;&amp; event.getActivityID() != null &amp;&amp; sa.getActivityID().equals(event.getActivityID())));</span>
    }

    /**
     * Get the MaxConsecutiveDaysConflicts for an employee. The max days is set
     * for the employee's organization.
     *
     * @param cEvents
     * @param maxAllowedDays
     * @param dtStart        the start of the scheduling period
     * @param dtEnd          the end of the scheduling period
     * @param pOrg
     * @return
     */
    public static Collection&lt;ShiftsConflict&gt; getMaxConsecutiveDaysConflicts(Collection&lt;? extends Event&gt; cEvents, int maxAllowedDays, Date
            dtStart, Date dtEnd, Organization pOrg) {
        // create a span for each org day in the range...
<span class="nc" id="L887">        LinkedList&lt;TimeSpan&gt; llDaySpans = new LinkedList&lt;TimeSpan&gt;();</span>

        // calendar for org day start
<span class="nc" id="L890">        Calendar cOrgDayStart = Calendar.getInstance(pOrg.getTimeZone());</span>

        // calendar for org day end.
<span class="nc" id="L893">        Calendar cOrgDayEnd = Calendar.getInstance(pOrg.getTimeZone());</span>

        // calendar for start of the date range to check conflicts for.
<span class="nc" id="L896">        Calendar cConflictRangeStart = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L897">        cConflictRangeStart.setTime(dtStart);</span>
<span class="nc" id="L898">        cConflictRangeStart.add(Calendar.DATE, -maxAllowedDays);</span>

        // calendar for end of the date range to check conflicts for.
<span class="nc" id="L901">        Calendar cConflictRangeEnd = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L902">        cConflictRangeEnd.setTime(dtEnd);</span>
<span class="nc" id="L903">        cConflictRangeEnd.add(Calendar.DATE, maxAllowedDays);</span>

        // the date range to check conflicts for.
<span class="nc" id="L906">        TimeRange conflictRange = new TimeRange(cConflictRangeStart.getTime(), cConflictRangeEnd.getTime());</span>

        // compute org day start.
<span class="nc" id="L909">        cOrgDayStart.setTime(cConflictRangeStart.getTime());</span>

        // set the day boundary and start time. We need this because
        // dtStart,dtEnd are aligned to the SP, not the org.
<span class="nc" id="L913">        cOrgDayStart.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / 60);</span>
<span class="nc" id="L914">        cOrgDayStart.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % 60);</span>
<span class="nc" id="L915">        cOrgDayStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L916">        cOrgDayStart.set(Calendar.MILLISECOND, 0);</span>

        // check if day start is after start date, set day start to 1 day in the
        // past
<span class="nc bnc" id="L920" title="All 2 branches missed.">        if (cOrgDayStart.getTime().after(dtStart)) {</span>
<span class="nc" id="L921">            cOrgDayStart.add(Calendar.DATE, -1);</span>
        }

        // compute org day end.
<span class="nc" id="L925">        cOrgDayEnd.setTime(cOrgDayStart.getTime());</span>
<span class="nc" id="L926">        cOrgDayEnd.add(Calendar.DATE, 1);</span>

        // identify org days that encompass the given time range (dtSTart,
        // dtEnd)
<span class="nc bnc" id="L930" title="All 2 branches missed.">        while (cOrgDayStart.getTime().before(cConflictRangeEnd.getTime())) {</span>
            // QC#94688: One warning about previous week showing in the current
            // week when orgTZ differnet than campTZ.
            // Only add this org day to the list if it overlaps the
            // conflictRange by more than 0.5 days (43200000 ms).
<span class="nc" id="L935">            TimeRange curDay = new TimeRange(cOrgDayStart.getTime(), cOrgDayEnd.getTime());</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">            if (curDay.getOverlapDuration(conflictRange) &gt;= 43200000) {</span>
<span class="nc" id="L937">                llDaySpans.add(new TimeSpan(cOrgDayStart.getTime(), cOrgDayEnd.getTime()));</span>
            }
<span class="nc" id="L939">            cOrgDayStart.setTime(cOrgDayEnd.getTime());</span>
<span class="nc" id="L940">            cOrgDayEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L941">        }</span>

<span class="nc" id="L943">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L944">        int numConsecShifts = 0;</span>
<span class="nc" id="L945">        Date conflictDate = null;</span>

        // sort cEvents because they are not necessarily in order
<span class="nc" id="L948">        ArrayList&lt;Event&gt; aEvents = new ArrayList&lt;Event&gt;(cEvents);</span>
<span class="nc" id="L949">        Collections.sort(aEvents, new StartTimeComparator());</span>

        // iterate through each org day in the range
<span class="nc bnc" id="L952" title="All 2 branches missed.">        for (Iterator&lt;TimeSpan&gt; l = llDaySpans.iterator(); l.hasNext(); ) {</span>
<span class="nc" id="L953">            TimeSpan daySpan = l.next();</span>
<span class="nc" id="L954">            boolean hasShiftThisDay = false;</span>
<span class="nc" id="L955">            Event pEvent = null;</span>

            // iterate through shift assignments
<span class="nc bnc" id="L958" title="All 2 branches missed.">            for (Iterator&lt;Event&gt; i = aEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L959">                pEvent = i.next();</span>
                // if shift assignment starts in this org day.
<span class="nc bnc" id="L961" title="All 2 branches missed.">                if (WorkRuleUtil.isInPeriodAndApproved(pEvent, daySpan.dtSpanStart, daySpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                    if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L963">                        hasShiftThisDay = true;</span>
<span class="nc" id="L964">                        break;</span>
                    }
                }
            }

<span class="nc bnc" id="L969" title="All 2 branches missed.">            if (hasShiftThisDay) {</span>
<span class="nc" id="L970">                numConsecShifts++;</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">                if (numConsecShifts &gt; maxAllowedDays) {</span>
<span class="nc" id="L972">                    conflictDate = pEvent.getStartTime();</span>
<span class="nc" id="L973">                    break;</span>
                }
            } else {
<span class="nc" id="L976">                numConsecShifts = 0;</span>
            }

<span class="nc" id="L979">        }</span>

<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (numConsecShifts &gt; maxAllowedDays) {</span>
<span class="nc" id="L982">            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_CONSECUTIVEDAY, maxAllowedDays,</span>
                    conflictDate);
            // cConflict.setDoubleTarget((double) nMaxMinutes);
<span class="nc" id="L985">            llNewConflicts.add(cConflict);</span>
        }

<span class="nc" id="L988">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getMinShiftSpacingConflicts(Collection&lt;? extends Event&gt; cEvents, int minSpacingMinutes, Date
            dtStart, Date dtEnd, Organization pOrg) {
<span class="nc" id="L993">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L994">        Date conflictDate = null;</span>
<span class="nc" id="L995">        HashMap&lt;Date, Integer&gt; conflictDates = new HashMap&lt;Date, Integer&gt;();</span>

        // sort cEvents because they are not necessarily in order
<span class="nc" id="L998">        ArrayList&lt;Event&gt; aEvents = new ArrayList&lt;Event&gt;(cEvents);</span>
<span class="nc" id="L999">        Collections.sort(aEvents, new StartTimeComparator());</span>

<span class="nc" id="L1001">        Date previousShiftEnd = null;</span>
<span class="nc" id="L1002">        boolean firstShift = true;</span>
<span class="nc" id="L1003">        int minutesBetweenShifts = 0;</span>

        // move back the period start to cover the min space, min space
        // violation is for later shift. so we need to lookback here.
<span class="nc" id="L1007">        Calendar cal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L1008">        cal.setTime(dtStart);</span>
<span class="nc" id="L1009">        cal.add(Calendar.MINUTE, -minSpacingMinutes);</span>
<span class="nc" id="L1010">        cal.add(Calendar.DAY_OF_YEAR, -1);</span>
<span class="nc" id="L1011">        Date eventCheckingStart = cal.getTime();</span>

        // iterate through shift assignments
<span class="nc bnc" id="L1014" title="All 2 branches missed.">        for (Iterator&lt;Event&gt; i = aEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1015">            Event pEvent = i.next();</span>

            // if shift assignment starts in this org day
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, eventCheckingStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">                    if (!firstShift) {</span>
<span class="nc" id="L1021">                        Date shiftStart = pEvent.getStartTime();</span>
<span class="nc" id="L1022">                        long millisBetweenShifts = shiftStart.getTime() - previousShiftEnd.getTime();</span>
<span class="nc" id="L1023">                        minutesBetweenShifts = (int) (millisBetweenShifts / 1000 / 60);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                        if (minutesBetweenShifts &lt; minSpacingMinutes) {</span>
<span class="nc" id="L1025">                            conflictDates.put(shiftStart, new Integer(minutesBetweenShifts));</span>
                        }
                    }

<span class="nc" id="L1029">                    firstShift = false;</span>
<span class="nc" id="L1030">                    previousShiftEnd = pEvent.getEndTime();</span>
                }
            }
<span class="nc" id="L1033">        }</span>

<span class="nc bnc" id="L1035" title="All 2 branches missed.">        if (!conflictDates.isEmpty()) {</span>
            Map.Entry entry;
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            for (Iterator i = conflictDates.entrySet().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1038">                entry = (Map.Entry) i.next();</span>
<span class="nc" id="L1039">                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_MINSPACING, minSpacingMinutes</span>
<span class="nc" id="L1040">                        - ((Integer) entry.getValue()).intValue(), (Date) entry.getKey());</span>
<span class="nc" id="L1041">                cConflict.setDoubleTarget(minSpacingMinutes);</span>
<span class="nc" id="L1042">                llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1043">            }</span>
        }

<span class="nc" id="L1046">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getShiftEventInvalidConflicts(Collection&lt;? extends Event&gt; cEvents,
                                                                           Map&lt;ID, Shift&gt; hShifts, Date dtStart, Date dtEnd) {
<span class="nc" id="L1051">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc bnc" id="L1053" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1054">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1057">                    ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc" id="L1058">                    Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">                    if (pShift == null) {</span>
<span class="nc" id="L1060">                        continue;</span>
                    }
<span class="nc" id="L1062">                    Collection cShiftEvents = pShift.getShiftEvents();</span>
<span class="nc" id="L1063">                    Collection cSEAs = pEvent.getChildren();</span>

                    // this is pretty inefficient...
<span class="nc" id="L1066">                    Collection&lt;ID&gt; cShiftEventIDsRequired = new LinkedList&lt;ID&gt;();</span>
<span class="nc" id="L1067">                    Collection&lt;ID&gt; cShiftEventIDsContained = new LinkedList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                    for (Iterator j = cShiftEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1069">                        ShiftEvent pShiftEvent = (ShiftEvent) j.next();</span>
<span class="nc" id="L1070">                        cShiftEventIDsRequired.add(pShiftEvent.getID());</span>
<span class="nc" id="L1071">                    }</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                    for (Iterator j = cSEAs.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1073">                        Event pSEvent = (Event) j.next();</span>
<span class="nc" id="L1074">                        ShiftEventAssignment pSEA = (ShiftEventAssignment) pSEvent;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">                        if (pSEA.getShiftEventID() != null) {</span>
                            // for ot event, shifteventid is null, don't check
                            // conflict for them
<span class="nc" id="L1078">                            cShiftEventIDsContained.add(pSEA.getShiftEventID());</span>
                        }
<span class="nc" id="L1080">                    }</span>

<span class="nc bnc" id="L1082" title="All 2 branches missed.">                    for (Iterator j = cSEAs.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1083">                        Event pSEvent = (Event) j.next();</span>
<span class="nc" id="L1084">                        ShiftEventAssignment pSEA = (ShiftEventAssignment) pSEvent;</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">                        if (pSEA.getShiftEventID() != null) {</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">                            if (!cShiftEventIDsRequired.contains(pSEA.getShiftEventID())) {</span>
                                // found an invalid sea...
<span class="nc" id="L1088">                                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_INVALID,</span>
<span class="nc" id="L1089">                                        pShift.getName(), pSEvent.getStartTime());</span>
<span class="nc" id="L1090">                                llNewConflicts.add(cConflict);</span>
                            }
                        }
<span class="nc" id="L1093">                    }</span>

                }
            }
<span class="nc" id="L1097">        }</span>

<span class="nc" id="L1099">        return llNewConflicts;</span>
    }


    public static int getRelativeDay(Event pEvent, Organization pOrg, Date dtStart, boolean isMonthly) {
<span class="nc bnc" id="L1104" title="All 2 branches missed.">        if (isMonthly) {</span>
<span class="nc" id="L1105">            return getRelativeDayInMonth(pEvent, dtStart);</span>
        } else {
<span class="nc" id="L1107">            return getRelativeDayInWeek(pEvent, pOrg);</span>
        }
    }

    protected static int getRelativeDayInWeek(Event pEvent, Organization pOrg) {
        // WorkPatterns are dictated by orgStartDay
<span class="nc" id="L1113">        int orgStartDay = pOrg.getWeekStartDay().get0SundayCount();</span>
<span class="nc" id="L1114">        Calendar cal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L1115">        cal.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L1116">        int eventDay = cal.get(Calendar.DAY_OF_WEEK) - 1;</span>

        // if ( Org WeekStartDay is Tuesday ) then return ( Tuesday as 1 or sunday as 6 or monday as 7)
<span class="nc" id="L1119">        int diff = eventDay - orgStartDay;</span>
<span class="nc bnc" id="L1120" title="All 14 branches missed.">        switch (diff) {</span>
            case 0:
<span class="nc" id="L1122">                return 1;</span>
            case 1:
<span class="nc" id="L1124">                return 2;</span>
            case 2:
<span class="nc" id="L1126">                return 3;</span>
            case 3:
<span class="nc" id="L1128">                return 4;</span>
            case 4:
<span class="nc" id="L1130">                return 5;</span>
            case 5:
<span class="nc" id="L1132">                return 6;</span>
            case 6:
<span class="nc" id="L1134">                return 7;</span>
            case -1:
<span class="nc" id="L1136">                return 7;</span>
            case -2:
<span class="nc" id="L1138">                return 6;</span>
            case -3:
<span class="nc" id="L1140">                return 5;</span>
            case -4:
<span class="nc" id="L1142">                return 4;</span>
            case -5:
<span class="nc" id="L1144">                return 3;</span>
            case -6:
<span class="nc" id="L1146">                return 2;</span>
            default:
<span class="nc" id="L1148">                return -1;</span>
        }
    }


    protected static int getRelativeDayInMonth(Event pEvent, Date dtStart) {
<span class="nc" id="L1154">        return (int) Math.ceil((pEvent.getStartTime().getTime() - dtStart.getTime()) / MILLIS_IN_DAY);</span>
    }

    private static boolean hasWorkPatternOccuranceConflict(Collection&lt;? extends Event&gt; cEvents,
                                                           ShiftPattern pWorkPattern, Date dtStart, Date dtEnd, Organization pOrg) {
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (pWorkPattern == null) {</span>
            // no work pattern, no problem
<span class="nc" id="L1161">            return false;</span>
        }
<span class="nc" id="L1163">        int numOfDays = pWorkPattern.getPeriod().getDaysInPeriod().length;</span>
<span class="nc" id="L1164">        ArrayList daysWithShifts = new ArrayList(numOfDays);</span>

<span class="nc bnc" id="L1166" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1167">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1170">                    ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">                    if (idShift == null) {</span>
<span class="nc" id="L1172">                        continue;</span>
                    }

<span class="nc" id="L1175">                    int nDay = getRelativeDay(pEvent, pOrg, dtStart, pWorkPattern.isMonthlyShiftPattern());</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">                    if (!pWorkPattern.getPossibleShiftIDs(nDay).contains(idShift)) {</span>
                        // conflict found
<span class="nc" id="L1178">                        return true;</span>
                    }

<span class="nc" id="L1181">                    daysWithShifts.add(nDay);</span>
                }
            }
<span class="nc" id="L1184">        }</span>

        // the day off indicator shift always has an SID of 1
<span class="nc" id="L1187">        ID SHIFT_OFF = new ID(1);</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">        for (int nDay = 1; nDay &lt; numOfDays + 1; nDay++) {</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (!daysWithShifts.contains(nDay)) {</span>
                // not working this day, so we need to make sure this day is allowed to be off
<span class="nc" id="L1191">                Collection&lt;ID&gt; shiftIDs = pWorkPattern.getPossibleShiftIDs(nDay);</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">                if (!shiftIDs.contains(SHIFT_OFF)) {</span>
                    // conflict found
<span class="nc" id="L1194">                    return true;</span>
                }
            }
        }
        // no conflict found
<span class="nc" id="L1199">        return false;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getWorkPatternConsistentShiftEvent(Collection&lt;? extends Event&gt; cEvents, Organization pOrg,
            ShiftPattern pWorkPattern, Date dtStart, Date dtEnd, Map&lt;ID, Shift&gt; hShifts) {

<span class="nc" id="L1205">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1206">        HashMap&lt;ImmutablePair, Long&gt; hStartOffsets = new HashMap&lt;ImmutablePair, Long&gt;();</span>

<span class="nc bnc" id="L1208" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1209">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc" id="L1211">                int nDay = ShiftsUtil.getRelativeDay(pEvent, pOrg, dtStart, pWorkPattern.isMonthlyShiftPattern());</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1213">                    ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">                    if (idShift == null) {</span>
<span class="nc" id="L1215">                        continue;</span>
                    }
<span class="nc" id="L1217">                    Integer nStartGroup = new Integer(pWorkPattern.getStartGroup(idShift, nDay));</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">                    if (nStartGroup.intValue() == ShiftPattern.NOSTARTGROUP) {</span>
<span class="nc" id="L1219">                        continue;</span>
                    }

<span class="nc bnc" id="L1222" title="All 2 branches missed.">                    if (pWorkPattern.isConsistentShiftActivities(idShift)) {</span>
                        // check shift events for consistency
<span class="nc" id="L1224">                        Collection cShiftEvents = pEvent.getChildren();</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                        for (Iterator j = cShiftEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1226">                            Event pSEA = (Event) j.next();</span>
<span class="nc" id="L1227">                            ShiftEventAssignment shiftEventAssignment = ((ShiftEventAssignment) pSEA);</span>
<span class="nc" id="L1228">                            ID idShiftEvent = shiftEventAssignment.getShiftEventID();</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">                            if (idShiftEvent != null) {</span>
                                // for ot and gap, it could be null.
<span class="nc" id="L1231">                                Long lOffset = new Long(pEvent.getStartTime().getTime() - pSEA.getStartTime().getTime());</span>
<span class="nc" id="L1232">                                ImmutablePair key = new ImmutablePair(nStartGroup, idShiftEvent);</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">                                if (hStartOffsets.containsKey(key)) {</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">                                    if (!lOffset.equals(hStartOffsets.get(key))) {</span>
<span class="nc" id="L1235">                                        Shift shift = hShifts.get(shiftEventAssignment.getParent().getShiftID());</span>
<span class="nc" id="L1236">                                        ShiftEvent shiftEvent = shift.getShiftEvent(idShiftEvent);</span>

                                        // Fixed for ESR#4163882 And QC#118790
                                        // ShiftEvent is coming null when no
                                        // campaign is selected
<span class="nc bnc" id="L1241" title="All 2 branches missed.">                                        if (shiftEvent != null) {</span>
<span class="nc" id="L1242">                                            ShiftsConflict cConflict = new ShiftsConflict(</span>
                                                    ShiftsConflict.WORKPATTERN_CONSISTENTSHIFTEVENT,
<span class="nc" id="L1244">                                                    shiftEvent.getName(), dtStart);</span>
<span class="nc" id="L1245">                                            llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1246">                                            return llNewConflicts;</span>
                                        }
<span class="nc" id="L1248">                                    }</span>
                                } else {
<span class="nc" id="L1250">                                    hStartOffsets.put(new ImmutablePair(nStartGroup, idShiftEvent), lOffset);</span>
                                }
                            }
<span class="nc" id="L1253">                        }</span>
                    }
                }
            }
<span class="nc" id="L1257">        }</span>

<span class="nc" id="L1259">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getWorkPatternConsistentStart(Collection&lt;? extends Event&gt; cEvents, ShiftPattern
            pWorkPattern, Date dtStart, Date dtEnd, Organization pOrg, Map&lt;ID, Shift&gt; hShifts) {

<span class="nc" id="L1265">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1266">        HashMap&lt;Integer, Integer&gt; hStartOffsets = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="nc" id="L1267">        Calendar cCalendar = Calendar.getInstance(pOrg.getTimeZone());</span>

<span class="nc bnc" id="L1269" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1270">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1273">                    cCalendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L1274">                    int nDay = ShiftsUtil.getRelativeDay(pEvent, pOrg, dtStart, pWorkPattern.isMonthlyShiftPattern());</span>
<span class="nc" id="L1275">                    ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                    if (idShift == null) {</span>
<span class="nc" id="L1277">                        continue;</span>
                    }

<span class="nc" id="L1280">                    Integer nStartGroup = new Integer(pWorkPattern.getStartGroup(idShift, nDay));</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">                    if (nStartGroup.intValue() != ShiftPattern.NOSTARTGROUP) {</span>
                        // check shifts for consistency
<span class="nc" id="L1283">                        int nShiftStartMinute = (cCalendar.get(Calendar.HOUR_OF_DAY) * 60)</span>
<span class="nc" id="L1284">                                + cCalendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L1285">                        Integer intShiftStartMinute = new Integer(nShiftStartMinute);</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">                        if (hStartOffsets.containsKey(nStartGroup)) {</span>
<span class="nc" id="L1287">                            Integer intGroupStartMinute = hStartOffsets.get(nStartGroup);</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">                            if (intShiftStartMinute.intValue() != intGroupStartMinute.intValue()</span>
<span class="nc" id="L1289">                                    &amp;&amp; Math.abs(intShiftStartMinute.intValue() - intGroupStartMinute.intValue()) &gt; pWorkPattern</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">                                    .getConsistentStartsTolerance()) {</span>
<span class="nc" id="L1291">                                Shift shift = hShifts.get(idShift);</span>
<span class="nc" id="L1292">                                ShiftsConflict cConflict = new ShiftsConflict(</span>
<span class="nc" id="L1293">                                        ShiftsConflict.WORKPATTERN_CONSISTENTSTART, shift.getName(), dtStart);</span>
<span class="nc" id="L1294">                                llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1295">                                return llNewConflicts;</span>
                            }
<span class="nc" id="L1297">                        } else {</span>
<span class="nc" id="L1298">                            hStartOffsets.put(nStartGroup, intShiftStartMinute);</span>
                        }
                    }
                }
            }
<span class="nc" id="L1303">        }</span>

<span class="nc" id="L1305">        return llNewConflicts;</span>
    }

    public static Collection&lt;ShiftsConflict&gt; getMeetingAttendanceConflicts(ID workResourceID, Collection&lt;? extends Event&gt; cEvents, Date
            dtStart, Date dtEnd, Map&lt;ID, Activity&gt; activityMap) {

<span class="nc" id="L1311">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1312">        Collection cInconstentShiftEvent = new LinkedList();</span>
<span class="nc" id="L1313">        HashMap hShiftEventStartOffsets = new HashMap();</span>
<span class="nc" id="L1314">        Calendar cCalendar = Calendar.getInstance();</span>
<span class="nc" id="L1315">        ShiftAssignment sa = null;</span>
<span class="nc" id="L1316">        Date saStart = null;</span>
<span class="nc" id="L1317">        Date saEnd = null;</span>

<span class="nc bnc" id="L1319" title="All 2 branches missed.">        for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1320">            Event pEvent = i.next();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">            if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) {</span>
<span class="nc" id="L1323">                    int eOverlap = ((CalendarEvent) pEvent).getOverlapType();</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">                    if (eOverlap == CalendarEventTemplate.OVERLAP_TYPE_MUST_OVERLAP_SHIFT) {</span>
<span class="nc" id="L1325">                        boolean bFoundOverlap = false;</span>

<span class="nc bnc" id="L1327" title="All 2 branches missed.">                        for (Iterator j = cEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1328">                            Event pEvent1 = (Event) j.next();</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">                            if (WorkRuleUtil.isInPeriodAndApproved(pEvent1, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                                if (pEvent1.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1331">                                    sa = (ShiftAssignment) pEvent1;</span>
<span class="nc" id="L1332">                                    Date shiftStart = getRealShiftStart(sa, cCalendar);</span>
<span class="nc" id="L1333">                                    Date shiftEnd = getRealShiftEnd(sa, cCalendar);</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">                                    if (!pEvent.getStartTime().before(shiftStart)</span>
<span class="nc bnc" id="L1335" title="All 2 branches missed.">                                            &amp;&amp; !pEvent.getEndTime().after(shiftEnd)) {</span>
<span class="nc" id="L1336">                                        bFoundOverlap = true;</span>
<span class="nc" id="L1337">                                        break;</span>
                                    }
                                }
                            }
<span class="nc" id="L1341">                        }</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                        if (!bFoundOverlap</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">                                &amp;&amp; ((CalendarEventAssignment) pEvent).isWorkResourceAttending(workResourceID)) {</span>
<span class="nc" id="L1344">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MEETING_ATTENDANCE, &quot;&quot;,</span>
<span class="nc" id="L1345">                                    pEvent.getStartTime(), pEvent.getDuration(), pEvent.getActivityID());</span>
<span class="nc" id="L1346">                            cConflict.setEvent(pEvent);</span>
<span class="nc" id="L1347">                            Activity activity = activityMap.get(pEvent.getActivityID());</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">                            if (activity != null) {</span>
<span class="nc" id="L1349">                                cConflict.setActivityName(activity.getName());</span>
                            }
<span class="nc" id="L1351">                            llNewConflicts.add(cConflict);</span>
                        }
                    }
                }

                // time off must overlap with shift - angela
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L1358">                    TimeOffEvent toEvent = (TimeOffEvent) pEvent;</span>
<span class="nc" id="L1359">                    short timeOffRule = toEvent.getTimeOffRule();</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">                    if (timeOffRule == TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES) {</span>
<span class="nc" id="L1361">                        int overlapMinutes = 0;</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">                        for (Iterator&lt;? extends Event&gt; j = cEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1363">                            Event pEvent1 = j.next();</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                            if (WorkRuleUtil.isInPeriodAndApproved(pEvent1, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                                if (pEvent1.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1366">                                    sa = (ShiftAssignment) pEvent1;</span>
<span class="nc" id="L1367">                                    saStart = getRealShiftStart(sa, cCalendar);</span>
<span class="nc" id="L1368">                                    saEnd = getRealShiftEnd(sa, cCalendar);</span>
<span class="nc bnc" id="L1369" title="All 4 branches missed.">                                    if (saStart.before(toEvent.getEndTime()) &amp;&amp; saEnd.after(toEvent.getStartTime())) {</span>
                                        // Flatten the events for this
                                        // ShiftAssignment
<span class="nc" id="L1372">                                        Collection&lt;SimpleEvent&gt; events = EventUtils</span>
<span class="nc" id="L1373">                                                .convertEventsToTimelineForSingleEmployee(Collections.singletonList(sa));</span>

<span class="nc bnc" id="L1375" title="All 2 branches missed.">                                        for (Iterator&lt;SimpleEvent&gt; eventIt = events.iterator(); eventIt.hasNext(); ) {</span>
<span class="nc" id="L1376">                                            SimpleEvent simpleEvent = eventIt.next();</span>
<span class="nc" id="L1377">                                            Date seStart = simpleEvent.getStartTime();</span>
<span class="nc" id="L1378">                                            Date seEnd = simpleEvent.getEndTime();</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">                                            if (simpleEvent.getPaid()</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                                                    &amp;&amp; toEvent.getStartTime().before(simpleEvent.getEndTime())</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">                                                    &amp;&amp; toEvent.getEndTime().after(simpleEvent.getStartTime())) {</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                                                overlapMinutes += (int) ((toEvent.getEndTime().before(seEnd) ? toEvent</span>
<span class="nc" id="L1383">                                                        .getEndTime().getTime() : seEnd.getTime()) - (toEvent</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">                                                        .getStartTime().after(seStart) ? toEvent.getStartTime()</span>
<span class="nc" id="L1385">                                                        .getTime() : seStart.getTime()))</span>
                                                        / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;
                                            }
<span class="nc" id="L1388">                                        }</span>
                                    }
                                }
                            }
<span class="nc" id="L1392">                        }</span>

<span class="nc bnc" id="L1394" title="All 2 branches missed.">                        if (overlapMinutes &lt; toEvent.getCountsMinutesTowardsRules()) {</span>
<span class="nc" id="L1395">                            ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MEETING_ATTENDANCE_TIMEOFF,</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">                                    &quot;&quot;, overlapMinutes, pEvent.getStartTime(), pEvent.getEndTime().after(dtEnd) ? dtEnd</span>
<span class="nc" id="L1397">                                    : pEvent.getEndTime(), toEvent.getCountsMinutesTowardsRules());</span>
<span class="nc" id="L1398">                            llNewConflicts.add(cConflict);</span>
                        }
                    }
                }
            }
<span class="nc" id="L1403">        }</span>
<span class="nc" id="L1404">        return llNewConflicts;</span>
    }

    /**
     * &lt;B&gt;getAllShiftConflictsForEmployee&lt;/B&gt; returns ShiftsConflicts for a
     * single Employee's Schedule, see ShiftsConflict.java for a list of
     * ShiftConflict types for all the collections (cEvents, cMinMaxHours,
     * etc...) and all the HashMaps (hShifts, hWorkPatterns, etc...) any
     * additional unneeded entries will be ignored, so is fine to pass in a
     * superset of the required entries.
     * &lt;p&gt;
     *
     * @param sName            the name of the Work Resource to be included in the conflict
     *                         message
     * @param idWorkResource   the ID of the Work Resource to be included in the conflict
     * @param cEvents          the collection of all Events the Work Resource is scheduled
     *                         for or working during the conflict checking window
     * @param dtStart          the start time of the conflict checking window (viewing start
     *                         date)
     * @param dtEnd            the end time of the conflict checking window (viewing end
     *                         date)
     * @param cOrgAssignments  the Work Resource's Org Assignments
     * @param cMinMaxHours     the collection of all WorkResourceMinMaxHour assigned during
     *                         the conflict checking window
     * @param cEmpWorkPatterns the collection of all WorkResourceWorkPattern assigned during
     *                         the window
     * @param cEmpRotations    the collection of all Rotations assigned during the window
     * @param hShifts          all Shifts which have corresponding scheduled Shift
     *                         Assignments
     * @param hWorkPatterns    all Work Patterns which are assigned to the Work Resource
     * @param hOrgs            all Orgs which the Work Resource or WorkRules are defined in
     * @param tzCampaign       the Campaign TZ
     * @param pCampaignHOOs    all HOOs assigned to the Campaign during the window
     * @param pOrgHOOs         all HOOs assigned to the Work Resource's Org during the window
     *                         &lt;p&gt;
     * @return Collection of ShiftsConflicts
     */
    public static Collection&lt;ShiftsConflict&gt; getAllShiftConflictsForEmployee(String sName, ID idWorkResource, Collection&lt;? extends Event&gt;
            cEvents, Date dtStart, Date dtEnd, List&lt;Pair&lt;Date, Date&gt;&gt; weekPairs, Collection cOrgAssignments,
            Collection&lt;WorkResourceMinMaxHour&gt; cMinMaxHours, Collection&lt;WorkResourceWorkPattern&gt; cEmpWorkPatterns,
            Collection&lt;WorkResourceRotation&gt; cEmpRotations, Map&lt;ID, Shift&gt; hShifts, Map&lt;ID, ShiftPattern&gt; hWorkPatterns,
            Map&lt;ID, Organization&gt; hOrgs, TimeZone tzCampaign, HOOPeriod pCampaignHOOs, HOOPeriod pOrgHOOs, Map hShiftOTExtensions,
            Map&lt;ID, Activity&gt; activityMap, boolean isMonthly, WorkResourceMonthlyMinMaxHour monthlyMinMax) {
<span class="nc" id="L1447">        List&lt;ShiftsConflict&gt; llConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc" id="L1449">        ID idOrg = ((WorkResourceAssignment) cOrgAssignments.iterator().next()).getOrganizationID();</span>
<span class="nc" id="L1450">        Organization pOrg = hOrgs.get(idOrg);</span>
        Collection&lt;ShiftsConflict&gt; cConflicts;

<span class="nc bnc" id="L1453" title="All 2 branches missed.">        if (isMonthly) {</span>
<span class="nc" id="L1454">            cConflicts = getMonthlyMinMaxHourConflicts(cEvents, monthlyMinMax, dtStart, dtEnd, pOrg, hShiftOTExtensions);</span>
<span class="nc" id="L1455">            llConflicts.addAll(cConflicts);</span>
        }

<span class="nc bnc" id="L1458" title="All 2 branches missed.">        for (Iterator&lt;WorkResourceMinMaxHour&gt; i = cMinMaxHours.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1459">            WorkResourceMinMaxHour pMinMax = i.next();</span>
<span class="nc" id="L1460">            Date dtAffecStart = dtStart;</span>
            //dtEnd has a minute subtracted in CalendarViewCache. adding it back
<span class="nc" id="L1462">            Date dtAffecEnd = new Date(dtEnd.getTime() + 60000);</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">            if (pMinMax.getStartTime().after(dtStart)) {</span>
<span class="nc" id="L1464">                dtAffecStart = pMinMax.getStartTime();</span>
            }
<span class="nc bnc" id="L1466" title="All 4 branches missed.">            if (pMinMax.getEndTime() != null &amp;&amp; pMinMax.getEndTime().before(dtEnd)) {</span>
<span class="nc" id="L1467">                dtAffecEnd = pMinMax.getEndTime();</span>
            }
<span class="nc bnc" id="L1469" title="All 2 branches missed.">            if (!dtAffecStart.after(dtAffecEnd)) {</span>
<span class="nc" id="L1470">                cConflicts = getMinMaxHourConflicts(cEvents, pMinMax, dtAffecStart, dtAffecEnd, pOrg,</span>
                        hShiftOTExtensions, isMonthly);
<span class="nc" id="L1472">                llConflicts.addAll(cConflicts);</span>
            }
<span class="nc" id="L1474">        }</span>

<span class="nc" id="L1476">        cConflicts = getHOOConflicts(cEvents, pCampaignHOOs, dtStart, dtEnd, tzCampaign, false, null);</span>
<span class="nc" id="L1477">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1479">        cConflicts = getHOOConflicts(cEvents, pOrgHOOs, dtStart, dtEnd, pOrg.getTimeZone(), true, pOrg);</span>
<span class="nc" id="L1480">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1482">        cConflicts = getMeetingAttendanceConflicts(idWorkResource, cEvents, dtStart, dtEnd, activityMap);</span>
<span class="nc" id="L1483">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1485">        cConflicts = getMinShiftSpacingConflicts(cEvents, pOrg.getMinTimeBetweenShift(), dtStart, dtEnd, pOrg);</span>
<span class="nc" id="L1486">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1488">        cConflicts = getShiftDurationConflicts(cEvents, hShifts, dtStart, dtEnd);</span>
<span class="nc" id="L1489">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1491">        cConflicts = getShiftEventDurationConflicts(cEvents, hShifts, dtStart, dtEnd);</span>
<span class="nc" id="L1492">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1494">        cConflicts = getShiftEventInvalidConflicts(cEvents, hShifts, dtStart, dtEnd);</span>
<span class="nc" id="L1495">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1497">        cConflicts = getShiftEventSpacingConflicts(cEvents, hShifts, dtStart, dtEnd, activityMap);</span>
<span class="nc" id="L1498">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1500">        cConflicts = getShiftEventStartTimeConflicts(cEvents, hShifts, hOrgs, dtStart, dtEnd, tzCampaign);</span>
<span class="nc" id="L1501">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1503">        cConflicts = getShiftStartTimeConflicts(cEvents, hShifts, dtStart, dtEnd, hOrgs, tzCampaign);</span>
<span class="nc" id="L1504">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1506">        cConflicts = getMaxConsecutiveDaysConflicts(cEvents, pOrg.getMaxConsecutiveWorkingDay(), dtStart, dtEnd, pOrg);</span>
<span class="nc" id="L1507">        llConflicts.addAll(cConflicts);</span>

        //if monthly wp found then do not look for weekly wp conflicts
<span class="nc" id="L1510">        boolean isMonthlyWPFound = false;</span>

<span class="nc bnc" id="L1512" title="All 2 branches missed.">        if (isMonthly) {</span>
            //dtEnd has a minute subtracted in CalendarViewCache. adding it back
<span class="nc" id="L1514">            Date end = new Date(dtEnd.getTime() + 60000);</span>
<span class="nc" id="L1515">            isMonthlyWPFound = getMonthlyWPConflicts(cEvents, llConflicts, cEmpWorkPatterns, hWorkPatterns, dtStart,</span>
                    end, hOrgs, hShifts);
        }

        //report conflicts for weekly SPs. and for monthly SPs where monthly WP is not found
<span class="nc bnc" id="L1520" title="All 4 branches missed.">        if (!isMonthly || !isMonthlyWPFound) {</span>
<span class="nc" id="L1521">            cConflicts = getWorkPatternConflicts(cEvents, cEmpRotations, cEmpWorkPatterns, hWorkPatterns, weekPairs,</span>
                    hOrgs, hShifts, tzCampaign, isMonthly);
        }

<span class="nc" id="L1525">        llConflicts.addAll(cConflicts);</span>

<span class="nc bnc" id="L1527" title="All 2 branches missed.">        for (Iterator&lt;ShiftsConflict&gt; i = llConflicts.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1528">            ShiftsConflict pConflict = i.next();</span>
<span class="nc" id="L1529">            pConflict.setWorkResourceName(sName);</span>
<span class="nc" id="L1530">            pConflict.setWorkResourceID(idWorkResource);</span>
<span class="nc" id="L1531">        }</span>

<span class="nc" id="L1533">        return llConflicts;</span>
    }

    /**
     * Determine which work pattern (if any) is assigned to the user for the
     * date range. If the user has a rotation work pattern, we only use that
     * one. If a work pattern is found, then we only use that one to check
     * conflicts for. If a work pattern is not found, then we do not check work
     * pattern conflicts.
     */
    public static Collection&lt;ShiftsConflict&gt; getWorkPatternConflicts(Collection&lt;? extends Event&gt; cEvents,
            Collection&lt;WorkResourceRotation&gt; cEmpRotations, Collection&lt;WorkResourceWorkPattern&gt; cEmpWorkPatterns, Map&lt;ID, ShiftPattern&gt;
            hWorkPatterns, List&lt;Pair&lt;Date, Date&gt;&gt; weekPairs, Map&lt;ID, Organization&gt; hOrgs, Map&lt;ID, Shift&gt; hShifts, TimeZone tzCampaign,
            boolean isMonthly) {
<span class="nc" id="L1547">        List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1548">        ShiftPattern pPattern = null;</span>
<span class="nc" id="L1549">        WorkResourceRotation wrr = null;</span>
<span class="nc" id="L1550">        int count = 0;</span>

<span class="nc bnc" id="L1552" title="All 2 branches missed.">        while (count &lt; weekPairs.size()) {</span>
<span class="nc" id="L1553">            pPattern = null;</span>
<span class="nc" id="L1554">            Date weekStart = weekPairs.get(count).getFirst();</span>
<span class="nc" id="L1555">            Date weekEnd = weekPairs.get(count).getSecond();</span>

            //if monthly and last week of the SP is partial then do not generate conflicts
<span class="nc bnc" id="L1558" title="All 6 branches missed.">            if (isMonthly &amp;&amp; count == weekPairs.size() - 1 &amp;&amp; isPartialWeek(weekStart, weekEnd)) {</span>
<span class="nc" id="L1559">                break;</span>
            }

<span class="nc" id="L1562">            Collection&lt;Event&gt; shiftAssignmentsThisWeek = getShiftAssignmentWithIn(cEvents, weekStart, weekEnd);</span>

            // If the user has a rotation, use it to get the current work
            // pattern for this week.
<span class="nc bnc" id="L1566" title="All 4 branches missed.">            if (cEmpRotations != null &amp;&amp; cEmpRotations.size() &gt; 0) {</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                for (Iterator&lt;WorkResourceRotation&gt; i = cEmpRotations.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1568">                    wrr = i.next();</span>
<span class="nc" id="L1569">                    pPattern = getRotationShiftPatternForTheWeek(wrr, weekStart, tzCampaign);</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                    if (pPattern != null) {</span>
<span class="nc" id="L1571">                        break; // user can only have one rotation assigned</span>
                    }
                }
            }

            // If the user has no rotation, but he has a single work pattern
            // assignement, use that work pattern.
<span class="nc bnc" id="L1578" title="All 6 branches missed.">            if (pPattern == null &amp;&amp; cEmpWorkPatterns != null &amp;&amp; cEmpWorkPatterns.size() == 1) {</span>
<span class="nc" id="L1579">                WorkResourceWorkPattern wrwp = cEmpWorkPatterns.iterator().next();</span>
<span class="nc" id="L1580">                ID workPatternID = wrwp.getWorkPatternSID();</span>
<span class="nc" id="L1581">                pPattern = hWorkPatterns.get(workPatternID);</span>
            }

<span class="nc bnc" id="L1584" title="All 2 branches missed.">            if (pPattern != null) {</span>
                // There is a single, unambiguous work pattern assigned to this
                // employee on this week. Check conflicts for this work pattern
                // only.
<span class="nc" id="L1588">                Organization workPatternOrg = hOrgs.get(pPattern.getOrganizationID());</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">                if (hasWorkPatternOccuranceConflict(shiftAssignmentsThisWeek, pPattern, weekStart, weekEnd, workPatternOrg)) {</span>
<span class="nc" id="L1590">                    ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.WORKPATTERN_OCCURANCE, &quot;&quot;, weekStart);</span>
<span class="nc" id="L1591">                    llNewConflicts.add(cConflict);</span>
                }

<span class="nc" id="L1594">                checkWorkPatternConflict(shiftAssignmentsThisWeek, pPattern, weekStart, weekEnd, workPatternOrg, hShifts,</span>
                        llNewConflicts);
<span class="nc bnc" id="L1596" title="All 4 branches missed.">            } else if (cEmpWorkPatterns != null &amp;&amp; cEmpWorkPatterns.size() &gt; 0) {</span>
                // There is no singular work pattern assignment, so we'll
                // iterate through all his wp's to see if the shifts match ANY
                // of them.
<span class="nc" id="L1600">                boolean foundMatchingWorkPattern = false;</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">                for (WorkResourceWorkPattern wrwp : cEmpWorkPatterns) {</span>
<span class="nc" id="L1602">                    ID workPatternID = wrwp.getWorkPatternSID();</span>
<span class="nc" id="L1603">                    pPattern = hWorkPatterns.get(workPatternID);</span>
<span class="nc" id="L1604">                    Organization workPatternOrg = hOrgs.get(pPattern.getOrganizationID());</span>

<span class="nc bnc" id="L1606" title="All 2 branches missed.">                    if (!hasWorkPatternOccuranceConflict(shiftAssignmentsThisWeek, pPattern, weekStart, weekEnd, workPatternOrg)) {</span>
<span class="nc" id="L1607">                        List&lt;ShiftsConflict&gt; llCurConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1608">                        checkWorkPatternConflict(shiftAssignmentsThisWeek, pPattern, weekStart, weekEnd, workPatternOrg, hShifts,</span>
                                llCurConflicts);
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                        if (llCurConflicts.size() == 0) {</span>
<span class="nc" id="L1611">                            foundMatchingWorkPattern = true;</span>
<span class="nc" id="L1612">                            break;</span>
                        }
                    }
<span class="nc" id="L1615">                }</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">                if (!foundMatchingWorkPattern) {</span>
                    // no work patterns matched the shiftAssignmentsThisWeek.
<span class="nc" id="L1618">                    ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.WORKPATTERN_OCCURANCE, &quot;&quot;, weekStart);</span>
<span class="nc" id="L1619">                    llNewConflicts.add(cConflict);</span>
                }
            }

            // move on to next week
<span class="nc" id="L1624">            count++;</span>
<span class="nc" id="L1625">        }</span>
<span class="nc" id="L1626">        return llNewConflicts;</span>
    }


    public static boolean getMonthlyWPConflicts(Collection&lt;? extends Event&gt; cEvents, Collection&lt;ShiftsConflict&gt; list,
                                                Collection&lt;WorkResourceWorkPattern&gt; cEmpWorkPatterns, Map&lt;ID, ShiftPattern&gt; hWorkPatterns,
                                                Date dtStart, Date dtEnd, Map&lt;ID, Organization&gt; hOrgs, Map&lt;ID, Shift&gt; hShifts) {

        //get monthly WP conflicts for monthly SPs
<span class="nc" id="L1635">        Collection&lt;Event&gt; shiftAssignmentsThisPeriod = getShiftAssignmentWithIn(cEvents, dtStart, dtEnd);</span>

<span class="nc bnc" id="L1637" title="All 4 branches missed.">        if (cEmpWorkPatterns != null &amp;&amp; cEmpWorkPatterns.size() &gt; 0) {</span>
<span class="nc" id="L1638">            ShiftPattern pPattern = null;</span>
<span class="nc" id="L1639">            boolean foundMatchingWPConflict = false;</span>

            //Loop through all the available workPatterns for the emp.
<span class="nc bnc" id="L1642" title="All 2 branches missed.">            for (WorkResourceWorkPattern wrwp : cEmpWorkPatterns) {</span>
<span class="nc" id="L1643">                ID workPatternID = wrwp.getWorkPatternSID();</span>
<span class="nc" id="L1644">                pPattern = hWorkPatterns.get(workPatternID);</span>
<span class="nc" id="L1645">                Organization workPatternOrg = hOrgs.get(pPattern.getOrganizationID());</span>

<span class="nc bnc" id="L1647" title="All 2 branches missed.">                if (isWorkPatternApplicableOnMonthlySP(dtStart, dtEnd, pPattern)) {</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">                    if (!hasWorkPatternOccuranceConflict(shiftAssignmentsThisPeriod, pPattern, dtStart, dtEnd, workPatternOrg)) {</span>
<span class="nc" id="L1649">                        List&lt;ShiftsConflict&gt; llCurConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1650">                        checkWorkPatternConflict(shiftAssignmentsThisPeriod, pPattern, dtStart, dtEnd, workPatternOrg, hShifts,</span>
                                llCurConflicts);
<span class="nc bnc" id="L1652" title="All 2 branches missed.">                        if (llCurConflicts.size() == 0) {</span>
<span class="nc" id="L1653">                            return true;</span>
                        } else {
<span class="nc" id="L1655">                            foundMatchingWPConflict = true;</span>
                        }
<span class="nc" id="L1657">                    } else {</span>
<span class="nc" id="L1658">                        foundMatchingWPConflict = true;</span>
                    }
                }
<span class="nc" id="L1661">            }</span>

<span class="nc bnc" id="L1663" title="All 2 branches missed.">            if (foundMatchingWPConflict) {</span>
<span class="nc" id="L1664">                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.WORKPATTERN_OCCURANCE, &quot;&quot;, dtStart);</span>
<span class="nc" id="L1665">                list.add(cConflict);</span>
<span class="nc" id="L1666">                return true;</span>
            }
        }

<span class="nc" id="L1670">        return false;</span>
    }

    protected static boolean isWorkPatternApplicableOnMonthlySP(Date dtStart, Date dtEnd, ShiftPattern wpPattern) {
<span class="nc" id="L1674">        int daysInSP = Math.round((dtEnd.getTime() - dtStart.getTime()) / MILLIS_IN_DAY);</span>
<span class="nc" id="L1675">        int daysInWP = wpPattern.getPeriod().getDaysInPeriod().length;</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">        if (daysInSP == daysInWP) {</span>
            //Monthly WP are applicable on same NumOfDays in a Monthly SP
<span class="nc" id="L1678">            return true;</span>
        }

<span class="nc" id="L1681">        return false;</span>
    }

    protected static boolean isPartialWeek(Date startDate, Date endDate) {
<span class="nc" id="L1685">        int days = Math.round((endDate.getTime() - startDate.getTime()) / MILLIS_IN_DAY);</span>

<span class="nc bnc" id="L1687" title="All 2 branches missed.">        if (days &lt; DAYS_IN_WEEK) {</span>
<span class="nc" id="L1688">            return true;</span>
        }

<span class="nc" id="L1691">        return false;</span>
    }

    public static Collection&lt;Event&gt; getShiftAssignmentWithIn(Collection&lt;? extends Event&gt; cEvents, Date start, Date end) {
<span class="nc" id="L1695">        ArrayList&lt;Event&gt; list = new ArrayList&lt;Event&gt;();</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">        if (!cEvents.isEmpty()) {</span>
<span class="nc" id="L1697">            Collections.sort(new ArrayList&lt;Event&gt;(cEvents), new StartTimeComparator());</span>
<span class="nc" id="L1698">            Event event = null;</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">            for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1700">                event = i.next();</span>
<span class="nc bnc" id="L1701" title="All 4 branches missed.">                if (event.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT &amp;&amp; !event.getStartTime().before(start)</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">                        &amp;&amp; event.getStartTime().before(end)) {</span>
<span class="nc" id="L1703">                    list.add(event);</span>
                }
            }
        }

<span class="nc" id="L1708">        return list;</span>
    }

    private static Collection&lt;ShiftPattern&gt; getShiftPatternForTheWeek(
            Collection&lt;WorkResourceWorkPattern&gt; cEmpWorkPatterns, Map&lt;ID, ShiftPattern&gt; hWorkPatterns, Date weekStart,
            Date weekEnd) {
<span class="nc" id="L1714">        Collection&lt;ShiftPattern&gt; workPatternPerWeek = new ArrayList&lt;ShiftPattern&gt;();</span>
<span class="nc" id="L1715">        ShiftPattern pPattern = null;</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">        for (Iterator&lt;WorkResourceWorkPattern&gt; i = cEmpWorkPatterns.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1717">            WorkResourceWorkPattern pWP = i.next();</span>
<span class="nc bnc" id="L1718" title="All 6 branches missed.">            if (pWP.getStartTime().before(weekEnd) &amp;&amp; (pWP.getEndTime() == null || pWP.getEndTime().after(weekStart))) {</span>
<span class="nc" id="L1719">                pPattern = hWorkPatterns.get(pWP.getWorkPatternSID());</span>
<span class="nc" id="L1720">                workPatternPerWeek.add(pPattern);</span>
            }
<span class="nc" id="L1722">        }</span>
<span class="nc" id="L1723">        return workPatternPerWeek;</span>
    }

    /**
     * Possible bug: This method doesn't take campaign timezone into account, so
     * We probably need to either round to the nearest int, or convert dtStart
     * to a localate in the campaign timezone)
     */
    public static ShiftPattern getRotationShiftPatternForTheWeek(WorkResourceRotation wr, Date dtStart) {
<span class="nc" id="L1732">        Date alignmentDate = wr.getRotation().getAlignmentDate().getTime(TimeZoneUtil.GMT_TIMEZONE);</span>
        // get number of weeks round
<span class="nc" id="L1734">        int weeks = Math</span>
<span class="nc" id="L1735">                .abs((int) ((dtStart.getTime() - alignmentDate.getTime()) / (TimeZoneUtil.DAY_IN_MILLISECONDS * 7)));</span>
<span class="nc" id="L1736">        int nWeek = (weeks % wr.getNumWeeksInRotation() + wr.getStartWeekOffSet()) % wr.getNumWeeksInRotation();</span>
<span class="nc" id="L1737">        return wr.getRotation().getShiftPatterns().get(new Integer(nWeek));</span>
    }

    public static ShiftPattern getRotationShiftPatternForTheWeek(WorkResourceRotation wr, Date dtStart,
                                                                 TimeZone tzCampaign) {
<span class="nc" id="L1742">        Date alignmentDate = wr.getRotation().getAlignmentDate().getTime(TimeZoneUtil.GMT_TIMEZONE);</span>

        // Need to convert dtStart to a local date in GMT, since we will compare
        // it to the alignmentDate, which is also a local date in GMT.
<span class="nc" id="L1746">        LocalDate viewStartDateLocal = new LocalDate(dtStart, tzCampaign);</span>
<span class="nc" id="L1747">        Calendar viewStartDate = viewStartDateLocal.getCal();</span>

        // get number of weeks round
<span class="nc" id="L1750">        int weeks = Math</span>
<span class="nc" id="L1751">                .abs((int) ((viewStartDate.getTime().getTime() - alignmentDate.getTime()) / (TimeZoneUtil.DAY_IN_MILLISECONDS * 7)));</span>
<span class="nc" id="L1752">        int nWeek = (weeks % wr.getNumWeeksInRotation() + wr.getStartWeekOffSet()) % wr.getNumWeeksInRotation();</span>

<span class="nc" id="L1754">        Rotation rotation = wr.getRotation();</span>
<span class="nc" id="L1755">        List&lt;ShiftPattern&gt; shiftPatterns = rotation.getShiftPatterns();</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">        if (shiftPatterns.size() &lt; (nWeek + 1)) {</span>
<span class="nc" id="L1757">            System.out</span>
<span class="nc" id="L1758">                    .println(&quot;Warning: The number of shiftPatterns doesn't match getNumWeeksInRotation() for employee &quot;</span>
<span class="nc" id="L1759">                            + wr.getWorkResourceID());</span>
<span class="nc" id="L1760">            return null;</span>
        } else {
<span class="nc" id="L1762">            return wr.getRotation().getShiftPatterns().get(new Integer(nWeek));</span>
        }
    }

    private static void checkWorkPatternConflict(Collection&lt;? extends Event&gt; cEvents, ShiftPattern pPattern, Date dtStart, Date dtEnd,
            Organization pOrg, Map&lt;ID, Shift&gt; hShifts, Collection&lt;ShiftsConflict&gt; llConflicts) {
<span class="nc" id="L1768">        Collection&lt;ShiftsConflict&gt; cConflicts = getWorkPatternConsistentShiftEvent(cEvents, pOrg, pPattern, dtStart,</span>
                dtEnd, hShifts);
<span class="nc" id="L1770">        llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1772">        cConflicts = getWorkPatternConsistentStart(cEvents, pPattern, dtStart, dtEnd, pOrg, hShifts);</span>
<span class="nc" id="L1773">        llConflicts.addAll(cConflicts);</span>

        // min max consecutive days for the Work Pattern
<span class="nc" id="L1776">        Collection shifts = pPattern.getRelatedObjects(ShiftPattern.SHIFT_RELATIONSHIP_KEY);</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">        if (shifts != null) {</span>
<span class="nc" id="L1778">            Shift shift = null;</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">            for (Iterator iShift = shifts.iterator(); iShift.hasNext(); ) {</span>
<span class="nc" id="L1780">                shift = (Shift) iShift.next();</span>
<span class="nc" id="L1781">                int minConsecutiveDays = pPattern.getMinConsecutiveDays(shift.getDEID());</span>
<span class="nc" id="L1782">                int maxConsecutiveDays = pPattern.getMaxConsecutiveDays(shift.getDEID());</span>
<span class="nc" id="L1783">                cConflicts = getMinMaxConsecutiveDaysForShiftConflicts(cEvents, shift, minConsecutiveDays,</span>
                        maxConsecutiveDays, dtStart, dtEnd, pOrg);
<span class="nc" id="L1785">                llConflicts.addAll(cConflicts);</span>
<span class="nc" id="L1786">            }</span>
        }
<span class="nc" id="L1788">    }</span>

    public static Collection&lt;TimeSpan&gt; getOrgDaySpan(Date dtStart, Date dtEnd, Organization pOrg) {
        // create a span for each org day in the range...
<span class="nc" id="L1792">        LinkedList&lt;TimeSpan&gt; llDaySpans = new LinkedList&lt;TimeSpan&gt;();</span>
        // calendar for org day start
<span class="nc" id="L1794">        Calendar cOrgDayStart = Calendar.getInstance(pOrg.getTimeZone());</span>
        // calendar for org day end.
<span class="nc" id="L1796">        Calendar cOrgDayEnd = Calendar.getInstance(pOrg.getTimeZone());</span>

        // compute org day start.
<span class="nc" id="L1799">        cOrgDayStart.setTime(dtStart);</span>
        // set the day boundary and start time
<span class="nc" id="L1801">        cOrgDayStart.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / 60);</span>
<span class="nc" id="L1802">        cOrgDayStart.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % 60);</span>
<span class="nc" id="L1803">        cOrgDayStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1804">        cOrgDayStart.set(Calendar.MILLISECOND, 0);</span>

        // check if day start is after start date, set day start to 1 day in the
        // past
<span class="nc bnc" id="L1808" title="All 2 branches missed.">        if (cOrgDayStart.getTime().after(dtStart)) {</span>
<span class="nc" id="L1809">            cOrgDayStart.add(Calendar.DATE, -1);</span>
        }

        // compute org day end.
<span class="nc" id="L1813">        cOrgDayEnd.setTime(cOrgDayStart.getTime());</span>
<span class="nc" id="L1814">        cOrgDayEnd.add(Calendar.DATE, 1);</span>

        // identify org days that encompass the given time range (dtSTart,
        // dtEnd)
<span class="nc bnc" id="L1818" title="All 2 branches missed.">        while (cOrgDayStart.getTime().before(dtEnd)) {</span>
            // System.out.println(cOrgDayStart.getTime());
            // System.out.println(cOrgDayEnd.getTime());
<span class="nc" id="L1821">            llDaySpans.add(new TimeSpan(cOrgDayStart.getTime(), cOrgDayEnd.getTime()));</span>
<span class="nc" id="L1822">            cOrgDayStart.setTime(cOrgDayEnd.getTime());</span>
<span class="nc" id="L1823">            cOrgDayEnd.add(Calendar.DATE, 1);</span>
        }
<span class="nc" id="L1825">        return llDaySpans;</span>
    }

    /**
     * Get the minConsecutiveDays, maxConsecutiveDays conflicts, as determined
     * by an employee's WorkPattern/Shift combination.
     *
     * @param cEvents            - All of the Events that occur during the date range.
     * @param shift              - The shift that we need to check for. The employee should be
     *                           scheduled between the min and max number of these shifts
     *                           within the date range.
     * @param minConsecutiveDays - The minimum consecutive days as defined by the work pattern.
     * @param maxConsecutiveDays - The maximum consecutive days as defined by the work pattern.
     * @param dtStart            - the start of the period to check (1 week, since work
     *                           patterns are weekly/monthly)
     * @param dtEnd              - the end of the period (1 week, since work patterns are
     *                           weekly/monthly)
     * @param pOrg               - the employee's organization
     * @return - Any min or max conflicts that are found.
     */
    public static Collection&lt;ShiftsConflict&gt; getMinMaxConsecutiveDaysForShiftConflicts(
            Collection&lt;? extends Event&gt; cEvents, Shift shift, int minConsecutiveDays, int maxConsecutiveDays,
            Date dtStart, Date dtEnd, Organization pOrg) {

<span class="nc bnc" id="L1849" title="All 2 branches missed.">        if (cEvents.isEmpty()) {</span>
<span class="nc" id="L1850">            return new LinkedList&lt;ShiftsConflict&gt;();</span>
        }

<span class="nc" id="L1853">        Collection&lt;TimeSpan&gt; llDaySpans = getOrgDaySpan(dtStart, dtEnd, pOrg);</span>

<span class="nc" id="L1855">        LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1856">        int numConsecShifts = 0;</span>
<span class="nc" id="L1857">        Date conflictDate = null;</span>

        // sort cEvents because they are not necessarily in order
<span class="nc" id="L1860">        ArrayList&lt;Event&gt; aEvents = new ArrayList&lt;Event&gt;(cEvents);</span>
<span class="nc" id="L1861">        Collections.sort(aEvents, new StartTimeComparator());</span>

        // iterate through each org day in the range
<span class="nc bnc" id="L1864" title="All 2 branches missed.">        for (Iterator&lt;TimeSpan&gt; l = llDaySpans.iterator(); l.hasNext(); ) {</span>
<span class="nc" id="L1865">            TimeSpan daySpan = l.next();</span>
<span class="nc" id="L1866">            boolean hasShiftThisDay = false;</span>
<span class="nc" id="L1867">            boolean hasAnyShiftThisDay = false;</span>
<span class="nc" id="L1868">            Event pEvent = null;</span>

            // iterate through shift assignments
<span class="nc bnc" id="L1871" title="All 2 branches missed.">            for (Iterator&lt;Event&gt; i = aEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1872">                pEvent = i.next();</span>
                // if shift assignment starts in this org day.
<span class="nc bnc" id="L1874" title="All 2 branches missed.">                if (WorkRuleUtil.isInPeriodAndApproved(pEvent, daySpan.dtSpanStart, daySpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">                    if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1876">                        hasAnyShiftThisDay = true;</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                        if ((((ShiftAssignment) pEvent).getShiftID() != null &amp;&amp; ((ShiftAssignment) pEvent).getShiftID()</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">                                .equals(shift.getID()))) {</span>
<span class="nc" id="L1879">                            hasShiftThisDay = true;</span>
<span class="nc" id="L1880">                            break;</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L1885" title="All 2 branches missed.">            if (!hasAnyShiftThisDay) {</span>
                // check if it is shift_off and there is no shift,
                // hasShiftThisDay should be true
<span class="nc bnc" id="L1888" title="All 2 branches missed.">                if (shift.getDEID().toString().trim().equals(&quot;SHIFT_OFF&quot;)) {</span>
<span class="nc" id="L1889">                    hasShiftThisDay = true;</span>
                }
            }

<span class="nc bnc" id="L1893" title="All 2 branches missed.">            if (hasShiftThisDay) {</span>
<span class="nc" id="L1894">                numConsecShifts++;</span>
<span class="nc bnc" id="L1895" title="All 4 branches missed.">                if (maxConsecutiveDays &gt; 0 &amp;&amp; numConsecShifts &gt; maxConsecutiveDays) {</span>
<span class="nc" id="L1896">                    conflictDate = daySpan.dtSpanStart; // for off days, we</span>
                    // can't use pEvent
                    // //pEvent.getStartTime();
<span class="nc" id="L1899">                    ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_MAXCONSECUTIVEDAY, numConsecShifts</span>
                            - maxConsecutiveDays, conflictDate);
<span class="nc" id="L1901">                    cConflict.setDoubleTarget(maxConsecutiveDays); // consecutive</span>
                    // day
                    // setting
<span class="nc" id="L1904">                    cConflict.setTarget(shift.getName()); // shift name</span>
<span class="nc" id="L1905">                    llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1906">                    break;</span>
                }
            } else {
<span class="nc bnc" id="L1909" title="All 6 branches missed.">                if (numConsecShifts &gt; 0 &amp;&amp; minConsecutiveDays &gt; 0 &amp;&amp; (numConsecShifts &lt; minConsecutiveDays)) {</span>
<span class="nc" id="L1910">                    conflictDate = daySpan.dtSpanStart; // for off days, we</span>
                    // can't use pEvent
                    // //pEvent.getStartTime();
<span class="nc" id="L1913">                    ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_MINCONSECUTIVEDAY,</span>
                            minConsecutiveDays - numConsecShifts, conflictDate);
<span class="nc" id="L1915">                    cConflict.setDoubleTarget(minConsecutiveDays); // consecutive</span>
                    // day
                    // setting
<span class="nc" id="L1918">                    cConflict.setTarget(shift.getName()); // shift name</span>
<span class="nc" id="L1919">                    llNewConflicts.add(cConflict);</span>
                }
<span class="nc" id="L1921">                numConsecShifts = 0;</span>
            }
<span class="nc" id="L1923">        }</span>
<span class="nc" id="L1924">        return llNewConflicts;</span>
    }

    // because of BUG in JROCKIT JVM 1.4_05 bug on DST transition for brazil
    // use this function to move to the next day for the calendar
    public static void addDaysToCalendar(Calendar cal, int days) {
<span class="nc" id="L1930">        cal.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH) + days);</span>
<span class="nc" id="L1931">    }</span>

    /**
     * Compute the next day for the given date, retaining the hour, minute and
     * seconds. For instance, if the given date is 11:53AM 1/1/2001, this
     * returns 11:53AM, 1/2/2001.
     * &lt;p/&gt;
     * Simply adding 24 * 60 * 60 * 1000 to the given date will not work for
     * days on which the DST starts or ends. Use a calendar to handle this case.
     *
     * @param date
     * @param tz
     * @return
     */
    public static Date getDateForwardOneDay(Date date, TimeZone tz) {
<span class="nc" id="L1946">        Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1947">        cal.setTime(date);</span>
<span class="nc" id="L1948">        addDaysToCalendar(cal, 1);</span>
        // cal.add(Calendar.DAY_OF_MONTH, 1); //move to next day

<span class="nc" id="L1951">        return cal.getTime();</span>
    }

    /**
     * Compute the previous day for the given date, retaining the hour, minute
     * and seconds. For instance, if the given date is 11:53AM 1/2/2001, this
     * returns 11:53AM, 1/1/2001.
     * &lt;p/&gt;
     * Simply adding 24 * 60 * 60 * 1000 to the given date will not work for
     * days on which the DST starts or ends. Use a calendar to handle this case.
     *
     * @param date
     * @param tz
     * @return
     */
    public static Date getDateBackwardOneDay(Date date, TimeZone tz) {
<span class="nc" id="L1967">        Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1968">        cal.setTime(date);</span>
<span class="nc" id="L1969">        addDaysToCalendar(cal, -1);</span>
        // cal.add(Calendar.DAY_OF_MONTH, 1); //move to next day

<span class="nc" id="L1972">        return cal.getTime();</span>
    }

    public static Date extendStartDays(Date startDate, Organization org) {
<span class="nc" id="L1976">        Date tempStartDate = new Date(startDate.getTime());</span>
        // For MaxConsecutiveWorkingDaysRule only
        // This fix is for SP crossing validation
<span class="nc bnc" id="L1979" title="All 2 branches missed.">        for (int i = 1; i &lt;= org.getMaxConsecutiveWorkingDay(); i++) {</span>
<span class="nc" id="L1980">            tempStartDate = getDateBackwardOneDay(tempStartDate, org.getTimeZone());</span>
        }
<span class="nc" id="L1982">        return tempStartDate;</span>
    }

    public static Date extendEndDays(Date endDate, Organization org) {
<span class="nc" id="L1986">        Date tempEndDate = new Date(endDate.getTime());</span>
        // For MaxConsecutiveWorkingDaysRule only
        // This fix is for SP crossing validation
<span class="nc bnc" id="L1989" title="All 2 branches missed.">        for (int i = 1; i &lt;= org.getMaxConsecutiveWorkingDay(); i++) {</span>
<span class="nc" id="L1990">            tempEndDate = getDateForwardOneDay(tempEndDate, org.getTimeZone());</span>
        }
<span class="nc" id="L1992">        return tempEndDate;</span>
    }

    /**
     * &lt;B&gt;getExpandedWindowForEmployee&lt;/B&gt; returns a Pair of Dates (Start Date,
     * End Date) which is an expanded version of the Start End Date passed in
     * The expanded Start Date will have enough look back to validate all Shift
     * Rules and WorkRules
     * &lt;p&gt;
     *
     * @param dtStart         the start date of the window for validation
     * @param dtEnd           the end date of the window for validation
     * @param hOrgs           all Orgs which the Work Resource or WorkRules are defined in
     * @param cOrgAssignments the Work Resource's Org Assignments
     * @param hWorkRules      a Collection containing all WorkRules assigned to the Work
     *                        Resource indexed by ID
     *                        &lt;p&gt;
     * @return (StartDate, EndDate) Pair
     */
    public static Pair&lt;Date, Date&gt; getExpandedWindowForEmployee(Date dtStart, Date dtEnd, Collection cOrgAssignments, Map&lt;ID,
            Organization&gt; hOrgs, Collection cRuleAssignments, HashMap hWorkRules) throws WorkRuleException {
<span class="nc" id="L2013">        ID idOrg = ((WorkResourceAssignment) cOrgAssignments.iterator().next()).getOrganizationID();</span>
<span class="nc" id="L2014">        Organization pOrg = hOrgs.get(idOrg);</span>
<span class="nc" id="L2015">        Calendar cCalendar = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L2016">        cCalendar.setTime(dtStart);</span>

<span class="nc" id="L2018">        int nDay = 0;</span>

<span class="nc bnc" id="L2020" title="All 2 branches missed.">        if (cCalendar.get(Calendar.DAY_OF_WEEK) != pOrg.getWeekStartDate()) {</span>
<span class="nc" id="L2021">            nDay = cCalendar.get(Calendar.DAY_OF_WEEK) - pOrg.getWeekStartDate();</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">            if (nDay &lt; 0) {</span>
<span class="nc" id="L2023">                nDay += 7;</span>
            }
<span class="nc bnc" id="L2025" title="All 2 branches missed.">        } else if (cCalendar.get(Calendar.HOUR) * 60 &lt; pOrg.getDayBoundaryOffset()) {</span>
<span class="nc" id="L2026">            nDay = 7;</span>
        }

<span class="nc" id="L2029">        cCalendar.add(Calendar.DAY_OF_YEAR, -1 * nDay);</span>
<span class="nc" id="L2030">        cCalendar.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset());</span>

<span class="nc" id="L2032">        Date dtExpandedStart = cCalendar.getTime();</span>
<span class="nc" id="L2033">        Date dtExpandedEnd = dtEnd;</span>

<span class="nc" id="L2035">        ArrayList&lt;WorkRule&gt; aWorkRules = new ArrayList&lt;WorkRule&gt;();</span>
<span class="nc" id="L2036">        ComplexWorkRule cWorkRule = null;</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">        for (Iterator i = cRuleAssignments.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2038">            WorkResourceComplexWorkRule pAssignment = (WorkResourceComplexWorkRule) i.next();</span>
<span class="nc" id="L2039">            cWorkRule = (ComplexWorkRule) hWorkRules.get(pAssignment.getComplexWorkRuleID());</span>
<span class="nc" id="L2040">            aWorkRules.add(new WorkRule(cWorkRule, null)); // ExpandRuleWindow</span>
            // API only takes
            // workrule objects
<span class="nc" id="L2043">        }</span>

<span class="nc" id="L2045">        Pair&lt;LocalDate, LocalDate&gt; pWindow = WorkRuleUtil.ExpandRuleWindow(aWorkRules, new LocalDate(dtStart),</span>
                new LocalDate(dtEnd));

<span class="nc" id="L2048">        Date dtWorkRuleStart = pWindow.getFirst().getTime(pOrg.getTimeZone());</span>
<span class="nc" id="L2049">        Date dtWorkRuleEnd = pWindow.getSecond().getTime(pOrg.getTimeZone());</span>

<span class="nc bnc" id="L2051" title="All 2 branches missed.">        if (dtWorkRuleStart.before(dtExpandedStart)) {</span>
<span class="nc" id="L2052">            dtExpandedStart = dtWorkRuleStart;</span>
        }
<span class="nc bnc" id="L2054" title="All 2 branches missed.">        if (dtWorkRuleEnd.after(dtExpandedEnd)) {</span>
<span class="nc" id="L2055">            dtExpandedEnd = dtWorkRuleEnd;</span>
        }

        // GQ for QC94660: Conflict checking date range needs to include
        // past/future sp's for MaxConsecutiveWorkingDays.
<span class="nc" id="L2060">        Date expandedStartForMaxConsecutiveDaysCheck = extendStartDays(dtStart, pOrg);</span>
<span class="nc" id="L2061">        Date expandedEndForMaxConsecutiveDaysCheck = extendEndDays(dtEnd, pOrg);</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">        if (expandedStartForMaxConsecutiveDaysCheck.before(dtExpandedStart)) {</span>
<span class="nc" id="L2063">            dtExpandedStart = expandedStartForMaxConsecutiveDaysCheck;</span>
        }
<span class="nc bnc" id="L2065" title="All 2 branches missed.">        if (expandedEndForMaxConsecutiveDaysCheck.after(dtExpandedEnd)) {</span>
<span class="nc" id="L2066">            dtExpandedEnd = expandedEndForMaxConsecutiveDaysCheck;</span>
        }

<span class="nc" id="L2069">        return new Pair&lt;Date, Date&gt;(dtExpandedStart, dtExpandedEnd);</span>

    }

    /**
     * &lt;B&gt;getAllAlertsForEmployee&lt;/B&gt; returns Alerts for a single Employee's
     * Schedule, see ShiftsConflict.java, Alert.java, and CommonConflict.java
     * for a list of Alert types. For all the collections (cEvents,
     * cMinMaxHours, etc...) and all the HashMaps (hShifts, hWorkPatterns,
     * etc...) except hWorkRules any additional unneeded entries will be
     * ignored, so is fine to pass in a superset of the required entries.
     * &lt;p&gt;
     *
     * @param sName              the name of the Work Resource to be included in the conflict
     *                           message
     * @param idWorkResource     the ID of the Work Resource to be included in the conflict
     * @param dtStart            the start time of the conflict checking window (viewing start
     *                           date)
     * @param dtEnd              the end time of the conflict checking window (viewing end
     *                           date)
     * @param cOrgAssignments    the Work Resource's Org Assignments
     * @param cMinMaxHours       the collection of all WorkResourceMinMaxHour assigned during
     *                           the conflict checking window
     * @param cEmpWorkPatterns   the collection of all WorkResourceWorkPattern assigned during
     *                           the window
     * @param cEmpRotations      the collection of all Rotations assigned during the window
     * @param hWorkRules         all Rules which are assigned
     * @param hShifts            all Shifts which have corresponding scheduled Shift
     *                           Assignments
     * @param hWorkPatterns      all Work Patterns which are assigned to the Work Resource
     * @param hOrgs              all Orgs which the Work Resource or WorkRules are defined in
     * @param tzCampaign         the Campaign TZ
     * @param pCampaignHOOs      all HOOs assigned to the Campaign during the window
     * @param pOrgHOOs           all HOOs assigned to the Work Resource's Org during the window
     * @param hShiftOTExtensions all ShiftOTExtensions for the work resource's Org during the window
     * @param activityMap        all activity id vs activity map
     * @param isMonthly          true if the SP is a monthly false otherwise
     * @param cMonthlyMinMax     monthly min and max for the work resource
     *                           &lt;p&gt;
     * @return Collection of Alerts (both CommonConflict and ShiftsConflict
     * objects!)
     */
    public static Collection&lt;Alert&gt; getAllAlertsForEmployee(String sName, ID idWorkResource, Collection&lt;? extends Event&gt; cEvents1, Date
            dtStart, Date dtEnd, List&lt;Pair&lt;Date, Date&gt;&gt; weekPairs, Collection cOrgAssignments, Collection&lt;RuleAssignment&gt; cRuleAssignments,
            Collection cMinMaxHours, Collection&lt;WorkResourceWorkPattern&gt; cEmpWorkPatterns, Collection&lt;WorkResourceRotation&gt; cEmpRotations,
            HashMap&lt;ID, WorkRule&gt; hWorkRules, Map&lt;ID, Shift&gt; hShifts, Map&lt;ID, ShiftPattern&gt; hWorkPatterns, Map&lt;ID, Organization&gt; hOrgs,
            TimeZone tzCampaign, HOOPeriod pCampaignHOOs, HOOPeriod pOrgHOOs, Map hShiftOTExtensions, Map&lt;ID, Activity&gt; activityMap,
            boolean isMonthly, WorkResourceMonthlyMinMaxHour cMonthlyMinMax) throws WorkRuleException {

<span class="nc" id="L2118">        ArrayList&lt;Event&gt; cSortedEvents = new ArrayList&lt;Event&gt;(cEvents1);</span>
        // this is quite inefficient
<span class="nc" id="L2120">        Collections.sort(cSortedEvents, new StartTimeComparator());</span>

<span class="nc" id="L2122">        ID idOrg = ((WorkResourceAssignment) cOrgAssignments.iterator().next()).getOrganizationID();</span>
<span class="nc" id="L2123">        Organization pOrg = hOrgs.get(idOrg);</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">        if (pOrg == null) {</span>
<span class="nc" id="L2125">            return new ArrayList&lt;Alert&gt;();</span>
        }

<span class="nc" id="L2128">        HashMap&lt;ID, WorkRule&gt; hEmployeeRules = new HashMap&lt;ID, WorkRule&gt;();</span>
<span class="nc bnc" id="L2129" title="All 2 branches missed.">        for (Iterator&lt;RuleAssignment&gt; i = cRuleAssignments.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2130">            RuleAssignment pAssignment = i.next();</span>
<span class="nc" id="L2131">            hEmployeeRules.put(pAssignment.getRuleID(), hWorkRules.get(pAssignment.getRuleID()));</span>
<span class="nc" id="L2132">        }</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">        Collection&lt;CommonConflict&gt; cEmpConflicts = WorkRuleUtil.getConflictsForEmployee(dtStart, dtEnd, idWorkResource,</span>
                pOrg, hEmployeeRules, cSortedEvents, cMonthlyMinMax != null ? true : false);

<span class="nc bnc" id="L2136" title="All 2 branches missed.">        for (Iterator&lt;CommonConflict&gt; i = cEmpConflicts.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2137">            CommonConflict pConflict = i.next();</span>
<span class="nc" id="L2138">            pConflict.SetWorkResourceName(sName);</span>
<span class="nc" id="L2139">        }</span>

<span class="nc" id="L2141">        Collection&lt;Alert&gt; cAlerts = new ArrayList&lt;Alert&gt;(cEmpConflicts);</span>
<span class="nc" id="L2142">        Collection&lt;ShiftsConflict&gt; cShiftAlerts = ShiftsUtil.getAllShiftConflictsForEmployee(sName, idWorkResource,</span>
                cSortedEvents, dtStart, dtEnd, weekPairs, cOrgAssignments, cMinMaxHours, cEmpWorkPatterns, cEmpRotations,
                hShifts, hWorkPatterns, hOrgs, tzCampaign, pCampaignHOOs, pOrgHOOs, hShiftOTExtensions, activityMap, isMonthly,
                cMonthlyMinMax);
<span class="nc" id="L2146">        cAlerts.addAll(cShiftAlerts);</span>

<span class="nc" id="L2148">        return cAlerts;</span>
    }

    public static boolean isShiftAssignmentCustomized(ShiftAssignment sa, Shift shift, TimeZone shiftTZ, Map&lt;ID, String&gt;
            customizedReasonCache, Localizer localizer, ResourceBundle bbmBundle, Organization org) {
<span class="nc bnc" id="L2153" title="All 2 branches missed.">        if (bbmBundle == null) {</span>
<span class="nc" id="L2154">            bbmBundle = localizer.getBundle(BbmEjbBundleKey.BUNDLE_NAME);</span>
        }
<span class="nc" id="L2156">        Object[] aArgs = null;</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">        if (shift == null) {</span>
            // IDS_CUSTOM_SHIFT_NOTFOUND
<span class="nc" id="L2159">            customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2160">                    MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_NOTFOUND), null));</span>
<span class="nc" id="L2161">            return true;</span>
<span class="nc bnc" id="L2162" title="All 2 branches missed.">        } else if (shift.isDeleted()) {</span>
            // ID_CUSTOM_SHIFT_NOTEXIST
<span class="nc" id="L2164">            customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2165">                    MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.ID_CUSTOM_SHIFT_NOTEXIST), null));</span>
<span class="nc" id="L2166">            return true;</span>
        }

        // check if length of the shift assignment is the same as the shift
        // definition
        // IDS_CUSTOM_SHIFT_LENGTH
        // This call assumes duration includes ot.
<span class="nc bnc" id="L2173" title="All 4 branches missed.">        if ((EventUtils.isOTShift(sa) &amp;&amp; sa.getDuration() != shift.getDuration())</span>
<span class="nc bnc" id="L2174" title="All 2 branches missed.">				|| (!EventUtils.isOTShift(sa) &amp;&amp; (sa.getDuration() - sa.getExtensionAfter() - sa.getExtensionBefore()) != shift</span>
<span class="nc bnc" id="L2175" title="All 2 branches missed.">                .getDuration())) {</span>
<span class="nc" id="L2176">            aArgs = new Object[]{localizer.formatDurationInMins(sa.getDuration()),</span>
<span class="nc" id="L2177">                    localizer.formatDurationInMins(shift.getDuration())};</span>
<span class="nc" id="L2178">            customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2179">                    MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_LENGTH), aArgs));</span>
<span class="nc" id="L2180">            return true;</span>
        }
        // IDS_CUSTOME_SHIFT_ACTIVITY
<span class="nc bnc" id="L2183" title="All 2 branches missed.">        if (!sa.getActivityID().equals(shift.getActivityID())) {</span>
<span class="nc" id="L2184">            customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2185">                    MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOME_SHIFT_ACTIVITY), null));</span>
<span class="nc" id="L2186">            return true;</span>
        }
        // IDS_CUSTOM_SHIFT_NOSTARTTIME
<span class="nc bnc" id="L2189" title="All 4 branches missed.">        if (shift.getStartTimes() == null || shift.getStartTimes().isEmpty()) {</span>
<span class="nc" id="L2190">            customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2191">                    MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_NOSTARTTIME), null));</span>
<span class="nc" id="L2192">            return true;</span>
        }
        // IDS_CUSTOM_SHIFT_STARTTIME
<span class="nc" id="L2195">        Calendar cCalendar = Calendar.getInstance(shiftTZ);</span>
<span class="nc" id="L2196">        cCalendar.setTime(getShiftStartConsiderOT(cCalendar, sa));</span>
<span class="nc" id="L2197">        TimeOfDay tShiftStart = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY), cCalendar.get(Calendar.MINUTE));</span>
<span class="nc bnc" id="L2198" title="All 4 branches missed.">        if (org != null &amp;&amp; org.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L2199">            tShiftStart = tShiftStart.addMinutes(-org.getDayBoundaryOffset());</span>
		}
<span class="nc bnc" id="L2201" title="All 2 branches missed.">        if (!shift.getStartTimes().contains(tShiftStart)) {</span>
<span class="nc" id="L2202">            ArrayList list = (ArrayList) shift.getStartTimes();</span>
<span class="nc" id="L2203">            Collections.sort(list);</span>
<span class="nc" id="L2204">            StringBuffer possibleStarts = new StringBuffer(200);</span>
<span class="nc" id="L2205">            TimeOfDay start = null;</span>
<span class="nc bnc" id="L2206" title="All 2 branches missed.">            for (Iterator i = list.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2207">                start = (TimeOfDay) i.next();</span>
<span class="nc" id="L2208">				possibleStarts.append(start.getHours() + &quot;:&quot; + getMinuteString(start.getMinutes()));</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">                if (i.hasNext()) {</span>
<span class="nc" id="L2210">                    possibleStarts.append(&quot;,&quot;);</span>
                }
            }
<span class="nc" id="L2213">            aArgs = new Object[]{possibleStarts.toString()};</span>
<span class="nc" id="L2214">            customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2215">                    MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_STARTTIME), aArgs));</span>
<span class="nc" id="L2216">            return true;</span>
        }

        //check each shift activity (not optional shift activity and not events on ot)
        //IDS_CUSTOM_SHIFT_NUM_EVENTS: if shift assignment has different numbers of shift events than the shift definition.
<span class="nc" id="L2221">        ShiftEventAssignment event = null;</span>
<span class="nc" id="L2222">        Map&lt;ID, Integer&gt; mandatoryIDMap = shift.getMandatoryShiftEventsID();</span>
<span class="nc" id="L2223">        Map&lt;ID, Integer&gt; shiftEventIDMap = new HashMap&lt;ID, Integer&gt;();</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">		for (Iterator i = sa.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2225">            event = (ShiftEventAssignment) i.next();</span>
<span class="nc bnc" id="L2226" title="All 4 branches missed.">            if (event.getStartTime().before(sa.getEndTime()) &amp;&amp; event.getEndTime().after(sa.getStartTime())) { //rule out over time events</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">                if (shiftEventIDMap.containsKey(event.getShiftEventID())) {</span>
<span class="nc" id="L2228">                    shiftEventIDMap.put(event.getShiftEventID(), shiftEventIDMap.get(event.getShiftEventID()) + 1);</span>
                } else {
<span class="nc" id="L2230">                    shiftEventIDMap.put(event.getShiftEventID(), 1);</span>
                }
            }
        }

<span class="nc" id="L2235">        Iterator it = mandatoryIDMap.entrySet().iterator();</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L2237">            Map.Entry&lt;ID, Integer&gt; pairs = (Map.Entry) it.next();</span>
<span class="nc bnc" id="L2238" title="All 2 branches missed.">            if (!shiftEventIDMap.containsKey(pairs.getKey())</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">                    || shiftEventIDMap.get(pairs.getKey()) &lt; pairs.getValue()) {</span>
<span class="nc" id="L2240">                aArgs = new Object[]{new Integer(pairs.getValue()), new Integer(mandatoryIDMap.get(pairs.getKey()))};</span>
<span class="nc" id="L2241">                customizedReasonCache.put(sa.getID(), MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey</span>
                        .IDS_CUSTOM_SHIFT_NUM_EVENTS), aArgs));
<span class="nc" id="L2243">                return true;</span>
            }
<span class="nc" id="L2245">        }</span>

<span class="nc bnc" id="L2247" title="All 2 branches missed.">        for (Iterator i = sa.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2248">            event = (ShiftEventAssignment) i.next();</span>
<span class="nc bnc" id="L2249" title="All 2 branches missed.">            if (isShiftEventAssignmentCustomized(sa, event, shift, shiftTZ, customizedReasonCache, localizer, bbmBundle, org</span>
<span class="nc" id="L2250">                    .getDayBoundaryOffset())) {</span>
<span class="nc" id="L2251">                return true;</span>
            }
        }

<span class="nc" id="L2255">        customizedReasonCache.remove(sa.getID());</span>
<span class="nc" id="L2256">        return false;</span>
    }

    private static Date getShiftStartConsiderOT(Calendar cCalendar, ShiftAssignment sa) {
<span class="nc" id="L2260">        cCalendar.setTime(sa.getStartTime());</span>
<span class="nc" id="L2261">        cCalendar.add(Calendar.MINUTE, sa.getExtensionBefore());</span>
<span class="nc" id="L2262">		return cCalendar.getTime();</span>
    }

    public static boolean isShiftEventAssignmentCustomized(ShiftAssignment sa, ShiftEventAssignment event, Shift shift, TimeZone shiftTZ,
            Map&lt;ID, String&gt; customizedReasonCache, Localizer localizer, ResourceBundle bbmBundle, int orgDayBoundary) {
<span class="nc bnc" id="L2267" title="All 2 branches missed.">        if (bbmBundle == null) {</span>
<span class="nc" id="L2268">            bbmBundle = localizer.getBundle(BbmEjbBundleKey.BUNDLE_NAME);</span>
        }
<span class="nc" id="L2270">        int eventStartInMinutes = 0;</span>
<span class="nc" id="L2271">        ShiftEvent shiftEvent = null;</span>
<span class="nc" id="L2272">        Object[] aArgs = null;</span>
<span class="nc" id="L2273">        Calendar cCalendar = Calendar.getInstance(shiftTZ);</span>
<span class="nc" id="L2274">        TimeRange mainTimeRange = sa.getMainShiftTimeRange();</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">        if (!event.getStartTime().before(mainTimeRange.getStartDate())</span>
<span class="nc bnc" id="L2276" title="All 2 branches missed.">                &amp;&amp; !event.getEndTime().after(mainTimeRange.getEndDate())) { // rule</span>
            // out
            // over
            // time
            // events
<span class="nc bnc" id="L2281" title="All 2 branches missed.">			if (shift != null) {</span>
<span class="nc" id="L2282">                shiftEvent = shift.getShiftEvent(event.getShiftEventID());</span>
            }
<span class="nc bnc" id="L2284" title="All 2 branches missed.">            if (shiftEvent != null) {</span>
<span class="nc bnc" id="L2285" title="All 2 branches missed.">                if (shiftEvent.isCafeteria()) { // absolute start time</span>
<span class="nc" id="L2286">                    cCalendar.setTime(event.getStartTime());</span>
<span class="nc" id="L2287">                    eventStartInMinutes = cCalendar.get(Calendar.HOUR_OF_DAY) * 60 + cCalendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L2288">					eventStartInMinutes -= orgDayBoundary; // even for absolute</span>
                    // start time, the
					// start/end minutes
                    // consider the day
                    // boundary offset
                    // before storing
                    // them in db. here,
                    // we have to take
					// it out. QC98032
                } else {
<span class="nc" id="L2298">                    eventStartInMinutes = (int) (event.getStartTime().getTime() - getShiftStartConsiderOT(cCalendar, sa)</span>
<span class="nc" id="L2299">                            .getTime()) / TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
                }
<span class="nc" id="L2301">                int numOfEvents = sa.getNumOfShiftEventAssignments(shiftEvent.getID());</span>
<span class="nc bnc" id="L2302" title="All 4 branches missed.">                if ((!shiftEvent.isFlexible() &amp;&amp; numOfEvents != 1)</span>
<span class="nc bnc" id="L2303" title="All 4 branches missed.">						|| (shiftEvent.isFlexible() &amp;&amp; (numOfEvents &lt; shiftEvent.getMinCount() || numOfEvents &gt; shiftEvent</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">                        .getMaxCount()))) {</span>
                    // IDS_CUSTOM_SHIFT_EVENT_NUM
<span class="nc" id="L2306">					customizedReasonCache</span>
<span class="nc" id="L2307">                            .put(sa.getID(),</span>
<span class="nc" id="L2308">                                    MessageFormat.format(</span>
<span class="nc" id="L2309">                                            localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_NUM), null));</span>
<span class="nc" id="L2310">					return true;</span>
                }
				// IDS_CUSTOM_SHIFT_EVENT_ACTIVITY
<span class="nc bnc" id="L2313" title="All 2 branches missed.">                if (!event.getActivityID().equals(shiftEvent.getActivityID())) {</span>
<span class="nc" id="L2314">                    boolean isCustomized = true;</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">                    if (shiftEvent.isFlexible()) {</span>
                        // there could be additional activities
<span class="nc" id="L2317">                        Collection&lt;Activity&gt; aList = shiftEvent.getAdditionalActivities();</span>
<span class="nc bnc" id="L2318" title="All 2 branches missed.">                        for (Iterator&lt;Activity&gt; i = aList.iterator(); i.hasNext(); ) {</span>
<span class="nc bnc" id="L2319" title="All 2 branches missed.">							if (event.getActivityID().equals(i.next().getID())) {</span>
<span class="nc" id="L2320">                                isCustomized = false;</span>
                            }
                        }
                    }
<span class="nc bnc" id="L2324" title="All 2 branches missed.">                    if (isCustomized) {</span>
<span class="nc" id="L2325">                        customizedReasonCache.put(sa.getID(), MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME,</span>
                                BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_ACTIVITY), null));
<span class="nc" id="L2327">                        return true;</span>
                    }
                }
                // IDS_CUSTOM_SHIFT_EVENT_LENGTH
<span class="nc bnc" id="L2331" title="All 2 branches missed.">                if (event.getDuration() != shiftEvent.getDuration().getDurationInMinutes()) {</span>
<span class="nc" id="L2332">                    aArgs = new Object[]{shiftEvent.getName(), localizer.formatDurationInMins(event.getDuration()),</span>
<span class="nc" id="L2333">                            localizer.formatDurationInMins(shiftEvent.getDuration().getDurationInMinutes())};</span>
<span class="nc" id="L2334">                    customizedReasonCache.put(sa.getID(), MessageFormat.format(</span>
<span class="nc" id="L2335">                            localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_LENGTH), aArgs));</span>
<span class="nc" id="L2336">                    return true;</span>
                }
                // IDS_CUSTOME_SHIFT_EVENT_PAID
<span class="nc bnc" id="L2339" title="All 2 branches missed.">                if (event.getPaid() != shiftEvent.isPaid()) {</span>
<span class="nc" id="L2340">                    customizedReasonCache.put(sa.getID(), MessageFormat.format(</span>
<span class="nc" id="L2341">                            localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOME_SHIFT_EVENT_PAID), null));</span>
<span class="nc" id="L2342">                    return true;</span>
                }
                // IDS_CUSTOM_SHIFT_EVENT_STARTTIME
<span class="nc" id="L2345">                cCalendar.setTime(getShiftStartConsiderOT(cCalendar, sa));</span>
<span class="nc" id="L2346">                TimeOfDay tShiftStart = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY),</span>
<span class="nc" id="L2347">                        cCalendar.get(Calendar.MINUTE));</span>
<span class="nc bnc" id="L2348" title="All 2 branches missed.">                if (!shiftEvent.isAnyTime()</span>
<span class="nc bnc" id="L2349" title="All 4 branches missed.">                        &amp;&amp; (eventStartInMinutes &lt; shiftEvent.getStart() || eventStartInMinutes &gt; shiftEvent.getEnd())) {</span>
                    // 15 minutes tolerance: duration + diff &lt;= 15, not consider as conflict
<span class="nc" id="L2351">                    if (Math.min(Math.abs(eventStartInMinutes - shiftEvent.getStart()),</span>
<span class="nc" id="L2352">                            Math.abs(eventStartInMinutes - shiftEvent.getEnd()))</span>
<span class="nc bnc" id="L2353" title="All 2 branches missed.">                            + event.getDuration() &gt; 15) {</span>
<span class="nc" id="L2354">                        TimeOfDay shiftEventStart = tShiftStart.addMinutes(shiftEvent.getStart());</span>
<span class="nc" id="L2355">                        TimeOfDay shiftEventEnd = tShiftStart.addMinutes(shiftEvent.getEnd() + event.getDuration());</span>
<span class="nc" id="L2356">                        aArgs = new Object[]{</span>
<span class="nc" id="L2357">                                shiftEvent.getName(),</span>
<span class="nc" id="L2358">                                shiftEventStart.getHours() + &quot; :&quot; + getMinuteString(shiftEventStart.getMinutes()) + &quot;-&quot;</span>
<span class="nc" id="L2359">                                        + shiftEventEnd.getHours() + &quot; :&quot; + shiftEventEnd.getMinutes()};</span>
<span class="nc" id="L2360">                        customizedReasonCache.put(sa.getID(), MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME,</span>
                                BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_STARTTIME), aArgs));
<span class="nc" id="L2362">                        return true;</span>
                    }
                }
<span class="nc bnc" id="L2365" title="All 6 branches missed.">			} else if (event.getID() != null &amp;&amp; (event.getOverTimeGapType() != 2 &amp;&amp; event.getOverTimeGapType() != 1)) {</span>
                // IDS_CUSTOME_SHIFT_EVENT_NOTEXIST
<span class="nc" id="L2367">                customizedReasonCache.put(sa.getID(), MessageFormat.format(</span>
<span class="nc" id="L2368">                        localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOME_SHIFT_EVENT_NOTEXIST), null));</span>
<span class="nc" id="L2369">                return true;</span>
            }
        }
<span class="nc" id="L2372">        return false;</span>
    }

    private static TimeOfDay getRealShiftStartInHourAndMinute(ShiftAssignment shiftAssignment, Calendar cCalendar) {
<span class="nc" id="L2376">        cCalendar.setTime(shiftAssignment.getStartTime());</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">        if (shiftAssignment.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L2378">            cCalendar.add(Calendar.MINUTE, shiftAssignment.getExtensionBefore());</span>
        }
<span class="nc" id="L2380">        return new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY), cCalendar.get(Calendar.MINUTE));</span>
    }

    private static Date getRealShiftStart(ShiftAssignment shiftAssignment, Calendar cCalendar) {
<span class="nc" id="L2384">        cCalendar.setTime(shiftAssignment.getStartTime());</span>
<span class="nc bnc" id="L2385" title="All 2 branches missed.">        if (shiftAssignment.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L2386">            cCalendar.add(Calendar.MINUTE, shiftAssignment.getExtensionBefore());</span>
        }
<span class="nc" id="L2388">        return cCalendar.getTime();</span>
    }

    private static Date getRealShiftEnd(ShiftAssignment shiftAssignment, Calendar cCalendar) {
<span class="nc" id="L2392">        cCalendar.setTime(shiftAssignment.getEndTime());</span>
<span class="nc bnc" id="L2393" title="All 2 branches missed.">        if (shiftAssignment.getExtensionAfter() &gt; 0) {</span>
<span class="nc" id="L2394">            cCalendar.add(Calendar.MINUTE, -shiftAssignment.getExtensionAfter());</span>
        }
<span class="nc" id="L2396">        return cCalendar.getTime();</span>
    }

    public static Collection getClassUnassignedConflicts(Collection events) {
        // to do
<span class="nc" id="L2401">        return null;</span>
    }

    private static String getMinuteString(int minute) {
<span class="nc bnc" id="L2405" title="All 2 branches missed.">        if (minute &lt; 10) {</span>
<span class="nc" id="L2406">            return &quot;0&quot; + minute;</span>
        } else {
<span class="nc" id="L2408">            return &quot;&quot; + minute;</span>
        }
    }

    public static Map&lt;ID, Collection&lt;Event&gt;&gt; filterEvents(Map&lt;ID, Collection&lt;Event&gt;&gt; unfilteredEvents,
                                                          Collection m_currentFilterShiftIDs, Collection m_currentFilterActivityIDs) {
<span class="nc" id="L2414">        return filterEvents(unfilteredEvents, m_currentFilterShiftIDs, m_currentFilterActivityIDs, false, null, false);</span>
    }

    public static Map&lt;ID, Collection&lt;Event&gt;&gt; filterEvents(Map&lt;ID, Collection&lt;Event&gt;&gt; unfilteredEvents, Collection
            m_currentFilterShiftIDs, Collection m_currentFilterActivityIDs, boolean isActivityFilter, Pair startEndDate,
            boolean isTopLayerOnly) {
<span class="nc bnc" id="L2420" title="All 2 branches missed.">        if (unfilteredEvents == null) {</span>
<span class="nc" id="L2421">            return null;</span>
        }

<span class="nc bnc" id="L2424" title="All 2 branches missed.">        Date start = startEndDate == null ? null : (Date) startEndDate.getFirst();</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">        Date end = startEndDate == null ? null : (Date) startEndDate.getSecond();</span>

<span class="nc" id="L2427">        Map&lt;ID, Collection&lt;Event&gt;&gt; filteredEvents = new HashMap&lt;ID, Collection&lt;Event&gt;&gt;(unfilteredEvents.size());</span>
<span class="nc" id="L2428">        Iterator&lt;ID&gt; itKeys = unfilteredEvents.keySet().iterator();</span>
<span class="nc bnc" id="L2429" title="All 2 branches missed.">        while (itKeys.hasNext()) {</span>
<span class="nc" id="L2430">            ID nextKey = itKeys.next();</span>
<span class="nc" id="L2431">            List&lt;Event&gt; filteredEventCollection = new ArrayList&lt;Event&gt;();</span>
<span class="nc" id="L2432">            filteredEvents.put(nextKey, filteredEventCollection);</span>
<span class="nc" id="L2433">            Collection&lt;Event&gt; nextEventsCollection = unfilteredEvents.get(nextKey);</span>
<span class="nc bnc" id="L2434" title="All 2 branches missed.">            if (isActivityFilter) {</span>
<span class="nc" id="L2435">                nextEventsCollection = EventUtils.flattenEvents(nextEventsCollection, true);</span>
            }
<span class="nc bnc" id="L2437" title="All 2 branches missed.">            for (Event nextEvent : nextEventsCollection) {</span>
<span class="nc" id="L2438">                boolean bAddEvent = false;</span>
<span class="nc bnc" id="L2439" title="All 2 branches missed.">                if (isActivityFilter) {</span>
<span class="nc" id="L2440">                    bAddEvent = canPassActivityFilter(m_currentFilterActivityIDs, nextEvent);</span>
                } else {
<span class="nc bnc" id="L2442" title="All 2 branches missed.">                    if (nextEvent instanceof ShiftAssignment) {</span>
<span class="nc bnc" id="L2443" title="All 2 branches missed.">                        if (m_currentFilterShiftIDs == null) {</span>
                            // indicates we should show all shifts
<span class="nc" id="L2445">                            bAddEvent = true;</span>
                        } else {
<span class="nc" id="L2447">                            ID shiftID = ((ShiftAssignment) nextEvent).getShiftID();</span>
<span class="nc bnc" id="L2448" title="All 2 branches missed.">                            if (m_currentFilterShiftIDs.contains(shiftID)) {</span>
<span class="nc" id="L2449">                                bAddEvent = true;</span>
                            }
<span class="nc" id="L2451">                        }</span>
                    } else {
<span class="nc" id="L2453">                        bAddEvent = canPassActivityFilter(m_currentFilterActivityIDs, nextEvent);</span>
                    }
                }

                // date range check
<span class="nc bnc" id="L2458" title="All 4 branches missed.">                if (bAddEvent &amp;&amp; startEndDate != null</span>
<span class="nc bnc" id="L2459" title="All 4 branches missed.">                        &amp;&amp; (nextEvent.getStartTime().after(end) || nextEvent.getEndTime().before(start))) {</span>
<span class="nc" id="L2460">                    bAddEvent = false;</span>
                }

<span class="nc bnc" id="L2463" title="All 2 branches missed.">                if (bAddEvent) {</span>
<span class="nc" id="L2464">                    filteredEventCollection.add(nextEvent);</span>
                }
<span class="nc" id="L2466">            }</span>

            // layer check only for activity filter
<span class="nc bnc" id="L2469" title="All 2 branches missed.">            if (isActivityFilter) {</span>
                // to show overlap events as grey, we get the overlap envents
                // here
<span class="nc" id="L2472">                Event event = null;</span>
<span class="nc" id="L2473">                Event eventInner = null;</span>
<span class="nc" id="L2474">                List&lt;Event&gt; allOverlaps = new ArrayList&lt;Event&gt;();</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                for (Iterator&lt;Event&gt; i = filteredEventCollection.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2476">                    event = i.next();</span>
<span class="nc" id="L2477">                    List&lt;Event&gt; overlaps = new ArrayList&lt;Event&gt;();</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">                    for (Iterator iInner = nextEventsCollection.iterator(); iInner.hasNext(); ) {</span>
<span class="nc" id="L2479">                        eventInner = (Event) iInner.next();</span>
<span class="nc bnc" id="L2480" title="All 2 branches missed.">                        if (event.getStartTime().before(eventInner.getEndTime())</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">                                &amp;&amp; event.getEndTime().after(eventInner.getStartTime())</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">                                &amp;&amp; eventInner.getEventType() != Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) {</span>
<span class="nc" id="L2483">                            overlaps.add(eventInner);</span>
                        }
                    }
<span class="nc" id="L2486">                    boolean isShown = true;</span>
<span class="nc bnc" id="L2487" title="All 4 branches missed.">                    if (!overlaps.isEmpty() &amp;&amp; isTopLayerOnly</span>
                            // &amp;&amp;(event.getEventType() !=
                            // Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) QC103541
<span class="nc bnc" id="L2490" title="All 2 branches missed.">                            &amp;&amp; !isEventAtTopAtLeastOneMinutes(event, overlaps)) {</span>
<span class="nc" id="L2491">                        i.remove(); // remove from the list of return. since it</span>
                        // is not top layer event
<span class="nc" id="L2493">                        overlaps.clear(); // no need to add overlaps to filtered</span>
                        // out event list any more
<span class="nc" id="L2495">                        isShown = false;</span>
                    }
<span class="nc" id="L2497">                    overlaps.remove(event);</span>
<span class="nc" id="L2498">                    overlaps.removeAll(allOverlaps); // avoid dup</span>
<span class="nc" id="L2499">                    allOverlaps.addAll(overlaps);</span>

<span class="nc bnc" id="L2501" title="All 4 branches missed.">                    if (isShown &amp;&amp; event.getEventType() == Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) {</span>
<span class="nc" id="L2502">                        i.remove(); // never put shift event in filtered events,</span>
                        // we put shift assignment instead.
                    }
<span class="nc" id="L2505">                }</span>

<span class="nc" id="L2507">                allOverlaps.removeAll(filteredEventCollection); // avoid dup</span>
<span class="nc" id="L2508">                filteredEventCollection.addAll(allOverlaps);</span>
            }
<span class="nc" id="L2510">        }</span>
<span class="nc" id="L2511">        return filteredEvents;</span>
    }

    private static boolean canPassActivityFilter(Collection m_currentFilterActivityIDs, Event nextEvent) {
<span class="nc bnc" id="L2515" title="All 2 branches missed.">        if (m_currentFilterActivityIDs == null) {</span>
<span class="nc" id="L2516">            return true;</span>
        } else {
<span class="nc" id="L2518">            ID activityID = nextEvent.getActivityID();</span>
<span class="nc bnc" id="L2519" title="All 2 branches missed.">            if (m_currentFilterActivityIDs.contains(activityID)) {</span>
<span class="nc" id="L2520">                return true;</span>
            }
        }
<span class="nc" id="L2523">        return false;</span>
    }

    private static boolean isEventAtTopAtLeastOneMinutes(Event event, Collection&lt;Event&gt; overlaps) {
<span class="nc" id="L2527">        List&lt;Event&gt; allEvents = new ArrayList&lt;Event&gt;(overlaps.size() + 1);</span>
<span class="nc" id="L2528">        allEvents.add(event);</span>
<span class="nc" id="L2529">        allEvents.addAll(overlaps);</span>

<span class="nc" id="L2531">        Collection&lt;SimpleEvent&gt; timelines = EventUtils.convertEventsToTimelineForSingleEmployee(allEvents);</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">        for (SimpleEvent simpleEvent : timelines) {</span>
<span class="nc bnc" id="L2533" title="All 2 branches missed.">            if (simpleEvent.getActivityID().equals(event.getActivityID())) {</span>
<span class="nc" id="L2534">                return true;</span>
            }
<span class="nc" id="L2536">        }</span>

<span class="nc" id="L2538">        return false;</span>
    }


    /**
     * Returns a hashcode for the ShiftAssignment which includes its children
     * This is used primarily by Shift Swap code to see if a swapped shift has been modified
     * See com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil.getHashCode(ShiftAssignment)
     **/
    public static int getShiftAssignmentHashCodeExtended(ShiftAssignment sa) {
<span class="nc" id="L2548">        int hashCode = sa.hashCode();</span>
<span class="nc" id="L2549">        Collection&lt;ShiftEventAssignment&gt; shiftEventAssignments = sa.getChildren();</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">        for (ShiftEventAssignment sea : shiftEventAssignments) {</span>
<span class="nc" id="L2551">            int h = 0;</span>
<span class="nc bnc" id="L2552" title="All 2 branches missed.">            if (sea.getActivityID() != null) {</span>
<span class="nc" id="L2553">                h = sea.getActivityID().hashCode();</span>
            }
<span class="nc" id="L2555">            h ^= sea.getStartTime().hashCode();</span>
<span class="nc" id="L2556">            h ^= sea.getDuration();</span>
<span class="nc" id="L2557">            hashCode ^= h;</span>
<span class="nc" id="L2558">        }</span>
<span class="nc" id="L2559">        return hashCode;</span>
    }

    /**
     * Returns a hashcode for the ShiftAssignment which includes its children
     * This is used primarily by Shift Swap code to see if a swapped shift has been modified
     * See com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil.getHashCode(ShiftAssignment)
     * Will only consider portions within the start/end time
     **/
    public static int getShiftAssignmentHashCodeExtendedInRange(ShiftAssignment sa, Date start, Date end) {
<span class="nc" id="L2569">        int hashCode = hashCodeExtendedInRange(sa, start, end);</span>
<span class="nc" id="L2570">        Collection&lt;ShiftEventAssignment&gt; shiftEventAssignments = sa.getChildren();</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">        for (ShiftEventAssignment sea : shiftEventAssignments) {</span>
<span class="nc" id="L2572">            Date startTime = sea.getStartTime();</span>
<span class="nc" id="L2573">            Date endTime = sea.getEndTime();</span>
<span class="nc bnc" id="L2574" title="All 8 branches missed.">            if (endTime.before(start) || endTime.equals(start) || startTime.after(end) || startTime.equals(end)) {</span>
<span class="nc" id="L2575">                continue;</span>
            }
<span class="nc bnc" id="L2577" title="All 2 branches missed.">            if (startTime.before(start)) {</span>
<span class="nc" id="L2578">                startTime = start;</span>
            }
<span class="nc bnc" id="L2580" title="All 2 branches missed.">            if (endTime.after(end)) {</span>
<span class="nc" id="L2581">                endTime = end;</span>
            }

<span class="nc" id="L2584">            int h = 0;</span>
<span class="nc bnc" id="L2585" title="All 2 branches missed.">            if (sea.getActivityID() != null) {</span>
<span class="nc" id="L2586">                h = sea.getActivityID().hashCode();</span>
            }
            // minutes
<span class="nc" id="L2589">            long duration = (endTime.getTime() - startTime.getTime()) / 60000;</span>
<span class="nc" id="L2590">            h ^= startTime.hashCode();</span>
<span class="nc" id="L2591">            h ^= duration;</span>
<span class="nc" id="L2592">            hashCode ^= h;</span>
<span class="nc" id="L2593">        }</span>
<span class="nc" id="L2594">        return hashCode;</span>
    }


    public static int hashCodeExtendedInRange(ShiftAssignment sa, Date start, Date end) {
<span class="nc" id="L2599">        Date dtStartTime = sa.getStartTime();</span>
<span class="nc" id="L2600">        Date dtEndTime = sa.getEndTime();</span>

<span class="nc bnc" id="L2602" title="All 4 branches missed.">        if (dtStartTime == null || dtStartTime.before(start)) {</span>
<span class="nc" id="L2603">            dtStartTime = start;</span>
        }
<span class="nc bnc" id="L2605" title="All 4 branches missed.">        if (dtEndTime == null || dtEndTime.after(end)) {</span>
<span class="nc" id="L2606">            dtEndTime = end;</span>
        }

<span class="nc" id="L2609">        int hash = dtStartTime.hashCode();</span>
<span class="nc" id="L2610">        hash ^= dtEndTime.hashCode();</span>
<span class="nc bnc" id="L2611" title="All 2 branches missed.">        for (Iterator&lt;ID&gt; it = sa.getWorkResourceIDs().iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2612">            hash ^= it.next().hashCode();</span>
        }
<span class="nc" id="L2614">        return hash;</span>

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>