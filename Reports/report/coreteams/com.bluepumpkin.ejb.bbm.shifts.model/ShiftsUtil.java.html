<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftsUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.shifts.model</a> &gt; <span class="el_source">ShiftsUtil.java</span></div><h1>ShiftsUtil.java</h1><pre class="source lang-java linenums">/*
 * (c) 2001-2012 Verint Systems, Inc.
 */

package com.bluepumpkin.ejb.bbm.shifts.model;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.ImmutablePair;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeOfDay;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.config.model.Config;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceComplexWorkRule;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceMinMaxHour;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceMonthlyMinMaxHour;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceRotation;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPattern;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.vo.HOOPeriod;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workrules.model.Alert;
import com.bluepumpkin.ejb.bbm.workrules.model.CommonConflict;
import com.bluepumpkin.ejb.bbm.workrules.model.ComplexWorkRule;
import com.bluepumpkin.ejb.bbm.workrules.model.Rotation;
import com.bluepumpkin.ejb.bbm.workrules.model.Shift;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftEvent;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftOTExtension;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.ejb.bbm.workrules.model.TimeSpan;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRule;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleException;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleUtil;

/**
 * A utility class containing methods for handling Shift conflicts.
 *
 * AJP: Why would a utility class with all static methods be Serializable?
 * TODO: Rename to ShiftConflictsUtil, to distinguish from the other Shift util classes.
 */
<span class="nc" id="L71">public class ShiftsUtil implements java.io.Serializable {</span>

	/**
	 *
	 */
	private static final long serialVersionUID = 1L;
	private static final float MILLIS_IN_DAY = 86400000f;
	private static final int DAYS_IN_WEEK = 7;
	private static final int MINUTES_IN_HOUR = 60;
	private static final int SIXTY_THOUSAND = 60000;

<span class="nc" id="L82">	public static final ID NONE_ACTIVITY = new ID(-4001);</span>

	public static Collection&lt;ShiftsConflict&gt; getShiftStartTimeConflicts(Collection&lt;? extends Event&gt; cEvents,
			Map&lt;ID, Shift&gt; hShifts, Date dtStart, Date dtEnd, Map&lt;ID, Organization&gt; hOrgs, TimeZone campaignTZ) {
<span class="nc" id="L86">		List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L87">		ShiftAssignment shiftAssignment = null;</span>
<span class="nc" id="L88">		Calendar cCalendar = Calendar.getInstance();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if (campaignTZ != null) {</span>
<span class="nc" id="L90">			cCalendar.setTimeZone(campaignTZ);</span>
		}
<span class="nc bnc" id="L92" title="All 2 branches missed.">		for (Iterator&lt;? extends Event&gt; i = cEvents.iterator(); i.hasNext();) {</span>

<span class="nc" id="L94">			Event pEvent = i.next();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">					&amp;&amp; WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc" id="L97">				shiftAssignment = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L98">				ID idShift = shiftAssignment.getShiftID();</span>
<span class="nc" id="L99">				Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">				if (pShift == null) {</span>
<span class="nc" id="L101">					continue;</span>
				}
<span class="nc" id="L103">				TimeZone tz = campaignTZ;</span>
<span class="nc" id="L104">				Organization pOrg = null;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">				if (pShift.getOrganizationID() != null) {</span>
<span class="nc" id="L106">					pOrg = hOrgs.get(pShift.getOrganizationID());</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">					tz = pOrg != null ? pOrg.getTimeZone() : campaignTZ;</span>
				}
<span class="nc" id="L109">				cCalendar.setTimeZone(tz);</span>
<span class="nc" id="L110">				cCalendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L111">				TimeOfDay tShiftStart = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY),</span>
<span class="nc" id="L112">						cCalendar.get(Calendar.MINUTE));</span>

<span class="nc" id="L114">				cCalendar.setTime(pEvent.getEndTime());</span>
<span class="nc" id="L115">				TimeOfDay tShiftEnd = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY),</span>
<span class="nc" id="L116">						cCalendar.get(Calendar.MINUTE));</span>
				// check cross org boundary
<span class="nc bnc" id="L118" title="All 4 branches missed.">				if (pOrg != null &amp;&amp; !pOrg.canCrossDayBoundary()) {</span>
<span class="nc" id="L119">					TimeOfDay tDayBoundary = new TimeOfDay(pOrg.getDayBoundaryOffset());</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">					if (tDayBoundary.intersects(tShiftStart, tShiftEnd)) {</span>
<span class="nc" id="L121">						ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_CROSSORGDAY, &quot;&quot;,</span>
<span class="nc" id="L122">								pEvent.getStartTime());</span>
<span class="nc" id="L123">						llNewConflicts.add(cConflict);</span>
					}
				}
				// check shift starts, have to consider ot before case
<span class="nc" id="L127">				tShiftStart = getRealShiftStartInHourAndMinute(shiftAssignment, cCalendar);</span>
				// consider day boundary offset
<span class="nc bnc" id="L129" title="All 4 branches missed.">				if (pOrg != null &amp;&amp; pOrg.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L130">					tShiftStart = tShiftStart.addMinutes(-pOrg.getDayBoundaryOffset());</span>
				}

<span class="nc bnc" id="L133" title="All 4 branches missed.">				if (pShift.getStartTimes() != null &amp;&amp; !pShift.getStartTimes().contains(tShiftStart)) {</span>
					// found a start time conflict...
<span class="nc" id="L135">					ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_STARTTIME, pShift.getName(),</span>
<span class="nc" id="L136">							pEvent.getStartTime());</span>
<span class="nc" id="L137">					llNewConflicts.add(cConflict);</span>
				}
			}
<span class="nc" id="L140">		}</span>

<span class="nc" id="L142">		return llNewConflicts;</span>
	}

<span class="nc" id="L145">	static class StartTimeComparator implements Comparator&lt;Event&gt; {</span>
		@Override
		public int compare(Event o1, Event o2) {
<span class="nc" id="L148">			return o1.getStartTime().compareTo(o2.getStartTime());</span>
		}
	}
	
	private static boolean isPaddingEvent(ShiftAssignment shift, ShiftEventAssignment event) {
<span class="nc bnc" id="L153" title="All 2 branches missed.">		if (event.getActivityID().equals(NONE_ACTIVITY)) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">			if (shift.getStartTime().equals(event.getStartTime()) ||</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">					shift.getEndTime().equals(event.getEndTime())) {</span>
<span class="nc" id="L156">				return true;</span>
			}
		}
<span class="nc" id="L159">		return false;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getShiftEventSpacingConflicts(Collection&lt;? extends Event&gt; cEvents,
			Map&lt;ID, Shift&gt; hShifts, Date dtStart, Date dtEnd, Map&lt;ID, Activity&gt; activityMap) {
<span class="nc" id="L164">		List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">		for (Event pEvent : cEvents) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT </span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">					&amp;&amp; WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc" id="L169">				ShiftAssignment shift = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L170">				ID idShift = shift.getShiftID();</span>
<span class="nc" id="L171">				Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">				if (pShift == null) {</span>
<span class="nc" id="L173">					continue;</span>
				}

<span class="nc" id="L176">				List&lt;ShiftEventAssignment&gt; aShiftEvents = new ArrayList&lt;&gt;(shift.getChildren());</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">				if (aShiftEvents.isEmpty()) {</span>
<span class="nc" id="L178">					continue;</span>
				}

<span class="nc" id="L181">				long lMinSpacing = pShift.getMinSpacing() * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>
<span class="nc" id="L182">				long lMaxSpacing = pShift.getMaxSpacing() * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>

				// this is quite inefficient
<span class="nc" id="L185">				Collections.sort(aShiftEvents, new StartTimeComparator());</span>

<span class="nc" id="L187">				boolean isFirstShiftEvent = true;</span>
<span class="nc" id="L188">				Date dtPreviousEnd = null;</span>
<span class="nc" id="L189">				Event pPreviousEvent = null;</span>
<span class="nc" id="L190">				ShiftEventAssignment pShiftEvent = null;</span>
<span class="nc" id="L191">				ArrayList&lt;ID&gt; minSpacingConflictEventIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L192">				ArrayList&lt;ID&gt; maxSpacingConflictEventIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">				for (Iterator&lt;ShiftEventAssignment&gt; j = aShiftEvents.iterator(); j.hasNext();) {</span>
					// note assuming shift events are ordered by start time
<span class="nc" id="L195">					pShiftEvent = j.next();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">					if (pShiftEvent.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">							|| pShiftEvent.getShiftEventID() == null </span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">							|| isWorkType(pShiftEvent, activityMap)</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">							|| isPaddingEvent(shift, pShiftEvent)) {</span>
<span class="nc" id="L200">						continue;</span>
					}
<span class="nc bnc" id="L202" title="All 2 branches missed.">					if (isFirstShiftEvent) {</span>

<span class="nc" id="L204">						long lSpacing = pShiftEvent.getStartTime().getTime() - pEvent.getStartTime().getTime();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">						if (isViolatingMinSpacing(lMinSpacing, lSpacing)) {</span>
							// found a min spacing conflict...
<span class="nc" id="L207">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L208">									(double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L209">							llNewConflicts.add(cConflict);</span>
						}

<span class="nc" id="L212">						isFirstShiftEvent = false;</span>
<span class="nc" id="L213">						pPreviousEvent = pShiftEvent;</span>
<span class="nc" id="L214">						dtPreviousEnd = pShiftEvent.getEndTime();</span>
<span class="nc" id="L215">						continue; // first event has no min space problem.</span>
					}
<span class="nc" id="L217">					long lSpacing = pShiftEvent.getStartTime().getTime() - dtPreviousEnd.getTime();</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">					if (isViolatingMinSpacing(lMinSpacing, lSpacing)) {</span>
						// found a min spacing conflict...
<span class="nc bnc" id="L220" title="All 4 branches missed.">						if (pPreviousEvent != null &amp;&amp; !minSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L221">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L222">									(double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pPreviousEvent.getStartTime());</span>
<span class="nc" id="L223">							minSpacingConflictEventIDs.add(pPreviousEvent.getID());</span>
<span class="nc" id="L224">							llNewConflicts.add(cConflict);</span>
						}

<span class="nc" id="L227">						ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L228">								(double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L229">						llNewConflicts.add(cConflict);</span>
<span class="nc" id="L230">						minSpacingConflictEventIDs.add(pShiftEvent.getID());</span>
					}
<span class="nc bnc" id="L232" title="All 4 branches missed.">					if (lMaxSpacing &gt; 0 &amp;&amp; lSpacing &gt; lMaxSpacing) {</span>
						// found a max spacing conflict...
<span class="nc bnc" id="L234" title="All 4 branches missed.">						if (pPreviousEvent != null &amp;&amp; !maxSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L235">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MAXSPACING,</span>
<span class="nc" id="L236">									(double) lMaxSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pPreviousEvent.getStartTime());</span>
<span class="nc" id="L237">							maxSpacingConflictEventIDs.add(pPreviousEvent.getID());</span>
<span class="nc" id="L238">							llNewConflicts.add(cConflict);</span>
						}
<span class="nc" id="L240">						ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MAXSPACING,</span>
<span class="nc" id="L241">								(double) lMaxSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L242">						llNewConflicts.add(cConflict);</span>
<span class="nc" id="L243">						maxSpacingConflictEventIDs.add(pShiftEvent.getID());</span>
					}
<span class="nc" id="L245">					pPreviousEvent = pShiftEvent;</span>
<span class="nc" id="L246">					dtPreviousEnd = pShiftEvent.getEndTime();</span>
<span class="nc" id="L247">				}</span>
				// check for spacing conflict at the end of the shift
<span class="nc bnc" id="L249" title="All 2 branches missed.">				if (dtPreviousEnd != null) {</span>
<span class="nc" id="L250">					long lSpacing = pEvent.getEndTime().getTime() - dtPreviousEnd.getTime();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">					if (isViolatingMinSpacing(lMinSpacing, lSpacing)) {</span>
						// found a min spacing conflict...
<span class="nc bnc" id="L253" title="All 2 branches missed.">						if (!minSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L254">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MINSPACING,</span>
<span class="nc" id="L255">									(double) lMinSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L256">							llNewConflicts.add(cConflict);</span>
						}
					}

<span class="nc bnc" id="L260" title="All 6 branches missed.">					if (lSpacing &gt; 0 &amp;&amp; lMaxSpacing &gt; 0 &amp;&amp; lSpacing &gt; lMaxSpacing) {</span>
						// found a max spacing conflict...
<span class="nc bnc" id="L262" title="All 2 branches missed.">						if (!maxSpacingConflictEventIDs.contains(pPreviousEvent.getID())) {</span>
<span class="nc" id="L263">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_MAXSPACING,</span>
<span class="nc" id="L264">									(double) lMaxSpacing / TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG, pShiftEvent.getStartTime());</span>
<span class="nc" id="L265">							llNewConflicts.add(cConflict);</span>
						}
					}
				}
			}
<span class="nc" id="L270">		}</span>

<span class="nc" id="L272">		return llNewConflicts;</span>
	}

	static boolean isViolatingMinSpacing(long lMinSpacing, long lSpacing) {
<span class="nc bnc" id="L276" title="All 4 branches missed.">		return lMinSpacing &gt; 0 &amp;&amp; lSpacing &lt; lMinSpacing;</span>
	}

	private static boolean isWorkType(ShiftEventAssignment shiftEvent, Map&lt;ID, Activity&gt; activityMap) {
<span class="nc" id="L280">		boolean isWorkType = false;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">		Activity activity = activityMap == null ? null : activityMap.get(shiftEvent.getActivityID());</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">		if (activity != null &amp;&amp; activity.isUsedInShift()) {</span>
<span class="nc" id="L283">			isWorkType = true;</span>
		}
<span class="nc" id="L285">		return isWorkType;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getShiftEventStartTimeConflicts(Collection&lt;? extends Event&gt; cEvents,
			Map&lt;ID, Shift&gt; hShifts, Map&lt;ID, Organization&gt; hOrgs, Date dtStart, Date dtEnd, TimeZone campaignTZ) {
<span class="nc" id="L290">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc" id="L292">		ShiftAssignment shiftAssignment = null;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">		for (Event pEvent : cEvents) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L296">					shiftAssignment = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L297">					ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc" id="L298">					Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">					if (pShift == null) {</span>
<span class="nc" id="L300">						continue;</span>
					}

<span class="nc" id="L303">					Collection cShiftActivities = pShift.getShiftEvents();</span>

<span class="nc" id="L305">					int orgDayBoundary = 0;</span>
<span class="nc" id="L306">					ID idOrganization = pShift.getOrganizationID();</span>
<span class="nc" id="L307">					Calendar cCalendar = Calendar.getInstance();</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">					if (idOrganization != null) {</span>
<span class="nc" id="L309">						Organization pOrg = hOrgs.get(idOrganization);</span>
<span class="nc" id="L310">						orgDayBoundary = pOrg.getDayBoundaryOffset();</span>
<span class="nc" id="L311">						cCalendar.setTimeZone(pOrg.getTimeZone());</span>
<span class="nc" id="L312">					} else {</span>
<span class="nc" id="L313">						cCalendar.setTimeZone(campaignTZ);</span>
					}

<span class="nc" id="L316">					HashMap&lt;ID, ShiftEvent&gt; hShiftActivities = new HashMap&lt;ID, ShiftEvent&gt;();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">					for (Iterator j = cShiftActivities.iterator(); j.hasNext();) {</span>
<span class="nc" id="L318">						ShiftEvent pShiftActivity = (ShiftEvent) j.next();</span>
<span class="nc" id="L319">						hShiftActivities.put(pShiftActivity.getID(), pShiftActivity);</span>
<span class="nc" id="L320">					}</span>

<span class="nc" id="L322">					Collection cShiftEvents = pEvent.getChildren();</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">					for (Iterator j = cShiftEvents.iterator(); j.hasNext();) {</span>
<span class="nc" id="L324">						Event pSEvent = (Event) j.next();</span>
<span class="nc" id="L325">						ShiftEventAssignment pSEA = (ShiftEventAssignment) pSEvent;</span>
<span class="nc" id="L326">						ShiftEvent pShiftEvent = hShiftActivities.get(pSEA.getShiftEventID());</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">						if (pShiftEvent != null) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">							if (pShiftEvent.isAnyTime()) {</span>
<span class="nc" id="L329">								continue;</span>
							}

<span class="nc" id="L332">							long lOffset = pSEvent.getStartTime().getTime() - pEvent.getStartTime().getTime();</span>
<span class="nc" id="L333">							lOffset /= TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>
							// check shift starts, have to consider ot before
							// case
<span class="nc bnc" id="L336" title="All 2 branches missed.">							if (shiftAssignment.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L337">								lOffset -= shiftAssignment.getExtensionBefore();</span>
							}

<span class="nc bnc" id="L340" title="All 2 branches missed.">							if (pShiftEvent.isCafeteria()) {</span>
<span class="nc" id="L341">								cCalendar.setTime(pSEvent.getStartTime());</span>
<span class="nc" id="L342">								lOffset = cCalendar.get(Calendar.HOUR_OF_DAY) * 60 + cCalendar.get(Calendar.MINUTE);</span>
								// even for absolute start time, the start/end minutes consider the day
								// boundary offset before storing them in db. here, we have to take it out. QC98032
<span class="nc" id="L345">								lOffset -= orgDayBoundary; </span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">								if (lOffset &lt; 0 ) {</span>
									//shift event crossing day
<span class="nc" id="L348">									lOffset += TimeZoneUtil.DAY_IN_MINUTES;</span>
								}
							}
<span class="nc bnc" id="L351" title="All 4 branches missed.">							if (lOffset &lt; pShiftEvent.getStart() || lOffset &gt; pShiftEvent.getEnd()) {</span>
								// 15 minutes tolerance: durtion + diff &lt;= 15,
								// not consider as conflict
<span class="nc" id="L354">								if (Math.min(Math.abs(lOffset - pShiftEvent.getStart()),</span>
<span class="nc" id="L355">										Math.abs(lOffset - pShiftEvent.getEnd()))</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">										+ pSEvent.getDuration() &gt; 15) {</span>
									// found a st conflict...
<span class="nc" id="L358">									ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_STARTTIME,</span>
<span class="nc" id="L359">											pShiftEvent.getName(), pSEvent.getStartTime());</span>
<span class="nc" id="L360">									llNewConflicts.add(cConflict);</span>
								}
							}
						}
<span class="nc" id="L364">					}</span>
				}
			}
<span class="nc" id="L367">		}</span>

<span class="nc" id="L369">		return llNewConflicts;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getHOOConflicts(Collection&lt;? extends Event&gt; cEvents, HOOPeriod pHoo,
			Date dtStart, Date dtEnd, boolean bOrg, Organization org) {

<span class="nc" id="L375">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">		if (pHoo == null) {</span>
<span class="nc" id="L377">			return llNewConflicts;</span>
		}

<span class="nc" id="L380">		int eType = ShiftsConflict.CAMPAIGN_HOO;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">		if (bOrg) {</span>
<span class="nc" id="L382">			eType = ShiftsConflict.ORG_HOO;</span>
		}
<span class="nc" id="L384">		Collection pClosedTimes = pHoo.getClosePeriods(dtStart, dtEnd);</span>

<span class="nc bnc" id="L386" title="All 2 branches missed.">		for (Event pEvent : cEvents) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">			for (Iterator j = pClosedTimes.iterator(); j.hasNext();) {</span>
<span class="nc" id="L388">				TimePeriod pClosed = (TimePeriod) j.next();</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">					if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>

<span class="nc bnc" id="L392" title="All 2 branches missed.">						if (pEvent.getStartTime().before(pClosed.getEndTime())</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">								&amp;&amp; pEvent.getEndTime().after(pClosed.getStartTime())) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">							if (!bOrg) {</span>
<span class="nc" id="L395">								ShiftsConflict cConflict = new ShiftsConflict(eType, null, pEvent.getStartTime());</span>
<span class="nc" id="L396">								llNewConflicts.add(cConflict);</span>
<span class="nc" id="L397">							} else {</span>
								// need org name for conflict message
<span class="nc" id="L399">								ShiftsConflict cConflict = new ShiftsConflict(eType, org.getName(),</span>
<span class="nc" id="L400">										pEvent.getStartTime());</span>
<span class="nc" id="L401">								llNewConflicts.add(cConflict);</span>
							}
<span class="nc" id="L403">							break;</span>
						}
					}
				}
<span class="nc" id="L407">			}</span>
<span class="nc" id="L408">		}</span>
<span class="nc" id="L409">		return llNewConflicts;</span>
	}

	/**
	 * @param cEvents
	 *            : collection of shift assignments for a single employee.
	 * @param nMinMinutes
	 *            : minimum # of minutes / week for the above employee.
	 * @param nMaxMinutes
	 *            : maximum # of minutes / week for the above employe.
	 * @param dtStart
	 *            : start of timeRange that includes all events in cEvents.
	 * @param dtEnd
	 *            : end of time range that includes all events in cEvents.
	 * @param pOrg
	 *            : organization the above employee belongs to.
	 *
	 */
<span class="nc" id="L427">	public final static ID VOLUNTARY_TIME_OFF = new ID(-4136);</span>

	/**
	 * Returns min/max hour conflicts
	 *
	 * @param cEvents
	 * @param nMinMinutes
	 * @param nMaxMinutes
	 * @param dtStart
	 * @param dtEnd
	 * @param pOrg
	 * @return
	 */
	public static Collection&lt;ShiftsConflict&gt; getMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents,
			int nMinMinutes, int nMaxMinutes, Date dtStart, Date dtEnd, Organization pOrg) {
<span class="nc" id="L442">		WorkResourceMinMaxHour minMax = new WorkResourceMinMaxHour();</span>
<span class="nc" id="L443">		minMax.setMinMinutes(nMinMinutes);</span>
<span class="nc" id="L444">		minMax.setMaxMinutes(nMaxMinutes);</span>
<span class="nc" id="L445">		return getMinMaxHourConflicts(cEvents, minMax, dtStart, dtEnd, pOrg, null);</span>
	}

	/**
	 * Return the min max conflicts for weekly and daily hours for agents. This method is used in request
	 * management code as well. This is a wrapper function which calls the main function always to run
	 * assuming weekly SP.
	 * @param cEvents
	 * @param minMax
	 * @param dtStart
	 * @param dtEnd
	 * @param pOrg
	 * @param shiftOTExtensions
	 * @return
	 */
	public static Collection&lt;ShiftsConflict&gt; getMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents,
			WorkResourceMinMaxHour minMax, Date dtStart, Date dtEnd, Organization pOrg, Map shiftOTExtensions) {
<span class="nc" id="L462">		Calendar endCal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L463">		endCal.setTime(dtEnd);</span>
<span class="nc" id="L464">		endCal.add(Calendar.SECOND, 1);</span>
<span class="nc" id="L465">		return getMinMaxHourConflicts(cEvents, minMax, dtStart, endCal.getTime(), pOrg, null, false);</span>
	}

	/**
	 * Generates conflicts for weekly and daily min/max hours including OT and VTO hours set for agents.
	 * Monthly SP also uses this code for daily min/max hour conflicts as well as
	 * weekly OT and VTO hours conflicts till we have a separate monthly OT/VTO hours defined.
	 * @param cEvents
	 * @param minMax
	 * @param dtStart
	 * @param dtEnd
	 * @param pOrg
	 * @param shiftOTExtensions
	 * @param isMonthlySP
	 * @return
	 */
	public static Collection&lt;ShiftsConflict&gt; getMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents,
			WorkResourceMinMaxHour minMax, Date dtStart, Date dtEnd, Organization pOrg, Map shiftOTExtensions, boolean isMonthlySP) {
<span class="nc" id="L483">		List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

		// lets create the periods...
<span class="nc" id="L486">		List&lt;TimeSpan&gt; llTimeSpans = getOrgWeeklyTimeSpans(dtStart, dtEnd, pOrg, false);</span>
<span class="nc" id="L487">		Calendar cOrgDay = Calendar.getInstance(pOrg.getTimeZone());</span>

		// for each org week during the timeRange which encompasses (dtStart,
		// dtEnd)
<span class="nc bnc" id="L491" title="All 2 branches missed.">		for (Iterator&lt;TimeSpan&gt; l = llTimeSpans.iterator(); l.hasNext();) {</span>
<span class="nc" id="L492">			TimeSpan pSpan = l.next();</span>
<span class="nc" id="L493">			Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; pair = getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, minMax, cOrgDay, shiftOTExtensions);</span>
<span class="nc" id="L494">			List&lt;ShiftsConflict&gt; dailyConflicts = pair.getFirst();</span>
<span class="nc" id="L495">			llNewConflicts.addAll(dailyConflicts);</span>

<span class="nc" id="L497">			long[] minuteArray = pair.getSecond();</span>
<span class="nc" id="L498">			long nMinutes = minuteArray[0];</span>

			// if weektotal violates min hours
<span class="nc" id="L501">			int nMinMinutes = minMax.getMinMinutes();</span>
<span class="nc bnc" id="L502" title="All 4 branches missed.">			if (nMinMinutes &gt; 0 &amp;&amp; nMinutes &lt; nMinMinutes) {</span>
<span class="nc" id="L503">				ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MIN_HOURS, nMinMinutes - nMinutes,</span>
						pSpan.dtSpanStart);
<span class="nc" id="L505">				cConflict.setDoubleTarget(nMinMinutes);</span>
<span class="nc" id="L506">				llNewConflicts.add(cConflict);</span>
			}
			// if weektotal violates max hours.
<span class="nc" id="L509">			int nMaxMinutes = minMax.getMaxMinutes();</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">			if (nMaxMinutes &gt; 0 &amp;&amp; nMinutes &gt; nMaxMinutes) {</span>
<span class="nc" id="L511">				ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MAX_HOURS, nMinutes - nMaxMinutes,</span>
						pSpan.dtSpanStart);
<span class="nc" id="L513">				cConflict.setDoubleTarget(nMaxMinutes);</span>
<span class="nc" id="L514">				llNewConflicts.add(cConflict);</span>
			}

			// check weekly OT
<span class="nc bnc" id="L518" title="All 2 branches missed.">			if (minuteArray[1] &gt; minMax.getMaxOTMinutesPerWeek()) {</span>
<span class="nc" id="L519">				ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_OT_WEEKLY,</span>
<span class="nc" id="L520">						minMax.getMaxOTMinutesPerWeek(), pSpan.dtSpanStart);</span>
<span class="nc" id="L521">				llNewConflicts.add(cConflict);</span>
			}
			// check weekly VTO
			// minMax.getMaxVTOHoursPerWeek() returns VTO minutes, not hours
<span class="nc bnc" id="L525" title="All 2 branches missed.">			if (minuteArray[2] &gt; minMax.getMaxVTOHoursPerWeek()) {</span>
<span class="nc" id="L526">				ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_VTO_WEEKLY,</span>
<span class="nc" id="L527">						minMax.getMaxVTOHoursPerWeek(), pSpan.dtSpanStart);</span>
<span class="nc" id="L528">				llNewConflicts.add(cConflict);</span>
			}
<span class="nc" id="L530">		}</span>
<span class="nc" id="L531">		return llNewConflicts;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getMonthlyMinMaxHourConflicts(Collection&lt;? extends Event&gt; cEvents,
			WorkResourceMonthlyMinMaxHour monthlyMinMax, Date dtStart, Date dtEnd, Organization pOrg, Map shiftOTExtensions) {
<span class="nc" id="L536">		List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

<span class="nc" id="L538">		Calendar cOrgDay = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L539">		TimeSpan pSpan = new TimeSpan(dtStart, dtEnd);</span>
<span class="nc" id="L540">		Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; pair = getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, null, cOrgDay, shiftOTExtensions);</span>

<span class="nc" id="L542">		long[] minuteArray = pair.getSecond();</span>
<span class="nc" id="L543">		long nMinutes = minuteArray[0];</span>

		// if month total violates min hours
<span class="nc bnc" id="L546" title="All 2 branches missed.">		int nMinMinutes = monthlyMinMax != null ? monthlyMinMax.getMinMinutes() : 0;</span>
<span class="nc bnc" id="L547" title="All 4 branches missed.">		if (nMinMinutes &gt; 0 &amp;&amp; nMinutes &lt; nMinMinutes) {</span>
<span class="nc" id="L548">			ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MONTHLY_MIN_HOURS, nMinMinutes - nMinutes,</span>
					pSpan.dtSpanStart);
<span class="nc" id="L550">			cConflict.setDoubleTarget(nMinMinutes);</span>
<span class="nc" id="L551">			llNewConflicts.add(cConflict);</span>
		}
		// if month total violates max hours.
<span class="nc bnc" id="L554" title="All 2 branches missed.">		int nMaxMinutes = monthlyMinMax != null ? monthlyMinMax.getMaxMinutes() : 0;</span>
<span class="nc bnc" id="L555" title="All 4 branches missed.">		if (nMaxMinutes &gt; 0 &amp;&amp; nMinutes &gt; nMaxMinutes) {</span>
<span class="nc" id="L556">			ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MONTHLY_MAX_HOURS, nMinutes - nMaxMinutes,</span>
					pSpan.dtSpanStart);
<span class="nc" id="L558">			cConflict.setDoubleTarget(nMaxMinutes);</span>
<span class="nc" id="L559">			llNewConflicts.add(cConflict);</span>
		}

<span class="nc" id="L562">		return llNewConflicts;</span>
	}

	/**
	 * Returns weekly time spans for each of org weeks ending in the period dtStart - dtEnd
	 *
	 * @param dtStart start of period
	 * @param dtEnd end of period
	 * @param pOrg organization
	 * @param includeOrgWeekPartiallyPresentInPeriod returns an extra last week even though the org week doesnt end during the period
	 * @return list of timespans
	 */
	public static List&lt;TimeSpan&gt; getOrgWeeklyTimeSpans(Date dtStart, Date dtEnd, Organization pOrg, boolean includeOrgWeekPartiallyPresentInPeriod) {
<span class="nc" id="L575">		List&lt;TimeSpan&gt; listTimeSpans = new LinkedList&lt;TimeSpan&gt;();</span>

<span class="nc" id="L577">		Calendar cal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L578">		cal.setTime(dtStart);</span>
<span class="nc" id="L579">		cal.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / MINUTES_IN_HOUR);</span>
<span class="nc" id="L580">		cal.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % MINUTES_IN_HOUR);</span>
<span class="nc" id="L581">		cal.set(Calendar.SECOND, 0);</span>

		//first find the start of the org week which is ending in the current sp week
		while (true) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">			if (cal.get(Calendar.DAY_OF_WEEK) == pOrg.getWeekStartDate()) {</span>
<span class="nc" id="L586">				break;</span>
			}
<span class="nc" id="L588">			cal.add(Calendar.DATE, -1);</span>
		}

<span class="nc" id="L591">		Date startOrgWeek = cal.getTime();</span>
<span class="nc" id="L592">		cal.add(Calendar.DATE, DAYS_IN_WEEK);</span>
<span class="nc" id="L593">		Date endOrgWeek = cal.getTime();</span>


		//now loop through the entire sp to find out all the org weeks ending in the period
		//Note: we will never enter this if org week end is same or greater to dtEnd! See below for fix
<span class="nc bnc" id="L598" title="All 2 branches missed.">		while (!endOrgWeek.after(dtEnd)) {</span>
<span class="nc" id="L599">			listTimeSpans.add(new TimeSpan(startOrgWeek, endOrgWeek));</span>
<span class="nc" id="L600">			startOrgWeek = endOrgWeek;</span>
<span class="nc" id="L601">			cal.add(Calendar.DATE, DAYS_IN_WEEK);</span>
<span class="nc" id="L602">			endOrgWeek = cal.getTime();</span>

		}
		// add last org week if required
		// OR If org week start/end align with request start/end, then we never
		// return anything. To prevent this error, if we are empty, we will
		// add the start end time period.
<span class="nc bnc" id="L609" title="All 6 branches missed.">		if ((includeOrgWeekPartiallyPresentInPeriod || listTimeSpans.isEmpty()) &amp;&amp; startOrgWeek.before(dtEnd)) {</span>
		   // if ((includeOrgWeekPartiallyPresentInPeriod) &amp;&amp; start.before(dtEnd)) {
<span class="nc" id="L611">			listTimeSpans.add(new TimeSpan(startOrgWeek, endOrgWeek));</span>
		}
<span class="nc" id="L613">		return listTimeSpans;</span>
	}

	/**
	 * @param cEvents
	 * @param pSpan
	 * @param cOrgDay
	 * @param shiftOTExtensions
	 * @return [0] The weekly scheduled minutes. [1] The weekly OT minutes. [2]
	 *         The weekly VTO minutes.
	 */
	public static long[] getWeeklyMinutes(Collection&lt;? extends Event&gt; cEvents, TimeSpan pSpan, Calendar cOrgDay,
			Map shiftOTExtensions) {
<span class="nc" id="L626">		Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; pair = getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, null, cOrgDay, shiftOTExtensions);</span>
<span class="nc" id="L627">		return pair.getSecond();</span>
	}

	public static Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; getWeeklyMinutesAndDailyConflicts(Collection&lt;? extends Event&gt; cEvents, TimeSpan pSpan,
			WorkResourceMinMaxHour minMax, Calendar cOrgDay, Map shiftOTExtensions) {
<span class="nc bnc" id="L632" title="All 2 branches missed.">		if (minMax != null) {</span>
<span class="nc" id="L633">			return getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, cOrgDay, shiftOTExtensions, minMax.getMaxOTMinutesPerDay(), minMax.getMaxVTOHoursPerDay());</span>
		} else {
<span class="nc" id="L635">			return getWeeklyMinutesAndDailyConflicts(cEvents, pSpan, cOrgDay, shiftOTExtensions, -1, -1);</span>
		}
	}

	/**
	 * @param cEvents
	 * @param pSpan
	 * @param cOrgDay
	 * @param shiftOTExtensions
	 * @param maxOTMinutesPerDay value of maxOTMinutesPerDay for employee or -1 for NA
	 * @param maxVTOHoursPerDay value of maxVTOHourPerDay for employee or -1 for NA
	 * @return Pair(LinkedList&lt;ShiftsConflict&gt; dailyConflicts, long[]: [0] The
	 *         weekly scheduled minutes. [1] The weekly OT minutes. [2] The
	 *         weekly VTO minutes.
	 */
	
	
			
	public static Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt; getWeeklyMinutesAndDailyConflicts(Collection&lt;? extends Event&gt; cEvents, TimeSpan pSpan,
			Calendar cOrgDay, Map shiftOTExtensions, int maxOTMinutesPerDay, int maxVTOHoursPerDay) {
<span class="nc" id="L655">		List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L656">		Map&lt;Integer, Integer&gt; hmDailyVTO = new HashMap&lt;Integer, Integer&gt;();</span>
	
<span class="nc" id="L658">		long nMinutes = 0;</span>
<span class="nc" id="L659">		int weeklyOTMinutes = 0;</span>
<span class="nc" id="L660">		int weeklyVTOMinutes = 0;</span>

<span class="nc bnc" id="L662" title="All 4 branches missed.">		if (cEvents == null || cEvents.isEmpty()) {</span>
<span class="nc" id="L663">			long[] returnValue = new long[3];</span>
<span class="nc" id="L664">			returnValue[0] = nMinutes;</span>
<span class="nc" id="L665">			returnValue[1] = weeklyOTMinutes;</span>
<span class="nc" id="L666">			returnValue[2] = weeklyVTOMinutes;</span>
<span class="nc" id="L667">			return new Pair&lt;List&lt;ShiftsConflict&gt;, long[]&gt;(llNewConflicts, returnValue);</span>
		}

		// iterate through shift assignments first time to see if any are just
		// being requested
<span class="nc" id="L672">		boolean hasRequestedShift = false;</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">		for (Event pEvent : cEvents) {</span>
			// if shift assignments starts in this org week.
<span class="nc bnc" id="L675" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, pSpan.dtSpanStart, pSpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L677">					ShiftAssignment shiftEvent = (ShiftAssignment) pEvent;</span>
					// The flag !VALIDATION_CHECK is set at OrgWeekValiationRule.java
<span class="nc bnc" id="L679" title="All 2 branches missed.">					boolean isRequestedShift = shiftEvent.getDescription() != null</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">							&amp;&amp; (shiftEvent.getDescription().indexOf(&quot;!VALIDATION_CHECK&quot;) &gt; -1);</span>

<span class="nc bnc" id="L682" title="All 2 branches missed.">					if (isRequestedShift) {</span>
<span class="nc" id="L683">						hasRequestedShift = true;</span>
<span class="nc" id="L684">						break;</span>
					}
				}
			}
<span class="nc" id="L688">		}</span>

		// iterate thru' shift assignments
<span class="nc bnc" id="L691" title="All 2 branches missed.">		for (Event pEvent : cEvents) {</span>
			// if shift assignments starts in this org week.
<span class="nc bnc" id="L693" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L694">				ShiftAssignment shiftEvent = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L695">				Date startTime = shiftEvent.getStartTime();</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">				if (shiftEvent.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L697">					Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L698">					cal.setTime(startTime);</span>
<span class="nc" id="L699">					cal.add(Calendar.MINUTE, shiftEvent.getExtensionBefore());</span>
<span class="nc" id="L700">					startTime = cal.getTime();</span>
				}
<span class="nc bnc" id="L702" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriod(startTime, shiftEvent.getEndTime(), pSpan.dtSpanStart, pSpan.dtSpanEnd,</span>
						Config.STARTSIN)) {
<span class="nc bnc" id="L704" title="All 2 branches missed.">					boolean isOTShift = shiftEvent.getDuration() == shiftEvent.getExtensionAfter();</span>
					// The flag !VALIDATION_CHECK is set at OrgWeekValiationRule.java
<span class="nc bnc" id="L706" title="All 2 branches missed.">					boolean isRequestedShift = shiftEvent.getDescription() != null</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">							&amp;&amp; (shiftEvent.getDescription().indexOf(&quot;!VALIDATION_CHECK&quot;) &gt; -1);</span>
<span class="nc" id="L708">					int dailyOTMinutes = 0;</span>
<span class="nc" id="L709">					int dailyShiftMinutes = 0;</span>

					// compute the duration for the shift assignment
<span class="nc" id="L712">					dailyShiftMinutes += pEvent.getDuration();</span>
<span class="nc" id="L713">					Collection&lt;ShiftEventAssignment&gt; cShiftEvents = shiftEvent.getChildren();</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">					for (Iterator&lt;ShiftEventAssignment&gt; j = cShiftEvents.iterator(); j.hasNext();) {</span>
<span class="nc" id="L715">						ShiftEventAssignment pSEvent = j.next();</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">						if (!isEventSameAsShiftAssignment(pSEvent, shiftEvent)) {</span>
							// make sure we're not looking at the shiftAssignment,
							// which is always paid
<span class="nc bnc" id="L719" title="All 4 branches missed.">							if (pSEvent.getOverTimeGapType() == 1 || pSEvent.getOverTimeGapType() == 2</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">									|| pSEvent.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)) {</span>
<span class="nc" id="L721">								dailyShiftMinutes -= pSEvent.getDuration();</span>
<span class="nc" id="L722">								continue;</span>
								// gap events are not counted as paid
								// minutes for the conflict check
							}

<span class="nc bnc" id="L727" title="All 4 branches missed.">							if (EventUtils.isOT(pSEvent) || isOTShiftEvent(shiftEvent, pSEvent)) {</span>
<span class="nc" id="L728">								continue; // will deal with OT events in the</span>
											// Daily OT Check section, below.
							}

<span class="nc bnc" id="L732" title="All 2 branches missed.">							if (!pSEvent.getPaid()) {</span>
<span class="nc" id="L733">								dailyShiftMinutes -= pSEvent.getDuration();</span>
							}
						}
<span class="nc" id="L736">					}</span>

<span class="nc bnc" id="L738" title="All 2 branches missed.">					if (isOTShift) {</span>
<span class="nc" id="L739">						dailyOTMinutes = dailyShiftMinutes;</span>
					} else {
<span class="nc" id="L741">						nMinutes += dailyShiftMinutes;</span>

						// Daily OT Check
<span class="nc" id="L744">						ID extensionID = null;</span>

<span class="nc bnc" id="L746" title="All 2 branches missed.">						if (shiftEvent.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L747">							dailyOTMinutes += shiftEvent.getExtensionBefore(); // overwrites</span>
						} else {
<span class="nc" id="L749">							extensionID = shiftEvent.getOTExtensionBeforeID();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">							if (extensionID != null) {</span>
<span class="nc" id="L751">								dailyOTMinutes += ((ShiftOTExtension) shiftOTExtensions.get(extensionID)).getDuration();</span>
							}
						}
<span class="nc bnc" id="L754" title="All 2 branches missed.">						if (shiftEvent.getExtensionAfter() &gt; 0) {</span>
<span class="nc" id="L755">							dailyOTMinutes += shiftEvent.getExtensionAfter(); // overwrites</span>
						} else {
<span class="nc" id="L757">							extensionID = shiftEvent.getOTExtensionAfterID();</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">							if (extensionID != null) {</span>
<span class="nc" id="L759">								dailyOTMinutes += ((ShiftOTExtension) shiftOTExtensions.get(extensionID)).getDuration();</span>
							}
						}

						// take out gap from ot minutes
<span class="nc" id="L764">						Collection events = shiftEvent.getChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT);</span>
<span class="nc" id="L765">						ShiftEventAssignment event = null;</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">						for (Iterator iInner = events.iterator(); iInner.hasNext();) {</span>
<span class="nc" id="L767">							event = (ShiftEventAssignment) iInner.next();</span>
<span class="nc bnc" id="L768" title="All 4 branches missed.">							if (isOTShiftEvent(shiftEvent, event) &amp;&amp; !event.getPaid() ||</span>
<span class="nc bnc" id="L769" title="All 4 branches missed.">									(event.getOverTimeGapType() == 1 || event.getOverTimeGapType() == 2) ||</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">									(event.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP) &amp;&amp;</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">											event.getOverTimeGapType() != 0)) {</span>
								// QC 144403: The gap of Extension-Not OT
								// extension( has TimeGap Type =0) was
								// counted in dailyShiftMinutes then
								// nMinutes already, 735,737,758
								// So it should not count one more time for
								// dailyOTMinutes since it will calculated
								// in nMinutes at line 794 nMinutes -=
								// dailyOTMinutes; one more time
<span class="nc" id="L780">								dailyOTMinutes -= event.getDuration();</span>
							}
						}
<span class="nc" id="L783">						nMinutes -= dailyOTMinutes;</span>
					}

<span class="nc" id="L786">					weeklyOTMinutes += dailyOTMinutes;</span>

<span class="nc bnc" id="L788" title="All 8 branches missed.">					if (maxOTMinutesPerDay != -1 &amp;&amp; dailyOTMinutes &gt; maxOTMinutesPerDay</span>
							&amp;&amp; (!hasRequestedShift || isRequestedShift)) {
<span class="nc" id="L790">						ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_OT_DAILY,</span>
<span class="nc" id="L791">								maxOTMinutesPerDay, pEvent.getStartTime());</span>
<span class="nc" id="L792">						llNewConflicts.add(cConflict);</span>
					}
				}
			}
<span class="nc bnc" id="L796" title="All 4 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_OFF &amp;&amp; pEvent.getActivityID().equals(VOLUNTARY_TIME_OFF)) {</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriodAndApproved(pEvent, pSpan.dtSpanStart, pSpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc" id="L798">					cOrgDay.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L799">					int nDay = cOrgDay.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L800">					Integer intDailyVTOMinutes = hmDailyVTO.get(new Integer(nDay));</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">					if (intDailyVTOMinutes == null) {</span>
<span class="nc" id="L802">						hmDailyVTO.put(new Integer(nDay), new Integer(0));</span>
<span class="nc" id="L803">						intDailyVTOMinutes = hmDailyVTO.get(new Integer(nDay));</span>
					}

<span class="nc bnc" id="L806" title="All 2 branches missed.">					if (intDailyVTOMinutes != -1) {</span>
<span class="nc" id="L807">						intDailyVTOMinutes += pEvent.getDuration();</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">						if (maxVTOHoursPerDay != -1 &amp;&amp; intDailyVTOMinutes &gt; maxVTOHoursPerDay) {</span>
<span class="nc" id="L809">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFT_VTO_DAILY,</span>
<span class="nc" id="L810">									maxVTOHoursPerDay, cOrgDay.getTime());</span>
<span class="nc" id="L811">							llNewConflicts.add(cConflict);</span>
<span class="nc" id="L812">							intDailyVTOMinutes = -1;</span>
						}
					}
<span class="nc" id="L815">					weeklyVTOMinutes += pEvent.getDuration();</span>
				}
			}
			
			
<span class="nc" id="L820">		}</span>

<span class="nc" id="L822">		long[] returnValue = new long[3];</span>
<span class="nc" id="L823">		returnValue[0] = nMinutes;</span>
<span class="nc" id="L824">		returnValue[1] = weeklyOTMinutes;</span>
<span class="nc" id="L825">		returnValue[2] = weeklyVTOMinutes;</span>
<span class="nc" id="L826">		return new Pair&lt;List&lt;ShiftsConflict&gt;,long[]&gt;(llNewConflicts, returnValue);</span>
	}

	private static boolean isOTShiftEvent(ShiftAssignment sa, ShiftEventAssignment event) {
<span class="nc bnc" id="L830" title="All 2 branches missed.">		if (sa.getExtensionBefore() &gt; 0</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">				&amp;&amp; TimeZoneUtil.numberOfMinutes(sa.getStartTime(), event.getStartTime()) &lt; sa.getExtensionBefore()) {</span>
<span class="nc" id="L832">			return true;</span>
		}

<span class="nc bnc" id="L835" title="All 2 branches missed.">		if (sa.getExtensionAfter() &gt; 0</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">				&amp;&amp; TimeZoneUtil.numberOfMinutes(event.getEndTime(), sa.getEndTime()) &lt; sa.getExtensionAfter()) {</span>
<span class="nc" id="L837">			return true;</span>
		}

<span class="nc" id="L840">		return false;</span>
	}

	private static boolean isEventSameAsShiftAssignment(Event event, ShiftAssignment sa) {
<span class="nc bnc" id="L844" title="All 2 branches missed.">		return sa.getStartTime().equals(event.getStartTime())</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">				&amp;&amp; sa.getDuration() == event.getDuration()</span>
<span class="nc bnc" id="L846" title="All 6 branches missed.">				&amp;&amp; ((sa.getActivityID() == null &amp;&amp; event.getActivityID() == null) || (sa.getActivityID() != null</span>
<span class="nc bnc" id="L847" title="All 4 branches missed.">						&amp;&amp; event.getActivityID() != null &amp;&amp; sa.getActivityID().equals(event.getActivityID())));</span>
	}

	/**
	 * Get the MaxConsecutiveDaysConflicts for an employee. The max days is set
	 * for the employee's organization.
	 *
	 * @param cEvents
	 * @param dtStart
	 *            - the start of the scheduling period
	 * @param dtEnd
	 *            - the end of the scheduling period
	 * @param pOrg
	 * @return
	 */
	public static Collection&lt;ShiftsConflict&gt; getMaxConsecutiveDaysConflicts(Collection&lt;? extends Event&gt; cEvents,
			Date dtStart, Date dtEnd, Organization pOrg) {
<span class="nc" id="L864">		return getMaxConsecutiveDaysConflicts(cEvents, pOrg.getMaxConsecutiveWorkingDay(), dtStart, dtEnd, pOrg);</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getMaxConsecutiveDaysConflicts(Collection&lt;? extends Event&gt; cEvents,
			int maxAllowedDays, Date dtStart, Date dtEnd, Organization pOrg) {
		// create a span for each org day in the range...
<span class="nc" id="L870">		LinkedList&lt;TimeSpan&gt; llDaySpans = new LinkedList&lt;TimeSpan&gt;();</span>
		// calendar for org day start
<span class="nc" id="L872">		Calendar cOrgDayStart = Calendar.getInstance(pOrg.getTimeZone());</span>

		// calendar for org day end.
<span class="nc" id="L875">		Calendar cOrgDayEnd = Calendar.getInstance(pOrg.getTimeZone());</span>

		// calendar for start of the date range to check conflicts for.
<span class="nc" id="L878">		Calendar cConflictRangeStart = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L879">		cConflictRangeStart.setTime(dtStart);</span>
<span class="nc" id="L880">		cConflictRangeStart.add(Calendar.DATE, -maxAllowedDays);</span>

		// calendar for end of the date range to check conflicts for.
<span class="nc" id="L883">		Calendar cConflictRangeEnd = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L884">		cConflictRangeEnd.setTime(dtEnd);</span>
<span class="nc" id="L885">		cConflictRangeEnd.add(Calendar.DATE, maxAllowedDays);</span>

		// the date range to check conflicts for.
<span class="nc" id="L888">		TimeRange conflictRange = new TimeRange(cConflictRangeStart.getTime(), cConflictRangeEnd.getTime());</span>

		// compute org day start.
<span class="nc" id="L891">		cOrgDayStart.setTime(cConflictRangeStart.getTime());</span>

		// set the day boundary and start time. We need this because
		// dtStart,dtEnd are aligned to the SP, not the org.
<span class="nc" id="L895">		cOrgDayStart.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / 60);</span>
<span class="nc" id="L896">		cOrgDayStart.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % 60);</span>
<span class="nc" id="L897">		cOrgDayStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L898">		cOrgDayStart.set(Calendar.MILLISECOND, 0);</span>
		// cOrgDayStart.set(Calendar.DAY_OF_WEEK, pOrg.getWeekStartDate());
		// //GQ: MaxConsecutiveDays are not &quot;per week&quot;

		// check if day start is after start date, set day start to 1 day in the
		// past
<span class="nc bnc" id="L904" title="All 2 branches missed.">		if (cOrgDayStart.getTime().after(dtStart)) {</span>
<span class="nc" id="L905">			cOrgDayStart.add(Calendar.DATE, -1);</span>
		}

		// compute org day end.
<span class="nc" id="L909">		cOrgDayEnd.setTime(cOrgDayStart.getTime());</span>
<span class="nc" id="L910">		cOrgDayEnd.add(Calendar.DATE, 1);</span>

		// identify org days that encompass the given time range (dtSTart,
		// dtEnd)
<span class="nc bnc" id="L914" title="All 2 branches missed.">		while (cOrgDayStart.getTime().before(cConflictRangeEnd.getTime())) {</span>
			// QC#94688: One warning about previous week showing in the current
			// week when orgTZ differnet than campTZ.
			// Only add this org day to the list if it overlaps the
			// conflictRange by more than 0.5 days (43200000 ms).
<span class="nc" id="L919">			TimeRange curDay = new TimeRange(cOrgDayStart.getTime(), cOrgDayEnd.getTime());</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">			if (curDay.getOverlapDuration(conflictRange) &gt;= 43200000) {</span>
<span class="nc" id="L921">				llDaySpans.add(new TimeSpan(cOrgDayStart.getTime(), cOrgDayEnd.getTime()));</span>
			}
<span class="nc" id="L923">			cOrgDayStart.setTime(cOrgDayEnd.getTime());</span>
<span class="nc" id="L924">			cOrgDayEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L925">		}</span>

<span class="nc" id="L927">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L928">		int numConsecShifts = 0;</span>
<span class="nc" id="L929">		Date conflictDate = null;</span>

		// sort cEvents because they are not necessarily in order
<span class="nc" id="L932">		ArrayList&lt;Event&gt; aEvents = new ArrayList&lt;Event&gt;(cEvents);</span>
<span class="nc" id="L933">		Collections.sort(aEvents, new StartTimeComparator());</span>

		// iterate through each org day in the range
<span class="nc bnc" id="L936" title="All 2 branches missed.">		for (Iterator&lt;TimeSpan&gt; l = llDaySpans.iterator(); l.hasNext();) {</span>
<span class="nc" id="L937">			TimeSpan daySpan = l.next();</span>
<span class="nc" id="L938">			boolean hasShiftThisDay = false;</span>
<span class="nc" id="L939">			Event pEvent = null;</span>

			// iterate through shift assignments
<span class="nc bnc" id="L942" title="All 2 branches missed.">			for (Iterator&lt;Event&gt; i = aEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L943">				pEvent = i.next();</span>
				// if shift assignment starts in this org day.
<span class="nc bnc" id="L945" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriodAndApproved(pEvent, daySpan.dtSpanStart, daySpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">					if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L947">						hasShiftThisDay = true;</span>
<span class="nc" id="L948">						break;</span>
					}
				}
			}

<span class="nc bnc" id="L953" title="All 2 branches missed.">			if (hasShiftThisDay) {</span>
<span class="nc" id="L954">				numConsecShifts++;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">				if (numConsecShifts &gt; maxAllowedDays) {</span>
<span class="nc" id="L956">					conflictDate = pEvent.getStartTime();</span>
<span class="nc" id="L957">					break;</span>
				}
			} else {
<span class="nc" id="L960">				numConsecShifts = 0;</span>
			}

<span class="nc" id="L963">		}</span>

<span class="nc bnc" id="L965" title="All 2 branches missed.">		if (numConsecShifts &gt; maxAllowedDays) {</span>
<span class="nc" id="L966">			ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_CONSECUTIVEDAY, maxAllowedDays,</span>
					conflictDate);
			// cConflict.setDoubleTarget((double) nMaxMinutes);
<span class="nc" id="L969">			llNewConflicts.add(cConflict);</span>
		}

<span class="nc" id="L972">		return llNewConflicts;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getMinShiftSpacingConflicts(Collection&lt;? extends Event&gt; cEvents,
			Date dtStart, Date dtEnd, Organization pOrg) {
<span class="nc" id="L977">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L978">		HashMap&lt;Date, Integer&gt; conflictDates = new HashMap&lt;Date, Integer&gt;();</span>
<span class="nc" id="L979">		int minSpacingMinutes = pOrg.getMinTimeBetweenShift();</span>

		// sort cEvents because they are not necessarily in order
<span class="nc" id="L982">		ArrayList&lt;Event&gt; aEvents = new ArrayList&lt;Event&gt;(cEvents);</span>
<span class="nc" id="L983">		Collections.sort(aEvents, new StartTimeComparator());</span>

<span class="nc" id="L985">		Date previousShiftEnd = null;</span>
<span class="nc" id="L986">		boolean firstShift = true;</span>
<span class="nc" id="L987">		int minutesBetweenShifts = 0;</span>

		// move back the period start to cover the min space, min space
		// violation is for later shift. so we need to lookback here.
<span class="nc" id="L991">		Calendar cal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L992">		cal.setTime(dtStart);</span>
<span class="nc" id="L993">		cal.add(Calendar.MINUTE, -minSpacingMinutes);</span>
<span class="nc" id="L994">		cal.add(Calendar.DAY_OF_YEAR, -1);</span>
<span class="nc" id="L995">		Date eventCheckingStart = cal.getTime();</span>

		// iterate through shift assignments
<span class="nc bnc" id="L998" title="All 2 branches missed.">		for (Iterator&lt;Event&gt; i = aEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L999">			Event pEvent = i.next();</span>

			// if shift assignment starts in this org day
<span class="nc bnc" id="L1002" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, eventCheckingStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">					if (!firstShift) {</span>
<span class="nc" id="L1005">						Date shiftStart = pEvent.getStartTime();</span>
<span class="nc" id="L1006">						long millisBetweenShifts = shiftStart.getTime() - previousShiftEnd.getTime();</span>
<span class="nc" id="L1007">						minutesBetweenShifts = (int) (millisBetweenShifts / 1000 / 60);</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">						if (minutesBetweenShifts &lt; minSpacingMinutes) {</span>
<span class="nc" id="L1009">							conflictDates.put(shiftStart, minutesBetweenShifts);</span>
						}
					}

<span class="nc" id="L1013">					firstShift = false;</span>
<span class="nc" id="L1014">					previousShiftEnd = pEvent.getEndTime();</span>
				}
			}
<span class="nc" id="L1017">		}</span>

<span class="nc bnc" id="L1019" title="All 2 branches missed.">		if (!conflictDates.isEmpty()) {</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">			for (Map.Entry&lt;Date, Integer&gt; entry: conflictDates.entrySet()) {</span>
<span class="nc" id="L1021">				ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_MINSPACING, minSpacingMinutes</span>
<span class="nc" id="L1022">					- entry.getValue(), entry.getKey());</span>
<span class="nc" id="L1023">				cConflict.setDoubleTarget(minSpacingMinutes);</span>
<span class="nc" id="L1024">				llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1025">			}</span>
		}

<span class="nc" id="L1028">		return llNewConflicts;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getShiftEventInvalidConflicts(Collection&lt;? extends Event&gt; cEvents,
			Map&lt;ID, Shift&gt; hShifts, Date dtStart, Date dtEnd) {
<span class="nc" id="L1033">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;&gt;();</span>

<span class="nc bnc" id="L1035" title="All 2 branches missed.">		for (Event pEvent : cEvents) {</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">					&amp;&amp; pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1038">				ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc" id="L1039">				Shift pShift = hShifts.get(idShift);</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">				if (pShift == null) {</span>
<span class="nc" id="L1041">					continue;</span>
				}
<span class="nc" id="L1043">				Collection cShiftEvents = pShift.getShiftEvents();</span>
<span class="nc" id="L1044">				Collection cSEAs = pEvent.getChildren();</span>

				// this is pretty inefficient...
<span class="nc" id="L1047">				Collection&lt;ID&gt; cShiftEventIDsRequired = new LinkedList&lt;ID&gt;();</span>
<span class="nc" id="L1048">				Collection&lt;ID&gt; cShiftEventIDsContained = new LinkedList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">				for (Iterator j = cShiftEvents.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1050">					ShiftEvent pShiftEvent = (ShiftEvent) j.next();</span>
<span class="nc" id="L1051">					cShiftEventIDsRequired.add(pShiftEvent.getID());</span>
<span class="nc" id="L1052">				}</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">				for (Iterator j = cSEAs.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1054">					Event pSEvent = (Event) j.next();</span>
<span class="nc" id="L1055">					ShiftEventAssignment pSEA = (ShiftEventAssignment) pSEvent;</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">					if (pSEA.getShiftEventID() != null) {</span>
						// for ot event, shifteventid is null, don't check
						// conflict for them
<span class="nc" id="L1059">						cShiftEventIDsContained.add(pSEA.getShiftEventID());</span>
					}
<span class="nc" id="L1061">				}</span>

<span class="nc bnc" id="L1063" title="All 2 branches missed.">				for (Iterator j = cSEAs.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L1064">					Event pSEvent = (Event) j.next();</span>
<span class="nc" id="L1065">					ShiftEventAssignment pSEA = (ShiftEventAssignment) pSEvent;</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">					if (pSEA.getShiftEventID() != null</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">						&amp;&amp; WorkRuleUtil.isInPeriod(pSEA.getStartTime(), pSEA.getEndTime(),</span>
<span class="nc" id="L1068">							pEvent.getStartTime(), pEvent.getEndTime(), WorkRule.STARTSIN)</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">						&amp;&amp; !cShiftEventIDsRequired.contains(pSEA.getShiftEventID())) {</span>
						// found an invalid sea...
<span class="nc" id="L1071">						ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.SHIFTEVENT_INVALID,</span>
<span class="nc" id="L1072">							pShift.getName(), pSEvent.getStartTime());</span>
<span class="nc" id="L1073">						llNewConflicts.add(cConflict);</span>
					}
<span class="nc" id="L1075">				}</span>
			}
<span class="nc" id="L1077">		}</span>

<span class="nc" id="L1079">		return llNewConflicts;</span>
	}
	
    public static int getRelativeDay(Event pEvent, ShiftsConflictData conflictData, Date dtStart, ShiftPattern workPattern) {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (workPattern.isMonthlyShiftPattern()) {</span>
<span class="nc" id="L1084">            return getRelativeDayInMonth(pEvent, dtStart);</span>
        } else {
<span class="nc" id="L1086">            return getRelativeDayInWeek(pEvent, conflictData, workPattern);</span>
        }
    }

	protected static int getRelativeDayInWeek(Event pEvent, ShiftsConflictData conflictData, ShiftPattern workPattern) {
		// WorkPatterns are dictated by startDay
<span class="nc" id="L1092">        int startDay = getWorkPatternWeekStartDay(conflictData, workPattern);</span>
<span class="nc" id="L1093">        Calendar cal = Calendar.getInstance(getWorkPatternTimeZone(conflictData, workPattern));</span>
<span class="nc" id="L1094">        cal.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L1095">        int eventDay = cal.get(Calendar.DAY_OF_WEEK) - 1;</span>

<span class="nc" id="L1097">		int diff = eventDay - startDay;</span>
<span class="nc bnc" id="L1098" title="All 14 branches missed.">		switch (diff) {</span>
		case 0:
<span class="nc" id="L1100">			return 1;</span>
		case 1:
<span class="nc" id="L1102">			return 2;</span>
		case 2:
<span class="nc" id="L1104">			return 3;</span>
		case 3:
<span class="nc" id="L1106">			return 4;</span>
		case 4:
<span class="nc" id="L1108">			return 5;</span>
		case 5:
<span class="nc" id="L1110">			return 6;</span>
		case 6:
<span class="nc" id="L1112">			return 7;</span>
		case -1:
<span class="nc" id="L1114">			return 7;</span>
		case -2:
<span class="nc" id="L1116">			return 6;</span>
		case -3:
<span class="nc" id="L1118">			return 5;</span>
		case -4:
<span class="nc" id="L1120">			return 4;</span>
		case -5:
<span class="nc" id="L1122">			return 3;</span>
		case -6:
<span class="nc" id="L1124">			return 2;</span>
		default:
<span class="nc" id="L1126">			return -1;</span>
		}
	}

	/**
	 * If the workPattern belongs to Org then get the org week start day
	 * but if the workPattern belongs to campaign then get the campaign week start day
	 * in case both of them is null then simply use the emp org week start day
	 * @param conflictData
	 * @param workPattern
	 * @return
	 */
	static int getWorkPatternWeekStartDay(ShiftsConflictData conflictData, ShiftPattern workPattern) {
<span class="nc bnc" id="L1139" title="All 2 branches missed.">		if (workPattern.getOrganizationID() != null) {</span>
<span class="nc" id="L1140">			Organization org = conflictData.getOrgsMap().get(workPattern.getOrganizationID());</span>
<span class="nc" id="L1141">			return org.getWeekStartDay().get0SundayCount();</span>
<span class="nc bnc" id="L1142" title="All 4 branches missed.">		} else if (workPattern.getCampaignID() != null &amp;&amp; conflictData.getCampaign() != null</span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">			&amp;&amp; conflictData.getCampaign().getID() == workPattern.getCampaignID()) {</span>
<span class="nc" id="L1144">			return conflictData.getCampaign().getWeekStart() / 1440;</span>
		}
<span class="nc" id="L1146">		return conflictData.getEmpOrg().getWeekStartDay().get0SundayCount();</span>
	}

	/**
	 * If the workPattern belongs to Org then get the org timezone else if
	 * the workPattern belongs to campaign then get the campaign timezone
	 * otherwise simply use the emp org timezone
	 * @param conflictData
	 * @param workPattern
	 * @return
	 */
	static TimeZone getWorkPatternTimeZone(ShiftsConflictData conflictData, ShiftPattern workPattern) {
<span class="nc bnc" id="L1158" title="All 2 branches missed.">		if (workPattern.getOrganizationID() != null) {</span>
<span class="nc" id="L1159">			Organization org = conflictData.getOrgsMap().get(workPattern.getOrganizationID());</span>
<span class="nc" id="L1160">			return org.getTimeZone();</span>
<span class="nc bnc" id="L1161" title="All 4 branches missed.">		} else if (workPattern.getCampaignID() != null &amp;&amp; conflictData.getCampaign() != null</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">				&amp;&amp; conflictData.getCampaign().getID() == workPattern.getCampaignID()) {</span>
<span class="nc" id="L1163">			return conflictData.getCampaign().getTimeZone();</span>
		}
<span class="nc" id="L1165">		return conflictData.getEmpOrg().getTimeZone();</span>
	}

    protected static int getRelativeDayInMonth(Event pEvent, Date dtStart) {
<span class="nc" id="L1169">        return (int)Math.ceil((pEvent.getStartTime().getTime() - dtStart.getTime()) / MILLIS_IN_DAY);</span>
    }

	private static boolean hasWorkPatternOccuranceConflict(ShiftsConflictData conflictData,
			ShiftPattern pWorkPattern, Date dtStart, Date dtEnd) {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">		if (pWorkPattern == null) {</span>
            // no work pattern, no problem
<span class="nc" id="L1176">            return false;</span>
		}
<span class="nc" id="L1178">        int numOfDays = pWorkPattern.getPeriod().getDaysInPeriod().length;</span>
<span class="nc" id="L1179">		ArrayList daysWithShifts = new ArrayList(numOfDays);</span>

<span class="nc bnc" id="L1181" title="All 2 branches missed.">		for (Event pEvent : conflictData.getShiftAssignmentWithInPeriod(dtStart, dtEnd)) {</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">					&amp;&amp; pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1184">				ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">				if (idShift == null) {</span>
<span class="nc" id="L1186">					continue;</span>
				}

<span class="nc" id="L1189">				int nDay = getRelativeDay(pEvent, conflictData, dtStart, pWorkPattern);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">				if (!pWorkPattern.getPossibleShiftIDs(nDay).contains(idShift)) {</span>
					// conflict found
<span class="nc" id="L1192">					return true;</span>
				}

<span class="nc" id="L1195">				daysWithShifts.add(nDay);</span>
			}
<span class="nc" id="L1197">		}</span>

        // the day off indicator shift always has an SID of 1
<span class="nc" id="L1200">		ID SHIFT_OFF = new ID(1);</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">		for (int nDay = 1; nDay &lt; numOfDays+1; nDay++) {</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">			if (!daysWithShifts.contains(nDay)) {</span>
				// not working this day, so we need to make sure this day is allowed to be off
<span class="nc" id="L1204">				Collection&lt;ID&gt; shiftIDs = pWorkPattern.getPossibleShiftIDs(nDay);</span>
<span class="nc bnc" id="L1205" title="All 2 branches missed.">				if (!shiftIDs.contains(SHIFT_OFF)) {</span>
                    // conflict found
<span class="nc" id="L1207">                    return true;</span>
				}
			}
		}
        // no conflict found
<span class="nc" id="L1212">		return false;</span>
	}

    public static Collection&lt;ShiftsConflict&gt; getWorkPatternConsistentShiftEvent(ShiftsConflictData conflictData,
			ShiftPattern pWorkPattern, Date dtStart, Date dtEnd) {

<span class="nc" id="L1218">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1219">		HashMap&lt;ImmutablePair, Long&gt; hStartOffsets = new HashMap&lt;ImmutablePair, Long&gt;();</span>

<span class="nc bnc" id="L1221" title="All 2 branches missed.">		for (Iterator&lt;? extends Event&gt; i = conflictData.getShiftAssignmentWithInPeriod(dtStart, dtEnd).iterator(); i.hasNext();) {</span>
<span class="nc" id="L1222">			Event pEvent = i.next();</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc" id="L1224">				int nDay = getRelativeDay(pEvent, conflictData, dtStart, pWorkPattern);</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1226">					ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">					if (idShift == null) {</span>
<span class="nc" id="L1228">						continue;</span>
					}
<span class="nc" id="L1230">					Integer nStartGroup = new Integer(pWorkPattern.getStartGroup(idShift, nDay));</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">					if (nStartGroup.intValue() == ShiftPattern.NOSTARTGROUP) {</span>
<span class="nc" id="L1232">						continue;</span>
					}

<span class="nc bnc" id="L1235" title="All 2 branches missed.">					if (pWorkPattern.isConsistentShiftActivities(idShift)) {</span>
						// check shift events for consistency
<span class="nc" id="L1237">						Collection cShiftEvents = pEvent.getChildren();</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">						for (Iterator j = cShiftEvents.iterator(); j.hasNext();) {</span>
<span class="nc" id="L1239">							Event pSEA = (Event) j.next();</span>
<span class="nc" id="L1240">							ShiftEventAssignment shiftEventAssignment = ((ShiftEventAssignment) pSEA);</span>
<span class="nc" id="L1241">							ID idShiftEvent = shiftEventAssignment.getShiftEventID();</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">							if (idShiftEvent != null) {</span>
                                // for ot and gap, it could be null.
<span class="nc" id="L1244">								Long lOffset = new Long(pEvent.getStartTime().getTime() - pSEA.getStartTime().getTime());</span>
<span class="nc" id="L1245">								ImmutablePair key = new ImmutablePair(nStartGroup, idShiftEvent);</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">								if (hStartOffsets.containsKey(key)) {</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">									if (!lOffset.equals(hStartOffsets.get(key))) {</span>
<span class="nc" id="L1248">										Shift shift = conflictData.getShiftsMap().get(shiftEventAssignment.getParent().getShiftID());</span>
<span class="nc" id="L1249">										ShiftEvent shiftEvent = shift.getShiftEvent(idShiftEvent);</span>

										// Fixed for ESR#4163882 And QC#118790
										// ShiftEvent is coming null when no
										// campaign is selected
<span class="nc bnc" id="L1254" title="All 2 branches missed.">										if (shiftEvent != null) {</span>
<span class="nc" id="L1255">											ShiftsConflict cConflict = new ShiftsConflict(</span>
													ShiftsConflict.WORKPATTERN_CONSISTENTSHIFTEVENT,
<span class="nc" id="L1257">													shiftEvent.getName(), dtStart);</span>
<span class="nc" id="L1258">											llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1259">											return llNewConflicts;</span>
										}
<span class="nc" id="L1261">									}</span>
								} else {
<span class="nc" id="L1263">									hStartOffsets.put(new ImmutablePair(nStartGroup, idShiftEvent), lOffset);</span>
								}
							}
<span class="nc" id="L1266">						}</span>
					}
				}
			}
<span class="nc" id="L1270">		}</span>

<span class="nc" id="L1272">		return llNewConflicts;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getWorkPatternConsistentStart(ShiftsConflictData conflictData,
			ShiftPattern pWorkPattern, Date dtStart, Date dtEnd) {

<span class="nc" id="L1278">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1279">		HashMap&lt;Integer, Integer&gt; hStartOffsets = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="nc" id="L1280">		Calendar cCalendar = Calendar.getInstance(getWorkPatternTimeZone(conflictData, pWorkPattern));</span>

<span class="nc bnc" id="L1282" title="All 2 branches missed.">		for (Iterator&lt;? extends Event&gt; i = conflictData.getShiftAssignmentWithInPeriod(dtStart, dtEnd).iterator(); i.hasNext();) {</span>
<span class="nc" id="L1283">			Event pEvent = i.next();</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1286">					cCalendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L1287">					int nDay = getRelativeDay(pEvent, conflictData, dtStart, pWorkPattern);</span>
<span class="nc" id="L1288">					ID idShift = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">					if (idShift == null) {</span>
<span class="nc" id="L1290">						continue;</span>
					}

<span class="nc" id="L1293">					Integer nStartGroup = new Integer(pWorkPattern.getStartGroup(idShift, nDay));</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">					if (nStartGroup.intValue() != ShiftPattern.NOSTARTGROUP) {</span>
						// check shifts for consistency
<span class="nc" id="L1296">						int nShiftStartMinute = (cCalendar.get(Calendar.HOUR_OF_DAY) * 60)</span>
<span class="nc" id="L1297">								+ cCalendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L1298">						Integer intShiftStartMinute = new Integer(nShiftStartMinute);</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">						if (hStartOffsets.containsKey(nStartGroup)) {</span>
<span class="nc" id="L1300">							Integer intGroupStartMinute = hStartOffsets.get(nStartGroup);</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">							if (intShiftStartMinute.intValue() != intGroupStartMinute.intValue()</span>
<span class="nc" id="L1302">									&amp;&amp; Math.abs(intShiftStartMinute.intValue() - intGroupStartMinute.intValue()) &gt; pWorkPattern</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">											.getConsistentStartsTolerance()) {</span>
<span class="nc" id="L1304">								Shift shift = conflictData.getShiftsMap().get(idShift);</span>
<span class="nc" id="L1305">								ShiftsConflict cConflict = new ShiftsConflict(</span>
<span class="nc" id="L1306">										ShiftsConflict.WORKPATTERN_CONSISTENTSTART, shift.getName(), dtStart);</span>
<span class="nc" id="L1307">								llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1308">								return llNewConflicts;</span>
							}
<span class="nc" id="L1310">						} else {</span>
<span class="nc" id="L1311">							hStartOffsets.put(nStartGroup, intShiftStartMinute);</span>
						}
					}
				}
			}
<span class="nc" id="L1316">		}</span>

<span class="nc" id="L1318">		return llNewConflicts;</span>
	}

	public static Collection&lt;ShiftsConflict&gt; getMeetingAttendanceConflicts(ID workResourceID,
			Collection&lt;? extends Event&gt; cEvents, Date dtStart, Date dtEnd, Map&lt;ID, Activity&gt; activityMap) {

<span class="nc" id="L1324">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1325">		Collection cInconstentShiftEvent = new LinkedList();</span>
<span class="nc" id="L1326">		HashMap hShiftEventStartOffsets = new HashMap();</span>
<span class="nc" id="L1327">		Calendar cCalendar = Calendar.getInstance();</span>
<span class="nc" id="L1328">		ShiftAssignment sa = null;</span>
<span class="nc" id="L1329">		Date saStart = null;</span>
<span class="nc" id="L1330">		Date saEnd = null;</span>

<span class="nc bnc" id="L1332" title="All 2 branches missed.">		for (Event pEvent : cEvents) {</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) {</span>
<span class="nc" id="L1335">					int eOverlap = ((CalendarEvent) pEvent).getOverlapType();</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">					if (eOverlap == CalendarEventTemplate.OVERLAP_TYPE_MUST_OVERLAP_SHIFT) {</span>
<span class="nc" id="L1337">						boolean bFoundOverlap = false;</span>

<span class="nc bnc" id="L1339" title="All 2 branches missed.">						for (Iterator j = cEvents.iterator(); j.hasNext();) {</span>
<span class="nc" id="L1340">							Event pEvent1 = (Event) j.next();</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">							if (WorkRuleUtil.isInPeriodAndApproved(pEvent1, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">								if (pEvent1.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1343">									sa = (ShiftAssignment) pEvent1;</span>
<span class="nc" id="L1344">									Date shiftStart = getRealShiftStart(sa, cCalendar);</span>
<span class="nc" id="L1345">									Date shiftEnd = getRealShiftEnd(sa, cCalendar);</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">									if (!pEvent.getStartTime().before(shiftStart)</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">											&amp;&amp; !pEvent.getEndTime().after(shiftEnd)) {</span>
<span class="nc" id="L1348">										bFoundOverlap = true;</span>
<span class="nc" id="L1349">										break;</span>
									}
								}
							}
<span class="nc" id="L1353">						}</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">						if (!bFoundOverlap</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">								&amp;&amp; ((CalendarEventAssignment) pEvent).isWorkResourceAttending(workResourceID)) {</span>
<span class="nc" id="L1356">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MEETING_ATTENDANCE, &quot;&quot;,</span>
<span class="nc" id="L1357">									pEvent.getStartTime(), pEvent.getDuration(), pEvent.getActivityID());</span>
<span class="nc" id="L1358">							cConflict.setEvent(pEvent);</span>
<span class="nc" id="L1359">							Activity activity = activityMap.get(pEvent.getActivityID());</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">							if (activity != null) {</span>
<span class="nc" id="L1361">								cConflict.setActivityName(activity.getName());</span>
							}
<span class="nc" id="L1363">							llNewConflicts.add(cConflict);</span>
						}
					}
				}

				// time off must overlap with shift - angela
<span class="nc bnc" id="L1369" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L1370">					TimeOffEvent toEvent = (TimeOffEvent) pEvent;</span>
<span class="nc" id="L1371">					short timeOffRule = toEvent.getTimeOffRule();</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">					if (timeOffRule == TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES) {</span>
<span class="nc" id="L1373">						int overlapMinutes = 0;</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">						for (Iterator&lt;? extends Event&gt; j = cEvents.iterator(); j.hasNext();) {</span>
<span class="nc" id="L1375">							Event pEvent1 = j.next();</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">							if (WorkRuleUtil.isInPeriodAndApproved(pEvent1, dtStart, dtEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">								if (pEvent1.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1378">									sa = (ShiftAssignment) pEvent1;</span>
<span class="nc" id="L1379">									saStart = getRealShiftStart(sa, cCalendar);</span>
<span class="nc" id="L1380">									saEnd = getRealShiftEnd(sa, cCalendar);</span>
<span class="nc bnc" id="L1381" title="All 4 branches missed.">									if (saStart.before(toEvent.getEndTime()) &amp;&amp; saEnd.after(toEvent.getStartTime())) {</span>
										// Flatten the events for this
										// ShiftAssignment
<span class="nc" id="L1384">										Collection&lt;SimpleEvent&gt; events = EventUtils</span>
<span class="nc" id="L1385">												.convertEventsToTimelineForSingleEmployee(Collections.singletonList(sa));</span>

<span class="nc bnc" id="L1387" title="All 2 branches missed.">										for (Iterator&lt;SimpleEvent&gt; eventIt = events.iterator(); eventIt.hasNext();) {</span>
<span class="nc" id="L1388">											SimpleEvent simpleEvent = eventIt.next();</span>
<span class="nc" id="L1389">											Date seStart = simpleEvent.getStartTime();</span>
<span class="nc" id="L1390">											Date seEnd = simpleEvent.getEndTime();</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">											if (simpleEvent.getPaid()</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">													&amp;&amp; toEvent.getStartTime().before(simpleEvent.getEndTime())</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">													&amp;&amp; toEvent.getEndTime().after(simpleEvent.getStartTime())) {</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">												overlapMinutes += (int) ((toEvent.getEndTime().before(seEnd) ? toEvent</span>
<span class="nc" id="L1395">														.getEndTime().getTime() : seEnd.getTime()) - (toEvent</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">														.getStartTime().after(seStart) ? toEvent.getStartTime()</span>
<span class="nc" id="L1397">														.getTime() : seStart.getTime()))</span>
														/ TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;
											}
<span class="nc" id="L1400">										}</span>
									}
								}
							}
<span class="nc" id="L1404">						}</span>

<span class="nc bnc" id="L1406" title="All 2 branches missed.">						if (overlapMinutes != toEvent.getCountsMinutesTowardsRules()) {</span>
<span class="nc" id="L1407">							ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.MEETING_ATTENDANCE_TIMEOFF,</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">									&quot;&quot;, overlapMinutes, pEvent.getStartTime(), pEvent.getEndTime().after(dtEnd) ? dtEnd</span>
<span class="nc" id="L1409">											: pEvent.getEndTime(), toEvent.getCountsMinutesTowardsRules());</span>
<span class="nc" id="L1410">							llNewConflicts.add(cConflict);</span>
						}
					}
				}
			}
<span class="nc" id="L1415">		}</span>
<span class="nc" id="L1416">		return llNewConflicts;</span>
	}

	/**
	 * &lt;B&gt;getAllShiftConflictsForEmployee&lt;/B&gt; returns ShiftsConflicts for a
	 * single Employee's Schedule, see ShiftsConflict.java for a list of
	 * ShiftConflict types for all the collections (cEvents, cMinMaxHours,
	 * etc...) and all the HashMaps (hShifts, hWorkPatterns, etc...) any
	 * additional unneeded entries will be ignored, so is fine to pass in a
	 * superset of the required entries.
	 * &lt;P&gt;
	 *
	 * @param conflictData
	 * @return Collection of ShiftsConflicts
	 */
	public static Collection&lt;ShiftsConflict&gt; getAllShiftConflictsForEmployee(ShiftsConflictData conflictData) {
<span class="nc" id="L1432">		List&lt;ShiftsConflict&gt; llConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>

		Collection&lt;ShiftsConflict&gt; cConflicts;
<span class="nc" id="L1435">		Date dtStart = conflictData.getPeriodStart();</span>
<span class="nc" id="L1436">		Date dtEnd = conflictData.getPeriodEnd();</span>
<span class="nc" id="L1437">		Collection&lt;Event&gt; cEvents = conflictData.getSortedEmpEvents();</span>
<span class="nc" id="L1438">		Organization empOrg = conflictData.getEmpOrg();</span>
<span class="nc" id="L1439">		Map&lt;ID, Shift&gt; shiftsMap = conflictData.getShiftsMap();</span>

<span class="nc bnc" id="L1441" title="All 2 branches missed.">		if (conflictData.isMonthlyCampaign()) {</span>
<span class="nc" id="L1442">			cConflicts = getMonthlyMinMaxHourConflicts(cEvents, conflictData.getEmpMonthlyMinMax(), dtStart, dtEnd, empOrg,</span>
<span class="nc" id="L1443">				conflictData.getShiftOTExtensions());</span>
<span class="nc" id="L1444">			llConflicts.addAll(cConflicts);</span>
		}

<span class="nc bnc" id="L1447" title="All 2 branches missed.">		for (Iterator&lt;WorkResourceMinMaxHour&gt; i = conflictData.getEmpMinMaxHours().iterator(); i.hasNext();) {</span>
<span class="nc" id="L1448">			WorkResourceMinMaxHour pMinMax = i.next();</span>
<span class="nc" id="L1449">			Date dtAffecStart = dtStart;</span>
			//dtEnd has a minute subtracted in CalendarViewCache. adding it back
<span class="nc" id="L1451">			Date dtAffecEnd = new Date(dtEnd.getTime() + SIXTY_THOUSAND);</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">			if (pMinMax.getStartTime().after(dtStart)) {</span>
<span class="nc" id="L1453">				dtAffecStart = pMinMax.getStartTime();</span>
			}
<span class="nc bnc" id="L1455" title="All 4 branches missed.">			if (pMinMax.getEndTime() != null &amp;&amp; pMinMax.getEndTime().before(dtEnd)) {</span>
<span class="nc" id="L1456">				dtAffecEnd = pMinMax.getEndTime();</span>
			}
<span class="nc bnc" id="L1458" title="All 2 branches missed.">			if (!dtAffecStart.after(dtAffecEnd)) {</span>
<span class="nc" id="L1459">				cConflicts = getMinMaxHourConflicts(cEvents, pMinMax, dtAffecStart, dtAffecEnd, empOrg,</span>
<span class="nc" id="L1460">					conflictData.getShiftOTExtensions(), conflictData.isMonthlyCampaign());</span>
<span class="nc" id="L1461">				llConflicts.addAll(cConflicts);</span>
			}
<span class="nc" id="L1463">		}</span>

<span class="nc" id="L1465">		cConflicts = getHOOConflicts(cEvents, conflictData.getCampaignHOOPeriod(), dtStart, dtEnd, false, null);</span>
<span class="nc" id="L1466">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1468">		cConflicts = getHOOConflicts(cEvents, conflictData.getOrgHOOPeriod(), dtStart, dtEnd, true, empOrg);</span>
<span class="nc" id="L1469">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1471">		cConflicts = getMeetingAttendanceConflicts(conflictData.getEmpID(), cEvents, dtStart, dtEnd, conflictData.getActivityMap());</span>
<span class="nc" id="L1472">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1474">		cConflicts = getMinShiftSpacingConflicts(cEvents, dtStart, dtEnd, empOrg);</span>
<span class="nc" id="L1475">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1477">		cConflicts = getShiftEventInvalidConflicts(cEvents, shiftsMap, dtStart, dtEnd);</span>
<span class="nc" id="L1478">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1480">		cConflicts = getShiftEventSpacingConflicts(cEvents, shiftsMap, dtStart, dtEnd, conflictData.getActivityMap());</span>
<span class="nc" id="L1481">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1483">		cConflicts = getShiftEventStartTimeConflicts(cEvents, shiftsMap, conflictData.getOrgsMap(), dtStart,</span>
<span class="nc" id="L1484">			dtEnd, conflictData.getCampaignOrUserTimeZone());</span>
<span class="nc" id="L1485">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1487">		cConflicts = getShiftStartTimeConflicts(cEvents, shiftsMap, dtStart, dtEnd, conflictData.getOrgsMap(),conflictData.getCampaignOrUserTimeZone());</span>
<span class="nc" id="L1488">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1490">		cConflicts = getMaxConsecutiveDaysConflicts(cEvents, dtStart, dtEnd, empOrg);</span>
<span class="nc" id="L1491">		llConflicts.addAll(cConflicts);</span>

        //if monthly wp found then do not look for weekly wp conflicts
<span class="nc" id="L1494">        boolean isMonthlyWPFound = false;</span>

<span class="nc bnc" id="L1496" title="All 2 branches missed.">        if (conflictData.isMonthlyCampaign()) {</span>
            //dtEnd has a minute subtracted in CalendarViewCache. adding it back
<span class="nc" id="L1498">            Date end = new Date(dtEnd.getTime() + SIXTY_THOUSAND);</span>
<span class="nc" id="L1499">            isMonthlyWPFound = getMonthlyWPConflicts(conflictData, llConflicts);</span>
        }

        //report conflicts for weekly SPs. and for monthly SPs where monthly WP is not found
<span class="nc bnc" id="L1503" title="All 4 branches missed.">        if (!conflictData.isMonthlyCampaign() || !isMonthlyWPFound) {</span>
<span class="nc" id="L1504">            cConflicts = getWorkPatternConflicts(conflictData);</span>
        }

<span class="nc" id="L1507">		llConflicts.addAll(cConflicts);</span>

<span class="nc bnc" id="L1509" title="All 2 branches missed.">		for (Iterator&lt;ShiftsConflict&gt; i = llConflicts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1510">			ShiftsConflict pConflict = i.next();</span>
<span class="nc" id="L1511">			pConflict.setWorkResourceName(conflictData.getEmpName());</span>
<span class="nc" id="L1512">			pConflict.setWorkResourceID(conflictData.getEmpID());</span>
<span class="nc" id="L1513">		}</span>

<span class="nc" id="L1515">		return llConflicts;</span>
	}

	/**
	 * Determine which work pattern (if any) is assigned to the user for the
	 * date range. If the user has a rotation work pattern, we only use that
	 * one. If a work pattern is found, then we only use that one to check
	 * conflicts for. If a work pattern is not found, then we do not check work
	 * pattern conflicts.
	 */
	public static Collection&lt;ShiftsConflict&gt; getWorkPatternConflicts(ShiftsConflictData conflictData) {
<span class="nc" id="L1526">		List&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1527">		ShiftPattern pPattern = null;</span>
<span class="nc" id="L1528">		WorkResourceRotation wrr = null;</span>
<span class="nc" id="L1529">		int count = 0;</span>
<span class="nc" id="L1530">		List&lt;Pair&lt;Date, Date&gt;&gt; weekPairs = conflictData.getWeekPairs();</span>

<span class="nc bnc" id="L1532" title="All 2 branches missed.">		while (count &lt; weekPairs.size()) {</span>
<span class="nc" id="L1533">			pPattern = null;</span>
<span class="nc" id="L1534">			Date weekStart = weekPairs.get(count).getFirst();</span>
<span class="nc" id="L1535">			Date weekEnd = weekPairs.get(count).getSecond();</span>

			//if monthly and last week of the SP is partial then do not generate conflicts
<span class="nc bnc" id="L1538" title="All 6 branches missed.">			if (conflictData.isMonthlyCampaign() &amp;&amp; count == weekPairs.size() - 1 &amp;&amp; isPartialWeek(weekStart, weekEnd)) {</span>
<span class="nc" id="L1539">				break;</span>
			}

			// If the user has a rotation, use it to get the current work
			// pattern for this week.
<span class="nc bnc" id="L1544" title="All 4 branches missed.">			if (conflictData.getEmpRotations() != null &amp;&amp; !conflictData.getEmpRotations().isEmpty()) {</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">				for (Iterator&lt;WorkResourceRotation&gt; i = conflictData.getEmpRotations().iterator(); i.hasNext();) {</span>
<span class="nc" id="L1546">					wrr = i.next();</span>
<span class="nc" id="L1547">					pPattern = getRotationShiftPatternForTheWeek(wrr, weekStart, conflictData.getCampaignOrUserTimeZone());</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">					if (pPattern != null) {</span>
<span class="nc" id="L1549">						break; // user can only have one rotation assigned</span>
					}
				}
			}

			// If the user has no rotation, but he has a single work pattern
			// assignement, use that work pattern.
<span class="nc bnc" id="L1556" title="All 6 branches missed.">			if (pPattern == null &amp;&amp; conflictData.getEmpWorkPatterns() != null &amp;&amp; conflictData.getEmpWorkPatterns().size() == 1) {</span>
<span class="nc" id="L1557">				WorkResourceWorkPattern wrwp = conflictData.getEmpWorkPatterns().iterator().next();</span>
<span class="nc" id="L1558">				ID workPatternID = wrwp.getWorkPatternSID();</span>
<span class="nc" id="L1559">				pPattern = conflictData.getWorkPatterns().get(workPatternID);</span>
			}

<span class="nc bnc" id="L1562" title="All 2 branches missed.">			if (pPattern != null) {</span>
				// There is a single, unambiguous work pattern assigned to this
				// employee on this week. Check conflicts for this work pattern
				// only.
<span class="nc bnc" id="L1566" title="All 2 branches missed.">				if (hasWorkPatternOccuranceConflict(conflictData, pPattern, weekStart, weekEnd)) {</span>
<span class="nc" id="L1567">					ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.WORKPATTERN_OCCURANCE, &quot;&quot;, weekStart);</span>
<span class="nc" id="L1568">					llNewConflicts.add(cConflict);</span>
				}

<span class="nc" id="L1571">				checkWorkPatternConflict(conflictData, pPattern, weekStart, weekEnd, llNewConflicts);</span>

<span class="nc bnc" id="L1573" title="All 4 branches missed.">			} else if (conflictData.getEmpWorkPatterns() != null &amp;&amp; !conflictData.getEmpWorkPatterns().isEmpty()) {</span>
				// There is no singular work pattern assignment, so we'll
				// iterate through all his wp's to see if the shifts match ANY
				// of them.
<span class="nc" id="L1577">				boolean foundMatchingWorkPattern = false;</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">				for (WorkResourceWorkPattern wrwp : conflictData.getEmpWorkPatterns()) {</span>
<span class="nc" id="L1579">					ID workPatternID = wrwp.getWorkPatternSID();</span>
<span class="nc" id="L1580">					pPattern = conflictData.getWorkPatterns().get(workPatternID);</span>

<span class="nc bnc" id="L1582" title="All 2 branches missed.">					if (!hasWorkPatternOccuranceConflict(conflictData, pPattern, weekStart, weekEnd)) {</span>
<span class="nc" id="L1583">						List&lt;ShiftsConflict&gt; llCurConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1584">						checkWorkPatternConflict(conflictData, pPattern, weekStart, weekEnd, llCurConflicts);</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">						if (llCurConflicts.isEmpty()) {</span>
<span class="nc" id="L1586">							foundMatchingWorkPattern = true;</span>
<span class="nc" id="L1587">							break;</span>
						}
					}
<span class="nc" id="L1590">				}</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">				if (!foundMatchingWorkPattern) {</span>
					// no work patterns matched the shiftAssignmentsThisWeek.
<span class="nc" id="L1593">					ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.WORKPATTERN_OCCURANCE, &quot;&quot;, weekStart);</span>
<span class="nc" id="L1594">					llNewConflicts.add(cConflict);</span>
				}
			}

			// move on to next week
<span class="nc" id="L1599">			count++;</span>
<span class="nc" id="L1600">		}</span>
<span class="nc" id="L1601">		return llNewConflicts;</span>
	}


    public static boolean getMonthlyWPConflicts(ShiftsConflictData conflictData, Collection&lt;ShiftsConflict&gt; list) {
        //get monthly WP conflicts for monthly SPs
<span class="nc" id="L1607">        Date dtStart = conflictData.getPeriodStart();</span>
<span class="nc" id="L1608">	    Date dtEnd = conflictData.getPeriodEnd();</span>

<span class="nc bnc" id="L1610" title="All 4 branches missed.">        if (conflictData.getEmpWorkPatterns() != null &amp;&amp; !conflictData.getEmpWorkPatterns().isEmpty()) {</span>
<span class="nc" id="L1611">            ShiftPattern pPattern = null;</span>
<span class="nc" id="L1612">            boolean foundMatchingWPConflict = false;</span>

            //Loop through all the available workPatterns for the emp.
<span class="nc bnc" id="L1615" title="All 2 branches missed.">            for (WorkResourceWorkPattern wrwp : conflictData.getEmpWorkPatterns()) {</span>
<span class="nc" id="L1616">                ID workPatternID = wrwp.getWorkPatternSID();</span>
<span class="nc" id="L1617">                pPattern = conflictData.getWorkPatterns().get(workPatternID);</span>

<span class="nc bnc" id="L1619" title="All 2 branches missed.">                if (isWorkPatternApplicableOnMonthlySP(dtStart, dtEnd, pPattern)) {</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                    if (!hasWorkPatternOccuranceConflict(conflictData, pPattern, dtStart, dtEnd)) {</span>
<span class="nc" id="L1621">                        List&lt;ShiftsConflict&gt; llCurConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1622">                        checkWorkPatternConflict(conflictData, pPattern, dtStart, dtEnd, llCurConflicts);</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                        if (llCurConflicts.isEmpty()) {</span>
<span class="nc" id="L1624">                            return true;</span>
                        } else {
<span class="nc" id="L1626">                            foundMatchingWPConflict = true;</span>
                        }
<span class="nc" id="L1628">                    } else {</span>
<span class="nc" id="L1629">                        foundMatchingWPConflict = true;</span>
                    }
                }
<span class="nc" id="L1632">            }</span>

<span class="nc bnc" id="L1634" title="All 2 branches missed.">            if (foundMatchingWPConflict) {</span>
<span class="nc" id="L1635">                ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.WORKPATTERN_OCCURANCE, &quot;&quot;, dtStart);</span>
<span class="nc" id="L1636">                list.add(cConflict);</span>
<span class="nc" id="L1637">                return true;</span>
            }
        }

<span class="nc" id="L1641">        return false;</span>
    }

    protected static boolean isWorkPatternApplicableOnMonthlySP(Date dtStart, Date dtEnd, ShiftPattern wpPattern) {
<span class="nc" id="L1645">        int daysInSP = Math.round((dtEnd.getTime() - dtStart.getTime()) / MILLIS_IN_DAY);</span>
<span class="nc" id="L1646">        int daysInWP = wpPattern.getPeriod().getDaysInPeriod().length;</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">        if (daysInSP == daysInWP) {</span>
            //Monthly WP are applicable on same NumOfDays in a Monthly SP
<span class="nc" id="L1649">            return true;</span>
        }

<span class="nc" id="L1652">        return false;</span>
    }

	protected static boolean isPartialWeek(Date startDate, Date endDate) {
<span class="nc" id="L1656">		int days = Math.round((endDate.getTime() - startDate.getTime()) / MILLIS_IN_DAY);</span>

<span class="nc bnc" id="L1658" title="All 2 branches missed.">		if (days &lt; DAYS_IN_WEEK) {</span>
<span class="nc" id="L1659">			return true;</span>
		}

<span class="nc" id="L1662">		return false;</span>
	}

	/**
	 * Return WP org in cases when the WP belongs to the parent org and emp is associated with Child Org.
	 * QC177320
	 *
	 * @return Organization to use for WorkPattern Conflicts
	 */
	protected static Organization getOrgForWP(Organization pOrg, ShiftPattern pPattern, Map&lt;ID, Organization&gt; hOrgs) {
<span class="nc bnc" id="L1672" title="All 4 branches missed.">		if (pPattern.getOrganizationID() != null &amp;&amp; pPattern.getOrganizationID() != pOrg.getID()) {</span>
<span class="nc" id="L1673">			return hOrgs.get(pPattern.getOrganizationID());</span>
		}
<span class="nc" id="L1675">		return pOrg;</span>
	}

	private static Collection&lt;ShiftPattern&gt; getShiftPatternForTheWeek(
			Collection&lt;WorkResourceWorkPattern&gt; cEmpWorkPatterns, Map&lt;ID, ShiftPattern&gt; hWorkPatterns, Date weekStart,
			Date weekEnd) {
<span class="nc" id="L1681">		Collection&lt;ShiftPattern&gt; workPatternPerWeek = new ArrayList&lt;ShiftPattern&gt;();</span>
<span class="nc" id="L1682">		ShiftPattern pPattern = null;</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">		for (Iterator&lt;WorkResourceWorkPattern&gt; i = cEmpWorkPatterns.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1684">			WorkResourceWorkPattern pWP = i.next();</span>
<span class="nc bnc" id="L1685" title="All 6 branches missed.">			if (pWP.getStartTime().before(weekEnd) &amp;&amp; (pWP.getEndTime() == null || pWP.getEndTime().after(weekStart))) {</span>
<span class="nc" id="L1686">				pPattern = hWorkPatterns.get(pWP.getWorkPatternSID());</span>
<span class="nc" id="L1687">				workPatternPerWeek.add(pPattern);</span>
			}
<span class="nc" id="L1689">		}</span>
<span class="nc" id="L1690">		return workPatternPerWeek;</span>
	}

	/**
	 * Possible bug: This method doesn't take campaign timezone into account, so
	 * We probably need to either round to the nearest int, or convert dtStart
	 * to a localate in the campaign timezone)
	 */
	public static ShiftPattern getRotationShiftPatternForTheWeek(WorkResourceRotation wr, Date dtStart) {
<span class="nc" id="L1699">		Date alignmentDate = wr.getRotation().getAlignmentDate().getTime(TimeZoneUtil.GMT_TIMEZONE);</span>
		// get number of weeks round
<span class="nc" id="L1701">		int weeks = Math</span>
<span class="nc" id="L1702">				.abs((int) ((dtStart.getTime() - alignmentDate.getTime()) / (TimeZoneUtil.DAY_IN_MILLISECONDS * 7)));</span>
<span class="nc" id="L1703">		int nWeek = (weeks % wr.getNumWeeksInRotation() + wr.getStartWeekOffSet()) % wr.getNumWeeksInRotation();</span>
<span class="nc" id="L1704">		return wr.getRotation().getShiftPatterns().get(new Integer(nWeek));</span>
	}

	public static ShiftPattern getRotationShiftPatternForTheWeek(WorkResourceRotation wr, Date dtStart,
			TimeZone tzCampaign) {
<span class="nc" id="L1709">		Date alignmentDate = wr.getRotation().getAlignmentDate().getTime(TimeZoneUtil.GMT_TIMEZONE);</span>

		// Need to convert dtStart to a local date in GMT, since we will compare
		// it to the alignmentDate, which is also a local date in GMT.
<span class="nc" id="L1713">		LocalDate viewStartDateLocal = new LocalDate(dtStart, tzCampaign);</span>
<span class="nc" id="L1714">		Calendar viewStartDate = viewStartDateLocal.getCal();</span>

		// get number of weeks round
<span class="nc" id="L1717">		int weeks = Math</span>
<span class="nc" id="L1718">				.abs((int) ((viewStartDate.getTime().getTime() - alignmentDate.getTime()) / (TimeZoneUtil.DAY_IN_MILLISECONDS * 7)));</span>
<span class="nc" id="L1719">		int nWeek = (weeks % wr.getNumWeeksInRotation() + wr.getStartWeekOffSet()) % wr.getNumWeeksInRotation();</span>

<span class="nc" id="L1721">		Rotation rotation = wr.getRotation();</span>
<span class="nc" id="L1722">		List&lt;ShiftPattern&gt; shiftPatterns = rotation.getShiftPatterns();</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">		if (shiftPatterns.size() &lt; (nWeek + 1)) {</span>
<span class="nc" id="L1724">			System.out</span>
<span class="nc" id="L1725">					.println(&quot;Warning: The number of shiftPatterns doesn't match getNumWeeksInRotation() for employee &quot;</span>
<span class="nc" id="L1726">							+ wr.getWorkResourceID());</span>
<span class="nc" id="L1727">			return null;</span>
		} else {
<span class="nc" id="L1729">			return wr.getRotation().getShiftPatterns().get(new Integer(nWeek));</span>
		}
	}

	private static void checkWorkPatternConflict(ShiftsConflictData conflictData, ShiftPattern pPattern,
			Date dtStart, Date dtEnd, Collection&lt;ShiftsConflict&gt; llConflicts) {
<span class="nc" id="L1735">		Collection&lt;ShiftsConflict&gt; cConflicts = getWorkPatternConsistentShiftEvent(conflictData, pPattern, dtStart, dtEnd);</span>
<span class="nc" id="L1736">		llConflicts.addAll(cConflicts);</span>

<span class="nc" id="L1738">		cConflicts = getWorkPatternConsistentStart(conflictData, pPattern, dtStart, dtEnd);</span>
<span class="nc" id="L1739">		llConflicts.addAll(cConflicts);</span>

		// min max consecutive days for the Work Pattern
<span class="nc" id="L1742">		Collection shifts = pPattern.getRelatedObjects(ShiftPattern.SHIFT_RELATIONSHIP_KEY);</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">		if (shifts != null) {</span>
<span class="nc" id="L1744">			Shift shift = null;</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">			for (Iterator iShift = shifts.iterator(); iShift.hasNext();) {</span>
<span class="nc" id="L1746">				shift = (Shift) iShift.next();</span>
<span class="nc" id="L1747">				int minConsecutiveDays = pPattern.getMinConsecutiveDays(shift.getDEID());</span>
<span class="nc" id="L1748">				int maxConsecutiveDays = pPattern.getMaxConsecutiveDays(shift.getDEID());</span>
<span class="nc" id="L1749">				cConflicts = getMinMaxConsecutiveDaysForShiftConflicts(conflictData.getShiftAssignmentWithInPeriod(dtStart, dtEnd),</span>
<span class="nc" id="L1750">					shift, minConsecutiveDays, maxConsecutiveDays, dtStart, dtEnd, conflictData.getEmpOrg());</span>
<span class="nc" id="L1751">				llConflicts.addAll(cConflicts);</span>
<span class="nc" id="L1752">			}</span>
		}
<span class="nc" id="L1754">	}</span>

	public static Collection&lt;TimeSpan&gt; getOrgDaySpan(Date dtStart, Date dtEnd, Organization pOrg) {
		// create a span for each org day in the range...
<span class="nc" id="L1758">		LinkedList&lt;TimeSpan&gt; llDaySpans = new LinkedList&lt;TimeSpan&gt;();</span>
		// calendar for org day start
<span class="nc" id="L1760">		Calendar cOrgDayStart = Calendar.getInstance(pOrg.getTimeZone());</span>
		// calendar for org day end.
<span class="nc" id="L1762">		Calendar cOrgDayEnd = Calendar.getInstance(pOrg.getTimeZone());</span>

		// compute org day start.
<span class="nc" id="L1765">		cOrgDayStart.setTime(dtStart);</span>
		// set the day boundary and start time
<span class="nc" id="L1767">		cOrgDayStart.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / 60);</span>
<span class="nc" id="L1768">		cOrgDayStart.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % 60);</span>
<span class="nc" id="L1769">		cOrgDayStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1770">		cOrgDayStart.set(Calendar.MILLISECOND, 0);</span>

		// check if day start is after start date, set day start to 1 day in the
		// past
<span class="nc bnc" id="L1774" title="All 2 branches missed.">		if (cOrgDayStart.getTime().after(dtStart)) {</span>
<span class="nc" id="L1775">			cOrgDayStart.add(Calendar.DATE, -1);</span>
		}

		// compute org day end.
<span class="nc" id="L1779">		cOrgDayEnd.setTime(cOrgDayStart.getTime());</span>
<span class="nc" id="L1780">		cOrgDayEnd.add(Calendar.DATE, 1);</span>

		// identify org days that encompass the given time range (dtSTart,
		// dtEnd)
<span class="nc bnc" id="L1784" title="All 2 branches missed.">		while (cOrgDayStart.getTime().before(dtEnd)) {</span>
			// System.out.println(cOrgDayStart.getTime());
			// System.out.println(cOrgDayEnd.getTime());
<span class="nc" id="L1787">			llDaySpans.add(new TimeSpan(cOrgDayStart.getTime(), cOrgDayEnd.getTime()));</span>
<span class="nc" id="L1788">			cOrgDayStart.setTime(cOrgDayEnd.getTime());</span>
<span class="nc" id="L1789">			cOrgDayEnd.add(Calendar.DATE, 1);</span>
		}
<span class="nc" id="L1791">		return llDaySpans;</span>
	}

	/**
	 * Get the minConsecutiveDays, maxConsecutiveDays conflicts, as determined
	 * by an employee's WorkPattern/Shift combination.
	 *
	 * @param cEvents
	 *            - All of the Events that occur during the date range.
	 * @param shift
	 *            - The shift that we need to check for. The employee should be
	 *            scheduled between the min and max number of these shifts
	 *            within the date range.
	 * @param minConsecutiveDays
	 *            - The minimum consecutive days as defined by the work pattern.
	 * @param maxConsecutiveDays
	 *            - The maximum consecutive days as defined by the work pattern.
	 * @param dtStart
	 *            - the start of the period to check (1 week, since work
	 *            patterns are weekly/monthly)
	 * @param dtEnd
	 *            - the end of the period (1 week, since work patterns are
	 *            weekly/monthly)
	 * @param pOrg
	 *            - the employee's organization
	 * @return - Any min or max conflicts that are found.
	 */
	public static Collection&lt;ShiftsConflict&gt; getMinMaxConsecutiveDaysForShiftConflicts(
			Collection&lt;? extends Event&gt; cEvents, Shift shift, int minConsecutiveDays, int maxConsecutiveDays,
			Date dtStart, Date dtEnd, Organization pOrg) {

<span class="nc bnc" id="L1822" title="All 2 branches missed.">		if (cEvents.isEmpty()) {</span>
<span class="nc" id="L1823">			return new LinkedList&lt;ShiftsConflict&gt;();</span>
		}

<span class="nc" id="L1826">		Collection&lt;TimeSpan&gt; llDaySpans = getOrgDaySpan(dtStart, dtEnd, pOrg);</span>

<span class="nc" id="L1828">		LinkedList&lt;ShiftsConflict&gt; llNewConflicts = new LinkedList&lt;ShiftsConflict&gt;();</span>
<span class="nc" id="L1829">		int numConsecShifts = 0;</span>
<span class="nc" id="L1830">		Date conflictDate = null;</span>

		// sort cEvents because they are not necessarily in order
<span class="nc" id="L1833">		ArrayList&lt;Event&gt; aEvents = new ArrayList&lt;Event&gt;(cEvents);</span>
<span class="nc" id="L1834">		Collections.sort(aEvents, new StartTimeComparator());</span>

		// iterate through each org day in the range
<span class="nc bnc" id="L1837" title="All 2 branches missed.">		for (Iterator&lt;TimeSpan&gt; l = llDaySpans.iterator(); l.hasNext();) {</span>
<span class="nc" id="L1838">			TimeSpan daySpan = l.next();</span>
<span class="nc" id="L1839">			boolean hasShiftThisDay = false;</span>
<span class="nc" id="L1840">			boolean hasAnyShiftThisDay = false;</span>
<span class="nc" id="L1841">			Event pEvent = null;</span>

			// iterate through shift assignments
<span class="nc bnc" id="L1844" title="All 2 branches missed.">			for (Iterator&lt;Event&gt; i = aEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1845">				pEvent = i.next();</span>
				// if shift assignment starts in this org day.
<span class="nc bnc" id="L1847" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriodAndApproved(pEvent, daySpan.dtSpanStart, daySpan.dtSpanEnd, Config.STARTSIN)) {</span>
<span class="nc bnc" id="L1848" title="All 2 branches missed.">					if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1849">						hasAnyShiftThisDay = true;</span>
<span class="nc bnc" id="L1850" title="All 2 branches missed.">						if (((ShiftAssignment) pEvent).getShiftID() != null &amp;&amp; ((ShiftAssignment) pEvent).getShiftID()</span>
<span class="nc bnc" id="L1851" title="All 2 branches missed.">								.equals(shift.getID())) {</span>
<span class="nc" id="L1852">							hasShiftThisDay = true;</span>
<span class="nc" id="L1853">							break;</span>
						}
					}
				}
			}
<span class="nc bnc" id="L1858" title="All 2 branches missed.">			if (!hasAnyShiftThisDay) {</span>
				// check if it is shift_off and there is no shift,
				// hasShiftThisDay should be true
<span class="nc bnc" id="L1861" title="All 2 branches missed.">				if (&quot;SHIFT_OFF&quot;.equals(shift.getDEID().toString().trim())) {</span>
<span class="nc" id="L1862">					hasShiftThisDay = true;</span>
				}
			}

<span class="nc bnc" id="L1866" title="All 2 branches missed.">			if (hasShiftThisDay) {</span>
<span class="nc" id="L1867">				numConsecShifts++;</span>
<span class="nc bnc" id="L1868" title="All 4 branches missed.">				if (maxConsecutiveDays &gt; 0 &amp;&amp; numConsecShifts &gt; maxConsecutiveDays) {</span>
					// for off days, we can't use pEvent getStartTime
<span class="nc" id="L1870">					conflictDate = daySpan.dtSpanStart;</span>
<span class="nc" id="L1871">					ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_MAXCONSECUTIVEDAY, numConsecShifts</span>
							- maxConsecutiveDays, conflictDate);
					//consecutive day setting
<span class="nc" id="L1874">					cConflict.setDoubleTarget(maxConsecutiveDays);</span>
					//shift name
<span class="nc" id="L1876">					cConflict.setTarget(shift.getName());</span>
<span class="nc" id="L1877">					llNewConflicts.add(cConflict);</span>
<span class="nc" id="L1878">					break;</span>
				}
			} else {
<span class="nc bnc" id="L1881" title="All 6 branches missed.">				if (numConsecShifts &gt; 0 &amp;&amp; minConsecutiveDays &gt; 0 &amp;&amp; (numConsecShifts &lt; minConsecutiveDays)) {</span>
					// for off days, we can't use pEvent getStartTime
<span class="nc" id="L1883">					conflictDate = daySpan.dtSpanStart;</span>
<span class="nc" id="L1884">					ShiftsConflict cConflict = new ShiftsConflict(ShiftsConflict.ORG_MINCONSECUTIVEDAY,</span>
							minConsecutiveDays - numConsecShifts, conflictDate);
					//consecutive day setting
<span class="nc" id="L1887">					cConflict.setDoubleTarget(minConsecutiveDays);</span>
					// shift name
<span class="nc" id="L1889">					cConflict.setTarget(shift.getName());</span>
<span class="nc" id="L1890">					llNewConflicts.add(cConflict);</span>
				}
<span class="nc" id="L1892">				numConsecShifts = 0;</span>
			}
<span class="nc" id="L1894">		}</span>
<span class="nc" id="L1895">		return llNewConflicts;</span>
	}

	// because of BUG in JROCKIT JVM 1.4_05 bug on DST transition for brazil
	// use this function to move to the next day for the calendar
	public static void addDaysToCalendar(Calendar cal, int days) {
<span class="nc" id="L1901">		cal.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH) + days);</span>
<span class="nc" id="L1902">	}</span>

	/**
	 * Compute the next day for the given date, retaining the hour, minute and
	 * seconds. For instance, if the given date is 11:53AM 1/1/2001, this
	 * returns 11:53AM, 1/2/2001.
	 * &lt;p/&gt;
	 * Simply adding 24 * 60 * 60 * 1000 to the given date will not work for
	 * days on which the DST starts or ends. Use a calendar to handle this case.
	 *
	 * @param date
	 * @param tz
	 * @return
	 */
	public static Date getDateForwardOneDay(Date date, TimeZone tz) {
<span class="nc" id="L1917">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1918">		cal.setTime(date);</span>
<span class="nc" id="L1919">		addDaysToCalendar(cal, 1);</span>
		// cal.add(Calendar.DAY_OF_MONTH, 1); //move to next day

<span class="nc" id="L1922">		return cal.getTime();</span>
	}

	/**
	 * Compute the previous day for the given date, retaining the hour, minute
	 * and seconds. For instance, if the given date is 11:53AM 1/2/2001, this
	 * returns 11:53AM, 1/1/2001.
	 * &lt;p/&gt;
	 * Simply adding 24 * 60 * 60 * 1000 to the given date will not work for
	 * days on which the DST starts or ends. Use a calendar to handle this case.
	 *
	 * @param date
	 * @param tz
	 * @return
	 */
	public static Date getDateBackwardOneDay(Date date, TimeZone tz) {
<span class="nc" id="L1938">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1939">		cal.setTime(date);</span>
<span class="nc" id="L1940">		addDaysToCalendar(cal, -1);</span>

<span class="nc" id="L1942">		return cal.getTime();</span>
	}

	public static Date extendStartDays(Date startDate, Organization org) {
<span class="nc" id="L1946">		Date tempStartDate = new Date(startDate.getTime());</span>
		// For MaxConsecutiveWorkingDaysRule only
		// This fix is for SP crossing validation
<span class="nc bnc" id="L1949" title="All 2 branches missed.">		for (int i = 1; i &lt;= org.getMaxConsecutiveWorkingDay(); i++) {</span>
<span class="nc" id="L1950">			tempStartDate = getDateBackwardOneDay(tempStartDate, org.getTimeZone());</span>
		}
<span class="nc" id="L1952">		return tempStartDate;</span>
	}

	public static Date extendEndDays(Date endDate, Organization org) {
<span class="nc" id="L1956">		Date tempEndDate = new Date(endDate.getTime());</span>
		// For MaxConsecutiveWorkingDaysRule only
		// This fix is for SP crossing validation
<span class="nc bnc" id="L1959" title="All 2 branches missed.">		for (int i = 1; i &lt;= org.getMaxConsecutiveWorkingDay(); i++) {</span>
<span class="nc" id="L1960">			tempEndDate = getDateForwardOneDay(tempEndDate, org.getTimeZone());</span>
		}
<span class="nc" id="L1962">		return tempEndDate;</span>
	}

	/**
	 * &lt;B&gt;getExpandedWindowForEmployee&lt;/B&gt; returns a Pair of Dates (Start Date,
	 * End Date) which is an expanded version of the Start End Date passed in
	 * The expanded Start Date will have enough look back to validate all Shift
	 * Rules and WorkRules
	 * &lt;P&gt;
	 *
	 * @param dtStart
	 *            the start date of the window for validation
	 * @param dtEnd
	 *            the end date of the window for validation
	 * @param hOrgs
	 *            all Orgs which the Work Resource or WorkRules are defined in
	 * @param cOrgAssignments
	 *            the Work Resource's Org Assignments
	 * @param hWorkRules
	 *            a Collection containing all WorkRules assigned to the Work
	 *            Resource indexed by ID
	 *            &lt;P&gt;
	 * @return (StartDate, EndDate) Pair
	 */
	public static Pair&lt;Date, Date&gt; getExpandedWindowForEmployee(Date dtStart, Date dtEnd, Collection cOrgAssignments,
			Map&lt;ID, Organization&gt; hOrgs, Collection cRuleAssignments, HashMap hWorkRules) throws WorkRuleException {
<span class="nc" id="L1988">		ID idOrg = ((WorkResourceAssignment) cOrgAssignments.iterator().next()).getOrganizationID();</span>
<span class="nc" id="L1989">		Organization pOrg = hOrgs.get(idOrg);</span>
<span class="nc" id="L1990">		Calendar cCalendar = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L1991">		cCalendar.setTime(dtStart);</span>

<span class="nc" id="L1993">		int nDay = 0;</span>

<span class="nc bnc" id="L1995" title="All 2 branches missed.">		if (cCalendar.get(Calendar.DAY_OF_WEEK) != pOrg.getWeekStartDate()) {</span>
<span class="nc" id="L1996">			nDay = cCalendar.get(Calendar.DAY_OF_WEEK) - pOrg.getWeekStartDate();</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">			if (nDay &lt; 0) {</span>
<span class="nc" id="L1998">				nDay += 7;</span>
			}
<span class="nc bnc" id="L2000" title="All 2 branches missed.">		} else if (cCalendar.get(Calendar.HOUR) * 60 &lt; pOrg.getDayBoundaryOffset()) {</span>
<span class="nc" id="L2001">			nDay = 7;</span>
		}

<span class="nc" id="L2004">		cCalendar.add(Calendar.DAY_OF_YEAR, -1 * nDay);</span>
<span class="nc" id="L2005">		cCalendar.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset());</span>

<span class="nc" id="L2007">		Date dtExpandedStart = cCalendar.getTime();</span>
<span class="nc" id="L2008">		Date dtExpandedEnd = dtEnd;</span>

<span class="nc" id="L2010">		ArrayList&lt;WorkRule&gt; aWorkRules = new ArrayList&lt;WorkRule&gt;();</span>
<span class="nc" id="L2011">		ComplexWorkRule cWorkRule = null;</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">		for (Iterator i = cRuleAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2013">			WorkResourceComplexWorkRule pAssignment = (WorkResourceComplexWorkRule) i.next();</span>
<span class="nc" id="L2014">			cWorkRule = (ComplexWorkRule) hWorkRules.get(pAssignment.getComplexWorkRuleID());</span>
<span class="nc" id="L2015">			aWorkRules.add(new WorkRule(cWorkRule, null)); // ExpandRuleWindow</span>
															// API only takes
															// workrule objects
<span class="nc" id="L2018">		}</span>

<span class="nc" id="L2020">		Pair&lt;LocalDate, LocalDate&gt; pWindow = WorkRuleUtil.ExpandRuleWindow(aWorkRules, new LocalDate(dtStart),</span>
				new LocalDate(dtEnd));

<span class="nc" id="L2023">		Date dtWorkRuleStart = pWindow.getFirst().getTime(pOrg.getTimeZone());</span>
<span class="nc" id="L2024">		Date dtWorkRuleEnd = pWindow.getSecond().getTime(pOrg.getTimeZone());</span>

<span class="nc bnc" id="L2026" title="All 2 branches missed.">		if (dtWorkRuleStart.before(dtExpandedStart)) {</span>
<span class="nc" id="L2027">			dtExpandedStart = dtWorkRuleStart;</span>
		}
<span class="nc bnc" id="L2029" title="All 2 branches missed.">		if (dtWorkRuleEnd.after(dtExpandedEnd)) {</span>
<span class="nc" id="L2030">			dtExpandedEnd = dtWorkRuleEnd;</span>
		}

		// GQ for QC94660: Conflict checking date range needs to include
		// past/future sp's for MaxConsecutiveWorkingDays.
<span class="nc" id="L2035">		Date expandedStartForMaxConsecutiveDaysCheck = extendStartDays(dtStart, pOrg);</span>
<span class="nc" id="L2036">		Date expandedEndForMaxConsecutiveDaysCheck = extendEndDays(dtEnd, pOrg);</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">		if (expandedStartForMaxConsecutiveDaysCheck.before(dtExpandedStart)) {</span>
<span class="nc" id="L2038">			dtExpandedStart = expandedStartForMaxConsecutiveDaysCheck;</span>
		}
<span class="nc bnc" id="L2040" title="All 2 branches missed.">		if (expandedEndForMaxConsecutiveDaysCheck.after(dtExpandedEnd)) {</span>
<span class="nc" id="L2041">			dtExpandedEnd = expandedEndForMaxConsecutiveDaysCheck;</span>
		}

<span class="nc" id="L2044">		return new Pair&lt;Date, Date&gt;(dtExpandedStart, dtExpandedEnd);</span>

	}

	/**
	 * &lt;B&gt;getAllAlertsForEmployee&lt;/B&gt; returns Alerts for a single Employee's
	 * Schedule, see ShiftsConflict.java, Alert.java, and CommonConflict.java
	 * for a list of Alert types. For all the collections (cEvents,
	 * cMinMaxHours, etc...) and all the HashMaps (hShifts, hWorkPatterns,
	 * etc...) except hWorkRules any additional unneeded entries will be
	 * ignored, so is fine to pass in a superset of the required entries.
	 * &lt;P&gt;
	 *
     * @param conflictData
     *            shiftsconflictData for generating conflicts
	 *            &lt;P&gt;
	 * @return Collection of Alerts (both CommonConflict and ShiftsConflict
	 *         objects!)
	 */
	public static Collection&lt;Alert&gt; getAllAlertsForEmployee(ShiftsConflictData conflictData)
			throws WorkRuleException {

<span class="nc bnc" id="L2066" title="All 2 branches missed.">		if (conflictData.getEmpOrg() == null) {</span>
<span class="nc" id="L2067">			return new ArrayList&lt;Alert&gt;();</span>
		}

<span class="nc" id="L2070">		Collection&lt;CommonConflict&gt; cEmpConflicts = WorkRuleUtil.getConflictsForEmployee(conflictData);</span>

<span class="nc bnc" id="L2072" title="All 2 branches missed.">		for (Iterator&lt;CommonConflict&gt; i = cEmpConflicts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2073">			CommonConflict pConflict = i.next();</span>
<span class="nc" id="L2074">			pConflict.SetWorkResourceName(conflictData.getEmpName());</span>
<span class="nc" id="L2075">		}</span>

<span class="nc" id="L2077">		Collection&lt;ShiftsConflict&gt; cShiftAlerts = ShiftsUtil.getAllShiftConflictsForEmployee(conflictData);</span>
<span class="nc" id="L2078">		Collection&lt;Alert&gt; cAlerts = new ArrayList&lt;Alert&gt;(cEmpConflicts);</span>
<span class="nc" id="L2079">		cAlerts.addAll(cShiftAlerts);</span>

<span class="nc" id="L2081">		return cAlerts;</span>
	}

	public static boolean isShiftAssignmentCustomized(ShiftAssignment sa, Shift shift, TimeZone shiftTZ,
			Map&lt;ID, String&gt; customizedReasonCache, Localizer localizer, ResourceBundle bbmBundle, int dayBoundary) {
<span class="nc bnc" id="L2086" title="All 2 branches missed.">		if (bbmBundle == null) {</span>
<span class="nc" id="L2087">			bbmBundle = localizer.getBundle(BbmEjbBundleKey.BUNDLE_NAME);</span>
		}
<span class="nc" id="L2089">		Object[] aArgs = null;</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">		if (shift == null) {</span>
			// IDS_CUSTOM_SHIFT_NOTFOUND
<span class="nc" id="L2092">			customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2093">					MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_NOTFOUND), (Object[]) null));</span>
<span class="nc" id="L2094">			return true;</span>
<span class="nc bnc" id="L2095" title="All 2 branches missed.">		} else if (shift.isDeleted()) {</span>
			// ID_CUSTOM_SHIFT_NOTEXIST
<span class="nc" id="L2097">			customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2098">					MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.ID_CUSTOM_SHIFT_NOTEXIST), (Object[]) null));</span>
<span class="nc" id="L2099">			return true;</span>
		}

		// check if length of the shift assignment is the same as the shift
		// definition
		// IDS_CUSTOM_SHIFT_LENGTH
		// This call assumes duration includes ot.
<span class="nc bnc" id="L2106" title="All 4 branches missed.">		if ((EventUtils.isOTShift(sa) &amp;&amp; sa.getDuration() != shift.getDuration())</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">				|| (!EventUtils.isOTShift(sa) &amp;&amp; (sa.getDuration() - sa.getExtensionAfter() - sa.getExtensionBefore()) != shift</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">						.getDuration())) {</span>
<span class="nc" id="L2109">			aArgs = new Object[] { localizer.formatDurationInMins(sa.getDuration()),</span>
<span class="nc" id="L2110">					localizer.formatDurationInMins(shift.getDuration()) };</span>
<span class="nc" id="L2111">			customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2112">					MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_LENGTH), aArgs));</span>
<span class="nc" id="L2113">			return true;</span>
		}
		// IDS_CUSTOME_SHIFT_ACTIVITY
<span class="nc bnc" id="L2116" title="All 2 branches missed.">		if (!sa.getActivityID().equals(shift.getActivityID())) {</span>
<span class="nc" id="L2117">			customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2118">					MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOME_SHIFT_ACTIVITY), (Object[]) null));</span>
<span class="nc" id="L2119">			return true;</span>
		}
		// IDS_CUSTOM_SHIFT_NOSTARTTIME
<span class="nc bnc" id="L2122" title="All 4 branches missed.">		if (shift.getStartTimes() == null || shift.getStartTimes().isEmpty()) {</span>
<span class="nc" id="L2123">			customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2124">					MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_NOSTARTTIME), (Object[]) null));</span>
<span class="nc" id="L2125">			return true;</span>
		}
		// IDS_CUSTOM_SHIFT_STARTTIME
<span class="nc" id="L2128">		Calendar cCalendar = Calendar.getInstance(shiftTZ);</span>
<span class="nc" id="L2129">		cCalendar.setTime(getShiftStartConsiderOT(cCalendar, sa));</span>
<span class="nc" id="L2130">		TimeOfDay tShiftStart = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY), cCalendar.get(Calendar.MINUTE));</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">        if (dayBoundary &gt; 0) {</span>
<span class="nc" id="L2132">            tShiftStart = tShiftStart.addMinutes(-dayBoundary);</span>
		}
<span class="nc bnc" id="L2134" title="All 2 branches missed.">		if (!shift.getStartTimes().contains(tShiftStart)) {</span>
<span class="nc" id="L2135">			ArrayList list = (ArrayList) shift.getStartTimes();</span>
<span class="nc" id="L2136">			Collections.sort(list);</span>
<span class="nc" id="L2137">			StringBuffer possibleStarts = new StringBuffer(200);</span>
<span class="nc" id="L2138">			TimeOfDay start = null;</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">			for (Iterator i = list.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2140">				start = (TimeOfDay) i.next();</span>
<span class="nc" id="L2141">				possibleStarts.append(start.getHours() + &quot;:&quot; + getMinuteString(start.getMinutes()));</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">				if (i.hasNext()) {</span>
<span class="nc" id="L2143">					possibleStarts.append(&quot;,&quot;);</span>
				}
			}
<span class="nc" id="L2146">			aArgs = new Object[] { possibleStarts.toString() };</span>
<span class="nc" id="L2147">			customizedReasonCache.put(sa.getID(),</span>
<span class="nc" id="L2148">					MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_STARTTIME), aArgs));</span>
<span class="nc" id="L2149">			return true;</span>
		}

		//check each shift activity (not optional shift activity and not events on ot)
		//IDS_CUSTOM_SHIFT_NUM_EVENTS: if shift assignment has different numbers of shift events than the shift definition.
<span class="nc" id="L2154">		ShiftEventAssignment event = null;</span>
<span class="nc" id="L2155">		Map&lt;ID,Integer&gt; mandatoryIDMap = shift.getMandatoryShiftEventsID();</span>
<span class="nc" id="L2156">		Map&lt;ID,Integer&gt; shiftEventIDMap = new HashMap&lt;ID,Integer&gt;();</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">		for (Iterator i = sa.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2158">			event = (ShiftEventAssignment)i.next();</span>
<span class="nc bnc" id="L2159" title="All 4 branches missed.">			if (event.getStartTime().before(sa.getEndTime()) &amp;&amp; event.getEndTime().after(sa.getStartTime())){ //rule out over time events</span>
<span class="nc bnc" id="L2160" title="All 2 branches missed.">				if(shiftEventIDMap.containsKey(event.getShiftEventID())) {</span>
<span class="nc" id="L2161">					shiftEventIDMap.put(event.getShiftEventID(), shiftEventIDMap.get(event.getShiftEventID())+1);</span>
				} else {
<span class="nc" id="L2163">					shiftEventIDMap.put(event.getShiftEventID(), 1);</span>
				}
			}
		}

<span class="nc" id="L2168">		Iterator it = mandatoryIDMap.entrySet().iterator();</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">		while (it.hasNext()) {</span>
<span class="nc" id="L2170">		     Map.Entry&lt;ID, Integer&gt; pairs = (Map.Entry)it.next();</span>
<span class="nc bnc" id="L2171" title="All 2 branches missed.">		     if(!shiftEventIDMap.containsKey(pairs.getKey())</span>
<span class="nc bnc" id="L2172" title="All 2 branches missed.">		       	|| shiftEventIDMap.get(pairs.getKey())&lt;pairs.getValue()){</span>
<span class="nc" id="L2173">		   		aArgs = new Object[]{new Integer(pairs.getValue()), new Integer(mandatoryIDMap.get(pairs.getKey()))};</span>
<span class="nc" id="L2174">				customizedReasonCache.put(sa.getID(), MessageFormat.format(localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_NUM_EVENTS), aArgs));</span>
<span class="nc" id="L2175">				return true;</span>
		     }
<span class="nc" id="L2177">		}</span>

<span class="nc bnc" id="L2179" title="All 2 branches missed.">		for (Iterator i = sa.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2180">			event = (ShiftEventAssignment)i.next();</span>
<span class="nc bnc" id="L2181" title="All 2 branches missed.">            if (isShiftEventAssignmentCustomized(sa, event, shift, shiftTZ, customizedReasonCache, localizer, bbmBundle,</span>
            		dayBoundary)) {
<span class="nc" id="L2183">				return true;</span>
			}
		}

<span class="nc" id="L2187">		customizedReasonCache.remove(sa.getID());</span>
<span class="nc" id="L2188">		return false;</span>
	}

	private static Date getShiftStartConsiderOT(Calendar cCalendar, ShiftAssignment sa) {
<span class="nc" id="L2192">		cCalendar.setTime(sa.getStartTime());</span>
<span class="nc" id="L2193">		cCalendar.add(Calendar.MINUTE, sa.getExtensionBefore());</span>
<span class="nc" id="L2194">		return cCalendar.getTime();</span>
	}

	public static boolean isShiftEventAssignmentCustomized(ShiftAssignment sa, ShiftEventAssignment event, Shift shift, TimeZone shiftTZ,
            Map&lt;ID, String&gt; customizedReasonCache, Localizer localizer, ResourceBundle bbmBundle, int dayBoundary) {
<span class="nc bnc" id="L2199" title="All 2 branches missed.">		if (bbmBundle == null) {</span>
<span class="nc" id="L2200">			bbmBundle = localizer.getBundle(BbmEjbBundleKey.BUNDLE_NAME);</span>
		}
<span class="nc" id="L2202">		int eventStartInMinutes = 0;</span>
<span class="nc" id="L2203">		ShiftEvent shiftEvent = null;</span>
<span class="nc" id="L2204">		Object[] aArgs = null;</span>
<span class="nc" id="L2205">		Calendar cCalendar = Calendar.getInstance(shiftTZ);</span>
<span class="nc" id="L2206">		TimeRange mainTimeRange = sa.getMainShiftTimeRange();</span>
<span class="nc bnc" id="L2207" title="All 2 branches missed.">		if (!event.getStartTime().before(mainTimeRange.getStartDate())</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">				&amp;&amp; !event.getEndTime().after(mainTimeRange.getEndDate())) { // rule</span>
																			// out
																			// over
																			// time
																			// events
<span class="nc bnc" id="L2213" title="All 2 branches missed.">			if (shift != null) {</span>
<span class="nc" id="L2214">				shiftEvent = shift.getShiftEvent(event.getShiftEventID());</span>
			}
<span class="nc bnc" id="L2216" title="All 2 branches missed.">			if (shiftEvent != null) {</span>
<span class="nc bnc" id="L2217" title="All 2 branches missed.">				if (shiftEvent.isCafeteria()) { // absolute start time</span>
<span class="nc" id="L2218">					cCalendar.setTime(event.getStartTime());</span>
<span class="nc" id="L2219">					eventStartInMinutes = cCalendar.get(Calendar.HOUR_OF_DAY) * 60 + cCalendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L2220">					eventStartInMinutes -= dayBoundary; // even for absolute</span>
															// start time, the
															// start/end minutes
															// consider the day
															// boundary offset
															// before storing
															// them in db. here,
															// we have to take
															// it out. QC98032
				} else {
<span class="nc" id="L2230">					eventStartInMinutes = (int) (event.getStartTime().getTime() - getShiftStartConsiderOT(cCalendar, sa)</span>
<span class="nc" id="L2231">							.getTime()) / TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
				}
<span class="nc" id="L2233">				int numOfEvents = sa.getNumOfShiftEventAssignments(shiftEvent.getID());</span>
<span class="nc bnc" id="L2234" title="All 4 branches missed.">				if ((!shiftEvent.isFlexible() &amp;&amp; numOfEvents != 1)</span>
<span class="nc bnc" id="L2235" title="All 4 branches missed.">						|| (shiftEvent.isFlexible() &amp;&amp; (numOfEvents &lt; shiftEvent.getMinCount() || numOfEvents &gt; shiftEvent</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">								.getMaxCount()))) {</span>
					// IDS_CUSTOM_SHIFT_EVENT_NUM
<span class="nc" id="L2238">					customizedReasonCache</span>
<span class="nc" id="L2239">							.put(sa.getID(),</span>
<span class="nc" id="L2240">									MessageFormat.format(</span>
<span class="nc" id="L2241">											localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_NUM), (Object[]) null));</span>
<span class="nc" id="L2242">					return true;</span>
				}
				// IDS_CUSTOM_SHIFT_EVENT_ACTIVITY
<span class="nc bnc" id="L2245" title="All 2 branches missed.">				if (!event.getActivityID().equals(shiftEvent.getActivityID())) {</span>
<span class="nc" id="L2246">					boolean isCustomized = true;</span>
<span class="nc bnc" id="L2247" title="All 2 branches missed.">					if (shiftEvent.isFlexible()) {</span>
						// there could be additional activities
<span class="nc" id="L2249">						Collection&lt;Activity&gt; aList = shiftEvent.getAdditionalActivities();</span>
<span class="nc bnc" id="L2250" title="All 2 branches missed.">						for (Iterator&lt;Activity&gt; i = aList.iterator(); i.hasNext();) {</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">							if (event.getActivityID().equals(i.next().getID())) {</span>
<span class="nc" id="L2252">								isCustomized = false;</span>
							}
						}
					}
<span class="nc bnc" id="L2256" title="All 2 branches missed.">					if (isCustomized) {</span>
<span class="nc" id="L2257">						customizedReasonCache.put(</span>
<span class="nc" id="L2258">								sa.getID(),</span>
<span class="nc" id="L2259">								MessageFormat.format(</span>
<span class="nc" id="L2260">										localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_ACTIVITY), (Object[]) null));</span>
<span class="nc" id="L2261">						return true;</span>
					}
				}
				// IDS_CUSTOM_SHIFT_EVENT_LENGTH
<span class="nc bnc" id="L2265" title="All 2 branches missed.">				if (event.getDuration() != shiftEvent.getDuration().getDurationInMinutes()) {</span>
<span class="nc" id="L2266">					aArgs = new Object[] { shiftEvent.getName(), localizer.formatDurationInMins(event.getDuration()),</span>
<span class="nc" id="L2267">							localizer.formatDurationInMins(shiftEvent.getDuration().getDurationInMinutes()) };</span>
<span class="nc" id="L2268">					customizedReasonCache.put(sa.getID(), MessageFormat.format(</span>
<span class="nc" id="L2269">							localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_LENGTH), aArgs));</span>
<span class="nc" id="L2270">					return true;</span>
				}
				// IDS_CUSTOME_SHIFT_EVENT_PAID
<span class="nc bnc" id="L2273" title="All 2 branches missed.">				if (event.getPaid() != shiftEvent.isPaid()) {</span>
<span class="nc" id="L2274">					customizedReasonCache.put(sa.getID(), MessageFormat.format(</span>
<span class="nc" id="L2275">							localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOME_SHIFT_EVENT_PAID), (Object[]) null));</span>
<span class="nc" id="L2276">					return true;</span>
				}
				// IDS_CUSTOM_SHIFT_EVENT_STARTTIME
<span class="nc" id="L2279">				cCalendar.setTime(getShiftStartConsiderOT(cCalendar, sa));</span>
<span class="nc" id="L2280">				TimeOfDay tShiftStart = new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY),</span>
<span class="nc" id="L2281">						cCalendar.get(Calendar.MINUTE));</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">				if (!shiftEvent.isAnyTime()</span>
<span class="nc bnc" id="L2283" title="All 2 branches missed.">						&amp;&amp; (eventStartInMinutes &lt; shiftEvent.getStart() </span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">						|| eventStartInMinutes &gt; (shiftEvent.getEnd() + shiftEvent.getDuration().getDurationInMinutes()))) {</span>
					// 15 minutes tolerance: duration + diff &lt;= 15, not consider as conflict
<span class="nc" id="L2286">					if (Math.min(Math.abs(eventStartInMinutes - shiftEvent.getStart()),</span>
<span class="nc" id="L2287">							Math.abs(eventStartInMinutes - shiftEvent.getEnd()))</span>
<span class="nc bnc" id="L2288" title="All 2 branches missed.">							+ event.getDuration() &gt; 15) {</span>
<span class="nc" id="L2289">						TimeOfDay shiftEventStart = getShiftEventTimeOfDay(shiftEvent, shiftEvent.getStart(), tShiftStart);</span>
<span class="nc" id="L2290">						TimeOfDay shiftEventEnd = getShiftEventTimeOfDay(shiftEvent, shiftEvent.getEnd() +</span>
<span class="nc" id="L2291">							event.getDuration(), tShiftStart);</span>
<span class="nc" id="L2292">						aArgs = new Object[] {</span>
<span class="nc" id="L2293">								shiftEvent.getName(),</span>
<span class="nc" id="L2294">							formatCustomShiftTimeRange(shiftEventStart, shiftEventEnd)};</span>
<span class="nc" id="L2295">						customizedReasonCache.put(</span>
<span class="nc" id="L2296">								sa.getID(),</span>
<span class="nc" id="L2297">								MessageFormat.format(</span>
<span class="nc" id="L2298">										localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOM_SHIFT_EVENT_STARTTIME), aArgs));</span>
<span class="nc" id="L2299">						return true;</span>
					}
				}
<span class="nc bnc" id="L2302" title="All 6 branches missed.">			} else if (event.getID() != null &amp;&amp; (event.getOverTimeGapType() != 2 &amp;&amp; event.getOverTimeGapType() != 1)) {</span>
				// IDS_CUSTOME_SHIFT_EVENT_NOTEXIST
<span class="nc" id="L2304">				customizedReasonCache.put(sa.getID(), MessageFormat.format(</span>
<span class="nc" id="L2305">						localizer.i18n(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.IDS_CUSTOME_SHIFT_EVENT_NOTEXIST), (Object[]) null));</span>
<span class="nc" id="L2306">				return true;</span>
			}
		}
<span class="nc" id="L2309">		return false;</span>
	}

	static String formatCustomShiftTimeRange(TimeOfDay shiftEventStart, TimeOfDay shiftEventEnd) {
<span class="nc" id="L2313">		return shiftEventStart.getHours() + &quot;:&quot; + getMinuteString(shiftEventStart.getMinutes()) + &quot;-&quot;</span>
<span class="nc" id="L2314">                + shiftEventEnd.getHours() + &quot;:&quot; + getMinuteString(shiftEventEnd.getMinutes());</span>
	}

	static TimeOfDay getShiftEventTimeOfDay(ShiftEvent shiftEvent, int nMinuteSinceMidnight,
			TimeOfDay tShiftStart) {
<span class="nc bnc" id="L2319" title="All 2 branches missed.">		return shiftEvent.isCafeteria() ? new TimeOfDay(nMinuteSinceMidnight) : tShiftStart.addMinutes(nMinuteSinceMidnight);</span>
	}

	private static TimeOfDay getRealShiftStartInHourAndMinute(ShiftAssignment shiftAssignment, Calendar cCalendar) {
<span class="nc" id="L2323">		cCalendar.setTime(shiftAssignment.getStartTime());</span>
<span class="nc bnc" id="L2324" title="All 2 branches missed.">		if (shiftAssignment.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L2325">			cCalendar.add(Calendar.MINUTE, shiftAssignment.getExtensionBefore());</span>
		}
<span class="nc" id="L2327">		return new TimeOfDay(cCalendar.get(Calendar.HOUR_OF_DAY), cCalendar.get(Calendar.MINUTE));</span>
	}

	private static Date getRealShiftStart(ShiftAssignment shiftAssignment, Calendar cCalendar) {
<span class="nc" id="L2331">		cCalendar.setTime(shiftAssignment.getStartTime());</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">		if (shiftAssignment.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L2333">			cCalendar.add(Calendar.MINUTE, shiftAssignment.getExtensionBefore());</span>
		}
<span class="nc" id="L2335">		return cCalendar.getTime();</span>
	}

	private static Date getRealShiftEnd(ShiftAssignment shiftAssignment, Calendar cCalendar) {
<span class="nc" id="L2339">		cCalendar.setTime(shiftAssignment.getEndTime());</span>
<span class="nc bnc" id="L2340" title="All 2 branches missed.">		if (shiftAssignment.getExtensionAfter() &gt; 0) {</span>
<span class="nc" id="L2341">			cCalendar.add(Calendar.MINUTE, -shiftAssignment.getExtensionAfter());</span>
		}
<span class="nc" id="L2343">		return cCalendar.getTime();</span>
	}

	public static Collection getClassUnassignedConflicts(Collection events) {
		// to do
<span class="nc" id="L2348">		return null;</span>
	}

	private static String getMinuteString(int minute) {
<span class="nc bnc" id="L2352" title="All 2 branches missed.">		if (minute &lt; 10) {</span>
<span class="nc" id="L2353">			return &quot;0&quot; + minute;</span>
		} else {
<span class="nc" id="L2355">			return &quot;&quot; + minute;</span>
		}
	}

	public static Map&lt;ID, Collection&lt;Event&gt;&gt; filterEvents(Map&lt;ID, Collection&lt;Event&gt;&gt; unfilteredEvents,
			Collection m_currentFilterShiftIDs, Collection m_currentFilterActivityIDs) {
<span class="nc" id="L2361">		return filterEvents(unfilteredEvents, m_currentFilterShiftIDs, m_currentFilterActivityIDs, false, null, false);</span>
	}

	public static Map&lt;ID, Collection&lt;Event&gt;&gt; filterEvents(Map&lt;ID, Collection&lt;Event&gt;&gt; unfilteredEvents,
			Collection m_currentFilterShiftIDs, Collection m_currentFilterActivityIDs, boolean isActivityFilter,
			Pair startEndDate, boolean isTopLayerOnly) {
<span class="nc bnc" id="L2367" title="All 2 branches missed.">		if (unfilteredEvents == null) {</span>
<span class="nc" id="L2368">			return null;</span>
		}

<span class="nc bnc" id="L2371" title="All 2 branches missed.">		Date start = startEndDate == null ? null : (Date) startEndDate.getFirst();</span>
<span class="nc bnc" id="L2372" title="All 2 branches missed.">		Date end = startEndDate == null ? null : (Date) startEndDate.getSecond();</span>

<span class="nc" id="L2374">		Map&lt;ID, Collection&lt;Event&gt;&gt; filteredEvents = new HashMap&lt;ID, Collection&lt;Event&gt;&gt;(unfilteredEvents.size());</span>
<span class="nc" id="L2375">		Iterator&lt;ID&gt; itKeys = unfilteredEvents.keySet().iterator();</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">		while (itKeys.hasNext()) {</span>
<span class="nc" id="L2377">			ID nextKey = itKeys.next();</span>
<span class="nc" id="L2378">			List&lt;Event&gt; filteredEventCollection = new ArrayList&lt;Event&gt;();</span>
<span class="nc" id="L2379">			filteredEvents.put(nextKey, filteredEventCollection);</span>
<span class="nc" id="L2380">			Collection&lt;Event&gt; nextEventsCollection = unfilteredEvents.get(nextKey);</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">			if (isActivityFilter) {</span>
<span class="nc" id="L2382">				nextEventsCollection = EventUtils.flattenEvents(nextEventsCollection, true);</span>
			}
<span class="nc bnc" id="L2384" title="All 2 branches missed.">			for (Event nextEvent : nextEventsCollection) {</span>
<span class="nc" id="L2385">				boolean bAddEvent = false;</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">				if (isActivityFilter) {</span>
<span class="nc" id="L2387">					bAddEvent = canPassActivityFilter(m_currentFilterActivityIDs, nextEvent);</span>
				} else {
<span class="nc bnc" id="L2389" title="All 2 branches missed.">					if (nextEvent instanceof ShiftAssignment) {</span>
<span class="nc bnc" id="L2390" title="All 2 branches missed.">						if (m_currentFilterShiftIDs == null) {</span>
							// indicates we should show all shifts
<span class="nc" id="L2392">							bAddEvent = true;</span>
						} else {
<span class="nc" id="L2394">							ID shiftID = ((ShiftAssignment) nextEvent).getShiftID();</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">							if (m_currentFilterShiftIDs.contains(shiftID)) {</span>
<span class="nc" id="L2396">								bAddEvent = true;</span>
							}
<span class="nc" id="L2398">						}</span>
					} else {
<span class="nc" id="L2400">						bAddEvent = canPassActivityFilter(m_currentFilterActivityIDs, nextEvent);</span>
					}
				}

				// date range check
<span class="nc bnc" id="L2405" title="All 4 branches missed.">				if (bAddEvent &amp;&amp; startEndDate != null</span>
<span class="nc bnc" id="L2406" title="All 4 branches missed.">						&amp;&amp; (nextEvent.getStartTime().after(end) || nextEvent.getEndTime().before(start))) {</span>
<span class="nc" id="L2407">					bAddEvent = false;</span>
				}

<span class="nc bnc" id="L2410" title="All 2 branches missed.">				if (bAddEvent) {</span>
<span class="nc" id="L2411">					filteredEventCollection.add(nextEvent);</span>
				}
<span class="nc" id="L2413">			}</span>

			// layer check only for activity filter
<span class="nc bnc" id="L2416" title="All 2 branches missed.">			if (isActivityFilter) {</span>
				// to show overlap events as grey, we get the overlap envents
				// here
<span class="nc" id="L2419">				Event event = null;</span>
<span class="nc" id="L2420">				Event eventInner = null;</span>
<span class="nc" id="L2421">				List&lt;Event&gt; allOverlaps = new ArrayList&lt;Event&gt;();</span>
<span class="nc bnc" id="L2422" title="All 2 branches missed.">				for (Iterator&lt;Event&gt; i = filteredEventCollection.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2423">					event = i.next();</span>
<span class="nc" id="L2424">					List&lt;Event&gt; overlaps = new ArrayList&lt;Event&gt;();</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">					for (Iterator iInner = nextEventsCollection.iterator(); iInner.hasNext();) {</span>
<span class="nc" id="L2426">						eventInner = (Event) iInner.next();</span>
<span class="nc bnc" id="L2427" title="All 2 branches missed.">						if (event.getStartTime().before(eventInner.getEndTime())</span>
<span class="nc bnc" id="L2428" title="All 2 branches missed.">								&amp;&amp; event.getEndTime().after(eventInner.getStartTime())</span>
<span class="nc bnc" id="L2429" title="All 2 branches missed.">								&amp;&amp; eventInner.getEventType() != Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) {</span>
<span class="nc" id="L2430">							overlaps.add(eventInner);</span>
						}
					}
<span class="nc" id="L2433">					boolean isShown = true;</span>
<span class="nc bnc" id="L2434" title="All 4 branches missed.">					if (!overlaps.isEmpty() &amp;&amp; isTopLayerOnly</span>
					// &amp;&amp;(event.getEventType() !=
					// Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) QC103541
<span class="nc bnc" id="L2437" title="All 2 branches missed.">							&amp;&amp; !isEventAtTopAtLeastOneMinutes(event, overlaps)) {</span>
<span class="nc" id="L2438">						i.remove(); // remove from the list of return. since it</span>
									// is not top layer event
<span class="nc" id="L2440">						overlaps.clear(); // no need to add overlaps to filtered</span>
											// out event list any more
<span class="nc" id="L2442">						isShown = false;</span>
					}
<span class="nc" id="L2444">					overlaps.remove(event);</span>
<span class="nc" id="L2445">					overlaps.removeAll(allOverlaps); // avoid dup</span>
<span class="nc" id="L2446">					allOverlaps.addAll(overlaps);</span>

<span class="nc bnc" id="L2448" title="All 4 branches missed.">					if (isShown &amp;&amp; event.getEventType() == Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) {</span>
<span class="nc" id="L2449">						i.remove(); // never put shift event in filtered events,</span>
									// we put shift assignment instead.
					}
<span class="nc" id="L2452">				}</span>

<span class="nc" id="L2454">				allOverlaps.removeAll(filteredEventCollection); // avoid dup</span>
<span class="nc" id="L2455">				filteredEventCollection.addAll(allOverlaps);</span>
			}
<span class="nc" id="L2457">		}</span>
<span class="nc" id="L2458">		return filteredEvents;</span>
	}

	private static boolean canPassActivityFilter(Collection m_currentFilterActivityIDs, Event nextEvent) {
<span class="nc bnc" id="L2462" title="All 2 branches missed.">		if (m_currentFilterActivityIDs == null) {</span>
<span class="nc" id="L2463">			return true;</span>
		} else {
<span class="nc" id="L2465">			ID activityID = nextEvent.getActivityID();</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">			if (m_currentFilterActivityIDs.contains(activityID)) {</span>
<span class="nc" id="L2467">				return true;</span>
			}
		}
<span class="nc" id="L2470">		return false;</span>
	}

	private static boolean isEventAtTopAtLeastOneMinutes(Event event, Collection&lt;Event&gt; overlaps) {
<span class="nc" id="L2474">		List&lt;Event&gt; allEvents = new ArrayList&lt;Event&gt;(overlaps.size() + 1);</span>
<span class="nc" id="L2475">		allEvents.add(event);</span>
<span class="nc" id="L2476">		allEvents.addAll(overlaps);</span>

<span class="nc" id="L2478">		Collection&lt;SimpleEvent&gt; timelines = EventUtils.convertEventsToTimelineForSingleEmployee(allEvents);</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">		for (SimpleEvent simpleEvent : timelines) {</span>
<span class="nc bnc" id="L2480" title="All 2 branches missed.">			if (simpleEvent.getActivityID().equals(event.getActivityID())) {</span>
<span class="nc" id="L2481">				return true;</span>
			}
<span class="nc" id="L2483">		}</span>

<span class="nc" id="L2485">		return false;</span>
	}
	
	
	/**
	 * Returns a hashcode for the ShiftAssignment which includes its children
	 * This is used primarily by Shift Swap code to see if a swapped shift has been modified 
	 * See com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil.getHashCode(ShiftAssignment)
	 **/
	public static int getShiftAssignmentHashCodeExtended(ShiftAssignment sa){
<span class="nc" id="L2495">		int hashCode = sa.hashCode();</span>
<span class="nc" id="L2496">		Collection&lt;ShiftEventAssignment&gt; shiftEventAssignments = sa.getChildren();</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">		for (ShiftEventAssignment sea : shiftEventAssignments) {</span>
<span class="nc" id="L2498">			int h = 0;</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">			if (sea.getActivityID() != null) {</span>
<span class="nc" id="L2500">				h = sea.getActivityID().hashCode();</span>
			}
<span class="nc" id="L2502">			h ^= sea.getStartTime().hashCode();</span>
<span class="nc" id="L2503">			h ^= sea.getDuration();</span>
<span class="nc" id="L2504">			hashCode ^= h;</span>
<span class="nc" id="L2505">		}</span>
<span class="nc" id="L2506">		return hashCode;</span>
	}
	
	/**
	 * Returns a hashcode for the ShiftAssignment which includes its children
	 * This is used primarily by Shift Swap code to see if a swapped shift has been modified 
	 * See com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil.getHashCode(ShiftAssignment)
	 * Will only consider portions within the start/end time
	 **/
	public static int getShiftAssignmentHashCodeExtendedInRange(ShiftAssignment sa, Date start, Date end){
<span class="nc" id="L2516">		int hashCode = hashCodeExtendedInRange(sa, start, end);</span>
<span class="nc" id="L2517">		Collection&lt;ShiftEventAssignment&gt; shiftEventAssignments = sa.getChildren();</span>
<span class="nc bnc" id="L2518" title="All 2 branches missed.">		for (ShiftEventAssignment sea : shiftEventAssignments) {</span>
<span class="nc" id="L2519">			Date startTime = sea.getStartTime();</span>
<span class="nc" id="L2520">			Date endTime = sea.getEndTime();</span>
<span class="nc bnc" id="L2521" title="All 8 branches missed.">			if(endTime.before(start) || endTime.equals(start)|| startTime.after(end) || startTime.equals(end)){</span>
<span class="nc" id="L2522">				continue;</span>
			} 
<span class="nc bnc" id="L2524" title="All 2 branches missed.">			if(startTime.before(start)){</span>
<span class="nc" id="L2525">				startTime = start;</span>
			} 
<span class="nc bnc" id="L2527" title="All 2 branches missed.">			if(endTime.after(end)){</span>
<span class="nc" id="L2528">				endTime = end;</span>
			}
			
<span class="nc" id="L2531">			int h = 0;</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">			if(sea.getActivityID() != null){</span>
<span class="nc" id="L2533">				h = sea.getActivityID().hashCode();</span>
			}
			// minutes
<span class="nc" id="L2536">			long duration = (endTime.getTime() - startTime.getTime()) / SIXTY_THOUSAND; </span>
<span class="nc" id="L2537">			h ^= startTime.hashCode();</span>
<span class="nc" id="L2538">			h ^= duration;</span>
<span class="nc" id="L2539">			hashCode ^= h;</span>
<span class="nc" id="L2540">		}</span>
<span class="nc" id="L2541">		return hashCode;</span>
	}
	
	
	public static int hashCodeExtendedInRange(ShiftAssignment sa, Date start, Date end){
<span class="nc" id="L2546">		Date dtStartTime = sa.getStartTime();</span>
<span class="nc" id="L2547">		Date dtEndTime = sa.getEndTime();</span>
		
<span class="nc bnc" id="L2549" title="All 4 branches missed.">		if(dtStartTime==null || dtStartTime.before(start)){</span>
<span class="nc" id="L2550">			dtStartTime = start;</span>
		}
<span class="nc bnc" id="L2552" title="All 4 branches missed.">		if(dtEndTime==null || dtEndTime.after(end)){</span>
<span class="nc" id="L2553">			dtEndTime = end;</span>
		}
				
<span class="nc" id="L2556">		int hash = dtStartTime.hashCode();</span>
<span class="nc" id="L2557">		hash ^= dtEndTime.hashCode();</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; it = sa.getWorkResourceIDs().iterator(); it.hasNext();) {</span>
<span class="nc" id="L2559">			hash ^= it.next().hashCode();</span>
		}
<span class="nc" id="L2561">		return hash;</span>
		
	}
	
	/*
	 * hasShiftAssignmentStartingInPeriod checks to see if the Event eventToCheck (typically a timeOff SimpleEvent) intersects with a shift and
	 * then checks if the shift starts within the period.
	 * This is needed to test if Timeoff Events intersect with a shift that begins with the specified periodRange.
	 * 
	 * 
	 * This is used by RequiredPayPeriodHoursUtil but may be useful for other applications.
	 */
	public static boolean hasShiftAssignmentStartingInPeriod(Collection&lt;? extends Event&gt; shiftEvents, 
			Event eventToCheck, TimeRange periodRange) {

<span class="nc bnc" id="L2576" title="All 2 branches missed.">		for (Event shiftEvent : shiftEvents) {</span>
<span class="nc bnc" id="L2577" title="All 2 branches missed.">			if (shiftEvent.getEventType() != Event.EVENT_TYPE_SHIFT_ASSIGNMENT){</span>
<span class="nc" id="L2578">				continue;</span>
			}

			// Does the shift intersects with eventToCheck? And does the ShiftEvent start in the period?
<span class="nc bnc" id="L2582" title="All 2 branches missed.">			if (shiftEvent.getStartTime().before(eventToCheck.getEndTime()) </span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">					&amp;&amp; shiftEvent.getEndTime().after(eventToCheck.getStartTime())</span>
<span class="nc bnc" id="L2584" title="All 2 branches missed.">					&amp;&amp; WorkRuleUtil.isInPeriod(shiftEvent.getStartTime(), </span>
<span class="nc" id="L2585">							shiftEvent.getEndTime(), periodRange.getStartDate(), </span>
<span class="nc" id="L2586">							periodRange.getEndDate(), Config.STARTSIN)) {</span>
<span class="nc" id="L2587">				return true;</span>
			}
<span class="nc" id="L2589">		}</span>

<span class="nc" id="L2591">		return false;</span>
	}

	

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>