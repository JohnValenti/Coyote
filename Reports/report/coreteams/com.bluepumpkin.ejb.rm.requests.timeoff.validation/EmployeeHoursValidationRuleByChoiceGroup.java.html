<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EmployeeHoursValidationRuleByChoiceGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.validation</a> &gt; <span class="el_source">EmployeeHoursValidationRuleByChoiceGroup.java</span></div><h1>EmployeeHoursValidationRuleByChoiceGroup.java</h1><pre class="source lang-java linenums">/*
 * EmployeeHoursValidationRule.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */

package com.bluepumpkin.ejb.rm.requests.timeoff.validation;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Set;

import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffAccrued;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TOAccrualCalculator;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOAccrual;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOAccrualDetailRow;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoiceGroup;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.employeehours.AccrualValidationDates;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.employeehours.AccrualValidationInputs;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.employeehours.TOAccrualLoaderForValidation;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;

/**
 * Rule in UI: Employee has enough time off hours.
 * This class is currently not hooked into the validations. 
 * Does validation by choice groups
 */
<span class="nc" id="L42">public class EmployeeHoursValidationRuleByChoiceGroup extends TimeoffValidationRule {</span>

<span class="nc" id="L44">	private static final String CLASS_NAME = EmployeeHoursValidationRule.class.getName();</span>
<span class="nc" id="L45">	private static final Category log = Log.initCategory(CLASS_NAME);</span>

<span class="nc" id="L47">	Localizer localizer = DefaultLocalizationManager.getDefaultInstance().getLocalizer();</span>
	//Zero carry over balance for this activity
<span class="nc" id="L49">	private boolean isZeroCarryOverBal = false;</span>



	private AccrualValidationDates validationDates;
	private AccrualValidationInputs inputs;

	private EmployeeTimeOffAccrued accruedTOFromDB;





	@Override
	protected void validateTimeOffChoiceGroup(TORequest tor, TOChoiceGroup choiceGroup) throws Exception {


<span class="nc bnc" id="L66" title="All 4 branches missed.">		if (tor.isUnavailability() || !initializeActivity(tor)) {</span>
<span class="nc" id="L67">			return;</span>
		}

<span class="nc" id="L70">		List&lt;TOHoursPerDay&gt; additionalHours = new ArrayList&lt;TOHoursPerDay&gt;(choiceGroup.size());</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">		for (TOChoice toChoice : choiceGroup.getChoices()) {</span>

<span class="nc" id="L73">			additionalHours.add(toChoice.getHoursPerDay());</span>

<span class="nc bnc" id="L75" title="All 2 branches missed.">			if (initializeZeroCarryOverBalanceFlag(tor, toChoice)) {</span>

				//initialize dates
<span class="nc" id="L78">				validationDates = new AccrualValidationDates();</span>
<span class="nc" id="L79">				validationDates.initialize(inputs, toChoice);</span>

<span class="nc" id="L81">				doAccrualValidation(tor, toChoice, additionalHours);</span>
			}
<span class="nc" id="L83">		}</span>
<span class="nc" id="L84">	}</span>

	private boolean initializeActivity(TORequest tor) throws Exception { // NOSONAR

<span class="nc" id="L88">		inputs = new AccrualValidationInputs();</span>
<span class="nc" id="L89">		inputs.load(tor.getEmployeeID(), tor.getTimeOffType());</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">		if (!inputs.isAccrualEnabled()) {</span>
			//This validation rule applies only to activities where accrual is enabled.
<span class="nc" id="L92">			return false;</span>
		}

<span class="nc" id="L95">		accruedTOFromDB = TOAccrualCalculator.getLastUpdatedTOAccrued(null, tor.getEmployeeID(), inputs.getActivityID(),</span>
<span class="nc" id="L96">				inputs.getActivityCategoryID(), null);</span>

<span class="nc" id="L98">		return true;</span>
	}

	private boolean initializeZeroCarryOverBalanceFlag(TORequest tor, TOChoice toChoice) throws Exception { // NOSONAR

<span class="nc bnc" id="L103" title="All 4 branches missed.">		if (TORequestUtil.isTimeOffChoiceForPastDate(tor, toChoice) &amp;&amp;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">				accruedTOFromDB != null &amp;&amp; toChoice.getStartDate().before(accruedTOFromDB.getAccruedAtDate())) {</span>

<span class="nc" id="L106">			log.debug(&quot;Requested Choice is for a date that falls before Last update date so we skip validation. Start date:&quot; +</span>
<span class="nc" id="L107">					toChoice.getStartDate() + &quot;: Balance update date:&quot; + accruedTOFromDB.getAccruedAtDate());</span>
<span class="nc" id="L108">			return false;</span>
		}

		//Determining that carryover==0 is very important for time off crossing TO year boundary!!!
<span class="nc bnc" id="L112" title="All 2 branches missed.">		isZeroCarryOverBal = accruedTOFromDB == null;</span>

<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (!isZeroCarryOverBal) {</span>
			//If Accrued is not null then check if carryover is explicitly set to zero for this activity / act category
<span class="nc" id="L116">			isZeroCarryOverBal = inputs.isZeroMaxCarryOver();</span>
		}

<span class="nc" id="L119">		return true;</span>
	}

	private void doAccrualValidation(TORequest tor, TOChoice toChoice, List&lt;TOHoursPerDay&gt; additionalHours) throws Exception { // NOSONAR

<span class="nc" id="L124">		TOAccrual toAccrual = TOAccrualLoaderForValidation.getTOAccruedForValidation(toChoice.getHoursPerDay(),</span>
				additionalHours,
				accruedTOFromDB,
				inputs,
				validationDates);

<span class="nc bnc" id="L130" title="All 2 branches missed.">		if (setValidationResults(toAccrual, toChoice)) {</span>
			//Hard validation errors on toAccrual? Need to check this
<span class="nc" id="L132">			return;</span>
		}


<span class="nc" id="L136">		Set&lt;TOAccrualDetailRow&gt; violationSet = toAccrual.getViolations();</span>

<span class="nc bnc" id="L138" title="All 4 branches missed.">		if (violationSet == null || violationSet.isEmpty()) {</span>
			//No violations
<span class="nc" id="L140">			return;</span>
		}

<span class="nc bnc" id="L143" title="All 2 branches missed.">		for (TOAccrualDetailRow row : violationSet) {</span>

<span class="nc" id="L145">			TOHoursPerDay hrsPerDay = row.getTOHoursPerDay();</span>

<span class="nc bnc" id="L147" title="All 2 branches missed.">			if (hrsPerDay == null) {</span>
<span class="nc" id="L148">				continue;</span>
			}

<span class="nc bnc" id="L151" title="All 4 branches missed.">			if (hrsPerDay.getTOChoiceID() != null &amp;&amp; hrsPerDay.getTOChoiceID().equals(toChoice.getID())) {</span>
				//the violation was caused by an hours per day attached to the request choice we are validating
<span class="nc" id="L153">				handleViolationForChoice(tor, toChoice, row);</span>
<span class="nc" id="L154">				return;</span>
			}

<span class="nc bnc" id="L157" title="All 2 branches missed.">			if (hrsPerDay.getStartTime().after(toChoice.getStartDate())) {</span>
				//the violation is after the request we are currently validating. 
<span class="nc" id="L159">				handleViolationAfterChoiceStart(tor, toChoice, toAccrual, row, hrsPerDay);</span>
<span class="nc" id="L160">				return;</span>
			}

			//This violation occurs before the start date of request
			// therefore cannot use it to show alert for this request/choice because it might not be relevant here
<span class="nc" id="L165">			log.info(&quot; skipping this violation TOR=&quot; + tor + &quot; :TOCHOICE=&quot; + toChoice + &quot;: ROW=&quot; + row.getTOHoursPerDay()</span>
						+ &quot;: toAccrual=&quot; + toAccrual);

<span class="nc" id="L168">		}</span>
<span class="nc" id="L169">	}</span>


	private void handleViolationAfterChoiceStart(TORequest tor, TOChoice toChoice, TOAccrual toAccrual, TOAccrualDetailRow row,
			TOHoursPerDay hrsPerDay) throws Exception { // NOSONAR

<span class="nc bnc" id="L175" title="All 2 branches missed.">		if (toAccrual.actTOBal.maxCarryOverNotApplicable()) {</span>
			// there is no concept of carryover; definitely raise an alert for any violation found anywhere in future.
<span class="nc" id="L177">			setSoftValidationResult(tor, toChoice, row.getAccrdHrsTillDate(), hrsPerDay.getStartTime());</span>
<span class="nc" id="L178">			return;</span>
		}

<span class="nc" id="L181">		Calendar empTOYearEndCal = RequestUtil.getEmployeeTimeOffYearEnd(toChoice.getStartDate(), toAccrual.org, toAccrual.empTOYrStArr);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">		if (!empTOYearEndCal.getTime().before(toChoice.getEndDate())) {</span>
			//Entire time off choice Falls in the same time off year
<span class="nc" id="L184">			checkForYear(tor, toChoice, row, empTOYearEndCal);</span>
<span class="nc" id="L185">			return;</span>
		}

		//Time off choice end crosses time off year
<span class="nc" id="L189">		Calendar empTOYearEndForTOChoiceEnDate = RequestUtil.getEmployeeTimeOffYearEnd(toChoice.getEndDate(), toAccrual.org,</span>
				toAccrual.empTOYrStArr);
<span class="nc" id="L191">		checkForYear(tor, toChoice, row, empTOYearEndForTOChoiceEnDate);</span>

<span class="nc" id="L193">	}</span>

	private void handleViolationForChoice(TORequest tor, TOChoice toChoice, TOAccrualDetailRow row) throws Exception { // NOSONAR

		///Accrual Calculator always return accrued Hrs Till Date of request taking into account the current request.
		//Hence accrued hours on start date should be calculated by getting accrued hours on Date of Time Off request
		//and adding the accounted hours for this request back.
<span class="nc" id="L200">		String key = RmEjbBundleKey.TO_NOT_ENOUGH_HOURS_ACCR;</span>

<span class="nc" id="L202">		double reqHrs = toChoice.getHoursPerDay().getTotalMinutes() / 60.0;</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">		if (validationDates.doesRequestCrossTimeOffYearBoundary()) {</span>
			//getAccrdHrsTillDate =  [Total accrued hours till row end] - [Total accounted hours till row end]
			//i.e. It is what is remaining at the end of the row 
			//Need to test this
<span class="nc" id="L208">			double accruedHours = row.getAccrdHrsTillDate() + row.getAcctHrsTillDate();</span>
<span class="nc" id="L209">			ValidationUtil.setSoftValidationResult(toChoice, key,</span>
					new Serializable[] {
<span class="nc" id="L211">							tor.getCache().getEmployeeNameByID(),</span>
<span class="nc" id="L212">							toChoice.getStartDate(), localizer.formatNumber(reqHrs, 2),</span>
<span class="nc" id="L213">							localizer.formatNumber(accruedHours, 2), row.getStartDate() }, CLASS_NAME);</span>
<span class="nc" id="L214">			return;</span>
		}

<span class="nc" id="L217">		double accruedHours = row.getAccrdHrsTillDate() + reqHrs;</span>
<span class="nc" id="L218">		ValidationUtil.setSoftValidationResult(toChoice, key,</span>
				new Serializable[] {
<span class="nc" id="L220">						tor.getCache().getEmployeeNameByID(),</span>
<span class="nc" id="L221">						toChoice.getStartDate(), localizer.formatNumber(reqHrs, 2),</span>
<span class="nc" id="L222">						localizer.formatNumber(accruedHours, 2), toChoice.getStartDate() }, CLASS_NAME);</span>

<span class="nc" id="L224">	}</span>

	private void checkForYear(TORequest tor, TOChoice toChoice, TOAccrualDetailRow row, Calendar yrEndCal) throws Exception { // NOSONAR
<span class="nc" id="L227">		TOHoursPerDay hrsPerDay = row.getTOHoursPerDay();</span>

<span class="nc bnc" id="L229" title="All 4 branches missed.">		if (yrEndCal.getTime().before(hrsPerDay.getStartTime()) &amp;&amp; isZeroCarryOverBal) {</span>
			//carryover is zero and entire violation is in next year so no violation here
<span class="nc" id="L231">			return;</span>
		}
<span class="nc" id="L233">		setSoftValidationResult(tor, toChoice, row.getAccrdHrsTillDate(), hrsPerDay.getStartTime());</span>
<span class="nc" id="L234">	}</span>

	private ValidationResult setSoftValidationResult(TORequest tor, TOChoice toChoice, double accrdHrsTillDate, Date startTime)
			throws Exception { // NOSONAR
		//Fails because the Employee does not have enough available hours due to a scheduled time off in future
<span class="nc" id="L239">		return ValidationUtil.setSoftValidationResult(toChoice, RmEjbBundleKey.TO_NOT_ENOUGH_HOURS_FUTURE,</span>
<span class="nc" id="L240">		        new Serializable[]{tor.getCache().getEmployeeNameByID(), toChoice.getStartDate(),</span>
						//remaining balance if we approve this request	
<span class="nc" id="L242">						localizer.formatNumber(accrdHrsTillDate, 2),</span>
						startTime }, CLASS_NAME);
	}

	protected boolean setValidationResults(TOAccrual toAccrual, TOChoice toChoice) {
<span class="nc bnc" id="L247" title="All 6 branches missed.">		if (toAccrual != null &amp;&amp; toAccrual.getValidationResults(true) != null &amp;&amp; !toAccrual.getValidationResults(true).isEmpty()) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">			for (ValidationResult vr : toAccrual.getValidationResults(true)) {</span>
<span class="nc" id="L249">				toChoice.addValidationResult(vr);</span>
<span class="nc" id="L250">				vr.setValidatorName(CLASS_NAME);</span>
<span class="nc" id="L251">			}</span>
<span class="nc" id="L252">			return true;</span>
		}
<span class="nc" id="L254">		return false;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>