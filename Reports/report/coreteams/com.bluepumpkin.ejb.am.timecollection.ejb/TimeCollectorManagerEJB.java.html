<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeCollectorManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.am.timecollection.ejb</a> &gt; <span class="el_source">TimeCollectorManagerEJB.java</span></div><h1>TimeCollectorManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.am.timecollection.ejb;

import com.bluepumpkin.common.config.ConfigManager;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.LogMessage;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.am.AmManagerFactory;
import com.bluepumpkin.ejb.am.Log;
import com.bluepumpkin.ejb.am.base.*;
import com.bluepumpkin.ejb.am.l10n.AmEjbBundleKey;
import com.bluepumpkin.ejb.am.l10n.AmEjbLogBundleKey;
import com.bluepumpkin.ejb.am.timecollection.jms.ChangeStateStatusMessage;
import com.bluepumpkin.ejb.am.timecollection.model.PunchStatus;
import com.bluepumpkin.ejb.am.timecollection.model.RawTimeEntry;
import com.bluepumpkin.ejb.am.timecollection.model.RawTimeEntryHandler;
import com.bluepumpkin.ejb.am.timecollection.model.RawTimeEntrySort;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.activity.model.EmployeeEvent;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.*;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.config.model.ConfigDAO;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.timerecord.ejb.TimeRecordManager;
import com.bluepumpkin.ejb.bbm.timerecord.ejb.TimeTrackingManager;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeEntrySourceCode;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecordEntry;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeTrackingEvent;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.licensing.LicenseKeys;

import javax.ejb.EJBException;
import java.rmi.ConnectException;
import java.rmi.RemoteException;
import java.util.*;

/**
 * Title:        Blue Pumpkin Software Activity Management
 * &lt;p&gt;
 * Description:  EJB Implementation for Time Collection
 * It may decide not to create RawTimeEntry, if there is no Payroll License
 * It will never send JMS message, as there is no need for Agent Control now
 * The only AutoClose policy is add one minute after last open entry in previous shift
 * HAA Feed is a seperate implementation now
 * Event Audit Trail is introduced for HAA and AutoClose
 * Cache is used to cache last entry for a given employee to reduce DB query overhead
 * Copyright:    Copyright (c) 2003
 * Company:      Blue Pumpkin Software, Inc
 *
 * @author Sheng Song
 * @author Richard Chandler
 * @version 1.0
 */


<span class="nc" id="L76">public class TimeCollectorManagerEJB extends SessionEJBBase {</span>
<span class="nc" id="L77">  private static final ID GL = Activity.ACTIVITY_GENERAL_TRAINING;</span>
<span class="nc" id="L78">  private static final ID GLENDS = Activity.ACTIVITY_LEARNING_END;</span>
<span class="nc" id="L79">  private static final ID GLSTART = Activity.ACTIVITY_LEARNING_START;</span>

  /**
   * ejb managers
   */
<span class="nc" id="L84">  private TimeRecordManager m_timeRecordManager = null;</span>
<span class="nc" id="L85">  private TimeTrackingManager m_timeTrackingManager = null;</span>
<span class="nc" id="L86">  private ActivityManager m_activityManager = null;</span>
<span class="nc" id="L87">  private DBConfigManager m_DBConfigManager = null;</span>
<span class="nc" id="L88">  private EventAuditTrailManager m_auditManager = null;</span>
<span class="nc" id="L89">  private HAATimeEntryManager m_haaManager = null;</span>
<span class="nc" id="L90">  private WorkResourceManager m_workResourceManager = null;</span>

  // IDs should not be inserted from MyTime
<span class="nc" id="L93">  private final static ID[] ProhibitInsertActivities = {Activity.ACTIVITY_NONE,</span>
      Activity.ACTIVITY_UNKNOWN};

  // BP Config attributes
  private static final boolean PerformAutoClose = true; //should time collection auto close records? Always auto close
<span class="nc" id="L98">  private static boolean IsConfigDataLoaded = false; //ensure that bp config is loaded only once</span>
<span class="nc" id="L99">  private static boolean CreateTimeRecords = true; //should time collection create records in the database?</span>
<span class="nc" id="L100">  private static boolean PerformAutoMerge = true; // should time collection merge records?</span>
<span class="nc" id="L101">  private static boolean FixZeroDuration = true;</span>

<span class="nc" id="L103">  private static int AutoCloseTimeoutInMillis = 600 * TimeZoneUtil.MINUTE_IN_MILLISECONDS; //time out for auto close decision</span>
<span class="nc" id="L104">  private static int AutoMergeTimeoutInMillis = 120 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>

  // License for generation of RawTimeEntries
<span class="nc" id="L107">  private static boolean NeedRawEntry = false;</span>

  // Activity information
  private static final int PAID_ACTIVE = 1;
  private static final int PAID_INACTIVE = -2;
  private static final int UNPAID_ACTIVE = 0;
  private static final int UNPAID_INACTIVE = -3;

  // cache usage
<span class="nc" id="L116">  private boolean ActivityCached = false;</span>
  /**
   * time dependent cache for preformance
   */
  private static final int MINUTE = 60000;
  private static final int ACTIVITIES_ISPAID_TIMEOUT = 15 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;
<span class="nc" id="L122">  private static long ActivitedIsPaidChecked = 0;</span>
<span class="nc" id="L123">  private static Hashtable ActivitiesIsPaidCacheTable = null;</span>
<span class="nc" id="L124">  private static long UnknownEventInterval = 720 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>

  // initialization code
<span class="nc" id="L127">  private static final String clsName = TimeCollectorManagerEJB.class.getName();</span>
<span class="nc" id="L128">  private static Category m_cat = Log.initCategory(clsName);</span>

  protected Category getCategory() {
<span class="nc" id="L131">    return m_cat;</span>
  }

  {
<span class="nc" id="L135">    super.init(clsName);</span>
<span class="nc" id="L136">  }</span>

  /**
   * &lt;B&gt;ejbCreate&lt;/B&gt;
   * &lt;p&gt;
   * creates ejb managers during ejb create
   */
  public void ejbCreate() {
    try {
      //----------------------------------------------
      // ejbs
      //----------------------------------------------
<span class="nc" id="L148">      m_timeRecordManager = WfmManagerFactory.getTimeRecordManager();</span>
<span class="nc" id="L149">      m_timeTrackingManager = BbmManagerFactory.getTimeTrackingManager();</span>
<span class="nc" id="L150">      m_activityManager = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L151">      m_DBConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc" id="L152">      m_auditManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L153">      m_haaManager = AmManagerFactory.getHAAManager();</span>
<span class="nc" id="L154">      m_workResourceManager = BbmManagerFactory.getWorkResourceManager();</span>

      //----------------------------------------------
      // get db config init parameters
      //----------------------------------------------
<span class="nc bnc" id="L159" title="All 2 branches missed.">      if (!IsConfigDataLoaded) {</span>
        // check license manager for Payroll License
<span class="nc" id="L161">        NeedRawEntry = CoreManagerFactory.getLicenseManager().isLicensed(LicenseKeys.APP_PAYROLL);</span>
        // load other config data
<span class="nc" id="L163">        String valueStr = null;</span>
<span class="nc" id="L164">        int valueInt = 0;</span>
        // create time records?
<span class="nc" id="L166">        valueStr = m_DBConfigManager.getValue(TimeCollectorManager.CREATE_TIMERECORDS_KEY);</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">        if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L168">          CreateTimeRecords = false;</span>
        } else {
<span class="nc" id="L170">          CreateTimeRecords = true;</span>
        }
        // Fix Zero duration entry?
<span class="nc" id="L173">        valueStr = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_EXPOSE_ZERO_DURATION);</span>
<span class="nc" id="L174">        ConfigDAO configDao = new ConfigDAO();</span>
        try {
<span class="nc" id="L176">          String dbValue = configDao.GetValue(ConfigKey.TIMERECORDS_EXPOSE_ZERO_DURATION);</span>
<span class="nc bnc" id="L177" title="All 6 branches missed.">          if (valueStr == null || (dbValue != null &amp;&amp; !dbValue.trim().equalsIgnoreCase(valueStr))) {</span>
<span class="nc" id="L178">            m_cat.error(&quot; ******** Value of FixZeroDuration from DB=&quot; + dbValue + &quot; does not match cached value=&quot; + valueStr + &quot; using DB value&quot;);</span>
<span class="nc" id="L179">            valueStr = dbValue;</span>
          }
        } finally {
<span class="nc" id="L182">          configDao.cleanUp();</span>
<span class="nc" id="L183">        }</span>
<span class="nc bnc" id="L184" title="All 4 branches missed.">        if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L185">          FixZeroDuration = false;</span>
        } else {
<span class="nc" id="L187">          FixZeroDuration = true;</span>
        }
<span class="nc" id="L189">        m_cat.info(&quot; ******** Value of FixZeroDuration=&quot; + FixZeroDuration + &quot; cacheUsed=&quot; + m_DBConfigManager.cacheUsed());</span>
        // Auto merge
<span class="nc" id="L191">        valueStr = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_AUTO_MERGE);</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">        if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L193">          PerformAutoMerge = false;</span>
        } else {
<span class="nc" id="L195">          PerformAutoMerge = true;</span>
        }
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (PerformAutoMerge) {</span>
<span class="nc" id="L198">          valueInt = m_DBConfigManager.getIntValue(ConfigKey.TIMERECORDS_MERGE_WITH_TIMEOUT);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">          if (valueInt != ConfigManager.NOVALUE)</span>
<span class="nc" id="L200">            AutoMergeTimeoutInMillis = valueInt * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
        }
        // Auto Close
<span class="nc" id="L203">        valueInt = m_DBConfigManager.getIntValue(ConfigKey.TIMERECORDS_TIMEOUT);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (valueInt != ConfigManager.NOVALUE)</span>
<span class="nc" id="L205">          AutoCloseTimeoutInMillis = valueInt * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
        // If cache is enabled at first, instantiate cache
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.ACTIVITY_CACHE_USAGE))</span>
<span class="nc" id="L208">          ActivityCached = true;</span>
<span class="nc" id="L209">        valueStr = m_DBConfigManager.getValue(TimeCollectorManager.UNKNOWN_EVENT_TIME_RANGE);</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">        if (valueStr != null &amp;&amp; valueStr.length() &gt; 0) {</span>
<span class="nc" id="L211">          UnknownEventInterval = Integer.parseInt(valueStr) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
        }
      }
<span class="nc" id="L214">    } catch (Exception e) {</span>
      // log problem but continue operation with default values
      // alos set m_isConfigDataLoaded to false so next ejb will try to load agian
<span class="nc" id="L217">      m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_FAILURE_BP_CONFIG, e);</span>
<span class="nc" id="L218">      setBPConfigDefaults();</span>
    } finally {
<span class="nc" id="L220">      IsConfigDataLoaded = true;</span>
<span class="nc" id="L221">    }</span>
<span class="nc" id="L222">  }</span>


  /**
   * = * &lt;B&gt;ejbRemove&lt;/B&gt;
   * &lt;p&gt;
   * creates ejb managers during ejb create
   */
  public void ejbRemove() {
    try {
<span class="nc bnc" id="L232" title="All 2 branches missed.">      if (m_DBConfigManager != null)</span>
<span class="nc" id="L233">        m_DBConfigManager.remove();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">      if (m_activityManager != null)</span>
<span class="nc" id="L235">        m_activityManager.remove();</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">      if (m_timeRecordManager != null)</span>
<span class="nc" id="L237">        m_timeRecordManager.remove();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">      if (m_auditManager != null)</span>
<span class="nc" id="L239">        m_auditManager.remove();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">      if (m_haaManager != null)</span>
<span class="nc" id="L241">        m_haaManager.remove();</span>
<span class="nc" id="L242">    } catch (Exception ignore) {</span>
<span class="nc" id="L243">      m_cat.l7dError(ignore.getMessage());</span>
<span class="nc" id="L244">    }</span>
<span class="nc" id="L245">  }</span>


  /**
   * &lt;B&gt;deleteUnknownActivities&lt;/B&gt;
   * &lt;p&gt;
   * deletes 'Unknown Activities' with given Date from db
   * these activities are system generated activities
   * and meant as temporary placeholders
   *
   * @param date date to delete
   * @deprecated
   */
  @Deprecated
  public void deleteUnknownActivities(Date date) throws AmException {
<span class="nc" id="L260">    methodStart(&quot;deleteUnknownActivities&quot;, date);</span>
    try {
<span class="nc" id="L262">      TimeCollectorDAO.deleteUnknownActivities(date);</span>
<span class="nc" id="L263">    } catch (JdmoException e) {</span>
<span class="nc" id="L264">      handleException(e, false);</span>
<span class="nc" id="L265">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L267">      methodFinish();</span>
<span class="nc" id="L268">    }</span>
<span class="nc" id="L269">  }</span>

  /**
   * &lt;B&gt;manualEndShift&lt;/B&gt;
   * &lt;p&gt;
   * TimeRecord id exist in RawTimeEntry table
   * insert an end shift in the RawTimeEntry table
   * Other wise end the shift in the TimeEntryEvent table
   *
   * @param timeRecordID Time Record ID
   * @param employeeID   Employee ID
   * @param remarkerID   manager ID
   * @param endDate      Date of end shift
   * @param deviceID     MyTime device id
   */
  public void manualEndShift(ID timeRecordID, ID employeeID, ID remarkerID,
                             Date endDate, String deviceID)
      throws AmRawEndShiftException, AmTimeRecordEndShiftException, AmException {
<span class="nc" id="L287">    methodStart(&quot;manualEndShift&quot;, timeRecordID, employeeID, endDate, deviceID);</span>
    try {
      //---------------------------------------------------------------------
      //  FIRST check TimeRecord table
      //    does timerecord id exist?
      //    will this be the last entry?
      //---------------------------------------------------------------------
<span class="nc bnc" id="L294" title="All 2 branches missed.">      if (!TimeCollectorDAO.lastEntryAndEndShift(timeRecordID, endDate)) {</span>
<span class="nc" id="L295">        throw new AmNotLastEndShiftException(AmEjbBundleKey.TIMECOLLECTOR_NOT_LAST_END_SHIFT_ERROR);</span>
      } else {
<span class="nc" id="L297">        ID rawEntryID = null;</span>
<span class="nc" id="L298">        RawTimeEntry rawTimeEntry = new RawTimeEntry(employeeID, Activity.ACTIVITY_NONE,</span>
            timeRecordID, null, RawTimeEntry.MANUAL_END_SHIFT, endDate);
<span class="nc" id="L300">        rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.MANUAL);</span>
        //---------------------------------------------------------------------
        //  if license requires RawTimeEntry create raw time entry
        //  if RawTimeEntry table doesn't already have an end shift
        //    create RawTimeEntry END_SHIFT entry in database
        //---------------------------------------------------------------------
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (NeedRawEntry) {</span>
          //------------------------------------------------------------
          //  if no BPX pre-set status to successful
          //------------------------------------------------------------
<span class="nc" id="L310">          rawTimeEntry.setPunchStatus(ChangeStateStatusMessage.SUCCESSFUL);</span>
          //------------------------------------------------------------
          //  create entry in RAWTIMEENTRY table
          //------------------------------------------------------------
<span class="nc" id="L314">          rawEntryID = TimeCollectorDAO.createRawTimeEntry(rawTimeEntry);</span>
<span class="nc" id="L315">          rawTimeEntry.setId(rawEntryID);</span>
        }
        //---------------------------------------------------------------------
        //  SECOND, always create TimeEntryEvent END_SHIFT entry in database
        //---------------------------------------------------------------------
        try {
          //---------------------------------------------------------------------
          //  check if timerecord is closed before inserting END_SHIFT
          //---------------------------------------------------------------------
<span class="nc" id="L324">          TimeRecordEntry timeRecordEntry = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, remarkerID, false);</span>
<span class="nc" id="L325">          m_timeRecordManager.createTimeRecordEntry(timeRecordID, timeRecordEntry);</span>
<span class="nc" id="L326">        } catch (Exception e) {</span>
<span class="nc" id="L327">          handleException(e);</span>
<span class="nc" id="L328">          throw new AmTimeRecordEndShiftException(AmEjbBundleKey.TIMECOLLECTOR_TIMERECORD_END_SHIFT_ERROR);</span>
<span class="nc" id="L329">        }</span>
      }
<span class="nc" id="L331">    } catch (JdmoException e) {</span>
<span class="nc" id="L332">      handleException(e);</span>
<span class="nc" id="L333">      throw new AmRawEndShiftException(AmEjbBundleKey.TIMECOLLECTOR_RAW_END_SHIFT_ERROR);</span>
    } finally {
<span class="nc" id="L335">      methodFinish();</span>
<span class="nc" id="L336">    }</span>
<span class="nc" id="L337">  }</span>

  /**
   * &lt;B&gt;findCurrentActivity&lt;/B&gt;
   * &lt;p&gt;
   * locates last activity for given employee id
   *
   * @param employeeID ID of employee
   * @return Activity, employees current Activity
   */
  public Activity findCurrentActivity(ID employeeID) throws AmException {
<span class="nc" id="L348">    methodStart(&quot;findCurrentActivity&quot;, employeeID);</span>
    try {
      // If cache used, get last activity id from cached event
<span class="nc" id="L351">      Event event = m_timeRecordManager.getLastEntry(employeeID, null);</span>
<span class="nc bnc" id="L352" title="All 4 branches missed.">      if (event != null &amp;&amp; event.getActivityID() != null)</span>
<span class="nc" id="L353">        return m_activityManager.findActivityById(event.getActivityID());</span>
<span class="nc" id="L354">      return null;</span>
<span class="nc" id="L355">    } catch (Exception e) {</span>
<span class="nc" id="L356">      handleException(e, false);</span>
<span class="nc" id="L357">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L359">      methodFinish();</span>
    }
  }

  /**
   * &lt;B&gt;findEventHistoryForEmployee&lt;/B&gt;
   * &lt;p&gt;
   * To obtain event history for given employee in a given period of time
   *
   * @param employeeID ID of employee
   * @param startDate  time to begin search
   * @param endDate    time to end search
   *                   &lt;p&gt;
   * @return Collection of MyTimeEvent objects
   */
  public Collection findEventHistoryForEmployee(ID employeeID,
                                                Date startDate,
                                                Date endDate) throws AmException {
<span class="nc" id="L377">    methodStart(&quot;findEventHistoryForEmployee&quot;, employeeID, startDate, endDate);</span>
    try {
<span class="nc" id="L379">      return m_timeRecordManager.getValidEventsForWorkResource(employeeID, startDate, endDate);</span>
<span class="nc" id="L380">    } catch (Exception e) {</span>
<span class="nc" id="L381">      handleException(e, false);</span>
<span class="nc" id="L382">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L384">      methodFinish();</span>
    }
  }


  /**
   * findPreceedingRawTimeEntries
   * &lt;p&gt;
   * finds the rawtimeentry for each employee and datasource
   *
   * @return Collection of RawTimeEntry objects
   */
  public Collection findPreceedingRawTimeEntries() throws AmException {
<span class="nc" id="L397">    methodStart(&quot;findPreceedingRawTimeEntries&quot;);</span>
    try {
<span class="nc" id="L399">      return m_timeRecordManager.findLastEntries();</span>
<span class="nc" id="L400">    } catch (Exception e) {</span>
<span class="nc" id="L401">      handleException(e, false);</span>
<span class="nc" id="L402">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L404">      methodFinish();</span>
    }
  }

  /**
   * findPreceedingRawTimeEntries
   * &lt;p&gt;
   * finds the rawtimeentry for each employee and datasource
   * that precedes the given date
   *
   * @param employeeIDs  collection of employee ID's
   * @param dataSourceID ID of dataSource
   * @param date         date search criteria
   * @return Collection of RawTimeEntry objects
   */
  public Collection findPreceedingRawTimeEntries(Collection employeeIDs,
                                                 ID dataSourceID,
                                                 Date date)
      throws AmException {
<span class="nc" id="L423">    methodStart(&quot;findPreceedingRawTimeEntries&quot;, employeeIDs, dataSourceID, date);</span>
    try {
<span class="nc" id="L425">      return m_timeRecordManager.findLastEntries(employeeIDs, dataSourceID, date);</span>
<span class="nc" id="L426">    } catch (Exception e) {</span>
<span class="nc" id="L427">      handleException(e, false);</span>
<span class="nc" id="L428">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L430">      methodFinish();</span>
    }
  }

  /**
   * findPunchErrorsForEmployee
   * &lt;p&gt;
   * returns a collection of PunchErrors for employees
   * last punch (rawtimeentry)
   *
   * @param employeeID employee ID
   * @return Collection of PunchError objects
   */
  public Collection findPunchErrorsForEmployee(ID employeeID) throws AmException {
<span class="nc" id="L444">    methodStart(&quot;findPunchErrorsForEmployee&quot;, employeeID);</span>
    try {
<span class="nc" id="L446">      return null;</span>
    } finally {
<span class="nc" id="L448">      methodFinish();</span>
    }
  }

  /**
   * findPunchErrorsForPunchID
   * &lt;p&gt;
   * returns a collection of PunchErrors for a given RawTimeEntry ID
   *
   * @param rawTimeEntryID RawTimeEntry ID used for search
   * @return Collection of PunchError objects
   */
  public Collection findPunchErrorsForRawTimeEntryID(ID rawTimeEntryID) throws AmException {
<span class="nc" id="L461">    methodStart(&quot;findPunchErrorsForRawTimeEntryID&quot;, rawTimeEntryID);</span>
    try {
<span class="nc" id="L463">      return null;</span>
    } finally {
<span class="nc" id="L465">      methodFinish();</span>
    }
  }

  /**
   * &lt;B&gt;getPunchStatus&lt;/B&gt;
   * &lt;p&gt;
   * pulls status of activity change from RawTimeEntry table
   *
   * @param rawTimeEntryID ID
   *                       &lt;p&gt;
   * @return int value of status
   * ChangeStateStatusMessage.UNDETERMINED = 0;
   * ChangeStateStatusMessage.SUCCESSFUL = 1;
   * ChangeStateStatusMessage.SUCCESSFUL_WITH_WARNINGS = 2;
   * ChangeStateStatusMessage.FAILED = 3;
   */
  public PunchStatus getPunchStatus(ID rawTimeEntryID) throws AmException {
<span class="nc" id="L483">    methodStart(&quot;findPunchStatus&quot;, rawTimeEntryID);</span>
    try {
<span class="nc" id="L485">      return null;</span>
    } finally {
<span class="nc" id="L487">      methodFinish();</span>
    }
  }

  /**
   * If eLearning import is per window, we can optimize by import in group
   *
   * @param empEntryMap
   * @throws AmException
   */
  public void insertELEntries(Map empEntryMap, Date start, Date end) throws AmException {
<span class="nc" id="L498">    methodStart(&quot;insertELEntries&quot;, empEntryMap, start, end);</span>
    try {
<span class="nc" id="L500">      insertHAAEntries(empEntryMap, empEntryMap.keySet(), start, end, true);</span>
<span class="nc" id="L501">    } catch (AmException e) {</span>
<span class="nc" id="L502">      throw e;</span>
<span class="nc" id="L503">    } catch (Exception e) {</span>
<span class="nc" id="L504">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L506">      methodFinish();</span>
<span class="nc" id="L507">    }</span>
<span class="nc" id="L508">  }</span>


  /**
   * Handle Historical Agent Adherence data, for a given time window
   * Based on DataSourceFailure ID to retrieve HAA entries
   * Based on DataSourceID to obtain Employee-DataSource association
   *
   * @param acdFailureID
   * @param dataSourceID
   * @param start
   * @param end
   * @throws AmException
   */
  public void insertHAAEntries(ID acdFailureID, ID dataSourceID, Date start, Date end) throws AmException {
<span class="nc" id="L523">    methodStart(&quot;insertHAAEntries&quot;, acdFailureID, dataSourceID, start, end);</span>
<span class="nc" id="L524">    Jdmo jdmo = new Jdmo();</span>
    try {
      // fetch all HAA entries
<span class="nc" id="L527">      HashMap haaEntryMap = m_haaManager.getHAATimeEntries(acdFailureID);</span>
      // try to figure out the Employees to be fixed
<span class="nc" id="L529">      int empSize = 100;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">      if (!haaEntryMap.isEmpty())</span>
<span class="nc" id="L531">        empSize = haaEntryMap.keySet().size();</span>
      // fetch associated employees
<span class="nc" id="L533">      String strSQL = &quot;SELECT EMPLOYEEID FROM EMPLOYEEDATASOURCE WHERE DATASOURCEID=?&quot;;</span>
<span class="nc" id="L534">      HashSet empSet = new HashSet(empSize);</span>
<span class="nc" id="L535">      JdmoQuery jQuery = jdmo.createQuery(strSQL, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L536">      jQuery.setParID(1, dataSourceID);</span>
<span class="nc" id="L537">      JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">      while (rs.next()) {</span>
<span class="nc" id="L539">        empSet.add(rs.getID(1));</span>
      }
<span class="nc" id="L541">      rs.close();</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">      if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L543">        m_cat.debug(&quot;Find following employees &quot; + empSet + &quot; associated with datasource &quot; + dataSourceID);</span>
      }
<span class="nc" id="L545">      insertHAAEntries(haaEntryMap, empSet, start, end, false);</span>
<span class="nc" id="L546">    } catch (AmException e) {</span>
<span class="nc" id="L547">      throw e;</span>
<span class="nc" id="L548">    } catch (Exception e) {</span>
<span class="nc" id="L549">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L551">      jdmo.cleanUp();</span>
<span class="nc" id="L552">      methodFinish();</span>
<span class="nc" id="L553">    }</span>
<span class="nc" id="L554">  }</span>

  private void adjustELEntries(ArrayList extRecordList, Collection elEntries, Date start, Date end) {
<span class="nc bnc" id="L557" title="All 4 branches missed.">    if (extRecordList == null || extRecordList.size() &lt;= 0)</span>
<span class="nc" id="L558">      return;</span>

<span class="nc bnc" id="L560" title="All 4 branches missed.">    if (elEntries == null || elEntries.size() &lt;= 0)</span>
<span class="nc" id="L561">      return;</span>

    // get existing GL's
<span class="nc" id="L564">    ArrayList gList = new ArrayList();</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">    for (int i = 0; i &lt; extRecordList.size(); i++) {</span>
<span class="nc" id="L566">      TimeRecord curRecord = (TimeRecord) extRecordList.get(i);</span>
<span class="nc" id="L567">      ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">      for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L569">        TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">        if (entry.getActivityID().equals(GL) || entry.getActivityID().equals(GLSTART)) {</span>
<span class="nc" id="L571">          gList.add(entry);</span>
        }
<span class="nc" id="L573">      }</span>
    }

<span class="nc bnc" id="L576" title="All 2 branches missed.">    if (gList.size() &lt;= 0)</span>
<span class="nc" id="L577">      return;</span>

    // scan and group ELentries as begin/end, compare
    // this with the GL's (above) and adjust the time stamps.
    // This is assuming elEntries are sorted
<span class="nc" id="L582">    Iterator iter = elEntries.iterator();</span>
<span class="nc" id="L583">    RawTimeEntry beginEL = null;</span>
<span class="nc" id="L584">    RawTimeEntry endEL = null;</span>
<span class="nc" id="L585">    TimeRecordEntry glCur = null;</span>
<span class="nc" id="L586">    TimeRecordEntry glNext = null;</span>

<span class="nc" id="L588">    Date newEnd = null;</span>
<span class="nc" id="L589">    Date newStart = null;</span>

<span class="nc" id="L591">    Iterator gIter = gList.iterator();</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">    while (iter.hasNext()) {</span>
<span class="nc" id="L593">      RawTimeEntry rte = (RawTimeEntry) iter.next();</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">      if (rte.getActivityID().equals(GLENDS))</span>
<span class="nc" id="L595">        endEL = rte;</span>
      else
<span class="nc" id="L597">        beginEL = rte;</span>

      // compare with GL
<span class="nc bnc" id="L600" title="All 4 branches missed.">      if (beginEL != null &amp;&amp; endEL != null) {</span>
<span class="nc bnc" id="L601" title="All 4 branches missed.">        if (glCur == null &amp;&amp; gIter.hasNext())</span>
<span class="nc" id="L602">          glCur = (TimeRecordEntry) gIter.next();</span>

<span class="nc bnc" id="L604" title="All 4 branches missed.">        if (glNext == null &amp;&amp; gIter.hasNext())</span>
<span class="nc" id="L605">          glNext = (TimeRecordEntry) gIter.next();</span>

        // EL before GL so truncate EL time to GL and set the new start time
<span class="nc bnc" id="L608" title="All 4 branches missed.">        if (glCur != null &amp;&amp; beginEL.getSortTime().before(glCur.getSortTime())) {</span>
<span class="nc" id="L609">          beginEL.setPunchTimestamp(glCur.getSortTime().getTime());</span>
<span class="nc" id="L610">          beginEL.setPunchDate(glCur.getSortTime());</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">          if (newStart == null)</span>
<span class="nc" id="L612">            newStart = beginEL.getSortTime();</span>
        }

        // EL end crosses the next GL so truncate EL end and set the new end time
<span class="nc bnc" id="L616" title="All 4 branches missed.">        if (glNext != null &amp;&amp; endEL.getSortTime().after(glNext.getSortTime())) {</span>
<span class="nc" id="L617">          Date endDate = new Date(glNext.getSortTime().getTime() - 1000L);</span>
<span class="nc" id="L618">          endEL.setPunchTimestamp(endDate.getTime());</span>
<span class="nc" id="L619">          endEL.setPunchDate(endDate);</span>
        }

<span class="nc" id="L622">        newEnd = endEL.getSortTime();</span>

<span class="nc" id="L624">        beginEL = null;</span>
<span class="nc" id="L625">        endEL = null;</span>
<span class="nc" id="L626">        glCur = glNext;</span>
<span class="nc" id="L627">        glNext = null;</span>
      }
<span class="nc" id="L629">    }</span>

    // adjust the start and end times
<span class="nc bnc" id="L632" title="All 2 branches missed.">    if (newStart != null)</span>
<span class="nc" id="L633">      start.setTime(newStart.getTime());</span>

<span class="nc bnc" id="L635" title="All 2 branches missed.">    if (newEnd != null)</span>
<span class="nc" id="L636">      end.setTime(newEnd.getTime());</span>
<span class="nc" id="L637">  }</span>

  private boolean isDuplicate(ArrayList extRecordList, Collection elEntries, Date start, Date end) {
<span class="nc bnc" id="L640" title="All 4 branches missed.">    if (extRecordList == null || extRecordList.size() &lt;= 0)</span>
<span class="nc" id="L641">      return false;</span>

<span class="nc bnc" id="L643" title="All 4 branches missed.">    if (elEntries == null || elEntries.size() &lt;= 0)</span>
<span class="nc" id="L644">      return false;</span>

<span class="nc" id="L646">    int matchCounter = 0;</span>

<span class="nc" id="L648">    Iterator iter = elEntries.iterator();</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">    while (iter.hasNext()) {</span>
<span class="nc" id="L650">      RawTimeEntry rteStart = (RawTimeEntry) iter.next();</span>
<span class="nc" id="L651">      RawTimeEntry rteEnd = null;</span>
<span class="nc" id="L652">      long duration = 0;</span>

<span class="nc bnc" id="L654" title="All 2 branches missed.">      if (iter.hasNext()) {</span>
<span class="nc" id="L655">        rteEnd = (RawTimeEntry) iter.next();</span>
<span class="nc" id="L656">        duration = (rteEnd.getPunchTimestamp() - rteStart.getPunchTimestamp()) / 60000L;</span>
      }

<span class="nc bnc" id="L659" title="All 2 branches missed.">      for (int i = 0; i &lt; extRecordList.size(); ++i) {</span>
<span class="nc" id="L660">        TimeRecord curRecord = (TimeRecord) extRecordList.get(i);</span>
<span class="nc" id="L661">        ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L663">          TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">          if (entry.getActivityID().equals(rteStart.getActivityID()) &amp;&amp;</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">              entry.getStartTime().equals(rteStart.getStartTime()) &amp;&amp;</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">              (entry.getDuration() == duration || duration == 0)) {</span>
<span class="nc" id="L667">            ++matchCounter;</span>
<span class="nc" id="L668">            break;</span>
          }
<span class="nc" id="L670">        }</span>
      }
<span class="nc" id="L672">    }</span>

<span class="nc bnc" id="L674" title="All 2 branches missed.">    return matchCounter == elEntries.size() / 2 ? true : false;</span>
  }

  public void insertHAAEntries(Map haaEntryMap, Collection empSet, Date start, Date end, boolean eLearning) throws AmException {
<span class="nc" id="L678">    Jdmo jdmo = new Jdmo();</span>
    try {
<span class="nc" id="L680">      HashSet empSetCopy = new HashSet(empSet);</span>
      // Then load all timerecords cross the haa window
      // If HAA window is between two entries, there will return no TimeRecord either
<span class="nc" id="L683">      HashMap extRecordMap = m_timeRecordManager.getEventsForWorkResourceWithOpenShift(empSet, TimeZoneUtil.toTimestamp(start), TimeZoneUtil.toTimestamp(end));</span>
      // define arraylist to save EventAuditTrail
<span class="nc" id="L685">      ArrayList eventAuditList = new ArrayList(empSet.size());</span>
      // insert HAA per employee with HAA entries

      // Fetch Employee Name first
<span class="nc" id="L689">      HashMap mapEmpNames = m_workResourceManager.getEmployeeNamesByIDs(empSet);</span>
<span class="nc" id="L690">      EmployeeName empName = null;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">      for (Iterator empIt = empSet.iterator(); empIt.hasNext(); ) {</span>
<span class="nc" id="L692">        ID empID = (ID) empIt.next();</span>
<span class="nc" id="L693">        ArrayList haaEntryList = (ArrayList) haaEntryMap.get(empID);</span>
        // get existing entry
<span class="nc" id="L695">        ArrayList extRecordList = (ArrayList) extRecordMap.get(empID);</span>

        // adjust EL entries
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (eLearning) {</span>
<span class="nc" id="L699">          this.adjustELEntries(extRecordList, haaEntryList, start, end);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">          if (isDuplicate(extRecordList, haaEntryList, start, end))</span>
<span class="nc" id="L701">            continue;</span>
        }

        // create audit trail entry
<span class="nc" id="L705">        empName = (EmployeeName) mapEmpNames.get(empID);</span>
<span class="nc" id="L706">        AuditTrailEntry auditEntry = new AuditTrailEntry(</span>
            AuditTrailEntry.MODULE_TIMERECORD,
            AuditTrailEntry.ACTION_UPDATE_OBJECT,
<span class="nc" id="L709">            empID, empName.getDisplayName(DefaultLocalizationManager.getDefaultInstance().getLocalizer()), start, end);</span>
<span class="nc" id="L710">        auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD), &quot;-1&quot;, false);</span>

<span class="nc" id="L712">        eventAuditList.add(auditEntry);</span>
<span class="nc bnc" id="L713" title="All 4 branches missed.">        if (haaEntryList != null &amp;&amp; !haaEntryList.isEmpty()) {</span>
          // locate first and last raw Time entry
<span class="nc" id="L715">          RawTimeEntry firstEntry = (RawTimeEntry) haaEntryList.get(0);</span>
<span class="nc" id="L716">          RawTimeEntry lastEntry = (RawTimeEntry) haaEntryList.get(haaEntryList.size() - 1);</span>

          // check if the HAA window cross any existing TimeRecord just before/after
          // to save the last Entry just before start of HAA
<span class="nc" id="L720">          ID prvTimeRecordID = null;</span>
<span class="nc" id="L721">          ID prvActivityID = null;</span>
<span class="nc" id="L722">          ID prvRawEntryID = null;</span>
<span class="nc" id="L723">          ID prvEntryID = null;</span>
<span class="nc" id="L724">          Date prvEntryStart = null;</span>
<span class="nc" id="L725">          int prvEntryTimeSourceCode = 0;</span>

          // to save the next entry just after the end of HAA
<span class="nc" id="L728">          ID nxtTimeRecordID = null;</span>
<span class="nc" id="L729">          ID nxtActivityID = null;</span>
<span class="nc" id="L730">          Date nxtEntryStart = null;</span>
<span class="nc" id="L731">          int recordSize = 0;</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">          if (extRecordList != null &amp;&amp; !extRecordList.isEmpty()) {</span>
<span class="nc" id="L733">            recordSize = extRecordList.size();</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">            for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L735">              TimeRecord curRecord = (TimeRecord) extRecordList.get(i);</span>
<span class="nc" id="L736">              ArrayList entryList = curRecord.getChild();</span>
<span class="nc" id="L737">              boolean foundPrv = false;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">              for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L739">                TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>

<span class="nc bnc" id="L741" title="All 4 branches missed.">                if (!foundPrv &amp;&amp; entry.getSortTime().before(firstEntry.getSortTime())) {</span>
<span class="nc" id="L742">                  prvTimeRecordID = curRecord.getID();</span>
<span class="nc" id="L743">                  prvActivityID = entry.getActivityID();</span>
<span class="nc" id="L744">                  prvEntryStart = entry.getSortTime();</span>
<span class="nc" id="L745">                  prvRawEntryID = entry.getRawTimeEntryID();</span>
<span class="nc" id="L746">                  prvEntryID = entry.getID();</span>
                } else {
<span class="nc" id="L748">                  foundPrv = true;</span>
                }
<span class="nc bnc" id="L750" title="All 2 branches missed.">                if (entry.getSortTime().after(lastEntry.getSortTime())) {</span>
                  // no need fetch next timerecord
<span class="nc" id="L752">                  nxtTimeRecordID = curRecord.getID();</span>
<span class="nc" id="L753">                  nxtActivityID = entry.getActivityID();</span>
<span class="nc" id="L754">                  nxtEntryStart = entry.getSortTime();</span>
<span class="nc" id="L755">                  break;</span>
                }
<span class="nc" id="L757">              }</span>
            }
          }
          // looking for preceding or next timerecord, may consider limit search window for one day bf/af
          // Find the preceding timerecord ID, ActivityID, and timestamp
<span class="nc bnc" id="L762" title="All 2 branches missed.">          if (prvTimeRecordID == null) {</span>
<span class="nc" id="L763">            String queryPrv =</span>
                &quot;select TIMERECORDID, ACTIVITYID, STARTTIME, RAWTIMEENTRYID, ID, TIMESOURCECODE from TIMEENTRYEVENT where UPDATETIMESTAMP=(&quot; +
                    &quot;select max(UPDATETIMESTAMP) from TIMEENTRYEVENT where UPDATETIMESTAMP&lt;? and EMPLOYEEID=?) and EMPLOYEEID=?&quot;;
<span class="nc" id="L766">            JdmoQuery jQuery2 = jdmo.createQuery(queryPrv, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L767">            jQuery2.setParLong(1, start.getTime());</span>
<span class="nc" id="L768">            jQuery2.setParID(2, empID);</span>
<span class="nc" id="L769">            jQuery2.setParID(3, empID);</span>
<span class="nc" id="L770">            JdmoRowset rs2 = jdmo.createRowset(jQuery2, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">            if (rs2.next()) {</span>
<span class="nc" id="L772">              prvTimeRecordID = rs2.getID(1);</span>
<span class="nc" id="L773">              prvActivityID = rs2.getID(2);</span>
<span class="nc" id="L774">              prvEntryStart = TimeZoneUtil.toDate(rs2.getTimestamp(3));</span>
<span class="nc" id="L775">              prvRawEntryID = rs2.getID(4);</span>
<span class="nc" id="L776">              prvEntryID = rs2.getID(5);</span>
<span class="nc" id="L777">              prvEntryTimeSourceCode = rs2.getInt(6);</span>
            }
<span class="nc" id="L779">            rs2.close();</span>
          }
          // Find the succeeding timerecord ID, ActivityID, and timestamp
<span class="nc bnc" id="L782" title="All 2 branches missed.">          if (nxtTimeRecordID == null) {</span>
            // Then search for the next TimeRecord
<span class="nc" id="L784">            String queryNxt =</span>
                &quot;select TIMERECORDID, ACTIVITYID, STARTTIME from TIMEENTRYEVENT where UPDATETIMESTAMP=(&quot; +
                    &quot;select min(UPDATETIMESTAMP) from TIMEENTRYEVENT where UPDATETIMESTAMP&gt;? and EMPLOYEEID=?) and EMPLOYEEID=?&quot;;
<span class="nc" id="L787">            JdmoQuery jQuery3 = jdmo.createQuery(queryNxt, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L788">            jQuery3.setParLong(1, end.getTime());</span>
<span class="nc" id="L789">            jQuery3.setParID(2, empID);</span>
<span class="nc" id="L790">            jQuery3.setParID(3, empID);</span>
<span class="nc" id="L791">            JdmoRowset rs3 = jdmo.createRowset(jQuery3, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">            if (rs3.next()) {</span>
<span class="nc" id="L793">              nxtTimeRecordID = rs3.getID(1);</span>
<span class="nc" id="L794">              nxtActivityID = rs3.getID(2);</span>
<span class="nc" id="L795">              nxtEntryStart = TimeZoneUtil.toDate(rs3.getTimestamp(3));</span>
            }
<span class="nc" id="L797">            rs3.close();</span>
          }
          // special handle the case, the HAA window is between two entries of one TR
<span class="nc bnc" id="L800" title="All 4 branches missed.">          if (extRecordList == null || extRecordList.isEmpty()) {</span>
<span class="nc bnc" id="L801" title="All 6 branches missed.">            if (prvTimeRecordID != null &amp;&amp; nxtTimeRecordID != null &amp;&amp; prvTimeRecordID.equals(nxtTimeRecordID)) {</span>
<span class="nc" id="L802">              extRecordList = new ArrayList();</span>
<span class="nc" id="L803">              extRecordList.add(m_timeRecordManager.getTimeRecordByID(prvTimeRecordID));</span>
<span class="nc" id="L804">              recordSize = extRecordList.size();</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">              for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L806">                TimeRecord curRecord = (TimeRecord) extRecordList.get(i);</span>
<span class="nc" id="L807">                ArrayList entryList = curRecord.getChild();</span>
<span class="nc" id="L808">                boolean foundPrv = false;</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">                for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L810">                  TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L811" title="All 4 branches missed.">                  if (!foundPrv &amp;&amp; entry.getSortTime().before(firstEntry.getSortTime())) {</span>
<span class="nc" id="L812">                    prvActivityID = entry.getActivityID();</span>
<span class="nc" id="L813">                    prvEntryStart = entry.getSortTime();</span>
<span class="nc" id="L814">                    prvRawEntryID = entry.getRawTimeEntryID();</span>
<span class="nc" id="L815">                    prvEntryID = entry.getID();</span>
<span class="nc" id="L816">                    prvEntryTimeSourceCode = entry.getTimeSourceCode();</span>
                  } else {
<span class="nc" id="L818">                    foundPrv = true;</span>
                  }
<span class="nc bnc" id="L820" title="All 2 branches missed.">                  if (entry.getSortTime().after(lastEntry.getSortTime())) {</span>
                    // no need fetch next timerecord
<span class="nc" id="L822">                    nxtActivityID = entry.getActivityID();</span>
<span class="nc" id="L823">                    nxtEntryStart = entry.getSortTime();</span>
<span class="nc" id="L824">                    break;</span>
                  }
<span class="nc" id="L826">                }</span>
              }
            }
          }
          // check merge/autoclose condition
<span class="nc" id="L831">          boolean autoUpdatePrv = false;</span>
<span class="nc" id="L832">          boolean autoMergePrv = false;</span>
<span class="nc" id="L833">          boolean autoClosePrv = false;</span>
          // auto create a new record if first entry no need append/merge
<span class="nc" id="L835">          boolean autoGen = false;</span>
          // if next Entry can update last entry, remove last entry
<span class="nc" id="L837">          boolean autoRm = false;</span>
<span class="nc" id="L838">          boolean autoMergeNxt = false;</span>
<span class="nc" id="L839">          boolean autoCloseNxt = false;</span>

          // if HAA entry is zero duration to previous entry, just update previous entry
<span class="nc bnc" id="L842" title="All 6 branches missed.">          if (FixZeroDuration &amp;&amp; prvTimeRecordID != null &amp;&amp; (firstEntry.getSortTime().getTime() - prvEntryStart.getTime() &lt; 1000))</span>
<span class="nc" id="L843">            autoUpdatePrv = true;</span>
          // if last HAA entry falls in same time as next entry, just remove last entry
<span class="nc bnc" id="L845" title="All 4 branches missed.">          if (nxtTimeRecordID != null &amp;&amp; lastEntry.getSortTime().getTime() == nxtEntryStart.getTime()) {</span>
<span class="nc" id="L846">            autoRm = true;</span>
<span class="nc" id="L847">            haaEntryList.remove(haaEntryList.size() - 1);</span>
          }
          // Most of the cases, there is previous TimeRecord and succeeding TimeRecord
<span class="nc bnc" id="L850" title="All 2 branches missed.">          if (PerformAutoMerge) {</span>
<span class="nc bnc" id="L851" title="All 6 branches missed.">            if (!autoUpdatePrv &amp;&amp; prvTimeRecordID != null &amp;&amp; prvActivityID.equals(Activity.ACTIVITY_NONE) &amp;&amp;</span>
<span class="nc bnc" id="L852" title="All 4 branches missed.">                (firstEntry.getSortTime().getTime() - prvEntryStart.getTime() &lt;= AutoMergeTimeoutInMillis) &amp;&amp;</span>
                !eLearning)
              // auto merge with previous record
<span class="nc" id="L855">              autoMergePrv = true;</span>
<span class="nc bnc" id="L856" title="All 6 branches missed.">            if (!autoRm &amp;&amp; nxtTimeRecordID != null &amp;&amp; lastEntry.isEndShift() &amp;&amp;</span>
<span class="nc bnc" id="L857" title="All 4 branches missed.">                (nxtEntryStart.getTime() - lastEntry.getSortTime().getTime() &lt;= AutoMergeTimeoutInMillis) &amp;&amp;</span>
                !eLearning)
              // next record auto merge with haa
<span class="nc" id="L860">              autoMergeNxt = true;</span>
          }
          if (PerformAutoClose) {
            // check Auto close
<span class="nc bnc" id="L864" title="All 6 branches missed.">            if (!autoUpdatePrv &amp;&amp; prvTimeRecordID != null &amp;&amp; !prvActivityID.equals(Activity.ACTIVITY_NONE) &amp;&amp;</span>
<span class="nc bnc" id="L865" title="All 4 branches missed.">                (firstEntry.getSortTime().getTime() - prvEntryStart.getTime() &gt;= AutoCloseTimeoutInMillis) &amp;&amp;</span>
                !eLearning) {
              // should auto close previous record first
<span class="nc" id="L868">              autoClosePrv = true;</span>
            }
<span class="nc bnc" id="L870" title="All 6 branches missed.">            if (!autoRm &amp;&amp; nxtTimeRecordID != null &amp;&amp; !lastEntry.isEndShift() &amp;&amp;</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">                (nxtEntryStart.getTime() - lastEntry.getSortTime().getTime() &gt;= AutoCloseTimeoutInMillis) &amp;&amp;</span>
                !eLearning) {
<span class="nc" id="L873">              autoCloseNxt = true;</span>
            }
          }
<span class="nc bnc" id="L876" title="All 6 branches missed.">          if (prvTimeRecordID == null || (prvActivityID.equals(Activity.ACTIVITY_NONE) &amp;&amp; !autoMergePrv)) {</span>
<span class="nc" id="L877">            autoGen = true;</span>
          }
<span class="nc bnc" id="L879" title="All 2 branches missed.">          if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L880">            m_cat.debug(&quot;In HAA, AutoUpdatePrv=&quot; + autoUpdatePrv + &quot;,AutoMergePrv=&quot; + autoMergePrv +</span>
                &quot;, AutoClosePrv=&quot; + autoClosePrv + &quot;, AutoGen=&quot; + autoGen + &quot;, AutoRm=&quot; + autoRm + &quot;, AutoMergeNxt=&quot; + autoMergeNxt + &quot;, AutoCloseNxt=&quot; + autoCloseNxt);
          }
          // mix existing entries with HAA entries, and rebuild the timerecords
<span class="nc" id="L884">          Set treRemoveSet = new HashSet();</span>
          // to support eLearning feed, here need scan the underlying entries
          // if no General Learning activity, but with other activities, won't impose the feed
          // if no entries at all, create feed regardless (which could be after endshift, etc.)
          // if found General Learning in between, then realign feed start time to it, remove General Learning, impose feed
          //
          // mix HAA with existing entries
<span class="nc" id="L891">          ArrayList mixedEntryList = new ArrayList();</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">          if (eLearning) {</span>
            // track what eLearning Entries will be imposed
<span class="nc" id="L894">            ArrayList elEntryList = new ArrayList();</span>
<span class="nc" id="L895">            boolean findGL = false;</span>
<span class="nc bnc" id="L896" title="All 4 branches missed.">            if (prvTimeRecordID != null &amp;&amp; prvActivityID.equals(GL)) {</span>
              // there is entry before EL window and it is General Learning, need keep it
<span class="nc" id="L898">              findGL = true;</span>
              // enhanced to compare with each HAA chunk's first entry, if not before it, need be removed
<span class="nc bnc" id="L900" title="All 2 branches missed.">              if (!prvEntryStart.before(((RawTimeEntry) haaEntryList.get(0)).getSortTime()))</span>
<span class="nc" id="L901">                treRemoveSet.add(prvEntryID);</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">              if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L903">                m_cat.debug(&quot;Find General Learning entry &quot; + prvEntryID + &quot; at &quot; + prvEntryStart);</span>
              }
            }
            // prepare underlying entries list
<span class="nc" id="L907">            ArrayList underList = new ArrayList();</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            if (prvTimeRecordID != null) {</span>
<span class="nc" id="L909">              TimeRecordEntry prvEntry = new TimeRecordEntry();</span>
<span class="nc" id="L910">              prvEntry.setID(prvEntryID);</span>
<span class="nc" id="L911">              prvEntry.setActivityID(prvActivityID);</span>
<span class="nc" id="L912">              prvEntry.setSortTime(prvEntryStart);</span>
<span class="nc" id="L913">              prvEntry.setTimeSourceCode(prvEntryTimeSourceCode);</span>
<span class="nc" id="L914">              underList.add(prvEntry);</span>
            }
            // now scan other entries
<span class="nc bnc" id="L917" title="All 2 branches missed.">            if (recordSize != 0) {</span>
<span class="nc" id="L918">              RawTimeEntry lastEL = null;</span>
              // need add existing records which is from MyTime/Manager back to HAA window
<span class="nc bnc" id="L920" title="All 2 branches missed.">              for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L921">                TimeRecord curRecord = (TimeRecord) extRecordList.get(i);</span>
<span class="nc" id="L922">                ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L924">                  TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L925" title="All 4 branches missed.">                  if (!entry.getSortTime().before(start) &amp;&amp; !entry.getSortTime().after(end)) {</span>
                    // in EL, keep every existing entries.
<span class="nc bnc" id="L927" title="All 2 branches missed.">                    if (entry.getID() != prvEntryID)</span>
<span class="nc" id="L928">                      underList.add(entry);</span>
<span class="nc bnc" id="L929" title="All 4 branches missed.">                    if (!findGL &amp;&amp; entry.getActivityID().equals(GL)) {</span>

                      // find GL in the middle for the first time, then just keep the last EL entry before it,
                      // and remove this entry from DB
<span class="nc bnc" id="L933" title="All 2 branches missed.">                      if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L934">                        m_cat.debug(&quot;Find GL in the middle for the first time at &quot; + entry);</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                      for (ListIterator haaIt = haaEntryList.listIterator(); haaIt.hasNext(); ) {</span>
<span class="nc" id="L936">                        RawTimeEntry haaEntry = (RawTimeEntry) haaIt.next();</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                        if (haaEntry.getSortTime().before(entry.getSortTime())) {</span>
<span class="nc" id="L938">                          lastEL = haaEntry;</span>
<span class="nc" id="L939">                          haaIt.remove();</span>
                        } else
                          break;
<span class="nc" id="L942">                      }</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">                      if (lastEL != null)</span>
<span class="nc" id="L944">                        haaEntryList.add(0, lastEL);</span>
<span class="nc" id="L945">                      findGL = true;</span>
<span class="nc" id="L946">                      treRemoveSet.add(entry.getID());</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                      if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L948">                        m_cat.debug(&quot;Find GL in the middle for the first time and left ELEntries &quot; + haaEntryList);</span>
                      continue;
<span class="nc bnc" id="L950" title="All 2 branches missed.">                    } else if (entry.getActivityID().equals(GL)) {</span>

                      // if there are multiple GLs, just use the first GL as cutting off line, simply remove the remaining GLs
                      //treRemoveSet.add(entry.getID());

<span class="nc bnc" id="L955" title="All 2 branches missed.">                      if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L956">                        m_cat.debug(&quot;Find other GL in the middle, remove it &quot; + entry);</span>
                      continue;
                    }
                  }
<span class="nc" id="L960">                }</span>
              }
            }
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (findGL) {</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">              if (!underList.isEmpty()) {</span>
                // find GL and underlying entries, now rebuild entries
                // it may dup entries, move EndShift to a different time
<span class="nc" id="L967">                ListIterator itHA = haaEntryList.listIterator();</span>
<span class="nc" id="L968">                RawTimeEntry elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc" id="L969">                TimeRecordEntry lastTRE = null;</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">                for (ListIterator itUnder = underList.listIterator(); itUnder.hasNext(); ) {</span>
<span class="nc" id="L971">                  TimeRecordEntry exEntry = (TimeRecordEntry) itUnder.next();</span>
<span class="nc" id="L972">                  lastTRE = exEntry;</span>


<span class="nc bnc" id="L975" title="All 2 branches missed.">                  if (exEntry.getSortTime().before(elEntry.getSortTime())) {</span>

                    // Check and truncate learning end if it crosses the next activity
                    // and the next activity is not an end shift

<span class="nc bnc" id="L980" title="All 2 branches missed.">                    if (exEntry.getActivityID().equals(GL)) {</span>
                      // dup last EL entry at this GL time first, if prev TRE is not GL
<span class="nc" id="L982">                      int prvIdx = itUnder.previousIndex() - 1;</span>
<span class="nc" id="L983">                      boolean prvGL = false;</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">                      if (prvIdx &gt;= 0) {</span>
<span class="nc" id="L985">                        TimeRecordEntry prvEntry = (TimeRecordEntry) underList.get(prvIdx);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">                        prvGL = prvEntry.getActivityID().equals(GL) ||</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">                            prvEntry.getActivityID().equals(Activity.ACTIVITY_NONE) ||</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                            prvEntry.getActivityID().equals(Activity.ACTIVITY_MERGE);</span>
                      }
<span class="nc bnc" id="L990" title="All 4 branches missed.">                      if (!elEntryList.isEmpty() &amp;&amp; !prvGL) {</span>
<span class="nc" id="L991">                        RawTimeEntry lstEL = (RawTimeEntry) elEntryList.get(elEntryList.size() - 1);</span>
                        // if last EL is GLENDS, no need to add it again
<span class="nc bnc" id="L993" title="All 2 branches missed.">                        if (!lstEL.getActivityID().equals(GLENDS)) {</span>
<span class="nc" id="L994">                          RawTimeEntry dupEL = new RawTimeEntry();</span>
<span class="nc" id="L995">                          dupEL.setEmployeeID(lstEL.getEmployeeID());</span>
<span class="nc" id="L996">                          dupEL.setActivityId(lstEL.getActivityID());</span>
<span class="nc" id="L997">                          dupEL.setPunchTimestamp(exEntry.getSortTime().getTime());</span>
<span class="nc" id="L998">                          dupEL.setPunchDate(exEntry.getSortTime());</span>
<span class="nc" id="L999">                          dupEL.setTimeSourceCode(exEntry.getTimeSourceCode());</span>
<span class="nc" id="L1000">                          elEntryList.add(dupEL);</span>
<span class="nc" id="L1001">                        } else {</span>
<span class="nc" id="L1002">                          treRemoveSet.remove(exEntry.getID());</span>
                        }
                      }
                      // save ELs, until the next TRE's start time, then next EL must be after next TRE
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                      if (itUnder.hasNext()) {</span>
<span class="nc" id="L1007">                        exEntry = (TimeRecordEntry) itUnder.next();</span>
<span class="nc" id="L1008">                        itUnder.previous();</span>
                      } else {
<span class="nc" id="L1010">                        elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
<span class="nc" id="L1011">                        break;</span>
                      }

                      do {
                        // skip if elentries are same
<span class="nc bnc" id="L1016" title="All 2 branches missed.">                        if (elEntry.getActivityID().equals(exEntry.getActivityID()) &amp;&amp;</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                            elEntry.getSortTime().equals(exEntry.getSortTime())) {</span>
                          // skip the GL end
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                          if (itHA.hasNext()) {</span>
<span class="nc" id="L1020">                            elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">                            if (elEntry.getActivityID().equals(GLENDS)) {</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                              if (itHA.hasNext()) {</span>
<span class="nc" id="L1023">                                elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc" id="L1024">                                continue;</span>
                              } else
                                break;
                            }
                            continue;
                          } else
                            break;

                        }

<span class="nc bnc" id="L1034" title="All 2 branches missed.">                        if (elEntry.getSortTime().after(exEntry.getSortTime())) {</span>

                          // truncate this EL to the prev TRE, only if it's not end shift
<span class="nc" id="L1037">                          itHA.remove();</span>
<span class="nc" id="L1038">                          elEntry = null;</span>

<span class="nc bnc" id="L1040" title="All 2 branches missed.">                          if (exEntry.getActivityID().equals(Activity.ACTIVITY_NONE))</span>
<span class="nc" id="L1041">                            break;</span>
                        } else {
<span class="nc" id="L1043">                          elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
                        }

<span class="nc bnc" id="L1046" title="All 2 branches missed.">                        if (itHA.hasNext())</span>
<span class="nc" id="L1047">                          elEntry = (RawTimeEntry) itHA.next();</span>
                        else {
                          break;
                        }
                      } while (true);


<span class="nc bnc" id="L1054" title="All 2 branches missed.">                      if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1055">                        m_cat.debug(&quot;Find a GL in the middle, elEntry has &quot; + elEntryList);</span>
                      // additionally break if no more EL entries
<span class="nc bnc" id="L1057" title="All 2 branches missed.">                      if (elEntry == null)</span>
<span class="nc" id="L1058">                        break;</span>
<span class="nc" id="L1059">                    } else {</span>
                      // keep this entry, skip all ELs till next TRE (if not GL), keep last entry if it is GL
                      // if this is EndShift/Merged entry, need extend it till next entry start.
<span class="nc bnc" id="L1062" title="All 2 branches missed.">                      if (exEntry.getActivityID().equals(Activity.ACTIVITY_NONE) ||</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                          exEntry.getActivityID().equals(Activity.ACTIVITY_MERGE)) {</span>
                        // ignore any endshift before EL starts
<span class="nc bnc" id="L1065" title="All 2 branches missed.">                        if (exEntry.getSortTime().before(start))</span>
<span class="nc" id="L1066">                          continue;</span>
                        // add back endshift
<span class="nc" id="L1068">                        RawTimeEntry rteEnd = new RawTimeEntry();</span>
<span class="nc" id="L1069">                        rteEnd.setEmployeeID(exEntry.getEmployeeID());</span>
<span class="nc" id="L1070">                        rteEnd.setActivityId(exEntry.getActivityID());</span>
<span class="nc" id="L1071">                        rteEnd.setTimeSourceCode(exEntry.getTimeSourceCode());</span>

                        // dup last EL entry at this GL time first, if prev TRE is not GL
<span class="nc" id="L1074">                        int prvIdx = itUnder.previousIndex() - 1;</span>
<span class="nc" id="L1075">                        boolean prvGL = false;</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">                        if (prvIdx &gt;= 0) {</span>
<span class="nc" id="L1077">                          TimeRecordEntry prvEntry = (TimeRecordEntry) underList.get(prvIdx);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">                          prvGL = prvEntry.getActivityID().equals(GL) ||</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">                              prvEntry.getActivityID().equals(Activity.ACTIVITY_NONE) ||</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">                              prvEntry.getActivityID().equals(Activity.ACTIVITY_MERGE);</span>
                        }
<span class="nc" id="L1082">                        treRemoveSet.add(exEntry.getID());</span>
<span class="nc bnc" id="L1083" title="All 4 branches missed.">                        if (!elEntryList.isEmpty() &amp;&amp; !prvGL) {</span>
<span class="nc" id="L1084">                          RawTimeEntry lstEL = (RawTimeEntry) elEntryList.get(elEntryList.size() - 1);</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">                          if (!lstEL.getActivityID().equals(GLENDS)) {</span>
<span class="nc" id="L1086">                            RawTimeEntry dupEL = new RawTimeEntry();</span>
<span class="nc" id="L1087">                            dupEL.setEmployeeID(lstEL.getEmployeeID());</span>
<span class="nc" id="L1088">                            dupEL.setActivityId(lstEL.getActivityID());</span>
<span class="nc" id="L1089">                            dupEL.setPunchTimestamp(exEntry.getSortTime().getTime());</span>
<span class="nc" id="L1090">                            dupEL.setPunchDate(exEntry.getSortTime());</span>
<span class="nc" id="L1091">                            dupEL.setTimeSourceCode(exEntry.getTimeSourceCode());</span>

<span class="nc" id="L1093">                            elEntryList.add(dupEL);</span>
<span class="nc" id="L1094">                          } else {</span>
<span class="nc" id="L1095">                            treRemoveSet.remove(exEntry.getID());</span>
                          }
                        }
<span class="nc" id="L1098">                        Date endTime = elEntry.getSortTime();</span>
<span class="nc" id="L1099">                        elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                        if (itUnder.hasNext()) {</span>
<span class="nc" id="L1101">                          exEntry = (TimeRecordEntry) itUnder.next();</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                          while (itHA.hasNext()) {</span>
<span class="nc" id="L1103">                            elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                            if (elEntry.getSortTime().before(exEntry.getSortTime())) {</span>
<span class="nc" id="L1105">                              endTime = elEntry.getSortTime();</span>
<span class="nc" id="L1106">                              elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
                            } else
                              break;
                          }
<span class="nc" id="L1110">                          itUnder.previous();</span>
                        } else {
                          // add all remaining
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                          while (itHA.hasNext()) {</span>
<span class="nc" id="L1114">                            elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc" id="L1115">                            endTime = elEntry.getSortTime();</span>
<span class="nc" id="L1116">                            elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
                          }
                        }
<span class="nc" id="L1119">                        rteEnd.setPunchDate(endTime);</span>
<span class="nc" id="L1120">                        rteEnd.setPunchTimestamp(endTime.getTime());</span>
<span class="nc" id="L1121">                        RawTimeEntry lstEntry = (RawTimeEntry) elEntryList.get(elEntryList.size() - 1);</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                        if (lstEntry.getActivityID().equals(GLENDS)) {</span>
                          // replace last GL Ends with this End Shift
<span class="nc" id="L1124">                          elEntryList.remove(elEntryList.size() - 1);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">                        } else if (lastTRE.getActivityID().equals(rteEnd.getActivityID()) &amp;&amp;</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                            rteEnd.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>

                          // don't add 2 end shifts, this will result in an records merge
                          // activity
<span class="nc" id="L1130">                          continue;</span>
                        } else {
                          // not GL Ends, create a system auto close, plus 1 second
<span class="nc" id="L1133">                          rteEnd.setPunchTimestamp(rteEnd.getPunchTimestamp() + 1000l);</span>
<span class="nc" id="L1134">                          rteEnd.setPunchDate(new Date(rteEnd.getPunchDate().getTime() + 1000l));</span>
<span class="nc" id="L1135">                          rteEnd.setPunchTimeCode(RawTimeEntry.AUTOCLOSE_END_SHIFT);</span>
                        }
<span class="nc" id="L1137">                        elEntryList.add(rteEnd);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">                        if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1139">                          m_cat.debug(&quot;Find an EndShift in the middle, add new one at &quot; + rteEnd + &quot; elEntry has &quot; + elEntryList);</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">                        if (elEntry == null) {</span>
<span class="nc" id="L1141">                          break;</span>
                        }
<span class="nc" id="L1143">                      } else {</span>

<span class="nc bnc" id="L1145" title="All 2 branches missed.">                        if (itUnder.hasNext()) {</span>
<span class="nc" id="L1146">                          exEntry = (TimeRecordEntry) itUnder.next();</span>
<span class="nc" id="L1147">                          itUnder.previous();</span>
                        } else {
                          break;
                        }
<span class="nc bnc" id="L1151" title="All 2 branches missed.">                        if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1152">                          m_cat.debug(&quot;Find a entry after current EL, next under Entry is &quot; + exEntry);</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                        if (exEntry.getActivityID().equals(GL)) {</span>
                          // now progress EL to the one just before GL
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                          if (itHA.hasNext()) {</span>
                            // skip till one just before exEntry ends
<span class="nc" id="L1157">                            RawTimeEntry nxtEntry = elEntry;</span>
                            do {
<span class="nc" id="L1159">                              elEntry = nxtEntry;</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                              if (itHA.hasNext())</span>
<span class="nc" id="L1161">                                nxtEntry = (RawTimeEntry) itHA.next();</span>
                              else {
                                break;
                              }
<span class="nc bnc" id="L1165" title="All 2 branches missed.">                            } while (nxtEntry.getSortTime().before(exEntry.getSortTime()));</span>
<span class="nc" id="L1166">                            itHA.previous();</span>
                          }
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                          if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1169">                            m_cat.debug(&quot;As next under Entry is GL, just keep last EL before this GL &quot; + elEntry);</span>
                          continue;
                        }
<span class="nc" id="L1172">                        boolean findEL = elEntry.getSortTime().after(exEntry.getSortTime());</span>
<span class="nc bnc" id="L1173" title="All 4 branches missed.">                        while (!findEL &amp;&amp; itHA.hasNext()) {</span>
<span class="nc" id="L1174">                          elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">                          if (elEntry.getSortTime().after(exEntry.getSortTime())) {</span>
<span class="nc" id="L1176">                            findEL = true;</span>
<span class="nc" id="L1177">                            break;</span>
                          }
                        }
<span class="nc bnc" id="L1180" title="All 2 branches missed.">                        if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1181">                          m_cat.debug(&quot;Continue to skip EL, next EL is &quot; + elEntry);</span>
<span class="nc bnc" id="L1182" title="All 4 branches missed.">                        if (!findEL &amp;&amp; !itHA.hasNext())</span>
<span class="nc" id="L1183">                          break;</span>
<span class="nc" id="L1184">                      }</span>
                    }
                  } else {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">                    if (exEntry.getActivityID().equals(GL)) {</span>
<span class="nc" id="L1188">                      Date lstELTime = null;</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">                      if (exEntry.getActivityID().equals(GLENDS)) {</span>
<span class="nc" id="L1190">                        treRemoveSet.remove(exEntry.getID());</span>
                      } else {
<span class="nc" id="L1192">                        elEntry.setPunchTimestamp(exEntry.getSortTime().getTime());</span>
<span class="nc" id="L1193">                        elEntry.setPunchDate(exEntry.getSortTime());</span>
<span class="nc" id="L1194">                        elEntry.setTimeSourceCode(exEntry.getTimeSourceCode());</span>
<span class="nc" id="L1195">                        elEntryList.add(elEntry);</span>
<span class="nc" id="L1196">                        lstELTime = exEntry.getSortTime();</span>
<span class="nc" id="L1197">                        elEntry = null;</span>
                      }
<span class="nc bnc" id="L1199" title="All 2 branches missed.">                      if (itHA.hasNext()) {</span>
                        // check next EL
<span class="nc bnc" id="L1201" title="All 2 branches missed.">                        if (itUnder.hasNext()) {</span>
                          // get next underlying entry
<span class="nc" id="L1203">                          exEntry = (TimeRecordEntry) itUnder.next();</span>
                          // add all ELs before next entry
                          do {
<span class="nc" id="L1206">                            elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                            if (elEntry.getSortTime().before(exEntry.getSortTime())) {</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                              if (lstELTime != null &amp;&amp;</span>
<span class="nc bnc" id="L1209" title="All 4 branches missed.">                                  (elEntry.getSortTime().equals(lstELTime) ||</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                                      (FixZeroDuration &amp;&amp; (elEntry.getSortTime().getTime() - lstELTime.getTime()) &lt; 1000))) {</span>
<span class="nc" id="L1211">                                elEntryList.remove(elEntryList.size() - 1);</span>
                              }
<span class="nc" id="L1213">                              elEntry = addEL(elEntryList, elEntry, lastTRE);</span>

                            } else
                              break;
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                          } while (itHA.hasNext());</span>
<span class="nc" id="L1218">                          itUnder.previous();</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                          if (elEntry == null)</span>
<span class="nc" id="L1220">                            break;</span>
                          else
                            continue;
                        }
                      }
<span class="nc" id="L1225">                      elEntry = null;</span>
<span class="nc" id="L1226">                      break;</span>
                    } else {

<span class="nc bnc" id="L1229" title="All 2 branches missed.">                      if (itHA.hasNext()) {</span>
                        // skip till one just before exEntry ends
<span class="nc" id="L1231">                        RawTimeEntry nxtEntry = elEntry;</span>
                        do {
<span class="nc" id="L1233">                          elEntry = nxtEntry;</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">                          if (itHA.hasNext())</span>
<span class="nc" id="L1235">                            nxtEntry = (RawTimeEntry) itHA.next();</span>
                          else {
                            break;
                          }
<span class="nc bnc" id="L1239" title="All 2 branches missed.">                        } while (nxtEntry.getSortTime().before(exEntry.getSortTime()));</span>
<span class="nc" id="L1240">                        itHA.previous();</span>
                      }
                    }
                  }
<span class="nc" id="L1244">                }</span>
                // special handle last entry cases
<span class="nc bnc" id="L1246" title="All 4 branches missed.">                if (elEntry == null &amp;&amp; itHA.hasNext())</span>
<span class="nc" id="L1247">                  elEntry = (RawTimeEntry) itHA.next();</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">                if (elEntry != null) {</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                  if (lastTRE.getSortTime().before(elEntry.getSortTime())) {</span>


<span class="nc bnc" id="L1252" title="All 2 branches missed.">                    if (lastTRE.getActivityID().equals(GL)) {</span>
                      // add all EL events after GL
<span class="nc" id="L1254">                      elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                      while (itHA.hasNext())</span>
<span class="nc" id="L1256">                        addEL(elEntryList, (RawTimeEntry) itHA.next(), lastTRE);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                    } else if (lastTRE.getActivityID().equals(Activity.ACTIVITY_NONE) ||</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">                        lastTRE.getActivityID().equals(Activity.ACTIVITY_MERGE)) {</span>
                      // special case, shift closed, then remove this end shift, impose all ELs and create a new EndShift at the end
<span class="nc bnc" id="L1260" title="All 2 branches missed.">                      while (itHA.hasNext())</span>
<span class="nc" id="L1261">                        addEL(elEntryList, (RawTimeEntry) itHA.next(), lastTRE);</span>
                      // handle new EndShift, remove last EL?
<span class="nc" id="L1263">                      treRemoveSet.add(lastTRE.getID());</span>
                      // add back endshift
<span class="nc" id="L1265">                      RawTimeEntry rteEnd = new RawTimeEntry();</span>
<span class="nc" id="L1266">                      rteEnd.setEmployeeID(lastTRE.getEmployeeID());</span>
<span class="nc" id="L1267">                      rteEnd.setActivityId(lastTRE.getActivityID());</span>
<span class="nc" id="L1268">                      rteEnd.setPunchDate(end);</span>
<span class="nc" id="L1269">                      rteEnd.setPunchTimestamp(end.getTime());</span>

<span class="nc" id="L1271">                      RawTimeEntry lstEntry = (RawTimeEntry) elEntryList.get(elEntryList.size() - 1);</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">                      if (lstEntry.getActivityID().equals(GLENDS) ||</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">                          lstEntry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
                        // replace last GL Ends with this End Shift
<span class="nc" id="L1275">                        elEntryList.remove(elEntryList.size() - 1);</span>
                      } else {
                        // not GL Ends, create a system auto close, plus 1 second
<span class="nc" id="L1278">                        rteEnd.setPunchTimestamp(rteEnd.getPunchTimestamp() + 1000l);</span>
<span class="nc" id="L1279">                        rteEnd.setPunchDate(new Date(rteEnd.getPunchDate().getTime() + 1000l));</span>
<span class="nc" id="L1280">                        rteEnd.setPunchTimeCode(RawTimeEntry.AUTOCLOSE_END_SHIFT);</span>
                      }
<span class="nc" id="L1282">                      elEntryList.add(rteEnd);</span>
<span class="nc" id="L1283">                    }</span>
                  } else {
<span class="nc bnc" id="L1285" title="All 2 branches missed.">                    if (lastTRE.getActivityID().equals(GL)) {</span>
                      // align last EL to lastTRE start time and save, ignore the remaining ELs
<span class="nc" id="L1287">                      RawTimeEntry lstEL = null;</span>
                      do {
<span class="nc" id="L1289">                        lstEL = elEntry;</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">                        if (itHA.hasNext())</span>
<span class="nc" id="L1291">                          elEntry = (RawTimeEntry) itHA.next();</span>
                        else
                          break;
<span class="nc bnc" id="L1294" title="All 2 branches missed.">                      } while (lastTRE.getSortTime().after(elEntry.getSortTime()));</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                      if (!lstEL.getActivityID().equals(GLENDS)) {</span>
<span class="nc" id="L1296">                        lstEL.setPunchTimestamp(lastTRE.getSortTime().getTime());</span>
<span class="nc" id="L1297">                        lstEL.setPunchDate(lastTRE.getStartTime());</span>
<span class="nc" id="L1298">                        addEL(elEntryList, lstEL, lastTRE);</span>
<span class="nc" id="L1299">                        elEntryList.add(lstEL);</span>
                      } else {
<span class="nc" id="L1301">                        treRemoveSet.remove(lastTRE.getID());</span>
                      }
                    }
                  }
                }
<span class="nc" id="L1306">              } else {</span>
                // directly impose, no special handling, should happen most of the time
<span class="nc" id="L1308">                elEntryList.addAll(haaEntryList);</span>
              }
            } else {
              // no underlying GL, just give up
              // need consider End Shift case? agent just log off phone and forgot to use GL
            }
<span class="nc" id="L1314">            mixedEntryList.addAll(elEntryList);</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">            if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1316">              m_cat.debug(&quot;ELEntries are &quot; + elEntryList);</span>
<span class="nc" id="L1317">              m_cat.debug(&quot;Removed entries &quot; + treRemoveSet);</span>
<span class="nc" id="L1318">              m_cat.debug(&quot;Mixed entries &quot; + mixedEntryList);</span>
            }
<span class="nc" id="L1320">          } else {</span>
            // for regular HAA
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            if (recordSize != 0) {</span>
<span class="nc" id="L1323">              mixedEntryList.addAll(haaEntryList);</span>
              // need add existing records which is from MyTime/Manager back to HAA window
<span class="nc bnc" id="L1325" title="All 2 branches missed.">              for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L1326">                TimeRecord curRecord = (TimeRecord) extRecordList.get(i);</span>
<span class="nc" id="L1327">                ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">                for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1329">                  TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L1330" title="All 4 branches missed.">                  if (!entry.getSortTime().before(start) &amp;&amp; !entry.getSortTime().after(end)) {</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">                    if (entry.getTimeSourceCode() != TimeEntrySourceCode.HAAFEED &amp;&amp;</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">                        entry.getTimeSourceCode() != TimeEntrySourceCode.RAWPUNCH &amp;&amp;</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                        entry.getTimeSourceCode() != TimeEntrySourceCode.AUTO_CLOSE &amp;&amp;</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">                        entry.getTimeSourceCode() != TimeEntrySourceCode.AUTO_MERGE) {</span>
                      // entry is within haa window, retain it
                      // it is not from Raw Punch and HAA
<span class="nc" id="L1337">                      mixedEntryList.add(entry);</span>
                    } else {
<span class="nc" id="L1339">                      treRemoveSet.add(entry.getID());</span>
                    }
                  }
<span class="nc" id="L1342">                }</span>
              }
            }
          }
          // resort HAA Entry based on sort time, and produce new records
<span class="nc" id="L1347">          Collections.sort(mixedEntryList, RawTimeEntrySort.PUNCHTIME_ORDER);</span>
          // TODO: if HAA is after eLearning feed, then it need
          // apply auto close/merge rules on the records
<span class="nc" id="L1350">          boolean containEndShift = false;</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">          for (ListIterator i = mixedEntryList.listIterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1352">            EmployeeEvent event = (EmployeeEvent) i.next();</span>
            // if endshift is last entry in the list and from existing TR, no need to reconsider it
<span class="nc bnc" id="L1354" title="All 6 branches missed.">            containEndShift = event.getActivityID().equals(Activity.ACTIVITY_NONE) &amp;&amp; (!((event.getID() != null) &amp;&amp; !i.hasNext()));</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">            if (!i.hasNext())</span>
<span class="nc" id="L1356">              break;</span>
<span class="nc" id="L1357">            EmployeeEvent nextEvent = (EmployeeEvent) i.next();</span>
            // remove 0 duration entry always
<span class="nc bnc" id="L1359" title="All 6 branches missed.">            if (FixZeroDuration &amp;&amp; (nextEvent.getSortTime().getTime() - event.getSortTime().getTime() &lt; 1000) ||</span>
                // not eLearning mode, if two events have same Activity, should discard the next Event
                // when two events are both from RawPunch
<span class="nc bnc" id="L1362" title="All 2 branches missed.">                (!eLearning &amp;&amp; nextEvent.getActivityID().equals(event.getActivityID())) &amp;&amp;</span>
<span class="nc bnc" id="L1363" title="All 4 branches missed.">                    (nextEvent.getTimeSourceCode() == event.getTimeSourceCode() &amp;&amp; event.getTimeSourceCode() == TimeEntrySourceCode.RAWPUNCH)) {</span>
              // if event will be gone, then check if it exists on DB, then
<span class="nc bnc" id="L1365" title="All 2 branches missed.">              if (event.getID() != null)</span>
<span class="nc" id="L1366">                treRemoveSet.add(event.getID());</span>
<span class="nc" id="L1367">              i.previous();</span>
<span class="nc" id="L1368">              i.remove();</span>
<span class="nc" id="L1369">              continue;</span>
            }
            // if activity is end shift, check auto merge condition
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            if (event.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
              // if two EndShift are next to each other, just auto merge
<span class="nc bnc" id="L1374" title="All 4 branches missed.">              if (nextEvent.getActivityID().equals(Activity.ACTIVITY_NONE) || (PerformAutoMerge &amp;&amp;</span>
<span class="nc bnc" id="L1375" title="All 2 branches missed.">                  ((nextEvent.getSortTime().getTime() - event.getSortTime().getTime()) &lt;= AutoMergeTimeoutInMillis))) {</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">                if (event instanceof RawTimeEntry) {</span>
                  // need perform auto merge
<span class="nc" id="L1378">                  RawTimeEntry rte = (RawTimeEntry) event;</span>
<span class="nc" id="L1379">                  rte.setActivityId(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1380">                  rte.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1381">                  rte.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
<span class="nc" id="L1382">                } else {</span>
<span class="nc" id="L1383">                  TimeRecordEntry tre = (TimeRecordEntry) event;</span>
<span class="nc" id="L1384">                  tre.setActivityID(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1385">                }</span>
              }
            } else {
              // check if need add auto close
              if (PerformAutoClose) {
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                if (!nextEvent.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">                  if ((nextEvent.getSortTime().getTime() - event.getSortTime().getTime()) &gt;= AutoCloseTimeoutInMillis &amp;&amp; !eLearning) {</span>
<span class="nc" id="L1392">                    RawTimeEntry autoClose = new RawTimeEntry(event.getEmployeeID(),</span>
                        Activity.ACTIVITY_NONE,
<span class="nc" id="L1394">                        event.getTimeRecordID(), null,</span>
                        RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1396">                        new Date(event.getSortTime().getTime() + MINUTE));</span>
                    // Add in between the two entries
<span class="nc" id="L1398">                    i.previous();</span>
<span class="nc" id="L1399">                    i.add(autoClose);</span>
<span class="nc" id="L1400">                  }</span>
                } else {
                  // if next event is end shift, move iterator back, no need auto close
<span class="nc" id="L1403">                  i.previous();</span>
                }
              }
            }
<span class="nc" id="L1407">          }</span>
          // now insert by shift
          // if HAA is within one timerecord, and has end shift inside HAA, may need split records, this rarely happens
<span class="nc bnc" id="L1410" title="All 10 branches missed.">          boolean splitTR = (prvTimeRecordID != null &amp;&amp; nxtTimeRecordID != null &amp;&amp; prvTimeRecordID.equals(nxtTimeRecordID) &amp;&amp; containEndShift &amp;&amp; !eLearning);</span>
          // if two records are not same, may consider merge, this happens in extreme condition
<span class="nc bnc" id="L1412" title="All 8 branches missed.">          boolean mergeTR = (prvTimeRecordID != null &amp;&amp; nxtTimeRecordID != null &amp;&amp; !prvTimeRecordID.equals(nxtTimeRecordID) &amp;&amp; !eLearning);</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">          if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1414">            m_cat.debug(&quot;Further decision, SplitTR=&quot; + splitTR + &quot;, MergeTR=&quot; + mergeTR + &quot;, PrvRecordID=&quot; + prvTimeRecordID + &quot;, NxtRecordID=&quot; + nxtTimeRecordID);</span>
          }
<span class="nc" id="L1416">          ID origTRID = null;</span>
          // when split, will create a new TR, and update old entry TRID
<span class="nc bnc" id="L1418" title="All 2 branches missed.">          if (splitTR)</span>
<span class="nc" id="L1419">            origTRID = nxtTimeRecordID;</span>
          // first remove entries not included in HAA
<span class="nc bnc" id="L1421" title="All 2 branches missed.">          if (!treRemoveSet.isEmpty()) {</span>
<span class="nc" id="L1422">            m_timeRecordManager.removeTimeRecordEntry(treRemoveSet);</span>
          }
<span class="nc" id="L1424">          ArrayList shiftEventList = new ArrayList(mixedEntryList.size());</span>
<span class="nc" id="L1425">          boolean firstShift = true;</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">          for (Iterator i = mixedEntryList.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1427">            EmployeeEvent event = (EmployeeEvent) i.next();</span>
<span class="nc" id="L1428">            shiftEventList.add(event);</span>
<span class="nc bnc" id="L1429" title="All 4 branches missed.">            if (!i.hasNext() || event.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1430">              ArrayList rteList = new ArrayList(shiftEventList.size() + 1);</span>
<span class="nc" id="L1431">              ArrayList createList = new ArrayList(shiftEventList.size() + 1);</span>
<span class="nc" id="L1432">              ArrayList updateIDList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1433">              ArrayList updateActList = new ArrayList(shiftEventList.size());</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">              if (firstShift) {</span>
                // a shift is found, start process it
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                if (autoUpdatePrv) {</span>
                  // if need raw time entry, and the previous entry has raw time entry, then update it
<span class="nc bnc" id="L1438" title="All 4 branches missed.">                  if (NeedRawEntry &amp;&amp; prvRawEntryID != null) {</span>
<span class="nc" id="L1439">                    EmployeeEvent sEvent = (EmployeeEvent) shiftEventList.get(0);</span>
                    // in case the first entry is no long raw time entry (0 duration removal)
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                    if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1442">                      ((RawTimeEntry) sEvent).setId(prvRawEntryID);</span>
<span class="nc" id="L1443">                      TimeCollectorDAO.updateRawTimeEntry((RawTimeEntry) sEvent);</span>
                    }
                  }
                  // handle TimeEntryEvent
<span class="nc" id="L1447">                  EmployeeEvent sEvent = (EmployeeEvent) shiftEventList.get(0);</span>
                  // in case the first entry is no long raw time entry (0 duration removal)
<span class="nc bnc" id="L1449" title="All 2 branches missed.">                  if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1450">                    TimeRecordEntry tre = convertHAATimeEntry((RawTimeEntry) sEvent, prvTimeRecordID, empID, null, isPaid(sEvent.getActivityID()));</span>
<span class="nc" id="L1451">                    tre.setID(prvEntryID);</span>
<span class="nc" id="L1452">                    m_timeRecordManager.updateTimeRecordEntry(tre);</span>
                  }
                  // set audit trail with right start time
<span class="nc" id="L1455">                  auditEntry.setImpactStart(prvEntryStart);</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                } else if (autoMergePrv) {</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">                  if (NeedRawEntry) {</span>
                    // in case the first entry is no long raw time entry (0 duration removal)
<span class="nc bnc" id="L1459" title="All 2 branches missed.">                    if (prvRawEntryID != null)</span>
<span class="nc" id="L1460">                      TimeCollectorDAO.updateRawTimeEntryForMerge(prvRawEntryID);</span>
                  }
                  // handle TimeEntryEvent
<span class="nc bnc" id="L1463" title="All 2 branches missed.">                  if (prvEntryID != null)</span>
<span class="nc" id="L1464">                    m_timeRecordManager.updateTimeRecordEntryForMerge(prvEntryID);</span>
                  // set audit trail with right start time
<span class="nc" id="L1466">                  auditEntry.setImpactStart(prvEntryStart);</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                } else if (autoClosePrv) {</span>
<span class="nc" id="L1468">                  RawTimeEntry autoClose = new RawTimeEntry(empID,</span>
                      Activity.ACTIVITY_NONE,
                      prvTimeRecordID, null,
                      RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1472">                      new Date(prvEntryStart.getTime() + MINUTE));</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                  if (NeedRawEntry) {</span>
<span class="nc" id="L1474">                    rteList.add(autoClose);</span>
                  }
                  // handle TimeEntryEvent
<span class="nc" id="L1477">                  createList.add(convertHAATimeEntry(autoClose, prvTimeRecordID, empID, null, isPaid(Activity.ACTIVITY_NONE)));</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                  if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1479">                    m_cat.debug(&quot;In autoClosePrv creating new TimeRecord, after autoclose with &quot; + autoClose);</span>
                  }
                  // create a new TR
<span class="nc" id="L1482">                  prvTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
                  // set audit trail with right start time
<span class="nc" id="L1484">                  auditEntry.setImpactStart(autoClose.getSortTime());</span>
<span class="nc" id="L1485">                } else {</span>
                  // if no special handling is found
<span class="nc bnc" id="L1487" title="All 8 branches missed.">                  if (!i.hasNext() &amp;&amp; (prvActivityID == null || prvActivityID.equals(Activity.ACTIVITY_NONE))</span>
<span class="nc bnc" id="L1488" title="All 4 branches missed.">                      &amp;&amp; nxtTimeRecordID != null &amp;&amp; !event.getActivityID().equals(Activity.ACTIVITY_NONE) &amp;&amp; !autoCloseNxt) {</span>
                    // if only one shift, if not appending to previous record, then append to next record
<span class="nc" id="L1490">                    prvTimeRecordID = nxtTimeRecordID;</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">                  } else if (autoGen) {</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">                    if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1493">                      m_cat.debug(&quot;In autoGen creating new TimeRecord, prvActivity=&quot; + prvActivityID + &quot;, nxtTimeRecordID=&quot; + nxtTimeRecordID + &quot;, event is &quot; + event + &quot;, autoCloseNxt=&quot; + autoCloseNxt);</span>
                    }
                    // just append HAA entries to previous TR, if no TR found create one
<span class="nc" id="L1496">                    prvTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
                  }
                }
                // set the timerecorod ID
                //auditEntry.setEventID(prvTimeRecordID);
                // if only one shift, do an earlier auto merge with next record fix
<span class="nc bnc" id="L1502" title="All 2 branches missed.">                if (!i.hasNext()) {</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">                  if (autoMergeNxt) {</span>
<span class="nc" id="L1504">                    EmployeeEvent lastEvent = (EmployeeEvent) shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">                    if (lastEvent.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
                      // need change the activity
<span class="nc bnc" id="L1507" title="All 2 branches missed.">                      if (lastEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1508">                        RawTimeEntry rte = (RawTimeEntry) lastEvent;</span>
<span class="nc" id="L1509">                        rte.setActivityId(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1510">                        rte.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1511">                        rte.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
<span class="nc" id="L1512">                      } else {</span>
<span class="nc" id="L1513">                        TimeRecordEntry tre = (TimeRecordEntry) lastEvent;</span>
<span class="nc" id="L1514">                        tre.setActivityID(Activity.ACTIVITY_MERGE);</span>
                      }
                    }
                    // set audit trail with right end time
<span class="nc" id="L1518">                    auditEntry.setImpactEnd(lastEvent.getSortTime());</span>
<span class="nc bnc" id="L1519" title="All 2 branches missed.">                  } else if (autoCloseNxt) {</span>
                    // if only one shift, do earlier autoClose fix
                    // find last event, add an AutoClose event after it
<span class="nc" id="L1522">                    EmployeeEvent lastEvent = (EmployeeEvent) shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc" id="L1523">                    RawTimeEntry autoClose = new RawTimeEntry(empID,</span>
                        Activity.ACTIVITY_NONE,
                        prvTimeRecordID, null,
                        RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1527">                        new Date(lastEvent.getStartTime().getTime() + MINUTE));</span>
<span class="nc" id="L1528">                    shiftEventList.add(autoClose);</span>
                    // set audit trail with right end time
<span class="nc" id="L1530">                    auditEntry.setImpactEnd(autoClose.getSortTime());</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                  } else if (event.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1532">                    mergeTR = false;</span>
                  }
                }
                // if need update prv shift, remove the first entry now which has been handled
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                if (autoUpdatePrv)</span>
<span class="nc" id="L1537">                  shiftEventList.remove(0);</span>
                // if only one shift, consider merge condition now, if no auto close condition exist, merge
                // TimeRecordID may be changed in previous step, so check it again here
<span class="nc bnc" id="L1540" title="All 8 branches missed.">                if (!i.hasNext() &amp;&amp; mergeTR &amp;&amp; !autoCloseNxt &amp;&amp; !autoClosePrv) {</span>
<span class="nc" id="L1541">                  m_timeRecordManager.updateTimeRecordEntry(nxtTimeRecordID, prvTimeRecordID, null);</span>
                }
<span class="nc" id="L1543">                firstShift = false;</span>
              } else {
                // if not first shift and it has new
<span class="nc bnc" id="L1546" title="All 2 branches missed.">                if (i.hasNext()) {</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">                  if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1548">                    m_cat.debug(&quot;In another shift, creating new TimeRecord&quot;);</span>
                  }
                  // should create a new TimeRecord
<span class="nc" id="L1551">                  prvTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
                } else {
                  // if it is the last chunk, just break
                  break;
                }
              }
<span class="nc" id="L1557">              Iterator rsi = shiftEventList.iterator();</span>
<span class="nc" id="L1558">              Iterator si = shiftEventList.iterator();</span>
              // create RTE in batch
<span class="nc bnc" id="L1560" title="All 2 branches missed.">              if (NeedRawEntry) {</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">                while (rsi.hasNext()) {</span>
<span class="nc" id="L1562">                  EmployeeEvent sEvent = (EmployeeEvent) rsi.next();</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">                  if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1564">                    ((RawTimeEntry) sEvent).setTimeRecordID(prvTimeRecordID);</span>
<span class="nc" id="L1565">                    rteList.add(sEvent);</span>
                  }
<span class="nc" id="L1567">                }</span>
<span class="nc" id="L1568">                TimeCollectorDAO.createRawTimeEntries(rteList);</span>
              }
              // create/update TEE(one condition is timerecord ID is different, the other is AutoMerge)
<span class="nc bnc" id="L1571" title="All 2 branches missed.">              while (si.hasNext()) {</span>
<span class="nc" id="L1572">                EmployeeEvent sEvent = (EmployeeEvent) si.next();</span>
<span class="nc bnc" id="L1573" title="All 2 branches missed.">                if (sEvent instanceof RawTimeEntry) {</span>
                  // for RawTimeEntry, we need create them
<span class="nc" id="L1575">                  createList.add(convertHAATimeEntry((RawTimeEntry) sEvent, prvTimeRecordID, empID, null, isPaid(sEvent.getActivityID())));</span>
                } else {
<span class="nc" id="L1577">                  TimeRecordEntry tre = (TimeRecordEntry) sEvent;</span>
                  // if entry is dirty, implies the activity ID is modified
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                  if (tre.getDirty()) {</span>
<span class="nc" id="L1580">                    updateActList.add(sEvent);</span>
                  }
<span class="nc bnc" id="L1582" title="All 2 branches missed.">                  if (!tre.getTimeRecordID().equals(prvTimeRecordID)) {</span>
                    // for TimeEntryEvent, we will update the timerecord ID, if it is different
<span class="nc" id="L1584">                    updateIDList.add(tre.getID());</span>
                  }
                }
<span class="nc" id="L1587">              }</span>
              // only need create raw time entries
<span class="nc" id="L1589">              m_timeRecordManager.createTimeRecordEntry(prvTimeRecordID, createList);</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">              if (!updateIDList.isEmpty())</span>
<span class="nc" id="L1591">                m_timeRecordManager.updateTimeRecordEntry(prvTimeRecordID, updateIDList);</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">              if (!updateActList.isEmpty())</span>
<span class="nc" id="L1593">                m_timeRecordManager.updateTimeRecordEntryActivity(prvTimeRecordID, updateActList);</span>
              // clear the shiftEvnetList
<span class="nc" id="L1595">              shiftEventList.clear();</span>
            }
<span class="nc" id="L1597">          }</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">          if (splitTR) {</span>
            // as there are at least two shifts, so split situation just happened
<span class="nc" id="L1600">            ID newTRID = null;</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">            if (nxtTimeRecordID.equals(origTRID)) {</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">              if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1603">                m_cat.debug(&quot;In splitTR, creating new TimeRecord, origTRID=&quot; + origTRID + &quot;, nxtTimeRecordID=&quot; + nxtTimeRecordID);</span>
              }
<span class="nc" id="L1605">              nxtTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
<span class="nc" id="L1606">              newTRID = nxtTimeRecordID;</span>
            } else
<span class="nc" id="L1608">              newTRID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
            // update timeentry after nxtEntryStart with origTRID to newTRID
<span class="nc" id="L1610">            m_timeRecordManager.updateTimeRecordEntry(origTRID, newTRID, nxtEntryStart);</span>
          }
          // last shift Event handling
<span class="nc bnc" id="L1613" title="All 2 branches missed.">          if (!shiftEventList.isEmpty()) {</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">            if (autoCloseNxt) {</span>
              // no need to merge with next timerecord, just create a new record
<span class="nc" id="L1616">              nxtTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
              // find last event, add an AutoClose event after it
<span class="nc" id="L1618">              EmployeeEvent lastEvent = (EmployeeEvent) shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc" id="L1619">              RawTimeEntry autoClose = new RawTimeEntry(empID,</span>
                  Activity.ACTIVITY_NONE,
                  nxtTimeRecordID, null,
                  RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1623">                  new Date(lastEvent.getSortTime().getTime() + MINUTE));</span>
<span class="nc" id="L1624">              shiftEventList.add(autoClose);</span>
              // set audit trail with right end time
<span class="nc" id="L1626">              auditEntry.setImpactEnd(autoClose.getSortTime());</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">            } else if (autoMergeNxt) {</span>
<span class="nc" id="L1628">              EmployeeEvent lastEvent = (EmployeeEvent) shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">              if (lastEvent.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
                // need change the activity
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                if (lastEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1632">                  RawTimeEntry rte = (RawTimeEntry) lastEvent;</span>
<span class="nc" id="L1633">                  rte.setActivityId(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1634">                  rte.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1635">                  rte.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
<span class="nc" id="L1636">                } else {</span>
<span class="nc" id="L1637">                  TimeRecordEntry tre = (TimeRecordEntry) lastEvent;</span>
<span class="nc" id="L1638">                  tre.setActivityID(Activity.ACTIVITY_MERGE);</span>
                }
              }
<span class="nc" id="L1641">            } else {</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">              if (nxtTimeRecordID == null) {</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1644">                  m_cat.debug(&quot;In last shift, nxtTimeRecordID is null, so creating new TimeRecord for &quot; + shiftEventList);</span>
                }
<span class="nc" id="L1646">                nxtTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
              }
            }
<span class="nc" id="L1649">            Iterator rsi = shiftEventList.iterator();</span>
<span class="nc" id="L1650">            Iterator si = shiftEventList.iterator();</span>
<span class="nc" id="L1651">            ArrayList rteList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1652">            ArrayList createList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1653">            ArrayList updateIDList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1654">            ArrayList updateActList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1655">            createHAAEntries(rsi, si, shiftEventList, rteList, createList, updateIDList, updateActList, nxtTimeRecordID, empID);</span>
          }
        }// finished one employee HAA
<span class="nc" id="L1658">      }</span>
      // remove employees unknown activity cross HAA window
<span class="nc bnc" id="L1660" title="All 4 branches missed.">      if (!empSetCopy.isEmpty() &amp;&amp; !eLearning) {</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1662">          m_cat.debug(&quot;In HAA, now remove unknown activities for &quot; + empSetCopy + &quot; from &quot; + start + &quot; to &quot; + end);</span>
        }
<span class="nc" id="L1664">        m_timeRecordManager.removeUnknownTimeRecordEntry(empSetCopy, start, end);</span>
      }
<span class="nc bnc" id="L1666" title="All 2 branches missed.">      if (NeedRawEntry) {</span>
        // remove unknown activity from RawTimeEntry table
<span class="nc" id="L1668">        TimeCollectorDAO.deleteUnknownActivities(empSetCopy, start, end);</span>
      }
      // last step create audit trail and refresh cache
<span class="nc" id="L1671">      m_auditManager.createAuditEntry(eventAuditList);</span>
<span class="nc" id="L1672">      m_timeRecordManager.refreshCacheForWorkResource(empSetCopy);</span>
<span class="nc" id="L1673">    } catch (JdmoException e) {</span>
<span class="nc" id="L1674">      handleException(e);</span>
<span class="nc" id="L1675">      throw new AmException(e);</span>
<span class="nc" id="L1676">    } catch (BbmCreateException e) {</span>
<span class="nc" id="L1677">      handleException(e);</span>
<span class="nc" id="L1678">      throw new AmException(e);</span>
<span class="nc" id="L1679">    } catch (BbmRemoveException e) {</span>
<span class="nc" id="L1680">      handleException(e);</span>
<span class="nc" id="L1681">      throw new AmException(e);</span>
<span class="nc" id="L1682">    } catch (BbmUpdateException e) {</span>
<span class="nc" id="L1683">      handleException(e);</span>
<span class="nc" id="L1684">      throw new AmException(e);</span>
<span class="nc" id="L1685">    } catch (BbmFinderException e) {</span>
<span class="nc" id="L1686">      handleException(e);</span>
<span class="nc" id="L1687">      throw new AmException(e);</span>
<span class="nc" id="L1688">    } catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L1689">      handleException(e);</span>
<span class="nc" id="L1690">      throw new AmException(e);</span>
<span class="nc" id="L1691">    } catch (RemoteException e) {</span>
<span class="nc" id="L1692">      handleException(e);</span>
<span class="nc" id="L1693">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L1695">      jdmo.cleanUp();</span>
<span class="nc" id="L1696">    }</span>
<span class="nc" id="L1697">  }</span>

  /**
   * internal function to create HAA entries and TimeRecordEntries
   *
   * @param rawEntryIterator
   * @param timeEntryIterator
   * @param shiftEventList
   * @param rteList
   * @param createList
   * @param updateIDList
   * @param updateActList
   * @param timeRecordID
   * @param empID
   * @throws JdmoException
   * @throws BbmUpdateException
   * @throws BbmCreateException
   * @throws RemoteException
   */
  private void createHAAEntries(Iterator rawEntryIterator, Iterator timeEntryIterator,
                                ArrayList shiftEventList,
                                ArrayList rteList,
                                ArrayList createList,
                                ArrayList updateIDList,
                                ArrayList updateActList,
                                ID timeRecordID,
                                ID empID) throws JdmoException, BbmUpdateException, BbmCreateException, RemoteException {
    // create RTE in batch
<span class="nc bnc" id="L1725" title="All 2 branches missed.">    if (NeedRawEntry) {</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">      while (rawEntryIterator.hasNext()) {</span>
<span class="nc" id="L1727">        EmployeeEvent sEvent = (EmployeeEvent) rawEntryIterator.next();</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">        if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1729">          ((RawTimeEntry) sEvent).setTimeRecordID(timeRecordID);</span>
<span class="nc" id="L1730">          rteList.add(sEvent);</span>
        }
<span class="nc" id="L1732">      }</span>
<span class="nc" id="L1733">      TimeCollectorDAO.createRawTimeEntries(rteList);</span>
    }
    // create/update TEE(one condition is timerecord ID is different, the other is AutoMerge)
<span class="nc bnc" id="L1736" title="All 2 branches missed.">    while (timeEntryIterator.hasNext()) {</span>
<span class="nc" id="L1737">      EmployeeEvent sEvent = (EmployeeEvent) timeEntryIterator.next();</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">      if (sEvent instanceof RawTimeEntry) {</span>
        // for RawTimeEntry, we need create them
<span class="nc" id="L1740">        createList.add(convertHAATimeEntry((RawTimeEntry) sEvent, timeRecordID, empID, null, isPaid(sEvent.getActivityID())));</span>
      } else {
<span class="nc" id="L1742">        TimeRecordEntry tre = (TimeRecordEntry) sEvent;</span>
        // if entry is dirty, implies the activity ID is modified
<span class="nc bnc" id="L1744" title="All 2 branches missed.">        if (tre.getDirty()) {</span>
<span class="nc" id="L1745">          updateActList.add(sEvent);</span>
        }
<span class="nc bnc" id="L1747" title="All 2 branches missed.">        if (!tre.getTimeRecordID().equals(timeRecordID)) {</span>
          // for TimeEntryEvent, we will update the timerecord ID, if it is different
<span class="nc" id="L1749">          updateIDList.add(tre.getID());</span>
        }
      }
<span class="nc" id="L1752">    }</span>
    // only need create raw time entries
<span class="nc" id="L1754">    m_timeRecordManager.createTimeRecordEntry(timeRecordID, createList);</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">    if (!updateIDList.isEmpty())</span>
<span class="nc" id="L1756">      m_timeRecordManager.updateTimeRecordEntry(timeRecordID, updateIDList);</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">    if (!updateActList.isEmpty())</span>
<span class="nc" id="L1758">      m_timeRecordManager.updateTimeRecordEntryActivity(timeRecordID, updateActList);</span>
<span class="nc" id="L1759">  }</span>

  /**
   * &lt;B&gt;insertRawTimeEntry&lt;/B&gt;
   * &lt;p&gt;
   * represents an activity change by a user
   * will create TimeRecord if start shift
   * creates RawTimeEntry and TimeEntryEvent records
   * sends JMS message to bpx
   *
   * @param rawTimeEntry raw time data to be inserted
   * @param deviceID     device id from user
   *                     &lt;p&gt;
   * @return ID of new entry
   */
  public ID insertRawTimeEntry(RawTimeEntry rawTimeEntry, String deviceID)
      throws AmInvalidActivityException, AmNoTimeRecordException, AmException {
<span class="nc" id="L1776">    methodStart(&quot;insertRawTimeEntry&quot;, rawTimeEntry, deviceID);</span>
<span class="nc" id="L1777">    ID newID = null;</span>
<span class="nc" id="L1778">    rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.MYTIME);</span>
    // If RawTimeEntry's activity is not longer active, just reject
<span class="nc" id="L1780">    int isPaid = getIsPaidForActivity(rawTimeEntry.getActivityID());</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">    if (isPaid &lt; 0)</span>
<span class="nc" id="L1782">      throw new AmInvalidActivityException(AmEjbBundleKey.TIMECOLLECTOR_ACTIVITY_NOTFOUND_ERROR);</span>
    try {
      //---------------------------------------------------------------------
      //  Don't allow these activity to be added
      //  (except for end shift since the ACTIVITY_NONE is in this list)
      //---------------------------------------------------------------------
<span class="nc bnc" id="L1788" title="All 2 branches missed.">      if (rawTimeEntry.getPunchTimeCode() != RawTimeEntry.END_SHIFT) {</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">        for (int i = 0; i &lt; ProhibitInsertActivities.length; i++) {</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">          if (rawTimeEntry.getActivityID().equals(ProhibitInsertActivities[i])) {</span>
<span class="nc" id="L1791">            throw new AmInvalidActivityException(AmEjbBundleKey.TIMECOLLECTOR_INVALID_ACTIVITY_ERROR);</span>
          }
        }
      }

<span class="nc" id="L1796">      long punchTimeMillis = System.currentTimeMillis();</span>
<span class="nc" id="L1797">      rawTimeEntry.setPunchDate(RawTimeEntry.roundSeconds(new Date(punchTimeMillis)));</span>
<span class="nc" id="L1798">      rawTimeEntry.setPunchTimestamp(punchTimeMillis);</span>

      //---------------------------------------------------------------------
      //  if create time records aren't config, just do nothing
      //---------------------------------------------------------------------
<span class="nc bnc" id="L1803" title="All 2 branches missed.">      if (!CreateTimeRecords) {</span>
<span class="nc" id="L1804">        return newID;</span>
      }

      //---------------------------------------------------------------------
      //  TimeRecord ID
      //    get current TimeRecord ID if it exists,
      //    or create new TimeRecord
      //      if create new, mark entry as START_SHIFT
      //---------------------------------------------------------------------
<span class="nc" id="L1813">      ID employeeID = rawTimeEntry.getEmployeeID();</span>
<span class="nc" id="L1814">      boolean doNotAutoClose = rawTimeEntry.isEndShift();</span>
<span class="nc" id="L1815">      TimeRecordEntry lastEvent = m_timeRecordManager.getLastEntry(employeeID, rawTimeEntry.getSortTime());</span>
<span class="nc" id="L1816">      Object[] result = findCurrentTimeRecordID(employeeID, lastEvent, rawTimeEntry.getSortTime(), doNotAutoClose, false);</span>
<span class="nc" id="L1817">      ID timeRecordID = (ID) result[0];</span>
<span class="nc" id="L1818">      Boolean merge = (Boolean) result[1];</span>
<span class="nc" id="L1819">      boolean mergeNeeded = false;</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">      if (merge != null) {</span>
<span class="nc" id="L1821">        mergeNeeded = merge.booleanValue();</span>
      }

      // check dual endShift, last Activity is EndShift, current one is EndShift also
<span class="nc bnc" id="L1825" title="All 6 branches missed.">      if (result[5] != null &amp;&amp; result[5].equals(Activity.ACTIVITY_NONE) &amp;&amp; doNotAutoClose) {</span>
<span class="nc" id="L1826">        throw new AmNoTimeRecordException(AmEjbBundleKey.TIMECOLLECTOR_TIMERECORD_END_SHIFT_ERROR);</span>
      }

      // check if should just update previous entry
<span class="nc" id="L1830">      boolean updatePrv = false;</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">      if (result[2] != null) {</span>
<span class="nc bnc" id="L1832" title="All 4 branches missed.">        if (FixZeroDuration &amp;&amp; Math.abs(rawTimeEntry.getSortTime().getTime() - ((Date) result[2]).getTime()) &lt; 1000) {</span>
<span class="nc" id="L1833">          updatePrv = true;</span>
        }
      }
      //---------------------------------------------------------
      // if we're merging, remove START_SHIFT code
      // new design is always remove start shifts, or BPX should never send this type
      //---------------------------------------------------------
<span class="nc bnc" id="L1840" title="All 2 branches missed.">      if (rawTimeEntry.getPunchTimeCode() == RawTimeEntry.START_SHIFT) {</span>
<span class="nc" id="L1841">        rawTimeEntry.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
      }

<span class="nc bnc" id="L1844" title="All 2 branches missed.">      if (timeRecordID == null) {</span>
        //---------------------------------------------------------
        // if insert is END SHIFT and NO current TimeRecord found
        // throw an exception
        //    no RawTimeEntry created,
        //    no messsage sent to BPX
        //---------------------------------------------------------
<span class="nc bnc" id="L1851" title="All 2 branches missed.">        if (rawTimeEntry.isEndShift()) {</span>
<span class="nc" id="L1852">          throw new AmNoTimeRecordException(AmEjbBundleKey.TIMECOLLECTOR_NO_TIME_RECORD_ERROR);</span>
        }
        // if no timerecord is found, create a new TimeRecord
<span class="nc" id="L1855">        TimeRecord timeRecord = createNewTimeRecord(employeeID);</span>
<span class="nc" id="L1856">        timeRecordID = timeRecord.getID();</span>
<span class="nc" id="L1857">        rawTimeEntry.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
      }
      //---------------------------------------------------------------------
      //  now that we have a TimeRecord ID
      //  update the  object RawTimeEntry
      //  we need to do this before we create the RawTimeEntry
      //---------------------------------------------------------------------
<span class="nc" id="L1864">      rawTimeEntry.setTimeRecordID(timeRecordID);</span>

      //---------------------------------------------------------------------
      // Set the punch status. If the punch is to be sent to BPX, the initial status is 'Undetermined'
      // and Msg Processor updates the status when it gets it from BPX, otherwise, the punch status is
      // always successful
      //---------------------------------------------------------------------
<span class="nc" id="L1871">      rawTimeEntry.setPunchStatus(ChangeStateStatusMessage.SUCCESSFUL);</span>

      //---------------------------------------------------------------------
      //  create RawTimeEntry entrys in database, if it is needed
      //  this is done first regardless of what else fails
      //---------------------------------------------------------------------
<span class="nc bnc" id="L1877" title="All 2 branches missed.">      if (NeedRawEntry) {</span>
        // if no need update previous, or raw time entry is null, just create
<span class="nc bnc" id="L1879" title="All 4 branches missed.">        if (!updatePrv || result[4] == null)</span>
<span class="nc" id="L1880">          newID = TimeCollectorDAO.createRawTimeEntry(rawTimeEntry);</span>
        else {
          // quick update
<span class="nc" id="L1883">          rawTimeEntry.setId((ID) result[4]);</span>
<span class="nc" id="L1884">          TimeCollectorDAO.updateRawTimeEntry(rawTimeEntry);</span>
        }
      }
      //----------------------------------------------
      //  create a TimeRecordEntry (TimeEntryEvent)
      //----------------------------------------------
<span class="nc" id="L1890">      TimeRecordEntry entry = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, isPaid(isPaid));</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">      if (timeRecordID != null) {</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        if (!mergeNeeded) {</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">          if (updatePrv) {</span>
<span class="nc" id="L1894">            entry.setID((ID) result[3]);</span>
<span class="nc" id="L1895">            m_timeRecordManager.updateTimeRecordEntry(entry);</span>
<span class="nc" id="L1896">            return entry.getID();</span>
          } else
<span class="nc" id="L1898">            newID = m_timeRecordManager.createTimeRecordEntry(timeRecordID, entry);</span>
        } else {
<span class="nc" id="L1900">          newID = m_timeRecordManager.createTimeRecordEntryForMerge(timeRecordID, entry, null);</span>
        }
      }
<span class="nc" id="L1903">      return newID;</span>
<span class="nc" id="L1904">    } catch (AmNoTimeRecordException e) {</span>
      // leave handling to the caller (can be a user error)
<span class="nc" id="L1906">      throw e;</span>
<span class="nc" id="L1907">    } catch (AmInvalidActivityException e) {</span>
<span class="nc" id="L1908">      handleException(e);</span>
<span class="nc" id="L1909">      throw e;</span>
<span class="nc" id="L1910">    } catch (JdmoException e) {</span>
<span class="nc" id="L1911">      handleException(e);</span>
<span class="nc" id="L1912">      throw new AmException(e);</span>
<span class="nc" id="L1913">    } catch (BbmCreateException e) {</span>
<span class="nc" id="L1914">      handleException(e);</span>
<span class="nc" id="L1915">      throw new AmException(e);</span>
<span class="nc" id="L1916">    } catch (Exception e) {</span>
<span class="nc" id="L1917">      handleException(e);</span>
<span class="nc" id="L1918">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L1920">      methodFinish();</span>
    }
  }

  /**
   * &lt;B&gt;insertRawTimeEntries&lt;/B&gt;
   * &lt;p&gt;
   * represents an activity change by a user
   * will create TimeRecord if start shift
   * creates RawTimeEntry and TimeEntryEvent records
   *
   * @param rawTimeEntries raw time data to be inserted
   * @param historical     true if not real time entry
   *                       &lt;p&gt;
   * @return Collection of new ID's created
   * returned in same order of rawTimeEntries
   * @deprecated
   */
  @Deprecated
  public Collection insertRawTimeEntries(Collection rawTimeEntries, boolean historical) throws AmException {
<span class="nc" id="L1940">    return null;</span>
  }

  /**
   * &lt;B&gt;insertRawTimeEntries&lt;/B&gt;
   * &lt;p&gt;
   *
   * @param rawTimeEntries raw time data to be inserted
   * @param deviceId       device id from user
   * @param historical     true if not real time entry
   *                       &lt;p&gt;
   * @return Collection of new ID's created
   * returned in same order of rawTimeEntries
   * @deprecated represents an activity change by a user
   * will create TimeRecord if start shift
   * creates RawTimeEntry and TimeEntryEvent records
   */
  @Deprecated
  public Collection insertRawTimeEntries(Collection rawTimeEntries,
                                         String deviceId,
                                         boolean historical)
      throws AmException {

<span class="nc" id="L1963">    return null;</span>
  }

  /**
   * BPX will make sure there is no zero duration entries
   *
   * @param rawTimeEntries
   * @throws AmException
   */
  public void insertTimeEntries(Collection rawTimeEntries,
                                boolean insertToPrimaryTimeLine) throws AmException {
<span class="nc" id="L1974">    methodStart(&quot;insertTimeEntries&quot;, rawTimeEntries, new Boolean(insertToPrimaryTimeLine));</span>

    try {
<span class="nc bnc" id="L1977" title="All 4 branches missed.">      if (rawTimeEntries == null || rawTimeEntries.size() &lt;= 0)</span>
<span class="nc" id="L1978">        return;</span>

<span class="nc bnc" id="L1980" title="All 2 branches missed.">      if (insertToPrimaryTimeLine) {</span>
<span class="nc" id="L1981">        insertRawTimeEntries(rawTimeEntries);</span>
      } else {
        try {
<span class="nc" id="L1984">          ArrayList evList = new ArrayList();</span>
<span class="nc" id="L1985">          Iterator iter = rawTimeEntries.iterator();</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">          while (iter.hasNext()) {</span>
<span class="nc" id="L1987">            RawTimeEntry rte = (RawTimeEntry) iter.next();</span>
<span class="nc" id="L1988">            TimeTrackingEvent tte = new TimeTrackingEvent();</span>

<span class="nc" id="L1990">            tte.setEmployeeID(rte.getEmployeeID());</span>
<span class="nc" id="L1991">            tte.setDataSourceID(rte.getDataSourceId());</span>
<span class="nc" id="L1992">            tte.setActivityID(rte.getActivityID());</span>
<span class="nc" id="L1993">            tte.setStartTime(rte.getStartTime());</span>

<span class="nc" id="L1995">            evList.add(tte);</span>

<span class="nc" id="L1997">          }</span>
<span class="nc" id="L1998">          m_timeTrackingManager.createEvents(evList);</span>
<span class="nc" id="L1999">        } catch (BbmCreateException e) {</span>
<span class="nc" id="L2000">          handleException(e, false);</span>
<span class="nc" id="L2001">          throw new AmException(e);</span>
<span class="nc" id="L2002">        } catch (RemoteException e) {</span>
<span class="nc" id="L2003">          handleException(e);</span>
<span class="nc" id="L2004">          throw new EJBException(e);</span>
<span class="nc" id="L2005">        }</span>
      }
    } finally {
<span class="nc" id="L2008">      methodFinish();</span>
<span class="nc" id="L2009">    }</span>

<span class="nc" id="L2011">  }</span>

  /**
   * BPX will make sure there is no zero duration entries
   *
   * @param rawTimeEntries
   * @throws AmException
   */
  public void insertRawTimeEntries(Collection rawTimeEntries) throws AmException {
<span class="nc" id="L2020">    methodStart(&quot;insertRawTimeEntries&quot;, rawTimeEntries);</span>
<span class="nc" id="L2021">    m_cat.debug(new LogMessage(rawTimeEntries, &quot;***********Entered Method with &quot; + rawTimeEntries.size() + &quot; enteries.&quot;));</span>
<span class="nc" id="L2022">    Collection rawTimeEntriesCopy = new ArrayList(rawTimeEntries);</span>

    //---------------------------------------------------------------------
    //  first make sure we have data
    //---------------------------------------------------------------------
<span class="nc bnc" id="L2027" title="All 4 branches missed.">    if (rawTimeEntriesCopy == null || rawTimeEntriesCopy.size() == 0) {</span>
<span class="nc" id="L2028">      return;</span>
    }
<span class="nc" id="L2030">    Exception cachedExp = null;</span>
    try {
<span class="nc" id="L2032">      Collection employeeIDs = getEmployeeIDs(rawTimeEntries);</span>
<span class="nc" id="L2033">      HashMap lastEventMap = m_timeRecordManager.getLastEntries(employeeIDs, null);</span>

      //---------------------------------------------------------------------
      //  set up our RawTimeEntry handler
      //  get employee id and first shift (applied auto merge rules)
      //---------------------------------------------------------------------
<span class="nc" id="L2039">      RawTimeEntryHandler rawTimeEntryHandler = new RawTimeEntryHandler(rawTimeEntriesCopy, PerformAutoMerge, AutoMergeTimeoutInMillis);</span>

<span class="nc" id="L2041">      ID employeeID = rawTimeEntryHandler.nextEmployeeId();</span>
<span class="nc" id="L2042">      m_cat.debug(&quot;Processing employee with ID= &quot; + employeeID);</span>
<span class="nc" id="L2043">      ArrayList nextShiftOfRawTimeEntries = rawTimeEntryHandler.nextEmployeeShift();</span>
<span class="nc" id="L2044">      m_cat.debug(&quot;number of enteries in nextShiftOfRawTimeEntries = &quot; + nextShiftOfRawTimeEntries.size());</span>

<span class="nc" id="L2046">      HashSet employeeHandled = new HashSet();</span>

      //---------------------------------------------------------------------
      //  get RawTimeEntries in groups of shifts
      //---------------------------------------------------------------------
      // We always get last event in the whole system, so it may be event from manager, and be after some events from BPX
      // A simple filter logic is introduced to discard any entries before last Event

<span class="nc bnc" id="L2054" title="All 2 branches missed.">      while (!nextShiftOfRawTimeEntries.isEmpty()) {</span>
<span class="nc" id="L2055">        boolean bInsertEnrty = true;</span>
<span class="nc bnc" id="L2056" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2057">          m_cat.debug(&quot;Before normalization, raw entries are &quot; + nextShiftOfRawTimeEntries);</span>
        }
        // normalize raw entries
<span class="nc" id="L2060">        RawTimeEntryHandler.normalizeEntries(nextShiftOfRawTimeEntries, FixZeroDuration);</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2062">          m_cat.debug(&quot;After normalization, raw entries are &quot; + nextShiftOfRawTimeEntries);</span>
        }
        // group works into one seperate tx
        // if it is first time to handle Employee, there are some logical conditions to judge
<span class="nc" id="L2066">        RawTimeEntry minRawTimeEntry = null;</span>
<span class="nc" id="L2067">        TimeRecordEntry lastEvent = null;</span>
<span class="nc" id="L2068">        boolean empHandled = employeeHandled.contains(employeeID);</span>
<span class="nc" id="L2069">        m_cat.debug(&quot;Employee Id = &quot; + employeeID + &quot; ishandled= &quot; + empHandled);</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">        if (!empHandled) {</span>
<span class="nc" id="L2071">          m_cat.debug(&quot;Employee Id = &quot; + employeeID + &quot; Not Handled.&quot;);</span>
          // first time, it is from the cache map, after that it will be the last Entry in shift
<span class="nc" id="L2073">          lastEvent = (TimeRecordEntry) lastEventMap.get(employeeID);</span>
<span class="nc" id="L2074">          boolean prvRecordClosed = true;</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">          if (lastEvent != null)</span>
<span class="nc" id="L2076">            prvRecordClosed = lastEvent.getActivityID().equals(Activity.ACTIVITY_NONE);</span>
          // Find earliest entry in the shift, which is after last event
<span class="nc bnc" id="L2078" title="All 2 branches missed.">          for (Iterator it = nextShiftOfRawTimeEntries.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2079">            RawTimeEntry entry = (RawTimeEntry) it.next();</span>
<span class="nc" id="L2080">            boolean isEndShift = entry.getActivityID().equals(Activity.ACTIVITY_NONE);</span>
            // if previous record is closed or not exist, we should remove end shift at the beginning
<span class="nc bnc" id="L2082" title="All 4 branches missed.">            if (prvRecordClosed &amp;&amp; isEndShift) {</span>
<span class="nc" id="L2083">              m_cat.debug(&quot;prvRecordClosed &amp;&amp; isEndShift are true, ignoring entry= &quot; + entry);</span>
<span class="nc" id="L2084">              it.remove();</span>
<span class="nc" id="L2085">              continue;</span>
            }
<span class="nc bnc" id="L2087" title="All 2 branches missed.">            if (lastEvent == null</span>
<span class="nc bnc" id="L2088" title="All 4 branches missed.">                || entry.getSortTime().after(lastEvent.getSortTime())</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">                || (!FixZeroDuration &amp;&amp; entry.getSortTime().equals(lastEvent.getSortTime()))) {</span>
<span class="nc" id="L2090">              m_cat.debug(&quot; **** setting min rte=&quot; + entry);</span>
<span class="nc" id="L2091">              minRawTimeEntry = entry;</span>
<span class="nc" id="L2092">              break;</span>
            } else {
              // remove entries before last event
<span class="nc" id="L2095">              m_cat.debug(&quot;entry before last event, ignoring entry= &quot; + entry);</span>
<span class="nc" id="L2096">              it.remove();</span>
            }
<span class="nc" id="L2098">          }</span>
<span class="nc bnc" id="L2099" title="All 2 branches missed.">          if (minRawTimeEntry == null) {</span>
            // Fix for QA77876
            // If there is only one event in the collection for employee and if it is logout
            // and if previous event for employee was logout or endshift
            // the loop terminates for all employees.

<span class="nc" id="L2105">            m_cat.debug(&quot;minRawTimeEntry is null&quot;);</span>
<span class="nc" id="L2106">            bInsertEnrty = false;</span>
          }
<span class="nc" id="L2108">        } else {</span>
          // need remove empty TR case, which has only one entry
<span class="nc bnc" id="L2110" title="All 4 branches missed.">          if (!nextShiftOfRawTimeEntries.isEmpty() &amp;&amp; nextShiftOfRawTimeEntries.size() == 1) {</span>
<span class="nc" id="L2111">            RawTimeEntry entry = (RawTimeEntry) nextShiftOfRawTimeEntries.get(0);</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">            if (entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
              // skip this case
<span class="nc bnc" id="L2114" title="All 2 branches missed.">              if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2115">                m_cat.debug(&quot;Detect an empty TR with only one EndShift, just skipt &quot; + entry);</span>
              }
<span class="nc" id="L2117">              bInsertEnrty = false;</span>
            }
          }
        }
        try {
          // each chunk is inserted in a seperate transaction
<span class="nc bnc" id="L2123" title="All 2 branches missed.">          if (bInsertEnrty)</span>
<span class="nc" id="L2124">            ((TimeCollectorManager) m_sessionContext.getEJBObject()).insertRawTimeEntriesPerChunk(employeeID, nextShiftOfRawTimeEntries, empHandled, lastEvent, minRawTimeEntry);</span>
<span class="nc" id="L2125">        } catch (RemoteException e) {</span>
<span class="nc bnc" id="L2126" title="All 2 branches missed.">          if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2127">            m_cat.debug(&quot;Failed to insert a chunk for employee &quot; + employeeID + &quot;, lastEvent is &quot; + lastEvent + &quot;, employee is handled &quot; + empHandled + &quot; minEntry &quot; + minRawTimeEntry);</span>
<span class="nc" id="L2128">            m_cat.debug(&quot;Chunk failed contains &quot; + nextShiftOfRawTimeEntries);</span>
          }
<span class="nc" id="L2130">          handleException(e);</span>
<span class="nc" id="L2131">          throw new EJBException(e);</span>
<span class="nc" id="L2132">        } catch (Exception e) {</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">          if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2134">            m_cat.debug(&quot;Failed to insert a chunk for employee &quot; + employeeID + &quot;, lastEvent is &quot; + lastEvent + &quot;, employee is handled &quot; + empHandled + &quot; minEntry &quot; + minRawTimeEntry);</span>
<span class="nc" id="L2135">            m_cat.debug(&quot;Chunk failed contains &quot; + nextShiftOfRawTimeEntries);</span>
          }
<span class="nc" id="L2137">          handleException(e);</span>
          //we want to cache the at least one exception so BPX will report failure
<span class="nc" id="L2139">          cachedExp = e;</span>
<span class="nc" id="L2140">        }</span>
        // continue to next Employee
<span class="nc" id="L2142">        m_cat.debug(&quot;Add Employee ID &quot; + employeeID);</span>
<span class="nc" id="L2143">        employeeHandled.add(employeeID);</span>
<span class="nc" id="L2144">        employeeID = rawTimeEntryHandler.nextEmployeeId();</span>
<span class="nc" id="L2145">        m_cat.debug(&quot;Next employee ID=  &quot; + employeeID);</span>
<span class="nc" id="L2146">        nextShiftOfRawTimeEntries = rawTimeEntryHandler.nextEmployeeShift();</span>
<span class="nc" id="L2147">        m_cat.debug(&quot;nextShiftOfRawTimeEntries=  &quot; + nextShiftOfRawTimeEntries);</span>
<span class="nc" id="L2148">      }</span>
			
<span class="nc bnc" id="L2150" title="All 2 branches missed.">			if (cachedExp!= null) {</span>
<span class="nc" id="L2151">				throw new AmException(cachedExp); </span>
			}
<span class="nc" id="L2153">    } catch (BbmFinderException e) {</span>
<span class="nc" id="L2154">      handleException(e, false);</span>
<span class="nc" id="L2155">      throw new AmException(e);</span>
<span class="nc" id="L2156">    } catch (RemoteException e) {</span>
<span class="nc" id="L2157">      handleException(e);</span>
<span class="nc" id="L2158">      throw new EJBException(e);</span>
    } finally {
<span class="nc" id="L2160">      methodFinish();</span>
<span class="nc" id="L2161">    }</span>
<span class="nc" id="L2162">  }</span>

  /**
   * Internal helper function to group insertion of raw time entries in chunk, and in one transaction
   * Not to be invoked directly by other
   *
   * @param employeeID
   * @param lastEvent
   * @param nextShiftOfRawTimeEntries
   * @param empHandled
   * @param minRawTimeEntry1
   * @throws Exception
   */
  public void insertRawTimeEntriesPerChunk(ID employeeID, ArrayList nextShiftOfRawTimeEntries, boolean empHandled, TimeRecordEntry lastEvent, RawTimeEntry minRawTimeEntry1) throws AmException, RemoteException {
    try {
<span class="nc" id="L2177">      m_cat.debug(new LogMessage(employeeID, &quot;Enter function insertRawTimeEntriesPerChunk&quot; +</span>
          &quot; employeeID= &quot; + employeeID +
          &quot; nextShiftOfRawTimeEntries= &quot; + nextShiftOfRawTimeEntries +
          &quot; empHandled= &quot; + empHandled +
          &quot; lastEvent= &quot; + lastEvent +
          &quot; minRawTimeEntry1+ &quot; + minRawTimeEntry1));

<span class="nc" id="L2184">      ID timeRecordID = null;</span>
<span class="nc" id="L2185">      boolean mergeNeeded = false;</span>
<span class="nc" id="L2186">      boolean updatePrv = false;</span>
<span class="nc" id="L2187">      ID prvEntryID = null;</span>
<span class="nc" id="L2188">      ID prvRawEntryID = null;</span>
<span class="nc" id="L2189">      ID prvActivityID = null;</span>
<span class="nc" id="L2190">      int prvTimeSourceCode = TimeEntrySourceCode.RAWPUNCH;</span>
<span class="nc bnc" id="L2191" title="All 2 branches missed.">      if (!empHandled) {</span>
        //-------------------------------------------------------------------
        // if the minRawTimeEntry is end shift, do not autoclose
        //-------------------------------------------------------------------
<span class="nc" id="L2195">        boolean doNotAutoClose = minRawTimeEntry1.isEndShift();</span>
<span class="nc" id="L2196">        Object[] result = findCurrentTimeRecordID(employeeID, lastEvent, minRawTimeEntry1.getPunchDate(), doNotAutoClose, false);</span>
<span class="nc" id="L2197">        timeRecordID = (ID) result[0];</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">        if (timeRecordID != null) {</span>
<span class="nc" id="L2199">          Boolean merge = (Boolean) result[1];</span>
<span class="nc bnc" id="L2200" title="All 2 branches missed.">          if (merge != null) {</span>
<span class="nc" id="L2201">            mergeNeeded = merge.booleanValue();</span>
          }
<span class="nc" id="L2203">          prvActivityID = (ID) result[5];</span>
<span class="nc" id="L2204">          Integer sourceCode = (Integer) result[6];</span>
<span class="nc bnc" id="L2205" title="All 2 branches missed.">          prvTimeSourceCode = sourceCode != null ? sourceCode.intValue() : prvTimeSourceCode;</span>
          // check if need update previous entry
<span class="nc bnc" id="L2207" title="All 2 branches missed.">          if (result[2] != null) {</span>
<span class="nc bnc" id="L2208" title="All 4 branches missed.">            if (FixZeroDuration &amp;&amp; (Math.abs(minRawTimeEntry1.getSortTime().getTime() - ((Date) result[2]).getTime())) &lt; 1000) {</span>
<span class="nc" id="L2209">              updatePrv = true;</span>
<span class="nc" id="L2210">              prvEntryID = (ID) result[3];</span>
<span class="nc" id="L2211">              prvRawEntryID = (ID) result[4];</span>
            }
          }
        }
      }

      //-------------------------------------------------------------------
      //  if we don't have a timerecord
      //    create one now
      //    make sure merge condition is not set
      //-------------------------------------------------------------------
<span class="nc bnc" id="L2222" title="All 2 branches missed.">      if (timeRecordID == null) {</span>
<span class="nc" id="L2223">        TimeRecord timeRecord = createNewTimeRecord(employeeID);</span>
<span class="nc" id="L2224">        timeRecordID = timeRecord.getID();</span>
<span class="nc" id="L2225">        mergeNeeded = false;</span>
      }

      // check if the first Event has the same Activity/TimeSourceCode as previous Event
      // if so no need to create duplicated Activity Event
<span class="nc" id="L2230">      RawTimeEntry minRawTimeEntry = (RawTimeEntry) nextShiftOfRawTimeEntries.get(0);</span>
<span class="nc bnc" id="L2231" title="All 8 branches missed.">      if (FixZeroDuration &amp;&amp;</span>
          !mergeNeeded &amp;&amp; prvTimeSourceCode == TimeEntrySourceCode.RAWPUNCH &amp;&amp;
          prvActivityID != null &amp;&amp;
<span class="nc bnc" id="L2234" title="All 2 branches missed.">          minRawTimeEntry.getActivityID().equals(prvActivityID) &amp;&amp;</span>
<span class="nc bnc" id="L2235" title="All 2 branches missed.">          minRawTimeEntry.getTimeSourceCode() == prvTimeSourceCode) {</span>
<span class="nc" id="L2236">        nextShiftOfRawTimeEntries.remove(0);</span>
<span class="nc" id="L2237">        updatePrv = false;</span>
      }

      //---------------------------------------------------------------------
      //  now that we have a TimeRecord ID
      //  update each of the RawTimeEntry value objects
      //---------------------------------------------------------------------
<span class="nc" id="L2244">      setTimeRecordID(nextShiftOfRawTimeEntries, timeRecordID);</span>

      //---------------------------------------------------------------------
      //  CREATE RawTimeEntry entrys in database in bulk
      //  this is done first regardless of what else fails
      //---------------------------------------------------------------------
<span class="nc bnc" id="L2250" title="All 2 branches missed.">      if (NeedRawEntry) {</span>
<span class="nc bnc" id="L2251" title="All 4 branches missed.">        if (updatePrv &amp;&amp; prvRawEntryID != null) {</span>
<span class="nc" id="L2252">          minRawTimeEntry.setId(prvRawEntryID);</span>
<span class="nc" id="L2253">          TimeCollectorDAO.updateRawTimeEntry(minRawTimeEntry);</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">          if (nextShiftOfRawTimeEntries.size() &gt; 1) {</span>
<span class="nc" id="L2255">            ArrayList createList = new ArrayList(nextShiftOfRawTimeEntries.subList(1, nextShiftOfRawTimeEntries.size() - 1));</span>
<span class="nc" id="L2256">            TimeCollectorDAO.createRawTimeEntries(createList);</span>
<span class="nc" id="L2257">          }</span>
        } else {
<span class="nc" id="L2259">          TimeCollectorDAO.createRawTimeEntries(nextShiftOfRawTimeEntries);</span>
        }
      }
      //---------------------------------------------------------------------
      //  now CREATE TimeEntryEvent entries for each RawTimeEntry
      //---------------------------------------------------------------------
<span class="nc" id="L2265">      ArrayList timeEntryList = new ArrayList(nextShiftOfRawTimeEntries.size());</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">      for (Iterator i = nextShiftOfRawTimeEntries.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2267">        RawTimeEntry rawTimeEntry = (RawTimeEntry) i.next();</span>
        //----------------------------------------------
        // create a TimeRecordEntry (TimeEntryEvent)
        // for each RawTimeEntry
        //----------------------------------------------
<span class="nc" id="L2272">        rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.RAWPUNCH);</span>
<span class="nc" id="L2273">        TimeRecordEntry entry = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, isPaid(getIsPaidForActivity(rawTimeEntry.getActivityID())));</span>
<span class="nc" id="L2274">        timeEntryList.add(entry);</span>
<span class="nc" id="L2275">      }</span>
      // Create through TimeRecordManager
<span class="nc bnc" id="L2277" title="All 2 branches missed.">      if (mergeNeeded) {</span>
        // fetch the first entry and create it with merge, then the left are just normal insert
<span class="nc" id="L2279">        TimeRecordEntry firstEntry = (TimeRecordEntry) timeEntryList.remove(0);</span>
<span class="nc" id="L2280">        m_timeRecordManager.createTimeRecordEntryForMerge(timeRecordID, firstEntry, null);</span>
<span class="nc" id="L2281">      } else {</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">        if (updatePrv) {</span>
<span class="nc" id="L2283">          TimeRecordEntry firstEntry = (TimeRecordEntry) timeEntryList.remove(0);</span>
<span class="nc" id="L2284">          firstEntry.setID(prvEntryID);</span>
<span class="nc" id="L2285">          m_timeRecordManager.updateTimeRecordEntry(firstEntry);</span>
        }
      }
<span class="nc bnc" id="L2288" title="All 2 branches missed.">      if (!timeEntryList.isEmpty())</span>
<span class="nc" id="L2289">        m_timeRecordManager.createTimeRecordEntry(timeRecordID, timeEntryList);</span>
<span class="nc" id="L2290">    } catch (JdmoException e) {</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">      if (e.isConnectivityException())</span>
<span class="nc" id="L2292">        throw new ConnectException(e.getMessage(), e);</span>
<span class="nc" id="L2293">      throw new AmException(e);</span>
<span class="nc" id="L2294">    } catch (BbmException e) {</span>
<span class="nc" id="L2295">      throw new AmException(e);</span>
<span class="nc" id="L2296">    } catch (RemoteException e) {</span>
<span class="nc" id="L2297">      throw new EJBException(e);</span>
<span class="nc" id="L2298">    }</span>
<span class="nc" id="L2299">  }</span>

  /**
   * &lt;B&gt;insertPunchTimeErrors&lt;/B&gt;
   * &lt;p&gt;
   * inserts errors from bpx in database
   *
   * @param changeStateStatusMessages Collection of status messages
   *                                  returned from bpx
   */
  public void insertPunchTimeErrors(Collection changeStateStatusMessages) throws AmException {
<span class="nc" id="L2310">    methodStart(&quot;insertPunchTimeErrors&quot;, changeStateStatusMessages);</span>
    try {
    } finally {
<span class="nc" id="L2313">      methodFinish();</span>
    }
<span class="nc" id="L2315">  }</span>

  /**
   * &lt;B&gt;insertUnknownActivity&lt;/B&gt;
   * &lt;p&gt;
   * insert Activity.ACTIVITY_UNKNOWN for each given employee associated with the DataSource
   * if their last record is open and has entry created from ACD
   *
   * @param dataSourceID ID of datasource
   * @param date         time of unknown activity
   */
  public void insertUnknownActivity(ID dataSourceID, Date date) throws AmException {
<span class="nc" id="L2327">    methodStart(&quot;insertUnkonwActivity&quot;, dataSourceID, date);</span>
<span class="nc" id="L2328">    int isUnknownActivityPaid = getIsPaidForActivity(Activity.ACTIVITY_UNKNOWN);</span>
<span class="nc" id="L2329">    boolean unKnownPaid = isPaid(isUnknownActivityPaid);</span>
<span class="nc" id="L2330">    Jdmo jdmo = new Jdmo();</span>
    try {
      // First find all employees associated with the DataSource
<span class="nc" id="L2333">      String strSQL = &quot;SELECT EMPLOYEEID FROM EMPLOYEEDATASOURCE WHERE DATASOURCEID=?&quot;;</span>
<span class="nc" id="L2334">      HashSet employeeIDs = new HashSet();</span>
<span class="nc" id="L2335">      JdmoQuery jQuery = jdmo.createQuery(strSQL, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2336">      jQuery.setParID(1, dataSourceID);</span>
<span class="nc" id="L2337">      JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">      while (rs.next()) {</span>
<span class="nc" id="L2339">        employeeIDs.add(rs.getID(1));</span>
      }
<span class="nc" id="L2341">      rs.close();</span>
      // list of employees that have unknown activity in past
<span class="nc" id="L2343">      ArrayList empList = new ArrayList();</span>
      // Now work on each employee, and check if need close previous record, but not auto merge
<span class="nc" id="L2345">      HashMap lastEventMap = m_timeRecordManager.getLastEntries(employeeIDs, null);</span>
<span class="nc" id="L2346">      HashSet recordSet = new HashSet(employeeIDs.size());</span>
<span class="nc bnc" id="L2347" title="All 2 branches missed.">      for (Iterator i = employeeIDs.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2348">        ID employeeID = (ID) i.next();</span>
<span class="nc" id="L2349">        TimeRecordEntry lastEvent = (TimeRecordEntry) lastEventMap.get(employeeID);</span>
<span class="nc" id="L2350">        Object[] result = findCurrentTimeRecordID(employeeID, lastEvent, date, false, true);</span>
<span class="nc" id="L2351">        ID timeRecordID = (ID) result[0];</span>
<span class="nc" id="L2352">        Boolean merge = (Boolean) result[1];</span>
        // if need merge, means prv record is closed, ignore it recreate a new TR
        // if no prv record is chosen, just create a new TR
<span class="nc bnc" id="L2355" title="All 4 branches missed.">        if (merge.booleanValue() || timeRecordID == null) {</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">          if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2357">            m_cat.debug(&quot;In Unknown window, the previous record is either closed or not exist, record id &quot; + result[0] + &quot; and needMerge is &quot; + result[1] + &quot; for employee &quot; + employeeID);</span>
          }
        } else {
          // We only create unknown shift, if previous shift is still open.
          // unknown event is historic, that is it occurs before
          // the last event, skip this employee and process later
<span class="nc bnc" id="L2363" title="All 2 branches missed.">          if (lastEvent.getStartTime().after(date)) {</span>
<span class="nc" id="L2364">            empList.add(employeeID);</span>
<span class="nc" id="L2365">            continue;</span>
          }
<span class="nc" id="L2367">          Pair empRecordPair = new Pair(timeRecordID, employeeID);</span>
<span class="nc" id="L2368">          recordSet.add(empRecordPair);</span>
        }
<span class="nc" id="L2370">      }</span>

<span class="nc" id="L2372">      ArrayList rawTimeEntries = new ArrayList(employeeIDs.size());</span>
<span class="nc" id="L2373">      ArrayList timeEntries = new ArrayList(employeeIDs.size());</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">      for (Iterator it = recordSet.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2375">        Pair empRecordPair = (Pair) it.next();</span>
<span class="nc" id="L2376">        ID timeRecordID = (ID) empRecordPair.getFirst();</span>
<span class="nc" id="L2377">        ID employeeID = (ID) empRecordPair.getSecond();</span>
<span class="nc" id="L2378">        RawTimeEntry rawTimeEntry =</span>
            new RawTimeEntry(null, employeeID,
                Activity.ACTIVITY_UNKNOWN,
                timeRecordID,
                dataSourceID,
                null,
                RawTimeEntry.START_ACTIVITY,
                date);
<span class="nc" id="L2386">        rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.RAWPUNCH);</span>
<span class="nc" id="L2387">        rawTimeEntries.add(rawTimeEntry);</span>
<span class="nc" id="L2388">        TimeRecordEntry tre = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, unKnownPaid);</span>
<span class="nc" id="L2389">        timeEntries.add(tre);</span>
<span class="nc" id="L2390">      }</span>
      // create
<span class="nc bnc" id="L2392" title="All 2 branches missed.">      if (NeedRawEntry) {</span>
<span class="nc" id="L2393">        TimeCollectorDAO.createRawTimeEntries(rawTimeEntries);</span>
      }
<span class="nc" id="L2395">      m_timeRecordManager.createTimeRecordEntry(timeEntries);</span>
      // process skipped employees
<span class="nc bnc" id="L2397" title="All 2 branches missed.">      if (empList.size() &gt; 0) {</span>
<span class="nc" id="L2398">        timeEntries.clear();</span>
<span class="nc" id="L2399">        rawTimeEntries.clear();</span>

<span class="nc" id="L2401">        Date dtStart = new Date(date.getTime() - UnknownEventInterval);</span>
<span class="nc" id="L2402">        Date dtEnd = new Date(date.getTime() + UnknownEventInterval);</span>

        // get the timerecord id for the unknown event date
<span class="nc" id="L2405">        Map extRecordMap = m_timeRecordManager.getEventsForWorkResource(empList, dtStart, dtEnd);</span>

<span class="nc bnc" id="L2407" title="All 2 branches missed.">        for (int i = 0; i &lt; empList.size(); ++i) {</span>
<span class="nc" id="L2408">          ID employeeID = (ID) empList.get(i);</span>
<span class="nc" id="L2409">          ArrayList extRecordList = (ArrayList) extRecordMap.get(employeeID);</span>
<span class="nc bnc" id="L2410" title="All 4 branches missed.">          if (extRecordList == null || extRecordList.isEmpty()) {</span>
<span class="nc" id="L2411">            continue; // no time record so skip</span>
          }

          // search for the correct time record
<span class="nc" id="L2415">          ID timeRecordID = null;</span>

<span class="nc bnc" id="L2417" title="All 2 branches missed.">          for (int j = 0; j &lt; extRecordList.size(); ++j) {</span>
<span class="nc" id="L2418">            TimeRecord curRecord = (TimeRecord) extRecordList.get(j);</span>
<span class="nc" id="L2419">            ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L2420" title="All 4 branches missed.">            if (entryList == null || entryList.size() &lt;= 0)</span>
<span class="nc" id="L2421">              continue;</span>

<span class="nc" id="L2423">            TimeRecordEntry first = (TimeRecordEntry) entryList.get(0);</span>
<span class="nc" id="L2424">            TimeRecordEntry last = (TimeRecordEntry) entryList.get(entryList.size() - 1);</span>

            // if first activity is end shift then skip
<span class="nc bnc" id="L2427" title="All 2 branches missed.">            if (first.getActivityID().equals(Activity.ACTIVITY_NONE))</span>
<span class="nc" id="L2428">              continue;</span>

<span class="nc bnc" id="L2430" title="All 4 branches missed.">            if (date.after(first.getStartTime()) &amp;&amp; date.before(last.getStartTime())) {</span>
<span class="nc" id="L2431">              timeRecordID = curRecord.getID();</span>
<span class="nc" id="L2432">              break;</span>
            }
          }

<span class="nc bnc" id="L2436" title="All 2 branches missed.">          if (timeRecordID == null)</span>
<span class="nc" id="L2437">            continue;</span>

<span class="nc" id="L2439">          RawTimeEntry rawTimeEntry =</span>
              new RawTimeEntry(null, employeeID,
                  Activity.ACTIVITY_UNKNOWN,
                  timeRecordID,
                  dataSourceID,
                  null,
                  RawTimeEntry.START_ACTIVITY,
                  date);
<span class="nc" id="L2447">          rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.RAWPUNCH);</span>
<span class="nc" id="L2448">          rawTimeEntries.add(rawTimeEntry);</span>
<span class="nc" id="L2449">          TimeRecordEntry tre = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, unKnownPaid);</span>
<span class="nc" id="L2450">          timeEntries.add(tre);</span>
        }

        // create
<span class="nc bnc" id="L2454" title="All 2 branches missed.">        if (NeedRawEntry) {</span>
<span class="nc" id="L2455">          TimeCollectorDAO.createRawTimeEntries(rawTimeEntries);</span>
        }
<span class="nc" id="L2457">        m_timeRecordManager.createTimeRecordEntry(timeEntries);</span>
      }
<span class="nc" id="L2459">    } catch (JdmoException e) {</span>
<span class="nc" id="L2460">      handleException(e);</span>
<span class="nc" id="L2461">      throw new AmException(e);</span>
<span class="nc" id="L2462">    } catch (BbmFinderException e) {</span>
<span class="nc" id="L2463">      handleException(e);</span>
<span class="nc" id="L2464">      throw new AmException(e);</span>
<span class="nc" id="L2465">    } catch (BbmCreateException e) {</span>
<span class="nc" id="L2466">      handleException(e);</span>
<span class="nc" id="L2467">      throw new AmException(e);</span>
<span class="nc" id="L2468">    } catch (RemoteException e) {</span>
<span class="nc" id="L2469">      handleException(e);</span>
<span class="nc" id="L2470">      throw new AmException(e);</span>
    } /*catch (BbmTimeRecordException e) {
      handleException(e);
			throw new AmException(e);
		} */ finally {
<span class="nc" id="L2475">      jdmo.cleanUp();</span>
<span class="nc" id="L2476">      methodFinish();</span>
<span class="nc" id="L2477">    }</span>
<span class="nc" id="L2478">  }</span>

  /**
   * &lt;B&gt;insertUnknownActivity&lt;/B&gt;
   * &lt;p&gt;
   * insert Activity.ACTIVITY_UNKNOWN for each given employee, no update for 0 duration entry
   *
   * @param employeeIDs  list of employee IDs for insert
   * @param dataSourceID ID of datasource
   * @param date         time of unknown activity
   * @return Collection of new ID's
   */
  public Collection insertUnknownActivity(Collection employeeIDs,
                                          ID dataSourceID,
                                          Date date) throws AmException {
<span class="nc" id="L2493">    return null;</span>
  }

  /**
   * &lt;B&gt;updateRawTimeEntry&lt;/B&gt;
   * &lt;p&gt;
   * updates fields of given RawTimeEntry
   *
   * @param rawTimeEntry raw time data to be updated
   */
  public void updateRawTimeEntry(RawTimeEntry rawTimeEntry) throws AmException {
<span class="nc" id="L2504">    ArrayList rawTimeEntries = new ArrayList(1);</span>
<span class="nc" id="L2505">    rawTimeEntries.add(rawTimeEntry);</span>
<span class="nc" id="L2506">    updateRawTimeEntries(rawTimeEntries);</span>
<span class="nc" id="L2507">  }</span>

  /**
   * &lt;B&gt;updateRawTimeEntries&lt;/B&gt;
   * updates fields of given RawTimeEntry's, quick update
   *
   * @param rawTimeEntries collection of raw time data to be updated
   *                       &lt;p&gt;
   * @return collection of ID's that couldn't be updated
   */
  public Collection updateRawTimeEntries(Collection rawTimeEntries) throws AmException {
<span class="nc" id="L2518">    methodStart(&quot;updateRawTimeEntries&quot;, rawTimeEntries);</span>
<span class="nc" id="L2519">    Collection rawTimeEntriesCopy = new ArrayList(rawTimeEntries);</span>
<span class="nc" id="L2520">    Collection updateErrors = new ArrayList();</span>
    try {
      //-----------------------------------------------------------------
      // first batch update the rawTimeEntries, if they exist
      //-----------------------------------------------------------------
<span class="nc bnc" id="L2525" title="All 2 branches missed.">      if (NeedRawEntry) {</span>
<span class="nc" id="L2526">        TimeCollectorDAO.updateRawTimeEntryActivities(rawTimeEntriesCopy);</span>
      }
      //-----------------------------------------------------------------
      // now we need to update the TimeRecordEntries (TimeEntryEvents)
      // update only if now error updating
      //-----------------------------------------------------------------
<span class="nc" id="L2532">      Collection recordEntryCol = new ArrayList();</span>
<span class="nc bnc" id="L2533" title="All 2 branches missed.">      for (Iterator i = rawTimeEntriesCopy.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2534">        RawTimeEntry rawTimeEntry = (RawTimeEntry) i.next();</span>
        //-------------------------------------------------------------------
        //  if RawTimeEntry.ID stop TimeRecordEntry update and log error
        //-------------------------------------------------------------------
<span class="nc bnc" id="L2538" title="All 2 branches missed.">        if (rawTimeEntry.getID() == null) {</span>
<span class="nc" id="L2539">          m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_TIMERECORDENTRY_UPDATE_FAILURE,</span>
              new Object[]{rawTimeEntry});
<span class="nc bnc" id="L2541" title="All 2 branches missed.">        } else if (!updateErrors.contains(rawTimeEntry.getID())) {</span>
<span class="nc" id="L2542">          int isPaid = getIsPaidForActivity(rawTimeEntry.getActivityID());</span>

          //-----------------------------------------------------------------
          // create new TimeRecordEntry. Only the activityID, isPaid and RawTimeEntryID are importent here
          //-----------------------------------------------------------------
<span class="nc" id="L2547">          TimeRecordEntry timeRecordEntry = null;</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">          if (NeedRawEntry) {</span>
<span class="nc" id="L2549">            timeRecordEntry = new TimeRecordEntry(null,</span>
<span class="nc" id="L2550">                rawTimeEntry.getID(),</span>
<span class="nc" id="L2551">                rawTimeEntry.getActivityID(),</span>
<span class="nc" id="L2552">                rawTimeEntry.getDataSourceId(),</span>
                null,
                null,
                null,
                TimeEntrySourceCode.RAWPUNCH,
<span class="nc" id="L2557">                isPaid(isPaid),</span>
                null);
          } else {
            // If there is no raw timeentry, then the ID from RawTimeEntry is TimeRecordEntry ID
<span class="nc" id="L2561">            timeRecordEntry = new TimeRecordEntry(rawTimeEntry.getId(),</span>
                null,
<span class="nc" id="L2563">                rawTimeEntry.getActivityID(),</span>
<span class="nc" id="L2564">                rawTimeEntry.getDataSourceId(),</span>
                null,
                null,
                null,
                TimeEntrySourceCode.RAWPUNCH,
<span class="nc" id="L2569">                isPaid(isPaid),</span>
                null);
          }
<span class="nc" id="L2572">          timeRecordEntry.setEmployeeID(rawTimeEntry.getEmployeeID());</span>
          //-----------------------------------------------------------------
          // now we can update the TimeRecordEntry
          //-----------------------------------------------------------------
<span class="nc" id="L2576">          recordEntryCol.add(timeRecordEntry);</span>

        }
<span class="nc" id="L2579">        m_timeRecordManager.quickUpdateTimeRecordEntry(recordEntryCol);</span>
<span class="nc" id="L2580">      }</span>
<span class="nc" id="L2581">      return updateErrors;</span>
<span class="nc" id="L2582">    } catch (Exception e) {</span>
<span class="nc" id="L2583">      handleException(e);</span>
<span class="nc" id="L2584">      throw new AmException(e);</span>
    } finally {
<span class="nc" id="L2586">      methodFinish();</span>
    }
  }

  /**
   * &lt;B&gt;findCurrentTimeRecordId&lt;/B&gt;
   * &lt;p&gt;
   * Find the current TimeRecord ID for this employee
   * looks for last entry (from cache, or DB)
   * IF not END_SHIFT (after apply auto close/merge rules)
   * returns its TimeRecord ID
   *
   * @param employeeID
   * @param punchDate
   * @param doNotAutoClose
   * @return Object (TimeRecordID, MergeNeeded, StartTime, ID, RTEID)
   * @throws JdmoException
   * @throws BbmFinderException
   * @throws RemoteException
   */
  private Object[] findCurrentTimeRecordID(ID employeeID, TimeRecordEntry lastEvent, Date punchDate, boolean doNotAutoClose, boolean doNotAutoMerge) throws JdmoException, BbmFinderException, RemoteException {
<span class="nc" id="L2607">    Object[] result = new Object[7];</span>
<span class="nc" id="L2608">    result[1] = Boolean.FALSE;</span>
<span class="nc" id="L2609">    ID foundTimeRecordID = null;</span>
<span class="nc" id="L2610">    ID foundEventID = null;</span>
<span class="nc" id="L2611">    ID foundEventActivityID = null;</span>
<span class="nc" id="L2612">    long foundEventTimestamp = 0;</span>
<span class="nc bnc" id="L2613" title="All 2 branches missed.">    long punchTime = (punchDate == null) ? System.currentTimeMillis() : punchDate.getTime();</span>
<span class="nc bnc" id="L2614" title="All 2 branches missed.">    if (lastEvent != null) {</span>
<span class="nc" id="L2615">      result[2] = lastEvent.getSortTime();</span>
<span class="nc" id="L2616">      result[3] = lastEvent.getID();</span>
<span class="nc" id="L2617">      result[4] = lastEvent.getRawTimeEntryID();</span>
<span class="nc" id="L2618">      result[5] = lastEvent.getActivityID();</span>
<span class="nc" id="L2619">      result[6] = NumberFactory.newInteger(lastEvent.getTimeSourceCode());</span>
      // If find cached object, handle it and return
<span class="nc bnc" id="L2621" title="All 2 branches missed.">      if (lastEvent.getSortTime() != null) {</span>
<span class="nc" id="L2622">        foundTimeRecordID = lastEvent.getTimeRecordID();</span>
<span class="nc" id="L2623">        foundEventID = lastEvent.getID();</span>
<span class="nc" id="L2624">        foundEventActivityID = lastEvent.getActivityID();</span>
<span class="nc" id="L2625">        foundEventTimestamp = lastEvent.getSortTime().getTime();</span>
        // handle merge or auto close
<span class="nc" id="L2627">        Pair pair = handleMergeAndClose(employeeID, foundTimeRecordID, foundEventID, foundEventActivityID, punchTime, foundEventTimestamp, doNotAutoClose, doNotAutoMerge);</span>
<span class="nc" id="L2628">        result[0] = pair.getFirst();</span>
<span class="nc" id="L2629">        result[1] = pair.getSecond();</span>
      }
    }
<span class="nc" id="L2632">    return result;</span>
  }

  /**
   * Util function to auto merge/close entries based on the configured rules
   *
   * @param employeeID
   * @param foundTimeRecordID
   * @param eventID
   * @param activityID
   * @param punchTime
   * @param lastEventTime
   * @param doNotAutoClose
   * @return [TimeRecordID, needMerge]
   * @throws JdmoException
   * @throws BbmFinderException
   * @throws RemoteException
   */
  private Pair handleMergeAndClose(ID employeeID, ID foundTimeRecordID, ID eventID, ID activityID, long punchTime, long lastEventTime, boolean doNotAutoClose, boolean doNotAutoMerge) throws JdmoException, BbmFinderException, RemoteException {
<span class="nc" id="L2651">    Pair pair = new Pair(foundTimeRecordID, Boolean.FALSE);</span>
<span class="nc" id="L2652">    boolean needMerge = false;</span>
    // Check the gap between last Entry and punchTime
<span class="nc" id="L2654">    long minutesSinceLastActivityChange = Math.abs(punchTime - lastEventTime);</span>
    // if last Event is EndShift consider AutoMerge, else consider AutoClose
<span class="nc bnc" id="L2656" title="All 2 branches missed.">    if (activityID.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc bnc" id="L2657" title="All 4 branches missed.">      if (PerformAutoMerge &amp;&amp; (minutesSinceLastActivityChange &lt;= AutoMergeTimeoutInMillis)) {</span>
<span class="nc bnc" id="L2658" title="All 4 branches missed.">        if (NeedRawEntry &amp;&amp; !doNotAutoMerge)</span>
<span class="nc" id="L2659">          TimeCollectorDAO.updateRawTimeEntryForMerge(eventID);</span>
<span class="nc" id="L2660">        needMerge = true;</span>
      }
<span class="nc bnc" id="L2662" title="All 2 branches missed.">      if (!needMerge) {</span>
<span class="nc" id="L2663">        foundTimeRecordID = null;</span>
      }
    } else {
<span class="nc bnc" id="L2666" title="All 4 branches missed.">      if (!doNotAutoClose &amp;&amp; PerformAutoClose &amp;&amp;</span>
          (minutesSinceLastActivityChange &gt;= AutoCloseTimeoutInMillis)) {
        //---------------------------------------------------------
        //  AUTO CLOSE, don't use timerecordid
        //---------------------------------------------------------
<span class="nc" id="L2671">        autocloseShift(employeeID, foundTimeRecordID, punchTime, lastEventTime);</span>
<span class="nc" id="L2672">        foundTimeRecordID = null;</span>
      }
    }
<span class="nc" id="L2675">    pair.setFirst(foundTimeRecordID);</span>
<span class="nc" id="L2676">    pair.setSecond(new Boolean(needMerge));</span>
<span class="nc" id="L2677">    return pair;</span>
  }

  /**
   * &lt;B&gt;autocloseShift&lt;/B&gt;
   * &lt;p&gt;
   * Auto-Close an open time record. Will not throw in case of an error.
   *
   * @param employeeId         employee id
   * @param timeRecordId       timerecord id
   * @param newEventTimeMilli  the new event, that generated the auto close, time in milliseconds
   * @param lastEventTimeMilli the last recorded event in milliseconds
   */
  private void autocloseShift(ID employeeId, ID timeRecordId, long newEventTimeMilli, long lastEventTimeMilli) {
    // determine the auto close time
<span class="nc" id="L2692">    Date autoCloseDate = new Date(lastEventTimeMilli + MINUTE);</span>
    // Create the raw time entry
<span class="nc" id="L2694">    RawTimeEntry rawTimeEntry = new RawTimeEntry(employeeId, Activity.ACTIVITY_NONE,</span>
        timeRecordId, null, RawTimeEntry.AUTOCLOSE_END_SHIFT, autoCloseDate);
<span class="nc" id="L2696">    rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.AUTO_CLOSE);</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">    if (NeedRawEntry) {</span>
      try {
<span class="nc" id="L2699">        ID newId = TimeCollectorDAO.createRawTimeEntry(rawTimeEntry);</span>
<span class="nc" id="L2700">        rawTimeEntry.setId(newId);</span>
<span class="nc" id="L2701">      } catch (JdmoException e) {</span>
        // if failed to auto-close, simply log on info level and not throw. Sometimes, there will be duplicate key exception
        // in RawTimeEntry table since we are basically giving an arbitrary time for end of shift.
<span class="nc" id="L2704">        m_cat.l7dInfo(AmEjbLogBundleKey.TIMECOLLECTOR_FAILURE_AUTO_CLOSE, new Object[]{rawTimeEntry}, e);</span>
<span class="nc" id="L2705">        return;</span>
<span class="nc" id="L2706">      }</span>
    }
    // Handle TimeRecordEntry
    try {
      // Create TimeEntryEvent
<span class="nc" id="L2711">      TimeRecordEntry entry = convertRawTimeEntry(rawTimeEntry, timeRecordId, employeeId, null, false);</span>
<span class="nc" id="L2712">      m_timeRecordManager.createTimeRecordEntry(timeRecordId, entry, false);</span>
      // Create AuditTrailEntry
<span class="nc" id="L2714">      EmployeeName empName = m_workResourceManager.getEmployeeNameByID(employeeId);</span>
<span class="nc" id="L2715">      AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD, AuditTrailEntry.ACTION_DELETE_OBJECT, employeeId, empName.getDisplayName(DefaultLocalizationManager.getDefaultInstance().getLocalizer()), autoCloseDate, new Date(newEventTimeMilli));</span>
<span class="nc" id="L2716">      auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD), &quot;-1&quot;, false);</span>
<span class="nc" id="L2717">      m_auditManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L2718">    } catch (Exception e) {</span>
<span class="nc" id="L2719">      m_cat.l7dInfo(AmEjbLogBundleKey.TIMECOLLECTOR_FAILURE_AUTO_CLOSE, new Object[]{rawTimeEntry}, e);</span>
<span class="nc" id="L2720">      return;</span>
<span class="nc" id="L2721">    }</span>
<span class="nc" id="L2722">  }</span>

  /**
   * &lt;B&gt;createNewTimeRecord&lt;/B&gt;
   * &lt;p&gt;
   * creates a TimeRecord for the given employee id
   * &lt;p&gt;
   *
   * @param employeeID ID of employee to create time record for
   *                   &lt;p&gt;
   * @return TimeRecord
   */
  private TimeRecord createNewTimeRecord(ID employeeID) {
<span class="nc" id="L2735">    TimeRecord timeRecord = null;</span>
    try {
<span class="nc" id="L2737">      timeRecord = new TimeRecord(employeeID);</span>
<span class="nc" id="L2738">      timeRecord.setID(m_timeRecordManager.createTimeRecord(timeRecord));</span>
<span class="nc" id="L2739">    } catch (Exception e) {</span>
<span class="nc" id="L2740">      m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_TIMERECORD_CREATE_FAILURE,</span>
          new Object[]{employeeID}, e);
<span class="nc" id="L2742">    }</span>
<span class="nc" id="L2743">    return timeRecord;</span>
  }

  /**
   * &lt;B&gt;getIsPaidForActivity&lt;/B&gt;
   * &lt;p&gt;
   * is isPaid value from given activity id
   *
   * @param activityID id of activity to look up
   *                   &lt;p&gt;
   * @return short, 0 is not paid, 1 is paid, -1 cannot find, -2 inactive paid, -3 inactive unpaid
   */
  private int getIsPaidForActivity(ID activityID) {
    // if activity is cached, then just go activity manager for latest activity object
<span class="nc bnc" id="L2757" title="All 2 branches missed.">    if (ActivityCached) {</span>
      try {
<span class="nc" id="L2759">        Activity activity = m_activityManager.findActivityById(activityID);</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">        int isPaid = activity.isPaid() ? PAID_ACTIVE : UNPAID_ACTIVE;</span>
<span class="nc bnc" id="L2761" title="All 2 branches missed.">        isPaid = activity.isDeleted() ? isPaid - 3 : isPaid;</span>
<span class="nc bnc" id="L2762" title="All 2 branches missed.">        if (ActivitiesIsPaidCacheTable != null)</span>
<span class="nc" id="L2763">          ActivitiesIsPaidCacheTable.put(activity.getID(), NumberFactory.newInteger(isPaid));</span>
<span class="nc" id="L2764">        return isPaid;</span>
<span class="nc" id="L2765">      } catch (Exception e) {</span>
<span class="nc" id="L2766">        m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_ACTIVITY_CACHE_ERROR, e);</span>
<span class="nc" id="L2767">        return -1;</span>
      }
    }
    //---------------------------------------------------
    //  first determine if we need to refesh cache
    //---------------------------------------------------
<span class="nc bnc" id="L2773" title="All 2 branches missed.">    if ((ActivitiesIsPaidCacheTable == null) ||</span>
<span class="nc bnc" id="L2774" title="All 2 branches missed.">        (ActivitedIsPaidChecked + ACTIVITIES_ISPAID_TIMEOUT &lt; System.currentTimeMillis())) {</span>
<span class="nc" id="L2775">      refreshActivitesIsPaidCache();</span>
    }
<span class="nc bnc" id="L2777" title="All 4 branches missed.">    if (activityID != null &amp;&amp; ActivitiesIsPaidCacheTable != null) {</span>
<span class="nc" id="L2778">      Integer isPaidObj = (Integer) ActivitiesIsPaidCacheTable.get(activityID);</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">      if (isPaidObj != null) {</span>
<span class="nc" id="L2780">        return isPaidObj.intValue();</span>
      }
    }
<span class="nc" id="L2783">    return -1;</span>
  }

  /**
   * &lt;B&gt;refreshActivitesIsPaidCache&lt;/B&gt;
   * &lt;p&gt;
   * time dependent cache of activities id/ispaid for TimeCollectorEJB only
   * &lt;p&gt;
   */
  private void refreshActivitesIsPaidCache() {
    //---------------------------------------------------
    //  first determine if we need to check database
    //---------------------------------------------------
    try {
<span class="nc" id="L2797">      ActivityFilter activityFilter = new ActivityFilter(ActivityFilter.FILTER_NONE);</span>
<span class="nc" id="L2798">      Collection activities = m_activityManager.findActivities(activityFilter);</span>

      //---------------------------------------------------
      //  timeout of current check
      //---------------------------------------------------
<span class="nc" id="L2803">      ActivitedIsPaidChecked = System.currentTimeMillis();</span>

<span class="nc" id="L2805">      ActivitiesIsPaidCacheTable = new Hashtable(activities.size());</span>
<span class="nc bnc" id="L2806" title="All 2 branches missed.">      for (Iterator i = activities.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2807">        Activity activity = (Activity) i.next();</span>
<span class="nc bnc" id="L2808" title="All 2 branches missed.">        int isPaid = activity.isPaid() ? PAID_ACTIVE : UNPAID_ACTIVE;</span>
<span class="nc bnc" id="L2809" title="All 2 branches missed.">        isPaid = activity.isDeleted() ? isPaid - 3 : isPaid;</span>
<span class="nc" id="L2810">        ActivitiesIsPaidCacheTable.put(activity.getID(), NumberFactory.newInteger(isPaid));</span>
<span class="nc" id="L2811">      }</span>
<span class="nc" id="L2812">    } catch (Exception e) {</span>
<span class="nc" id="L2813">      m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_ACTIVITY_CACHE_ERROR, e);</span>
<span class="nc" id="L2814">    }</span>
<span class="nc" id="L2815">  }</span>

  /**
   * &lt;B&gt;setTimeRecordID&lt;/B&gt;
   * &lt;p&gt;
   * sets each RatTimeEntry's TimeRecord id to given id
   *
   * @param rawTimeEntries Collection of raw time data to be updated
   * @param timeRecordID   TimeRecordID
   *                       &lt;p&gt;
   */
  private void setTimeRecordID(Collection rawTimeEntries, ID timeRecordID) {
    //---------------------------------------------------------------------
    //  update TimeRecord ID each of the RawTimeEntry value objects
    //---------------------------------------------------------------------
<span class="nc bnc" id="L2830" title="All 2 branches missed.">    for (Iterator i = rawTimeEntries.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2831">      RawTimeEntry rawTimeEntry = (RawTimeEntry) i.next();</span>
<span class="nc" id="L2832">      rawTimeEntry.setTimeRecordID(timeRecordID);</span>
<span class="nc" id="L2833">    }</span>
<span class="nc" id="L2834">  }</span>

  private boolean isPaid(ID activityID) {
<span class="nc" id="L2837">    return isPaid(getIsPaidForActivity(activityID));</span>
  }

  private static boolean isPaid(int flag) {
<span class="nc bnc" id="L2841" title="All 3 branches missed.">    switch (flag) {</span>
      case UNPAID_ACTIVE:
      case UNPAID_INACTIVE:
<span class="nc" id="L2844">        return false;</span>
      case PAID_ACTIVE:
      case PAID_INACTIVE:
<span class="nc" id="L2847">        return true;</span>
      default:
<span class="nc" id="L2849">        return false;</span>
    }
  }

  private static TimeRecordEntry convertHAATimeEntry(RawTimeEntry rawTimeEntry, ID timeRecordID, ID employeeID, ID remarkerID, boolean isPaid) {
<span class="nc" id="L2854">    TimeRecordEntry tre = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, remarkerID, isPaid);</span>
<span class="nc" id="L2855">    return tre;</span>
  }

  private static TimeRecordEntry convertRawTimeEntry(RawTimeEntry rawTimeEntry, ID timeRecordID, ID employeeID, ID remarkerID, boolean isPaid) {
    //----------------------------------------------
    // create a TimeRecordEntry (TimeEntryEvent)
    //----------------------------------------------
<span class="nc" id="L2862">    TimeRecordEntry timeRecordEntry = new TimeRecordEntry(null,</span>
<span class="nc" id="L2863">        rawTimeEntry.getID(),</span>
<span class="nc" id="L2864">        rawTimeEntry.getActivityID(),</span>
<span class="nc" id="L2865">        rawTimeEntry.getDataSourceId(),</span>
<span class="nc" id="L2866">        rawTimeEntry.getStartTime(),</span>
        null,
<span class="nc" id="L2868">        rawTimeEntry.getSortTime(),</span>
<span class="nc" id="L2869">        rawTimeEntry.getTimeSourceCode(),</span>
        isPaid,
<span class="nc" id="L2871">        rawTimeEntry.getRemark());</span>
<span class="nc" id="L2872">    timeRecordEntry.setParentID(timeRecordID);</span>
<span class="nc" id="L2873">    timeRecordEntry.setEmployeeID(employeeID);</span>
<span class="nc" id="L2874">    timeRecordEntry.setRemarkerID(remarkerID);</span>
<span class="nc" id="L2875">    return timeRecordEntry;</span>
  }

  private static Collection getEmployeeIDs(Collection entries) {
<span class="nc" id="L2879">    HashSet empSet = new HashSet(100);</span>
<span class="nc bnc" id="L2880" title="All 2 branches missed.">    for (Iterator it = entries.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2881">      EmployeeEvent event = (EmployeeEvent) it.next();</span>
<span class="nc" id="L2882">      empSet.add(event.getEmployeeID());</span>
<span class="nc" id="L2883">    }</span>
<span class="nc" id="L2884">    return empSet;</span>
  }

  private static void setBPConfigDefaults() {
<span class="nc" id="L2888">    CreateTimeRecords = true;</span>
<span class="nc" id="L2889">    PerformAutoMerge = true;</span>
<span class="nc" id="L2890">    AutoCloseTimeoutInMillis = 600 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc" id="L2891">    AutoMergeTimeoutInMillis = 120 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc" id="L2892">  }</span>

  private static RawTimeEntry addEL(Collection elCol, RawTimeEntry elEntry, TimeRecordEntry lastTRE) {
<span class="nc bnc" id="L2895" title="All 4 branches missed.">    if (elEntry.getActivityID().equals(GLENDS) &amp;&amp; lastTRE != null) {</span>
<span class="nc" id="L2896">      elEntry.setActivityId(lastTRE.getActivityID());</span>
<span class="nc" id="L2897">      elEntry.setTimeSourceCode(lastTRE.getTimeSourceCode());</span>
<span class="nc bnc" id="L2898" title="All 2 branches missed.">      if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2899">        m_cat.debug(&quot;Replaced EL Ends with last TRE &quot; + elEntry + &quot; with last TRE &quot; + lastTRE);</span>
      }
    }
<span class="nc" id="L2902">    elCol.add(elEntry);</span>
<span class="nc" id="L2903">    return null;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>