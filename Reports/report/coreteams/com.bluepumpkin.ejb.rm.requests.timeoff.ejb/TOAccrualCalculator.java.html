<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOAccrualCalculator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.ejb</a> &gt; <span class="el_source">TOAccrualCalculator.java</span></div><h1>TOAccrualCalculator.java</h1><pre class="source lang-java linenums">/*
	 * TOAccrualCalculator.java
	 *
	 * Copyright (c) 2008, Verint, Inc.
	 * Sameet Joshi
	 * All rights reserved.
	 */
package com.bluepumpkin.ejb.rm.requests.timeoff.ejb;

import java.rmi.RemoteException;
import java.util.*;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Filter.Filter;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityCategory;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityTimeOffBalance;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTimeOffAccruedDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTimeOffYearlyDAO;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffAccrued;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffYearly;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmRuntimeException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOAccrual;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;
import com.verint.ejb.wfm.WfmManagerFactory;


<span class="nc" id="L47">public class TOAccrualCalculator {</span>
<span class="fc" id="L48">	private static final String m_className = TOAccrualCalculator.class.getName();</span>
<span class="fc" id="L49">	private static Category m_cat = Log.initCategory(m_className);</span>

	public static boolean hasLicenseForAccrual() {
<span class="fc" id="L52">         return true; //Accrual license has been retired. Accrual is always enabled.</span>
	}
	private static Set getActivityIDsForActivityCatID(Map activityMap, ID actCatID) {
<span class="nc" id="L55">		TreeSet activityIDSet = new TreeSet();</span>
<span class="nc bnc" id="L56" title="All 4 branches missed.">		if (activityMap != null &amp;&amp; !activityMap.isEmpty()) {</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">			for (Iterator iterator = activityMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L58">				Activity activity = (Activity) iterator.next();</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">				if (activity != null &amp;&amp; activity.getActivityCategoryId().equals(actCatID)) {</span>
<span class="nc" id="L60">					activityIDSet.add(activity.getID());</span>
				}
<span class="nc" id="L62">			}</span>
		}
<span class="nc" id="L64">		return activityIDSet;</span>
	}

	private static TOAccrual validateAndInitData(Jdmo dmo, ID empID, ID activityID, ID actCatID, Date startDate, Date endDate, EmployeeTimeOffAccrued accruedTO, HashMap empData) throws Exception {

<span class="nc" id="L69">		TOAccrual toAccrual = null;</span>
<span class="nc bnc" id="L70" title="All 8 branches missed.">		if (empID == null || (activityID == null &amp;&amp; actCatID == null) || endDate == null) {</span>
<span class="nc" id="L71">			m_cat.info(&quot;TimeOff Accrual Calc invalid data received empID=&quot; + empID + &quot; , activityID=&quot; + activityID + &quot;;actCatID=&quot; + actCatID + &quot; ;Date=&quot; + endDate);</span>
			//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_INVALID_DATA, m_cat);
<span class="nc" id="L73">			toAccrual = new TOAccrual();</span>
<span class="nc" id="L74">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_INVALID_DATA, null, m_className);</span>
<span class="nc" id="L75">			return toAccrual;</span>
		}
<span class="nc" id="L77">		Organization org = null;</span>
<span class="nc" id="L78">		ActivityTimeOffBalance actTOBal = null;</span>
<span class="nc" id="L79">		Activity activity = null;</span>
<span class="nc" id="L80">		ActivityCategory cat = null;</span>
<span class="nc" id="L81">		int[] empTOYrStArr = null;</span>
<span class="nc" id="L82">		ValidationResult result = null;</span>
<span class="nc" id="L83">		Employee emp = null;</span>
<span class="nc" id="L84">		TreeSet hrsPerDaySet = null;</span>
<span class="nc" id="L85">		HashMap yearlyAllotMapForActOrActCat = null;</span>
<span class="nc" id="L86">		Set activityIDs = new TreeSet();</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">		if (empData != null) {</span>
<span class="nc" id="L88">			emp = (Employee) empData.get(&quot;Employee&quot;);</span>
<span class="nc" id="L89">			org = (Organization) empData.get(&quot;Organization&quot;);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">			if (activityID != null) {</span>
<span class="nc" id="L91">				HashMap orgActivityMap = (HashMap) empData.get(&quot;ActivityMap&quot;);</span>
<span class="nc" id="L92">				activity = (Activity) orgActivityMap.get(activityID);</span>
<span class="nc" id="L93">				activityIDs.add(activityID);</span>
			}
<span class="nc bnc" id="L95" title="All 2 branches missed.">			if (actCatID != null) {</span>
<span class="nc" id="L96">				HashMap actCatMap = (HashMap) empData.get(&quot;ActivityCatMap&quot;);</span>
<span class="nc" id="L97">				cat = (ActivityCategory) actCatMap.get(actCatID);</span>
<span class="nc" id="L98">				activityIDs = getActivityIDsForActivityCatID((HashMap) empData.get(&quot;ActivityMap&quot;), actCatID);</span>
			}
<span class="nc" id="L100">			empTOYrStArr = (int[]) empData.get(&quot;AnniverseryMonthYear&quot;);</span>

<span class="nc" id="L102">			HashMap actTOBalMap = (HashMap) empData.get(&quot;actTOBalMap&quot;);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">			if (actTOBalMap != null) {</span>
<span class="nc" id="L104">				actTOBal = (ActivityTimeOffBalance) actTOBalMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));</span>
			}
<span class="nc bnc" id="L106" title="All 2 branches missed.">			if (actTOBal == null) {</span>
<span class="nc" id="L107">				actTOBal = ActivityTimeOffBalance.getDefault(empID, activityID, actCatID);</span>
			}
<span class="nc" id="L109">			HashMap yearlyAllotmentMap = (HashMap) empData.get(&quot;yearlyAllotmentMap&quot;);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">			if (yearlyAllotmentMap != null) {</span>
<span class="nc" id="L111">				yearlyAllotMapForActOrActCat = (HashMap) yearlyAllotmentMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">				if (yearlyAllotMapForActOrActCat == null) {</span>
<span class="nc" id="L113">					yearlyAllotMapForActOrActCat = new HashMap();</span>
				}
			}
<span class="nc" id="L116">			Collection hrsPerDayCol = (Collection) empData.get(&quot;hrsPerDayCol&quot;);</span>
			//Sameet Nov 2010; changing this implementation to stop Unnecessary Database calls when in fact no HRs Per Day exist.
			//Done for TO REPORTDUMP refactoring.
<span class="nc" id="L119">			hrsPerDaySet = new TreeSet();</span>
<span class="nc bnc" id="L120" title="All 4 branches missed.">			if (hrsPerDayCol != null &amp;&amp; !hrsPerDayCol.isEmpty()) {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">				for (Iterator iterator = hrsPerDayCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L122">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">					if (hoursPerDay != null &amp;&amp; hoursPerDay.getTOEventID() != null) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">						if (hrsPerDaySet == null) hrsPerDaySet = new TreeSet();</span>
<span class="nc" id="L125">						hrsPerDaySet.add(hoursPerDay);</span>
					}
<span class="nc" id="L127">				}</span>
			}
<span class="nc" id="L129">		} else {</span>
<span class="nc" id="L130">			ID orgID = ValidationUtil.getOrgIDForEmployeeDuringPeriod(empID, new Date(), endDate);</span>
<span class="nc" id="L131">			org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">			if(emp==null)emp = BbmManagerFactory.getWorkResourceManager().getEmployeeByID(empID, null, 0);</span>
<span class="nc" id="L133">			empTOYrStArr = RequestUtil.getEmployeeTimeOffYearStart(emp, org);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">			activity = activityID != null ? getActivity(activityID) : null;</span>
<span class="nc bnc" id="L135" title="All 4 branches missed.">			if (actCatID == null &amp;&amp; activity != null) {</span>
<span class="nc" id="L136">				actCatID = activity.getActivityCategoryId();</span>
			}
<span class="nc" id="L138">			cat = getActivityCategory(actCatID);</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">			if (cat.isTOAllotment()) {//This activity uses group accrual by activity so set activity  and activityid to null</span>
<span class="nc" id="L140">				activity = null;</span>
<span class="nc" id="L141">				activityID = null;</span>
<span class="nc" id="L142">				activityIDs.addAll(getTOActivityIDs(actCatID));</span>
			} else {
<span class="nc" id="L144">				cat = null;   //need to explicitly set ActivityCategory to null if it does not support accrual by group.</span>
<span class="nc" id="L145">				actCatID = null;</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">				if (activity.isTimeoffWithAllotment()) {</span>
					//Accrual is enabled at activity level
				} else {
					//Accrual is not enabled for this activity
<span class="nc" id="L150">					m_cat.info(&quot;Accrual is not enabled for this activity for empID=&quot; + empID + &quot; ,activityID=&quot; + activityID + &quot; ,orgID=&quot; + orgID);</span>
					//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, m_cat);
<span class="nc" id="L152">					toAccrual = new TOAccrual();</span>
<span class="nc" id="L153">					ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
<span class="nc" id="L154">					return toAccrual;</span>
				}
<span class="nc" id="L156">				activityIDs.add(activityID);</span>
			}
			//Get the EMPLOYEE TIMEOFF ACCRUED &amp; Last update Date
			//Sometimes we will pass the last accrued date &amp; balance. This is used for sending alerts
<span class="nc bnc" id="L160" title="All 2 branches missed.">			if (accruedTO == null) {</span>
<span class="nc" id="L161">				accruedTO = getLastUpdatedTOAccrued(dmo, empID, activityID, actCatID, startDate);</span>
			}
			/* not having EmployeeTimeOffAccrued is OK
			if (accruedTO == null) {
				m_cat.info(&quot;Employee TimeOff Accrued is null for empID=&quot; + empID + &quot; , activityID=&quot; + activityID);
				throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUED_NA, m_cat);
			}*/
			//get activity TO Balance
<span class="nc" id="L169">			actTOBal = getActivityTimeOffBalance(empID, activityID, actCatID);</span>
		}
<span class="nc bnc" id="L171" title="All 2 branches missed.">		if (actTOBal == null) {</span>
			//m_cat.info(&quot;Activity TimeOff Balance is null for empID=&quot; + empID + &quot; ,activityID=&quot; + activityID + &quot; ,orgID=&quot; + orgID);
			//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_ACTIVITY_TO_BAL_NA, m_cat);
<span class="nc" id="L174">			result = ValidationUtil.getValidationResult(RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.TO_ACCRUAL_ACTIVITY_TO_BAL_NA, null, m_className, true);</span>
		}
		//No Activity  Time Off Balance settings exist for this activity / act Cat. &amp; No Last updated balance available.
		//This will enforce the Max Carry Over to 0 and the Hours will be calculated from start of employee's TO Year
<span class="nc bnc" id="L178" title="All 4 branches missed.">		if (accruedTO == null &amp;&amp; actTOBal.getID() == null) {</span>
<span class="nc" id="L179">			actTOBal.setMaxCarryOver(0);</span>
		}
		/* moved inside TOAccrual
				if (startDate == null) {
					startDate = adjustStartDate(activity, actTOBal, accruedTO, org, empTOYrStArr, startDate, endDate);
				} else {*/
		//If start date is not null then the request is not for present year. it is only for past.
		//ignore the accrued balance in this case
		/* Since we always query for last updated balance less than start date this will never happen.
		if (accruedTO != null &amp;&amp; accruedTO.getAccruedAtDate().after(startDate)) {
			accruedTO = null;
		}*/
		/*
				if (accruedTO != null) {
				startDate = accruedTO.getAccruedAtDate();
			}
		}*/
		//construct the holder object that will have all TO accrual related info for this period.
<span class="nc" id="L197">		toAccrual = TOAccrual.getTOAccrualRow(emp, activity, cat, actTOBal, accruedTO, empTOYrStArr, empID, org, startDate, endDate);</span>
		/*  Moved to getTOAccruedForGivenDate()because the End Date will change
		    based on available TO Events when Accrual Calc is invoked from Employee Hours Validation rule
		    Sameet Nov 2009 QC 48578
				if (empData == null) {
					HashMap yearlyAllotmentMap = getEmployeeTimeOffYearly(dmo, toAccrual);
					if (yearlyAllotmentMap != null) {
						yearlyAllotMapForActOrActCat = (HashMap) yearlyAllotmentMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));
					}
					if (yearlyAllotMapForActOrActCat == null) {
						yearlyAllotMapForActOrActCat = new HashMap();
					}
				} */
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L211">			toAccrual.addValidationResult(result);</span>
		} else {
<span class="nc" id="L213">			toAccrual.setHrsPerDaySet(hrsPerDaySet);</span>
<span class="nc" id="L214">			toAccrual.setEmployeeTimeOffYearlyMap(yearlyAllotMapForActOrActCat);</span>
<span class="nc" id="L215">			toAccrual.setActivityIDs(activityIDs);</span>
		}
<span class="nc" id="L217">		return toAccrual;</span>
	}

	//Assumes the activity category passed in has isTOAllotment set to true
	private static Collection getTOActivityIDs(ID activityCategoryID) throws BbmEJBCreateException, RemoteException, BbmFinderException {
<span class="nc" id="L222">		ActivityFilter filter = new ActivityFilter();</span>

		//QC:137557 setting filter.setTimeoffWithAllotment(true) will filter out activities that does not have ISTIMEOFFWITHALLOTMENT set to true
		// but this is not correct since it is set at the activity category level in this specific case 

<span class="nc" id="L227">		filter.setActivityCategoryId(activityCategoryID, Filter.OP_EQUAL);</span>
<span class="nc" id="L228">		return WfmManagerFactory.getActivityManager().findActivitiesIds(filter);</span>
	}


	private static Set&lt;TOHoursPerDay&gt; getSchedOrUsedTOEvents(TOAccrual toAccrual, TOHoursPerDay hoursPerDayTOAdd,
			boolean calcTillLastAvailEvent, Date enDate) throws Exception {
		//boolean printData=toAccrual.getHrsPerDaySet() == null;
<span class="nc bnc" id="L235" title="All 2 branches missed.">		if (toAccrual.getHrsPerDaySet() != null) {</span>
<span class="nc" id="L236">			return toAccrual.getHrsPerDaySet();</span>
		}
<span class="nc" id="L238">		TreeSet schedOrUsedTOEventSet = new TreeSet();</span>
<span class="nc" id="L239">		TOHoursPerDayManager hoursPerDayManager = RmManagerFactory.getInstance(true).getTOHoursPerDayManager(null, null);</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">		Date endDate = hoursPerDayTOAdd != null || calcTillLastAvailEvent ? RequestUtil.MAX_DATE : toAccrual.endDate;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if(enDate != null){</span>
<span class="nc" id="L242">            endDate = enDate;</span>
        }
<span class="nc" id="L244">		Collection schedOrUsedTOEvents = hoursPerDayManager.getHoursPerDayForCalendar(Collections.singletonList(toAccrual.getEmployeeID()), toAccrual.startDate, endDate, toAccrual.getActivityIDs(), true);</span>
<span class="nc" id="L245">		schedOrUsedTOEventSet.addAll(schedOrUsedTOEvents);//Hrs Per Day need to be sorted by start time</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">		if (hoursPerDayTOAdd != null || calcTillLastAvailEvent) {</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">			if (schedOrUsedTOEventSet != null &amp;&amp; !schedOrUsedTOEventSet.isEmpty()) {</span>
<span class="nc" id="L248">				TOHoursPerDay hoursPerDay = (TOHoursPerDay) schedOrUsedTOEventSet.last();</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">				if (hoursPerDay.getEndTime().after(toAccrual.endDate)) {</span>
<span class="nc" id="L250">					toAccrual.endDate = new Date(hoursPerDay.getEndTime().getTime());</span>
				}
<span class="nc bnc" id="L252" title="All 2 branches missed.">                if(enDate!=null){</span>
<span class="nc" id="L253">                    toAccrual.endDate = new Date(enDate.getTime());</span>
                }
			}
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (hoursPerDayTOAdd != null) {</span>
<span class="nc" id="L257">				schedOrUsedTOEventSet.add(hoursPerDayTOAdd);</span>
			}
		}
		//if(printData)System.out.println(&quot;Returned value=&quot;+schedOrUsedTOEventSet.size() +&quot;: EMPID=&quot;+toAccrual.getEmployeeID()  );
<span class="nc" id="L261">		return schedOrUsedTOEventSet;</span>
	}

	public static TOAccrual getTOAccruedForValidation(Date stDate, TOHoursPerDay hrsPerDaytoVal, Date enDate) {
<span class="nc" id="L265">		Jdmo dmo = null;</span>
<span class="nc" id="L266">		TOAccrual toAccrual = null;</span>
		try {
<span class="nc" id="L268">			dmo = new Jdmo();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">			toAccrual = validateAndInitData(dmo, hrsPerDaytoVal.getEmployeeID(), hrsPerDaytoVal.getActivityID(), null, stDate,</span>
<span class="nc" id="L270">                    enDate!=null ?enDate:hrsPerDaytoVal.getEndTime(), null, null);</span>
<span class="nc" id="L271">			toAccrual = getTOAccruedForGivenDate(toAccrual, hrsPerDaytoVal, dmo, false, enDate);</span>
<span class="nc" id="L272">		} catch (Exception e) {</span>
<span class="nc" id="L273">			m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L274">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
		} finally {
<span class="nc bnc" id="L276" title="All 6 branches missed.">			if (dmo != null) dmo.cleanUp();</span>
		}
<span class="nc" id="L278">		return toAccrual;</span>
	}

	public static TOAccrual getTOAccruedForBalanceCheck(EmployeeTimeOffAccrued accrued, Date endDate) {
<span class="nc" id="L282">		Jdmo dmo = null;</span>
<span class="nc" id="L283">		TOAccrual toAccrual = null;</span>
		try {
<span class="nc" id="L285">			dmo = new Jdmo();</span>
<span class="nc" id="L286">			toAccrual = validateAndInitData(dmo, accrued.getEmployeeID(), accrued.getActivityID(), accrued.getActivityCategoryId(), null, endDate, accrued, null);</span>
<span class="nc" id="L287">			toAccrual = getTOAccruedForGivenDate(toAccrual, null, dmo, true, null);</span>
<span class="nc" id="L288">		} catch (Exception e) {</span>
<span class="nc" id="L289">			m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L290">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
		} finally {
<span class="nc bnc" id="L292" title="All 6 branches missed.">			if (dmo != null) dmo.cleanUp();</span>
		}
		
<span class="nc" id="L295">		return toAccrual;</span>
	}

	public static TOAccrual getTOAccruedForGivenDate(ID empID, ID activityID, ID actCatID, Date startDate, Date endDate, EmployeeTimeOffAccrued accruedTO, HashMap empDataMap) {
<span class="nc" id="L299">		Jdmo dmo = null;</span>
<span class="nc" id="L300">		TOAccrual toAccrual = null;</span>
		try {
<span class="nc" id="L302">			dmo = new Jdmo();</span>
<span class="nc" id="L303">			toAccrual = validateAndInitData(dmo, empID, activityID, actCatID, startDate, endDate, accruedTO, empDataMap);</span>
<span class="nc" id="L304">			toAccrual = getTOAccruedForGivenDate(toAccrual, null, dmo, false, null);</span>
<span class="nc" id="L305">		} catch (Exception e) {</span>
<span class="nc" id="L306">			m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L307">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
		} finally {
<span class="nc bnc" id="L309" title="All 6 branches missed.">			if (dmo != null) dmo.cleanUp();</span>
<span class="nc bnc" id="L310" title="All 12 branches missed.">			if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;TO Accr for empID=&quot; + empID + &quot; for actID=&quot; + activityID + &quot;: actCatID=&quot; + actCatID + &quot;: as Of &quot; + endDate + &quot;: accrhrs=&quot; + (toAccrual != null ? &quot;&quot; + toAccrual.getEstimatedAccrHrs() : &quot;null&quot;));</span>
		}
		
<span class="nc" id="L313">		return toAccrual;</span>
	}

    public static TOAccrual getTOAccrdForGivenDtWthOverlapTOAtStofYr(ID empID, ID activityID, ID actCatID, Date startDate, Date endDate, EmployeeTimeOffAccrued accruedTO, HashMap empDataMap) {
<span class="nc" id="L317">        Jdmo dmo = null;</span>
<span class="nc" id="L318">        TOAccrual toAccrual = null;</span>
        try {
<span class="nc" id="L320">            dmo = new Jdmo();</span>

<span class="nc" id="L322">            Date stDate = new Date(startDate.getTime());</span>
<span class="nc" id="L323">            toAccrual = validateAndInitData(dmo, empID, activityID, actCatID, startDate, endDate, accruedTO, empDataMap);</span>

<span class="nc" id="L325">            toAccrual.setStDateForStartingBalance(stDate);</span>
<span class="nc" id="L326">            toAccrual = getTOAccruedForGivenDate(toAccrual, null, dmo, false, null);</span>
<span class="nc" id="L327">        } catch (Exception e) {</span>
<span class="nc" id="L328">            m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L329">            ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
        } finally {
<span class="nc bnc" id="L331" title="All 6 branches missed.">            if (dmo != null) dmo.cleanUp();</span>
<span class="nc bnc" id="L332" title="All 12 branches missed.">            if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;getTOAccrdForGivenDtWthOverlapTOAtStofYr() method--&gt;TO Accr for empID=&quot; + empID + &quot; for actID=&quot; + activityID + &quot;: actCatID=&quot; + actCatID + &quot;: as Of &quot; + endDate + &quot;: accrhrs=&quot; + (toAccrual != null ? &quot;&quot; + toAccrual.getEstimatedAccrHrs() : &quot;null&quot;));</span>
        }
        
<span class="nc" id="L335">        return toAccrual;</span>
    }

	private static TOAccrual getTOAccruedForGivenDate(TOAccrual toAccrual, TOHoursPerDay hrsPerDaytoVal, Jdmo dmo, boolean calcTillLastAvailEvent, Date enDate) throws Exception {
<span class="nc" id="L339">		Set&lt;TOHoursPerDay&gt; schedOrUsedTOEventSet = getSchedOrUsedTOEvents(toAccrual, hrsPerDaytoVal, calcTillLastAvailEvent, enDate);</span>
		/*End Date will change based on available TO Events when Accrual Calc is invoked from Employee Hours Validation rule
		  Sameet Nov 2009 QC 48578*/
<span class="nc bnc" id="L342" title="All 2 branches missed.">		if (toAccrual.getEmployeeTimeOffYearlyMap() == null) {</span>
<span class="nc" id="L343">			toAccrual.setEmployeeTimeOffYearlyMap(getEmployeeTimeOffYearly(dmo, toAccrual));</span>
		}
<span class="nc" id="L345">		Calendar startCal = Calendar.getInstance(toAccrual.org.getTimeZone());</span>
<span class="nc" id="L346">		startCal.setTime(toAccrual.startDate);</span>
<span class="nc" id="L347">		Calendar empTOYearStartCal = RequestUtil.getEmployeeTimeOffYearStart(toAccrual.startDate, toAccrual.org, toAccrual.empTOYrStArr);</span>
		// Get the ending of the time off year (inclusive)
<span class="nc" id="L349">		Calendar empTOYearEndCal = RequestUtil.getEmployeeTimeOffYearEnd(toAccrual.startDate, toAccrual.org, toAccrual.empTOYrStArr);</span>
<span class="nc" id="L350">		Date empTOYearStartDate = empTOYearStartCal.getTime();</span>
<span class="nc" id="L351">		Date empTOYearEndDate = empTOYearEndCal.getTime();</span>
		do {
<span class="nc bnc" id="L353" title="All 2 branches missed.">			Date startPeriod = toAccrual.startDate.before(empTOYearStartDate) ? empTOYearStartDate : toAccrual.startDate;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">			Date endPeriod = toAccrual.endDate.after(empTOYearEndDate) ? empTOYearEndDate : toAccrual.endDate;</span>
<span class="nc" id="L355">			int startYear = toAccrual.getEmployeeTimeOffYear(startPeriod);</span>
<span class="nc" id="L356">			EmployeeTimeOffYearly toYearly = toAccrual.getEmployeeTimeOffYearly(startYear);</span>
<span class="nc bnc" id="L357" title="All 4 branches missed.">			if (toYearly == null || toYearly.getAccrualRateForYear() == EmployeeTimeOffYearly.ACCRUAL_RATE_NA) {</span>
				//m_cat.info(&quot;Employee TimeOff Accrual Rate for year is null for &quot; + toAccrual + &quot;, YEAR=&quot; + startYear);
				//Cannot proceed with Accrual calculation when acc
<span class="nc" id="L360">				ValidationUtil.setSoftValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, &quot;&quot; + startYear, m_className);</span>
<span class="nc" id="L361">				return toAccrual;</span>
				//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, m_cat);
			}
<span class="nc" id="L364">			int endYear = toAccrual.getEmployeeTimeOffYear(endPeriod);</span>
<span class="nc" id="L365">			toYearly = toAccrual.getEmployeeTimeOffYearly(endYear);</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">			if (toYearly == null || toYearly.getAccrualRateForYear() == EmployeeTimeOffYearly.ACCRUAL_RATE_NA) {</span>
				//m_cat.info(&quot;Employee TimeOff Accrual Rate for year is null for &quot; + toAccrual + &quot;, YEAR=&quot; + endYear);
				//Cannot proceed with Accrual calculation when acc
<span class="nc" id="L369">				ValidationUtil.setSoftValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, &quot;&quot; + endYear, m_className);</span>
<span class="nc" id="L370">				return toAccrual;</span>
				//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, m_cat);
			}

<span class="nc bnc" id="L374" title="All 6 branches missed.">			if (toAccrual.actTOBal.getMaxCarryOver() == 0 &amp;&amp; toAccrual.getAccruedTO() != null &amp;&amp; toAccrual.getAccruedTO().getAccruedAtDate().before(startPeriod)) {</span>
<span class="nc" id="L375">				toAccrual.setEstimatedAccrHrs(0);</span>
				//set the estimated hrs to 0 because no carry over is allowed from previous years
			}
<span class="nc" id="L378">			getAccruedHrsWithinYear(dmo, toAccrual, startPeriod, endPeriod, toYearly, schedOrUsedTOEventSet);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">			if (!endPeriod.equals(toAccrual.endDate)) { //Check for Max balance carry over here</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">				if (toAccrual.actTOBal != null &amp;&amp; toAccrual.getEstimatedAccrHrs() &gt; toAccrual.actTOBal.getMaxCarryOver()) {</span>
<span class="nc" id="L381">					toAccrual.setEstimatedAccrHrs(toAccrual.actTOBal.getMaxCarryOver());</span>
				}
			}
			// bump to the next year
			//Bug Fix for 40978; [10SP4_TO Accrual] TO Hour is calculated using incorrect Accrual Rate for Year
			//(using Accrual Rate of next year to calculate for current year and so on..)
			//empTOYear++;
			// compute TOYear start and end for next year.
			//empTOYearEndCal.add(Calendar.SECOND,1);
			//empTOYearStartCal = empTOYearEndCal;
			//RequestUtil.getCalendar(empTOYear, toAccrual.empTOYrStArr[0], toAccrual.empTOYrStArr[1], toAccrual.org.getTimeZone());
			//empTOYearEndCal = RequestUtil.getCalendarForwardOneYear(empTOYear, toAccrual.empTOYrStArr[0], toAccrual.empTOYrStArr[1], toAccrual.org.getTimeZone());
<span class="nc" id="L393">			empTOYearEndCal.add(Calendar.MILLISECOND, 1);</span>
<span class="nc" id="L394">			empTOYearStartDate = empTOYearEndCal.getTime();</span>
			//empTOYear = empTOYearEndCal.get(Calendar.YEAR);
			// QC 144918: Leap Day: First add the year to get the calendar back to March 1st Leap Year,
			// and then subtract the millisecond so February 29th isn't missed.
<span class="nc" id="L398">			empTOYearEndCal.add(Calendar.YEAR, 1);</span>
<span class="nc" id="L399">			empTOYearEndCal.add(Calendar.MILLISECOND, -1);</span>
<span class="nc" id="L400">			empTOYearEndDate = empTOYearEndCal.getTime();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">		} while (!toAccrual.endDate.before(empTOYearStartDate));</span>
		//} while (toAccrual.endDate.after(empTOYearStartDate));
		//Bug Fix for 44720; [10SP4_TO Accrual] Accrued hours at start date of TO Year is not correct
/*			return toAccrual;
		} catch (RmException ex) {
			throw ex;*/
<span class="nc" id="L407">		return toAccrual;</span>
	}

	public static HashMap getEmployeeTimeOffYearly(Jdmo dmo, TOAccrual toAccrual) throws Exception {
<span class="nc" id="L411">		HashMap yearlyAllotMapForActOrActCat = null;</span>
<span class="nc" id="L412">		EmployeeTimeOffYearlyDAO dao = new EmployeeTimeOffYearlyDAO(dmo);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">		ID activityID = toAccrual.getActivity() != null ? toAccrual.getActivity().getID() : null;</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">		ID actCatID = toAccrual.getActivityCategory() != null ? toAccrual.getActivityCategory().getID() : null;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">		Collection actIDs = activityID != null ? Collections.singletonList(activityID) : null;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">		Collection actCatIDs = actCatID != null ? Collections.singletonList(actCatID) : null;</span>

<span class="nc" id="L418">		Calendar cal = Calendar.getInstance(toAccrual.org.getTimeZone());</span>
<span class="nc" id="L419">		cal.setTime(toAccrual.startDate);</span>
<span class="nc" id="L420">		int stYear = cal.get(Calendar.YEAR) - 2;</span>
<span class="nc" id="L421">		cal.setTime(toAccrual.endDate);</span>
<span class="nc" id="L422">		int enYear = cal.get(Calendar.YEAR);</span>
<span class="nc" id="L423">		HashMap map = dao.getEmployeeTimeOffYearlyMap(Collections.singletonList(toAccrual.getEmployeeID()), actIDs, actCatIDs, stYear, enYear);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">		HashMap yearlyAllotmentMap = map != null ? (HashMap) map.get(toAccrual.getEmployeeID()) : null;</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">		if (yearlyAllotmentMap != null) {</span>
<span class="nc" id="L426">			yearlyAllotMapForActOrActCat = (HashMap) yearlyAllotmentMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));</span>
		}
<span class="nc bnc" id="L428" title="All 2 branches missed.">		if (yearlyAllotMapForActOrActCat == null) {</span>
<span class="nc" id="L429">			yearlyAllotMapForActOrActCat = new HashMap();</span>
		}
<span class="nc" id="L431">		return yearlyAllotMapForActOrActCat;</span>
	}

	public static EmployeeTimeOffAccrued getLastUpdatedTOAccrued(Jdmo dmo, ID empID, ID activityID, ID actCatID, Date startDate) {

<span class="nc bnc" id="L436" title="All 2 branches missed.">		String key = String.format(&quot;[%s][%s][%s][%d]&quot;, empID, activityID, actCatID, startDate == null ? 0L : startDate.getTime());</span>
<span class="nc" id="L437">		Map&lt;String, EmployeeTimeOffAccrued&gt; cache = ThreadLocalCache.getMap(&quot;TOAccrualCalculator.getLastUpdatedTOAccrued&quot;);</span>

<span class="nc bnc" id="L439" title="All 2 branches missed.">		if (cache.containsKey(key)) {</span>
<span class="nc" id="L440">			return cache.get(key);</span>
		}

<span class="nc" id="L443">		EmployeeTimeOffAccrued result = getLastUpdatedTOAccruedFromDb(dmo, empID, activityID, actCatID, startDate);</span>
<span class="nc" id="L444">		cache.put(key, result);</span>
<span class="nc" id="L445">		return result;</span>
	}

	public static EmployeeTimeOffAccrued getLastUpdatedTOAccruedFromDb(Jdmo dmo, ID empID, ID activityID, ID actCatID, Date startDate) {
<span class="nc" id="L449">		EmployeeTimeOffAccruedDAO dao = null;</span>
		try {
<span class="nc bnc" id="L451" title="All 2 branches missed.">			dao = (dmo == null) ? new EmployeeTimeOffAccruedDAO() : new EmployeeTimeOffAccruedDAO(dmo);</span>
<span class="nc" id="L452">			return dao.getLastUpdatedTOAccruedBeforeDate(empID, activityID, actCatID, startDate);</span>
<span class="nc" id="L453">		} catch (Exception e) {</span>
<span class="nc" id="L454">			throw RmRuntimeException.toRuntimeException(e);</span>
		} finally {
<span class="nc bnc" id="L456" title="All 8 branches missed.">			if (dmo == null &amp;&amp; dao != null) { //Cleanup only if the dmo was /DAO was created here</span>
<span class="nc" id="L457">				dao.cleanUp();</span>
			}
		}
	}

	public static ActivityTimeOffBalance getActivityTimeOffBalance(ID empID, ID activityID, ID actCatID) throws Exception {

<span class="nc" id="L464">		String key = String.format(&quot;[%s][%s][%s]&quot;, empID, activityID, actCatID);</span>
<span class="nc" id="L465">		Map&lt;String, ActivityTimeOffBalance&gt; cache = ThreadLocalCache.getMap(&quot;TOAccrualCalculator.getActivityTimeOffBalance&quot;);</span>

<span class="nc bnc" id="L467" title="All 2 branches missed.">		if (cache.containsKey(key)) {</span>
<span class="nc" id="L468">			return cache.get(key);</span>
		}

<span class="nc" id="L471">		ActivityTimeOffBalance result = getActivityTimeOffBalanceFromDb(empID, activityID, actCatID);</span>
<span class="nc" id="L472">		cache.put(key, result);</span>
<span class="nc" id="L473">		return result;</span>
	}

	private static ActivityTimeOffBalance getActivityTimeOffBalanceFromDb(ID empID, ID activityID, ID actCatID) throws Exception {
<span class="nc" id="L477">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">		Collection actIDs = activityID != null ? Collections.singletonList(activityID) : null;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">		Collection actCatIDs = actCatID != null ? Collections.singletonList(actCatID) : null;</span>
<span class="nc" id="L480">		Collection activityBalCol = activityMgr.getTOBalanceForActivities(Collections.singletonList(empID), actIDs, actCatIDs);</span>
<span class="nc bnc" id="L481" title="All 4 branches missed.">		return (activityBalCol != null &amp;&amp; !activityBalCol.isEmpty()</span>
<span class="nc" id="L482">		        ? (ActivityTimeOffBalance) activityBalCol.iterator().next()</span>
<span class="nc" id="L483">		        : ActivityTimeOffBalance.getDefault(empID, activityID, actCatID));</span>
	}

	public static Activity getActivity(ID activityID) throws Exception {

<span class="nc" id="L488">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L489">		return activityMgr.findActivityById(activityID);</span>
	}

	public static ActivityCategory getActivityCategory(ID activityCategoryID) throws Exception {

<span class="nc" id="L494">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L495">		return activityMgr.findActivityCategoryById(activityCategoryID);</span>
	}

	private static double getAccruedHrsWithinYear(Jdmo dmo, TOAccrual toAccrual, Date startDate, Date endDate, EmployeeTimeOffYearly toYearly, Collection schedOrUsedTOEvents) throws Exception {
<span class="nc" id="L499">		double accruedHrsForPeriod = toAccrual.getEstimatedAccrHrs();</span>
<span class="nc" id="L500">		boolean chkAccrualForEachTO = true;//toAccrual.actTOBal != null &amp;&amp; ((toAccrual.getEstimatedAccrHrs() + accrHrsForEntireRange) &gt; toAccrual.actTOBal.getMaxBalance());</span>
		/*
		if (!chkAccrualForEachTO) {     //No need to compute Accrued Hrs on each TO, just calculate for whole period.
			accruedHrsForPeriod += accrHrsForEntireRange;
		}*/
<span class="nc" id="L505">		double usedHrsForPeriod = 0;</span>

		//Handle scenario where there is no TO for the given range.
<span class="nc bnc" id="L508" title="All 4 branches missed.">		if (schedOrUsedTOEvents == null || schedOrUsedTOEvents.isEmpty()) {</span>
<span class="nc" id="L509">			double[] accrHrsForEntireRange = calcAccruedHrsForPeriod(dmo, toAccrual, startDate, endDate);</span>

<span class="nc" id="L511">			accruedHrsForPeriod += accrHrsForEntireRange[0];</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">			if (accruedHrsForPeriod &gt; toAccrual.actTOBal.getMaxBalance()) {</span>
<span class="nc" id="L513">				accruedHrsForPeriod = toAccrual.actTOBal.getMaxBalance();</span>
			}
<span class="nc" id="L515">			toAccrual.addTOAccrlDetailRow(toYearly.getCalendarYear(),</span>
<span class="nc" id="L516">			        toYearly.getAccrualRateForYear(),</span>
			        null,
			        startDate, endDate, endDate,
			        chkAccrualForEachTO,
			        0,
			        accrHrsForEntireRange[0],
			        0,
			        accruedHrsForPeriod, (int) accrHrsForEntireRange[1]);
<span class="nc" id="L524">		} else {</span>
<span class="nc" id="L525">			ArrayList removeList = new ArrayList(schedOrUsedTOEvents.size());</span>
<span class="nc" id="L526">			Date lastTODate = new Date(startDate.getTime());</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">			for (Iterator it = schedOrUsedTOEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L528">				TOHoursPerDay hrsPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">				if (   !( hrsPerDay.getStartTime().before(endDate) ) || //Ignore any event that doesn't begin before the enddate , including event starting on the enddate  </span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">						   !( hrsPerDay.getEndTime().after(startDate) ) ||  //Ignore any event that ends before the startdate ,including event ending on the startdate</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">						   !toAccrual.getActivityIDs().contains(hrsPerDay.getActivityID())) //Ignore any events that are not part of the Accrual</span>
				{
<span class="nc" id="L533">					continue;</span>
				}

<span class="nc bnc" id="L536" title="All 2 branches missed.">                if((toAccrual.getStDateForStartingBalance() != null) &amp;&amp;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                        (hrsPerDay.getStartTime().equals(toAccrual.getStDateForStartingBalance())</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                                || ( hrsPerDay.getStartTime().before(toAccrual.getStDateForStartingBalance())</span>
                                            &amp;&amp;
<span class="nc bnc" id="L540" title="All 2 branches missed.">                                     hrsPerDay.getEndTime().after(toAccrual.getStDateForStartingBalance())))){</span>
<span class="nc" id="L541">                    continue;</span>

                }
				//removeList.add(hrsPerDay);
<span class="nc" id="L545">				boolean isToEvtStartBeforeStart = hrsPerDay.getStartTime().before(startDate);</span>
<span class="nc" id="L546">				boolean isToEvtEndAfterEnd = hrsPerDay.getEndTime().after(endDate);</span>
<span class="nc" id="L547">				double usedHrsForThisTO = 0;</span>
<span class="nc" id="L548">				double accrdHrsForThisTO = 0;</span>
<span class="nc" id="L549">				int accrualCount = 0;</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">				Date adjStDate = isToEvtStartBeforeStart ? startDate : hrsPerDay.getStartTime();</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">				Date adjEnDate = isToEvtEndAfterEnd ? endDate : hrsPerDay.getEndTime();</span>

<span class="nc bnc" id="L553" title="All 4 branches missed.">				if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc" id="L554">					DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hrsPerDay, adjStDate, adjEnDate);</span>
<span class="nc" id="L555">					usedHrsForThisTO += dailyBuckets.getTotalHours();</span>
<span class="nc" id="L556">				} else {</span>
<span class="nc" id="L557">					usedHrsForThisTO += (hrsPerDay.getTotalMinutes() / 60f);</span>
				}

<span class="nc bnc" id="L560" title="All 2 branches missed.">				if (chkAccrualForEachTO) {</span>
<span class="nc" id="L561">					double[] accrdHrsForThisTORange = calcAccruedHrsForPeriod(dmo, toAccrual, lastTODate, adjStDate);         </span>
<span class="nc" id="L562">					accrdHrsForThisTO = accrdHrsForThisTORange[0];</span>
<span class="nc" id="L563">					accrualCount = (int) accrdHrsForThisTORange[1];</span>
				}
<span class="nc" id="L565">				accruedHrsForPeriod += accrdHrsForThisTO;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">				if (accruedHrsForPeriod &gt; toAccrual.actTOBal.getMaxBalance()) {</span>
<span class="nc" id="L567">					accruedHrsForPeriod = toAccrual.actTOBal.getMaxBalance();</span>
				}
<span class="nc" id="L569">				usedHrsForPeriod += usedHrsForThisTO;</span>
<span class="nc" id="L570">				accruedHrsForPeriod -= usedHrsForThisTO;</span>
<span class="nc" id="L571">				toAccrual.addTOAccrlDetailRow(toYearly.getCalendarYear(),</span>
<span class="nc" id="L572">				        toYearly.getAccrualRateForYear(),</span>
				        hrsPerDay,
				        lastTODate, adjStDate, adjEnDate,
				        chkAccrualForEachTO,
				        usedHrsForThisTO,
				        accrdHrsForThisTO,
				        usedHrsForPeriod,
				        accruedHrsForPeriod, accrualCount);

<span class="nc" id="L581">				lastTODate = new Date(adjStDate.getTime());</span>
<span class="nc" id="L582">			}</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">			if (chkAccrualForEachTO) {</span>
<span class="nc" id="L584">				double[] accrdHrsForThisTORange = calcAccruedHrsForPeriod(dmo, toAccrual, lastTODate, endDate);</span>
<span class="nc" id="L585">				double accrdHrsForThisTO = accrdHrsForThisTORange[0];</span>
<span class="nc" id="L586">				int accrualCount = (int) accrdHrsForThisTORange[1];</span>
<span class="nc" id="L587">				accruedHrsForPeriod += accrdHrsForThisTO;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">				if (accruedHrsForPeriod &gt; toAccrual.actTOBal.getMaxBalance()) {</span>
<span class="nc" id="L589">					accruedHrsForPeriod = toAccrual.actTOBal.getMaxBalance();</span>
				}
<span class="nc" id="L591">				toAccrual.addTOAccrlDetailRow(toYearly.getCalendarYear(),</span>
<span class="nc" id="L592">				        toYearly.getAccrualRateForYear(),</span>
				        null,
				        lastTODate, endDate, endDate,
				        chkAccrualForEachTO,
				        0,
				        accrdHrsForThisTO,
				        0,
				        accruedHrsForPeriod, accrualCount);
			}
<span class="nc" id="L601">			schedOrUsedTOEvents.removeAll(removeList);</span>
		}
		//if (RequestUtil.isRMDebugEnabled()m_cat.info(&quot;getAccruedHrsWithinYear start=&quot; + startDate + &quot;; end=&quot; + endDate + &quot;; usedHrsForPeriod=&quot; + usedHrsForPeriod + &quot; ; accruedHrsForPeriod=&quot; + accruedHrsForPeriod);

<span class="nc" id="L605">		toAccrual.setEstimatedAccrHrs(accruedHrsForPeriod);</span>
<span class="nc" id="L606">		return accruedHrsForPeriod;</span>
	}

	private static double[] calcAccruedHrsForPeriod(Jdmo dmo, TOAccrual toAccrual, Date start, Date end) throws Exception {
<span class="nc" id="L610">		EmployeeTimeOffYearly toYearlyStart = toAccrual.getEmployeeTimeOffYearly(toAccrual.getEmployeeTimeOffYear(start));</span>
<span class="nc" id="L611">		EmployeeTimeOffYearly toYearlyPrevAccrPeriod = null;</span>
<span class="nc" id="L612">		Date adjEnd = null;</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">		if (toAccrual.getToAccrualPolicy() == Activity.ACCRUAL_POLICY_PRORATED_ON_NEXT</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">		        || toAccrual.getToAccrualPolicy() == Activity.ACCRUAL_POLICY_ALL_HOURS_ON_NEXT) {</span>
<span class="nc" id="L615">			Calendar cal = Calendar.getInstance(toAccrual.org.getTimeZone());</span>
<span class="nc" id="L616">			cal.setTime(start);</span>
<span class="nc" id="L617">			toAccrual.decrementPeriod(cal);</span>
<span class="nc" id="L618">			toYearlyPrevAccrPeriod = toAccrual.getEmployeeTimeOffYearly(toAccrual.getEmployeeTimeOffYear(cal.getTime()));</span>

<span class="nc" id="L620">			toAccrual.incrementPeriod(cal);</span>
<span class="nc" id="L621">			adjEnd = cal.getTime();</span>
		}
		//Decide whether we want to calculate accrual for two different accrual rates or only one.
		//if adjEnd.after(end) then no need to calculate accrual in two parts since the next accrual is after the end date.
		//we might as well calculate with  one call, since we do not even want to calculate accrual for next accrual schedule.
		//QC 49312 ; Sameet Nov 2009
<span class="nc bnc" id="L627" title="All 8 branches missed.">		if (toYearlyPrevAccrPeriod == null || toYearlyStart.equals(toYearlyPrevAccrPeriod) || (adjEnd!=null &amp;&amp; adjEnd.after(end))) {</span>
<span class="nc" id="L628">			return calcAccruedHrsForPeriod(dmo, toAccrual, start, end, toYearlyStart);</span>
		} else {
<span class="nc" id="L630">			double[] accrdHrsForStart = calcAccruedHrsForPeriod(dmo, toAccrual, start, adjEnd, toYearlyPrevAccrPeriod);</span>
<span class="nc" id="L631">			toAccrual.addTOAccrlDetailRow(toYearlyPrevAccrPeriod.getCalendarYear(),</span>
<span class="nc" id="L632">			        toYearlyPrevAccrPeriod.getAccrualRateForYear(),</span>
			        null,
			        start, adjEnd, adjEnd,
			        true,
			        0,
			        accrdHrsForStart[0],
			        0,
			        TOAccrual.NUMBER_NA, (int) accrdHrsForStart[1]);
<span class="nc" id="L640">			double[] accrdHrsForEnd = calcAccruedHrsForPeriod(dmo, toAccrual, adjEnd, end, toYearlyStart);</span>
			//Date endAdjusted is hack for debugging purposes only so that toAccrual.toHtml() displays all the info correctly
			//should not have any effect on business logic.
			//TODO: to find a better  way to do this
<span class="nc" id="L644">			Date endAdjusted = new Date(end.getTime() - 1);</span>
<span class="nc" id="L645">			toAccrual.addTOAccrlDetailRow(toYearlyStart.getCalendarYear(),</span>
<span class="nc" id="L646">			        toYearlyStart.getAccrualRateForYear(),</span>
			        null,
			        adjEnd, endAdjusted, end,
			        true,
			        0,
			        accrdHrsForEnd[0],
			        0,
			        TOAccrual.NUMBER_NA, (int) accrdHrsForEnd[1]);
<span class="nc" id="L654">			return new double[]{accrdHrsForStart[0] + accrdHrsForEnd[0], accrdHrsForStart[1] + accrdHrsForEnd[1]};</span>
		}
	}

	private static double[] calcAccruedHrsForPeriod(Jdmo dmo, TOAccrual toAccrual, Date start, Date end, EmployeeTimeOffYearly toYearly) throws Exception {

<span class="nc" id="L660">		int countBetnPeriod = toAccrual.getCountInBetween(start, end);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">		double accrRate = toYearly.getAccrualRateForYear() != EmployeeTimeOffYearly.ACCRUAL_RATE_NA ? toYearly.getAccrualRateForYear() : 0;</span>
<span class="nc" id="L662">		double accruedHrs = 0;</span>
<span class="nc bnc" id="L663" title="All 4 branches missed.">		if (toAccrual.isAccrualPolicyAdjustmentReqd(start, end) &amp;&amp; !toAccrual.isAccrualPolicyAdjusted()) {</span>
<span class="nc" id="L664">			EmployeeTimeOffAccrued accrued = toAccrual.adjustAccruedTOByAccrualPolicy(start, end);</span>
<span class="nc bnc" id="L665" title="All 6 branches missed.">			if (accrued != null &amp;&amp; (toAccrual.getToAccrualPolicy() == Activity.ACCRUAL_POLICY_PRORATED_ON_NEXT) &amp;&amp; countBetnPeriod &gt; 0) {</span>
<span class="nc" id="L666">				countBetnPeriod--;  //Since its already counted when adjusting the accrual policy</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;calcAccruedHrsForPeriod setting countBetnPeriod by -1 = &quot; + countBetnPeriod);</span>
			}
<span class="nc bnc" id="L669" title="All 2 branches missed.">			accruedHrs += (accrued != null ? accrued.getAccruedHours() : 0);</span>
<span class="nc bnc" id="L670" title="All 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;calcAccruedHrsForPeriod ACCRD HRS BY POLICY= &quot; + (accrued != null ? &quot;&quot; + accrued.getAccruedHours() : &quot;NULL&quot;));</span>
		}
<span class="nc" id="L672">		accruedHrs += (accrRate * countBetnPeriod);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;calcAccruedHrsForPeriodXXX start=&quot; + start + &quot;; end=&quot; + end + &quot;; count=&quot; + countBetnPeriod + &quot; ; Accrual Rate=&quot; + toYearly.getAccrualRateForYear() + &quot; ; Accrued hours=&quot; + accruedHrs);</span>
<span class="nc" id="L674">		return new double[]{accruedHrs, countBetnPeriod};</span>
	}
	/*
		public static int getCountBetweenPeriod(TOAccrual toAccrual, Date start, Date end) {
			int count = 0;
			Calendar calStart = Calendar.getInstance(toAccrual.org.getTimeZone());
			calStart.setTime(start);
			Calendar calEnd = Calendar.getInstance(toAccrual.org.getTimeZone());
			calEnd.setTime(end);
			switch (toAccrual.toAccrualSchedule) {
				case TO_ACCRUAL_SCHEDULE_DAILY:
					count = DateUtil.getDayCountInBetween(calStart, calEnd);
					break;
				case TO_ACCRUAL_SCHEDULE_SEMI_MONTHLY:
					count = DateUtil.getSemiMonthCountInBetween(calStart, calEnd);
					break;
				case TO_ACCRUAL_SCHEDULE_MONTHLY:
					count = DateUtil.getMonthCountInBetween(calStart, calEnd);
					break;
				case TO_ACCRUAL_SCHEDULE_YEARLY:
					count = DateUtil.getYearsCountInBetween(calStart, calEnd, toAccrual.empTOYrStArr[0], toAccrual.empTOYrStArr[1]);
					break;
			}
			return count;
		}        */
}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>