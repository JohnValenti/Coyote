<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SPQueueTreeNodeHelper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.bbm.workload.queue.selection</a> &gt; <span class="el_source">SPQueueTreeNodeHelper.java</span></div><h1>SPQueueTreeNodeHelper.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.bbm.workload.queue.selection;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javax.swing.tree.DefaultMutableTreeNode;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.web.bbm.campaign.MediaUtil;
import com.witness.web.uif.pagecomponent.BaseNodeData;
import com.witness.web.uif.pagecomponent.DefaultMultiColumnNodeData;
import com.witness.web.uif.pagecomponent.DefaultNodeData;
import com.witness.web.uif.pagecomponent.selection.SelectablePC;
import com.witness.web.uif.pagecomponent.tree.util.TreeNodeHelper;
import com.witness.web.uif.system.RequestContext;
import com.witness.web.uif.util.SortUtil;

public class SPQueueTreeNodeHelper implements TreeNodeHelper {
	private static final String NODE_DISPLAY = &quot;NODE_DISPLAY&quot;;
	
<span class="fc" id="L29">	private boolean m_isEmptyRoot = false;</span>
<span class="fc" id="L30">	private boolean m_isForSingleCol = true;</span>
<span class="fc" id="L31">	private boolean m_isComplexIDs = false;</span>
<span class="fc" id="L32">	private boolean m_isNodeDisplayEnabled = false;</span>
<span class="fc" id="L33">	private int m_combQueueCount = 0;</span>

<span class="fc" id="L35">	private Map m_nodeMap = Collections.emptyMap();</span>
<span class="fc" id="L36">	private Map m_parentMap = new HashMap(10);</span>
<span class="fc" id="L37">	private Map&lt;ID, Media&gt; m_mediaMap = Collections.emptyMap();</span>
<span class="fc" id="L38">	private Collection m_dataList = Collections.emptyList();</span>
<span class="fc" id="L39">	private Collection&lt;ID&gt; m_rootLinkQueues = Collections.emptyList();</span>

<span class="fc" id="L41">	private ID m_campaignID = null;</span>
	private DefaultMutableTreeNode m_rootNode;
	private RequestContext m_context;
	private Localizer m_localizer;
	private final ISPQueueSelectionStrategy m_selectionStrategy;
	private final SchedulingPeriod m_sp;

	private ID m_queueAttributeFilterID;
	private Map&lt;ID, ID&gt; m_queueMediaMap;
	/**
	 * Constructor
	 */
	public SPQueueTreeNodeHelper(RequestContext context, Collection nodeList, Map&lt;ID, Media&gt; mediaMap, 
			ID campaignID, SchedulingPeriod sp, Localizer localizer,
			boolean isNodeDisplayEnabled, boolean isForSingleCol, 
			boolean isComplexID,
			ISPQueueSelectionStrategy selectionStrategy, 
			Collection&lt;ID&gt; rootLinkQueues, 
			ID queueAttributeFilterID, 
<span class="fc" id="L60">			Map&lt;ID, ID&gt; queueMediaMap) {</span>
<span class="fc" id="L61">		m_dataList = nodeList;</span>
<span class="fc" id="L62">		m_mediaMap = mediaMap;</span>
<span class="fc" id="L63">		m_campaignID = campaignID;</span>
<span class="fc" id="L64">		m_localizer = localizer;</span>
<span class="fc" id="L65">		m_isNodeDisplayEnabled = isNodeDisplayEnabled;</span>
<span class="fc" id="L66">		m_isForSingleCol = isForSingleCol;</span>
<span class="fc" id="L67">		m_isComplexIDs = isComplexID;</span>
<span class="fc" id="L68">		m_context = context;</span>
<span class="fc" id="L69">		m_rootLinkQueues = rootLinkQueues;</span>
<span class="fc" id="L70">		m_sp = sp;</span>
<span class="fc" id="L71">		m_selectionStrategy = selectionStrategy;</span>
		
<span class="fc" id="L73">		m_queueAttributeFilterID = queueAttributeFilterID;</span>
<span class="fc" id="L74">		m_queueMediaMap = queueMediaMap;</span>
<span class="fc" id="L75">		buildTreeNodeMap();</span>
		
		/*
		Need to accomodate these scenarios while building the tree nodes.  
		-	Skill Based multi-queue (show combined + queue nodes in service goals, forecast and fte requirements navigation tree)
		-	Skill Based single queue (not sure but if QA files, it is a unrealistic practical scenario)
		-	Non-Skilled multi-queue (show combined + queue nodes in forecasting navigation tree but Service goals and fte requirements just shows combined nodes only)
		-	Non-Skilled with 1 queue (show queue name in both service goals and forecasting, however, in service goals and fte requirements the queue name is superficial for display, the node represents the combined node and id)
		*/
<span class="fc" id="L84">	}</span>

	/**
	 * Return true if Root is empty
	 */
	public boolean isEmptyRoot() {
<span class="nc bnc" id="L90" title="All 2 branches missed.">		if (m_rootNode == null) initRootNode();</span>
<span class="nc" id="L91">		return m_isEmptyRoot;</span>
	}

	private BaseNodeData createNodeData(String nodeID, String name, String desc, 
			boolean isSelectable, boolean isSingleSelect) {
		BaseNodeData nodeData;
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">		if (m_isForSingleCol) {</span>
<span class="nc" id="L98">			nodeData = new DefaultNodeData(nodeID, name, desc);</span>
		} else {
<span class="fc" id="L100">			DefaultMultiColumnNodeData mNodeData = new DefaultMultiColumnNodeData(nodeID);</span>
<span class="fc" id="L101">			mNodeData.add(name);</span>
<span class="fc" id="L102">			nodeData = mNodeData;</span>
		}

<span class="pc bpc" id="L105" title="1 of 2 branches missed.">		if (m_isNodeDisplayEnabled) {</span>
<span class="fc" id="L106">			nodeData.getNodeAttributes().put(NODE_DISPLAY, name);</span>
		}

<span class="fc" id="L109">		nodeData.setSelectable(isSelectable);</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">		nodeData.getNodeAttributes().put(SelectablePC.IS_SINGLE_SELECT, isSingleSelect ? &quot;true&quot; : &quot;false&quot;);</span>

<span class="fc" id="L112">		return nodeData;</span>
	}

	/**
	 * Return the number of Combined Queues found
	 */
	public int getCombinedQueueCount() {
<span class="nc" id="L119">		return m_combQueueCount;</span>
	}

	/**
	 * Initialize Root Node
	 */
	private void initRootNode() {
<span class="fc" id="L126">		m_rootNode = (DefaultMutableTreeNode) m_parentMap.get(null);</span>
<span class="fc" id="L127">		int mediaCount = 0;</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">		if (m_rootNode == null) {</span>
			
			// create Media ID Set for Parent Nodes
<span class="fc" id="L131">			Map&lt;ID,Integer&gt; mediaInfo = getMediaInformation(m_dataList);</span>
<span class="fc" id="L132">			Set keySet = m_mediaMap.keySet();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">			for (Iterator keys = keySet.iterator(); keys.hasNext();) {</span>
<span class="fc" id="L134">				Media media = (Media) m_mediaMap.get(keys.next());</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">				if (mediaInfo.containsKey(media.getId())) {</span>
<span class="fc" id="L136">					mediaCount++;</span>
				}
<span class="fc" id="L138">			}</span>

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">			if(m_sp == null) return;</span>
			
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">			String nodeID = m_isComplexIDs ? createComplexID(m_context, m_campaignID, m_sp.getID(), null, null, m_sp.getSkillBased(), -1, m_queueAttributeFilterID, m_queueMediaMap) : &quot;&quot;;</span>
<span class="fc" id="L143">			BaseNodeData nodeData = null;</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">			if (mediaCount &gt; 1) {</span>
<span class="nc" id="L145">				String name = MediaUtil.getMediaNodeName(null, m_localizer);</span>
<span class="nc" id="L146">				nodeData = createNodeData(nodeID, name, &quot;&quot;, m_selectionStrategy.areCombinedQueuesSelectable(m_sp), true);</span>
<span class="nc" id="L147">				nodeData.getNodeAttributes().put(&quot;MEDIA_NAME&quot;, name);</span>
<span class="nc" id="L148">				m_isEmptyRoot = false;</span>
<span class="nc" id="L149">			} else {</span>
<span class="fc" id="L150">				nodeData = createNodeData(nodeID, &quot;&quot;, &quot;&quot;, m_selectionStrategy.areCombinedQueuesSelectable(m_sp), true);</span>
<span class="fc" id="L151">				m_isEmptyRoot = true;</span>
			}

<span class="fc" id="L154">			m_rootNode = new DefaultMutableTreeNode(nodeData);</span>
<span class="fc" id="L155">			m_parentMap.put(null, m_rootNode);</span>
		}
<span class="fc" id="L157">	}</span>

	/**
	 * Return Root Node of the Tree
	 */
	public DefaultMutableTreeNode getRootNode() {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">		if (m_rootNode == null) initRootNode();</span>
<span class="fc" id="L164">		return m_rootNode;</span>
	}

	/**
	 * Return Parent Tree Node for the given Data
	 */
	public DefaultMutableTreeNode getParentNode(Object data) {
<span class="fc" id="L171">		Object node=null;</span>

<span class="fc" id="L173">		Queue queue = (Queue) data;</span>
<span class="fc" id="L174">		ID parentID = queue.getParentID();  // This is the PARENTQUEUEID from the db.</span>
		
		// If the node has a parent queue (virtual or distributed) then associate this node
		// to that one.
<span class="pc bpc" id="L178" title="3 of 4 branches missed.">		if (parentID!=null &amp;&amp; !parentID.equals(queue.getID())) {</span>
<span class="nc" id="L179">			node = m_nodeMap.get(parentID);</span>
		}
		
		// Try to use Media as Parent, but only if there are &gt; 1 queues total to be shown
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		if (node==null) </span>
		{
<span class="fc" id="L185">			Map&lt;ID,Integer&gt; mediaInfo = getMediaInformation(m_dataList);</span>
<span class="fc" id="L186">			Object parentKey = queue.getMediaID();</span>
			
<span class="fc" id="L188">			int mediaQueueCount = 0;</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">			if(mediaInfo.containsKey(parentKey)) mediaQueueCount = mediaInfo.get(parentKey); </span>
			
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">			if(mediaQueueCount &gt; 1)</span>
			{
<span class="nc" id="L193">				node = m_parentMap.get(parentKey);</span>
	
				// Create Parent Media Node Node on the fly
<span class="nc bnc" id="L196" title="All 4 branches missed.">				if (node == null &amp;&amp; parentKey != null) </span>
				{
<span class="nc" id="L198">					Media media = (Media) m_mediaMap.get(parentKey);</span>
<span class="nc" id="L199">					node = toTreeNode(media, mediaQueueCount);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">	                if (node != null)</span>
	                {
<span class="nc" id="L202">						m_parentMap.put(parentKey, node);</span>
<span class="nc" id="L203">						getRootNode().add((DefaultMutableTreeNode) node);</span>
	                }
				}
			}
		}

		// Finally just use root node as parent
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">		if (node == null) node = getRootNode();</span>
<span class="fc" id="L211">		return (DefaultMutableTreeNode) node;</span>
	}

	/**
	 * Return Tree Node for the given Data
	 */
	public DefaultMutableTreeNode getNode(Object data) {
<span class="fc" id="L218">		Queue queue = (Queue) data;</span>
<span class="fc" id="L219">		return (DefaultMutableTreeNode) m_nodeMap.get(queue.getID());</span>
	}

	/**
	 * Build Map of Organization Tree Nodes
	 */
	private void buildTreeNodeMap() {
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">		if (m_dataList.isEmpty()) return;</span>

		// create Media ID Set for Parent Nodes, this contains the media types of the queues
		// and the number of queues found for each of those media types within the list.
<span class="fc" id="L230">		Map&lt;ID,Integer&gt; mediaInfo = getMediaInformation(m_dataList);</span>

<span class="fc" id="L232">		initRootNode();</span>

		//put all media IDs into the parent map, but only if there are &gt;1 total queues to be shown.
<span class="fc" id="L235">		Collection medias = SortUtil.sortBasicVO(m_mediaMap.values(), m_localizer);</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">		for (Iterator it = medias.iterator(); it.hasNext(); ) </span>
		{
<span class="fc" id="L238">			Media media = (Media)it.next();</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">			if (mediaInfo.containsKey(media.getId())) </span>
			{
<span class="fc" id="L241">				m_combQueueCount++;</span>
				
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">				if(mediaInfo.get(media.getId()) &gt; 1)</span>
				{
<span class="nc" id="L245">					Object node = toTreeNode(media, mediaInfo.get(media.getId()));</span>
<span class="nc" id="L246">					m_parentMap.put(media.getId(), node);</span>
<span class="nc" id="L247">					getRootNode().add((DefaultMutableTreeNode) node);				</span>
				}
				// When there is only 1 child queue and service goals, the queue won't be displayed
				// and the combined node should take the name of the queue for display only,
				// saves are still to the combined.
				/*else if(mediaInfo.get(media.getId()) == 1 &amp;&amp; isServiceGoalsCombinedType() &amp;&amp; !m_isSkillBasedSp) {
					Queue childQueue = getFirstQueueByMediaID(media.getId());
					Object node = toTreeNode(media, childQueue.getName(), 1);
					m_parentMap.put(media.getId(), node);
					getRootNode().add((DefaultMutableTreeNode) node);				
				}*/
			}
<span class="fc" id="L259">		}</span>
		
		// Build Tree
<span class="fc" id="L262">		m_nodeMap = new HashMap(m_dataList.size());</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">		for (Iterator it = m_dataList.iterator(); it.hasNext();) {</span>
<span class="fc" id="L264">			Queue queue = (Queue) it.next();</span>

<span class="fc" id="L266">			int schedulingPeriodQueueCount = mediaInfo.get(queue.getMediaID());</span>
			
			// Use selection strategy to determine if constituent queues are visible
<span class="pc bpc" id="L269" title="1 of 4 branches missed.">			if(!m_selectionStrategy.areConstituentQueuesVisible(m_sp) &amp;&amp; m_parentMap.containsKey(queue.getMediaID())) </span>
<span class="nc" id="L270">				continue;</span>
			
			// Update Node Map
<span class="fc" id="L273">			DefaultMutableTreeNode node = toTreeNode(queue, schedulingPeriodQueueCount);</span>
<span class="fc" id="L274">			m_nodeMap.put(queue.getID(), node);</span>
<span class="fc" id="L275">		}</span>
<span class="fc" id="L276">	}</span>

	private Map&lt;ID,Integer&gt; getMediaInformation(Collection&lt;Queue&gt; queues) {
<span class="fc" id="L279">		Map&lt;ID,Integer&gt; results = new HashMap&lt;ID, Integer&gt;();</span>
		
<span class="fc bfc" id="L281" title="All 2 branches covered.">		for (Iterator&lt;Queue&gt; it = queues.iterator(); it.hasNext();) {</span>
<span class="fc" id="L282">			Queue queue = it.next();</span>
<span class="fc" id="L283">			Integer mediaQueueCount = 1;</span>
			
<span class="fc" id="L285">			ID mediaID = queue.getMediaID();</span>
<span class="pc bpc" id="L286" title="2 of 4 branches missed.">			if (mediaID != null &amp;&amp; !results.containsKey(mediaID)) </span>
			{
<span class="fc" id="L288">				results.put(mediaID, mediaQueueCount);</span>
			} else { // the media type is already present.
<span class="nc" id="L290">				mediaQueueCount = results.get(mediaID);</span>
<span class="nc" id="L291">				mediaQueueCount++;</span>
<span class="nc" id="L292">				results.put(mediaID, mediaQueueCount);</span>
			}
<span class="fc" id="L294">		}</span>
		
<span class="fc" id="L296">		return results;</span>
	}

	/**
	 * Returns a formatted id containing several metadata elements.
	 */
	private static String createComplexID(RequestContext context, ID campaignID, 
			ID schedulingPeriodID, ID mediaID, ID queueID, boolean isSkilledSchedulingPeriod,
			int schedulingPeriodQueueCount, ID queueAttribFilterID, Map&lt;ID, ID&gt; queueMediaMap) {
<span class="fc" id="L305">		SPQueueSelection selection = new SPQueueSelection(campaignID, </span>
				schedulingPeriodID, mediaID, queueID, isSkilledSchedulingPeriod, schedulingPeriodQueueCount, queueAttribFilterID, queueMediaMap);
<span class="fc" id="L307">		return selection.toIDString();</span>
	}

	/**
	 * Convert Queue Object to MutableTreeNode
	 */
	private DefaultMutableTreeNode toTreeNode(Queue queue, int schedulingPeriodQueueCount) {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">		if (queue == null) return null;</span>

		// Generate Node ID
<span class="fc" id="L317">		ID qID = queue.getID();</span>
<span class="fc" id="L318">		String nodeID = null;</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">		if (m_isComplexIDs) {</span>
<span class="fc" id="L320">			nodeID = createComplexID(m_context, m_campaignID, m_sp.getID(), queue.getMediaID(), qID, m_sp.getSkillBased(), schedulingPeriodQueueCount, m_queueAttributeFilterID, m_queueMediaMap);</span>
		} else {
<span class="nc bnc" id="L322" title="All 2 branches missed.">			nodeID = (qID != null) ? qID.toString() : &quot;&quot;;</span>
		}

		// Generate Name
<span class="fc" id="L326">		String name = queue.getName();</span>

		// Make sure parent queues do support multi-select
<span class="fc" id="L329">        boolean isSingleSelect = false;</span>
        
<span class="fc" id="L331">		BaseNodeData nodeData = createNodeData(nodeID, name, queue.getDescription(), true, isSingleSelect);</span>
<span class="fc" id="L332">		nodeData.getNodeAttributes().put(&quot;MEDIA_ID&quot;, queue.getMediaID().toString());</span>
<span class="fc" id="L333">		nodeData.getNodeAttributes().put(SelectablePC.MULTISELECT_GROUP, queue.getMediaID().toString());</span>
		
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">		if(nodeData instanceof DefaultMultiColumnNodeData) {</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">			if(m_rootLinkQueues.contains(queue.getID())) {</span>
<span class="nc" id="L337">				((DefaultMultiColumnNodeData)nodeData).setIcon(&quot;/bbm/images/icons/icon_link.gif&quot;);</span>
			}
		}
<span class="fc" id="L340">		return new DefaultMutableTreeNode(nodeData);</span>
	}

	/**
	 * Convert Media Object to MutableTreeNode
	 */
	private DefaultMutableTreeNode toTreeNode(Media media, int queueCount) {
<span class="nc" id="L347">		return toTreeNode(media, null, queueCount);</span>
	}
	
	/**
	 * Convert Media Object to MutableTreeNode
	 */
	private DefaultMutableTreeNode toTreeNode(Media media, String displayName, int schedulingPeriodQueueCount) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">		if (media == null) return null;</span>

		// Generate Node ID
<span class="nc" id="L357">		String nodeID = null;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (m_isComplexIDs) {</span>
			// Set the value of this node to an array of the child queue IDs.
<span class="nc" id="L360">			nodeID = createComplexID(m_context, m_campaignID, m_sp.getID(), media.getId(), </span>
<span class="nc" id="L361">					null, m_sp.getSkillBased(), schedulingPeriodQueueCount, m_queueAttributeFilterID, m_queueMediaMap);</span>
		} else {
<span class="nc" id="L363">			nodeID = media.getID().toString();</span>
		}

<span class="nc bnc" id="L366" title="All 2 branches missed.">		String name = (displayName == null ? MediaUtil.getMediaNodeName(media.getName(), m_localizer) : displayName);</span>
<span class="nc" id="L367">		BaseNodeData nodeData = createNodeData(nodeID, name, media.getDescription(), </span>
<span class="nc" id="L368">				m_selectionStrategy.areCombinedQueuesSelectable(m_sp), true);</span>
<span class="nc" id="L369">		nodeData.getNodeAttributes().put(&quot;MEDIA_NAME&quot;, name);</span>
<span class="nc" id="L370">		nodeData.getNodeAttributes().put(SelectablePC.MULTISELECT_GROUP, media.getID().toString());</span>
<span class="nc" id="L371">		nodeData.setSelectable(m_selectionStrategy.areCombinedQueuesSelectable(m_sp));</span>

<span class="nc" id="L373">		return new DefaultMutableTreeNode(nodeData);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>