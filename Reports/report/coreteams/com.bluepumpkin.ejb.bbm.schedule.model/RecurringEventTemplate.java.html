<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RecurringEventTemplate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.model</a> &gt; <span class="el_source">RecurringEventTemplate.java</span></div><h1>RecurringEventTemplate.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.model;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Value object class that adds to the Calendar Event Template to
 *               furthur describe Recurring Events that may not be floating.
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import com.bluepumpkin.common.datatypes.ID;

<span class="nc" id="L21">public class RecurringEventTemplate extends RecurringEventTemplateBase {</span>
	/**
	 * This is an enumeration that describes the type of recurrence for the
	 * event
	 */
	public static final short RECURRENCE_TYPE_WEEKLY = 0;

	/**
	 * Returns the type of the calendar event template object. This could be one
	 * of the int values defined as constants above: simple, floating or
	 * recurring or recurring floating
	 */
	public short getTemplateType() {
<span class="nc" id="L34">		return CalendarEventTemplate.EVENT_TEMPLATE_RECURRING;</span>
	}

	/**
	 * Sets the type of the calendar event object instances of which this
	 * template will create. See the com.bluepumpkin.ejb.bbm.activity.Event
	 * class for possible values. Possible values are:
	 * Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT or
	 * Event.EVENT_TYPE_TIME_OFF_EVENT to create recurring time off events or
	 * Event.EVENT_TYPE_UNAVAILABILITY_EVENT to create recurring
	 * unavailabilities
	 */
	public void setEventType(int eventType) {
<span class="nc" id="L47">		getAggregatedTemplate().setEventType(eventType);</span>
<span class="nc" id="L48">	}</span>

	/**
	 * Returns the earliest time during the day, in minutes, for which this
	 * recurring event can begin. The offset is in the timezone of the recurring
	 * event template.
	 */
	public int getDayStartOffset() {
<span class="nc" id="L56">		return getFieldValueInt(RecurringEventTemplateFields.DAYSTARTOFFSET);</span>
	}

	/**
	 * Sets the time during the day, in minutes, at which this recurring event
	 * can begin. The offset is in the timezone of the recurring event template.
	 * For example, to have a recurring event that starts at 9AM PDT, you would
	 * set the day start offset to 9 * 60 = 540 minutes
	 */
	public void setDayStartOffset(int mins) {
<span class="nc" id="L66">		setFieldValue(RecurringEventTemplateFields.DAYSTARTOFFSET, mins);</span>
<span class="nc" id="L67">	}</span>

	/**
	 * Returns the number of minutes the event instances from this template will
	 * count towards various rules, such as vacation allocation, min/max hours,
	 * etc. This property will only have an effect on recurring time off events.
	 */
	public int getCountsMinutesTowardsRules() {
<span class="nc" id="L75">		return getAggregatedTemplate().getCountsMinutesTowardsRules();</span>
	}

	/**
	 * Sets the number of minutes the event instances from this template will
	 * count towards various rules, such as vacation allocation, min/max hours,
	 * etc. This property will only have an effect on recurring time off events.
	 */
	public void setCountsMinutesTowardsRules(int mins) {
<span class="nc" id="L84">		getAggregatedTemplate().setCountsMinutesTowardsRules(mins);</span>
<span class="nc" id="L85">	}</span>

	/**
	 * Returns the enumeration value that tells how to calculate the minutes the
	 * event instances from this template will count towards various rules (e.g.
	 * vacation allocation, min/max hours, etc.). Possible enumeration values
	 * are: use underlying shift or use the value specified by
	 * CountsMinutesTowardsRules property. This property will only have an
	 * effect on recurring time off events.
	 */
	public short getTimeOffRule() {
<span class="nc" id="L96">		return getAggregatedTemplate().getTimeOffRule();</span>
	}

	/**
	 * Sets the enumeration value that tells how to calculate the minutes the
	 * event instances from this template will count towards various rules (e.g.
	 * vacation allocation, min/max hours, etc.). This property will only have
	 * an effect on recurring time off events.
	 */
	public void setTimeOffRule(short rule) {
<span class="nc" id="L106">		getAggregatedTemplate().setTimeOffRule(rule);</span>
<span class="nc" id="L107">	}</span>

	/**
	 * Returns the earliest possible time that some instance of this recurring
	 * event template may begin
	 */
	public Date getEarliestPossibleStartTime() {
<span class="nc" id="L114">		Date dtFirstOccurrenceStart = getAdjustedRecurringStartDate();</span>
<span class="nc" id="L115">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L116">		cal.setLenient(true);</span>
<span class="nc" id="L117">		cal.setTime(dtFirstOccurrenceStart);</span>
<span class="nc" id="L118">		cal.add(Calendar.MINUTE, getDayStartOffset());</span>
<span class="nc" id="L119">		return cal.getTime();</span>
	}

	/**
	 * Return the latest possible time that some instance of this recurring
	 * event template may end
	 */
	public Date getLatestPossibleEndTime() {
<span class="nc" id="L127">		Date dtLastOccurrenceEnd = getAdjustedRecurringEndDate();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">		if (dtLastOccurrenceEnd != null) {</span>
<span class="nc" id="L129">			Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L130">			cal.setLenient(true);</span>
<span class="nc" id="L131">			cal.setTime(dtLastOccurrenceEnd);</span>
<span class="nc" id="L132">			cal.add(Calendar.MINUTE, 1); // dtLastOccurrenceEnd is the last</span>
											// minute of the day, add it back
<span class="nc" id="L134">			cal.add(Calendar.MINUTE, getDayStartOffset());</span>
<span class="nc" id="L135">			cal.add(Calendar.MINUTE, getDuration());</span>
<span class="nc" id="L136">			dtLastOccurrenceEnd = cal.getTime();</span>
		}
<span class="nc" id="L138">		return dtLastOccurrenceEnd;</span>
	}

	/**
	 * Returns a collection of calendar event instances which are a result of
	 * the instantiation of recurring event template for the week that contains
	 * a given date.
	 *
	 * Important note: the week is NOT defined as a calendar week (i.e. always
	 * starting on monday), but rather the week is aligned with the recurring
	 * event template start date. In other words, it is defined as follows: *
	 * week start day is the recurring start date + appropriate number of
	 * icrements of event template periodicity interval times 7 days to make
	 * sure the given date falls within the 7 day interval * week end = week
	 * start + 7 days
	 *
	 * Notes: this method currently assumes that the recurrence type of the
	 * recurring event template is always set to RECURRENCE_TYPE_WEEKLY
	 *
	 * @param dtInWeek
	 *            arbitrary point in time, such that events for the week that
	 *            contains this point will be retrieved
	 * @param workResourceIDs
	 *            set of work resource IDs for which to retrieve recurring event
	 *            instances. If this parameter is null then events for all
	 *            recurring event template attendees will be retrieved
	 */
	protected Collection&lt;CalendarEventAssignment&gt; getRecurringEventsStartingInTheWeekOf(Date dtInWeek,
			Collection&lt;ID&gt; workResourceIDs) {
<span class="nc" id="L167">		Date recurringStartDate = getAdjustedRecurringStartDate();</span>
<span class="nc" id="L168">		Date recurringEndDate = getAdjustedRecurringEndDate();</span>

<span class="nc" id="L170">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L171">		cal.setLenient(true);</span>
<span class="nc" id="L172">		cal.setTime(recurringStartDate);</span>
<span class="nc" id="L173">		cal.add(Calendar.WEEK_OF_MONTH, 1);</span>
<span class="nc" id="L174">		Date dtWeekEnd = cal.getTime();</span>

		/**
		 * march forward by adding the appropriate number of weeks until I can
		 * find the appropriate week that encompasses the given date
		 */
<span class="nc bnc" id="L180" title="All 2 branches missed.">		while (!dtWeekEnd.after(dtInWeek)) {</span>
<span class="nc" id="L181">			cal.add(Calendar.WEEK_OF_MONTH, getPeriodicityInterval());</span>
<span class="nc" id="L182">			dtWeekEnd = cal.getTime();</span>
		}

<span class="nc" id="L185">		List&lt;CalendarEventAssignment&gt; events = new ArrayList&lt;CalendarEventAssignment&gt;();</span>

		/* set the calendar to the very beginning of the week */
<span class="nc" id="L188">		cal.add(Calendar.WEEK_OF_MONTH, -1);</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">		for (cal.set(Calendar.MINUTE, getDayStartOffset()); cal.getTime().before(dtWeekEnd); cal.add(</span>
				Calendar.DAY_OF_WEEK, 1)) {
			// QA 72956 - Unable to load data in Time off calendar for one org
			// We should re-calculate the start date for every day because
			// during the week
			// DST can begin at Month day but the week start at sun day in this
			// case the
			// start date and end date of month day is less than sun day 1 hours
			// fix 97934 as well
			/*
			 * REVERSING QA72956 FIX per QC45961 Calendar calNew =
			 * Calendar.getInstance(getTimeZone());
			 * calNew.setTime(cal.getTime()); calNew.set(Calendar.MILLISECOND,
			 * 0); calNew.set(Calendar.SECOND, 0);
			 * calNew.set(Calendar.HOUR_OF_DAY, 0); // next 3 lines were
			 * previous to QA 72956 fix int daystart = getDayStartOffset(); int
			 * duration = getDuration(); int newoffset = daystart + duration;
			 * int newoffset = getDayStartOffset(); if (newoffset &gt; 60) { int
			 * newoffsethour = newoffset/60; int newoffsetmin = newoffset -
			 * (newoffsethour * 60); calNew.set(Calendar.HOUR_OF_DAY,
			 * newoffsethour); calNew.set(Calendar.MINUTE, newoffsetmin); } else
			 * calNew.set(Calendar.MINUTE, newoffset); newoffset +=
			 * getDuration();
			 */
<span class="nc" id="L214">			Date dtTime = cal.getTime();</span>

			// Fix for QA 55778. Calculate end time and pass it on for duration
			// calculation
<span class="nc" id="L218">			Calendar calNew = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L219">			calNew.setTime(dtTime);</span>
<span class="nc" id="L220">			calNew.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L221">			calNew.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L222">			calNew.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L223">			int daystart = getDayStartOffset();</span>
<span class="nc" id="L224">			int duration = getDuration();</span>
<span class="nc" id="L225">			int newoffset = daystart + duration;</span>
			// have not totally port over 55778 into 7.8.1 yet.

			// Fix for QA 55778. Caluculate end time and pass it on for duration
			// calculation
			// Calendar calNew = Calendar.getInstance(getTimeZone());
			// calNew.setTime(dtTime);
			// calNew.set(Calendar.MILLISECOND, 0);
			// calNew.set(Calendar.SECOND, 0);
			// calNew.set(Calendar.HOUR_OF_DAY, 0);
			// int daystart = getDayStartOffset();
			// int duration = getDuration();
			// int newoffset = daystart + duration;
			// have not totally port over 55778 into 7.8.1 yet.
			// newoffset += getDuration(); extra line merged from 10 sp4 fix
			// QC56374
<span class="nc bnc" id="L241" title="All 2 branches missed.">			if (newoffset &gt; 60) {</span>
<span class="nc" id="L242">				int newoffsethour = newoffset / 60;</span>
<span class="nc" id="L243">				int newoffsetmin = newoffset - (newoffsethour * 60);</span>
<span class="nc" id="L244">				calNew.set(Calendar.HOUR_OF_DAY, newoffsethour);</span>
<span class="nc" id="L245">				calNew.set(Calendar.MINUTE, newoffsetmin);</span>
<span class="nc" id="L246">			} else {</span>
<span class="nc" id="L247">				calNew.set(Calendar.MINUTE, newoffset);</span>
			}

<span class="nc" id="L250">			Date dtEndTime = calNew.getTime();</span>

			/*
			 * make sure we don't return any events that actually start before
			 * the recurring start date
			 */
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (dtTime.before(recurringStartDate)) {</span>
<span class="nc" id="L257">				continue;</span>
			}

			/*
			 * make sure we don't return any events that actually start after
			 * the recurring end date
			 */
<span class="nc bnc" id="L264" title="All 4 branches missed.">			if (recurringEndDate != null &amp;&amp; dtTime.after(recurringEndDate)) {</span>
<span class="nc" id="L265">				break;</span>
			}

			/**
			 * make sure we only return those events that start on the specified
			 * day of the week
			 */
<span class="nc bnc" id="L272" title="All 2 branches missed.">			if (!canOccurOnWeekday(cal.get(Calendar.DAY_OF_WEEK))) {</span>
<span class="nc" id="L273">				continue;</span>
			}

			/**
			 * find out what are the actual attendees for this event instance
			 * and get a fresh instance of the event for thee given date
			 */
<span class="nc" id="L280">			Collection&lt;ID&gt; eventAttendees = getEventInstanceAttendees(dtTime);</span>
			/*
			 * iterate through all work resources for this event instance to see
			 * if there is an intersection with the passwed in collection of
			 * work resource IDs
			 */
<span class="nc bnc" id="L286" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; it = eventAttendees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L287">				ID workResourceID = it.next();</span>

				/* skip those work resources that the client did not ask for */
<span class="nc bnc" id="L290" title="All 4 branches missed.">				if (workResourceIDs != null &amp;&amp; !workResourceIDs.contains(workResourceID)) {</span>
<span class="nc" id="L291">					continue;</span>
				}

				/*
				 * now now we know that there is an event on this date that
				 * includes at least one of the passed in work resources, create
				 * a single instance that includes all attendees and add it to
				 * the collection to be returned
				 */
<span class="nc" id="L300">				events.add(getRecurringEventInstance(dtTime, dtEndTime, eventAttendees));</span>

				/*
				 * break out of this loop because we only need to return a
				 * single event instance for a given date from this method
				 */
<span class="nc" id="L306">				break;</span>
			}
		}
<span class="nc" id="L309">		return events;</span>
	}

	@Override
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForTemplate(boolean isNewObject,
		Collection&lt;ShiftAssignment&gt; shifts, Collection&lt;CalendarEventAssignment&gt; events,
		Collection&lt;RecurringEventTemplateBase&gt; templates) {
<span class="nc" id="L316">		Collection&lt;BbmScheduleConflict&gt; listConflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>

<span class="nc bnc" id="L318" title="All 6 branches missed.">		if (events.isEmpty() &amp;&amp; shifts.isEmpty() &amp;&amp; templates.isEmpty()) {</span>
<span class="nc" id="L319">			return listConflicts;</span>
		}

		/*
		 * 1) See if there're any shifts that overlap with any of the events
		 * instantiated by this template
		 */
<span class="nc bnc" id="L326" title="All 2 branches missed.">		for (Iterator&lt;ShiftAssignment&gt; it = shifts.iterator(); it.hasNext();) {</span>

<span class="nc" id="L328">			ShiftAssignment shift = it.next();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">			if (getOverlayPrecedence() != shift.getOverlayPrecedence()) {</span>
<span class="nc" id="L330">				continue;</span>
			}

<span class="nc" id="L333">			Collection&lt;CalendarEventAssignment&gt; listOverlappingEvents = whichInstancesOverlapWithEvent(shift);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">			if (listOverlappingEvents.isEmpty()) {</span>
<span class="nc" id="L335">				continue;</span>
			}

<span class="nc" id="L338">			listConflicts.add(new BbmScheduleConflict(this, shift));</span>
<span class="nc" id="L339">		}</span>

		/*
		 * 2) Check all calendar events except recurring events to see if there
		 * are overlapping events with the same precedence. We'll check the
		 * recurring events separately, since it is a little tricky
		 */

<span class="nc" id="L347">		ArrayList&lt;CalendarEventAssignment&gt; conflictEvents = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; it = events.iterator(); it.hasNext();) {</span>
<span class="nc" id="L349">			CalendarEventAssignment event = it.next();</span>
<span class="nc bnc" id="L350" title="All 4 branches missed.">			if ((isNewObject || !getID().equals(event.getEventTemplateID()))</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">					&amp;&amp; getOverlayPrecedence() == event.getOverlayPrecedence()) {</span>
<span class="nc" id="L352">				Collection&lt;CalendarEventAssignment&gt; listOverlappingEvents = whichInstancesOverlapWithEvent(event);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">				if (listOverlappingEvents.isEmpty()) {</span>
<span class="nc" id="L354">					continue;</span>
				}
<span class="nc bnc" id="L356" title="All 2 branches missed.">				if (!conflictEvents.contains(event)) {</span>
<span class="nc" id="L357">					listConflicts.add(new BbmScheduleConflict(this, event));</span>
<span class="nc" id="L358">					conflictEvents.add(event);</span>
				}
			}
<span class="nc" id="L361">		}</span>

		/*
		 * 3) And now the tricky part - need to check if there are any conflicts
		 * due to overlapping recurring event templates with the same
		 * precedence.
		 */
<span class="nc" id="L368">		Collection&lt;RecurringEventTemplateBase&gt; conflictTemplates = new ArrayList&lt;RecurringEventTemplateBase&gt;();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">		for (Iterator&lt;RecurringEventTemplateBase&gt; it = templates.iterator(); it.hasNext();) {</span>
<span class="nc" id="L370">			RecurringEventTemplateBase recTemplate2 = it.next();</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">			if ((isNewObject || !getID().equals(recTemplate2.getID()))</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">					&amp;&amp; getOverlayPrecedence() == recTemplate2.getOverlayPrecedence()</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">					&amp;&amp; anyInstancesOverlapWithTemplate(recTemplate2)) {</span>
				/*
				 * @todo: implement conflict resolution for this case: The
				 *        problem: what if this is a recurring event with no end
				 *        date Also the other recurring event does not have an
				 *        end date either. Suppose someone were to provide a
				 *        conflict resolution
				 *        &quot;remove overlapping event assignment(s)&quot;. To do this
				 *        would imply creating a potentially infinite number of
				 *        exceptions to the recurring event rule. In other words
				 *        I am not quite sure how to implement this quite yet.
				 */
<span class="nc bnc" id="L385" title="All 2 branches missed.">				if (!conflictTemplates.contains(recTemplate2)) {</span>
<span class="nc" id="L386">					listConflicts.add(new BbmScheduleConflict(this, recTemplate2));</span>
<span class="nc" id="L387">					conflictTemplates.add(recTemplate2);</span>
				}
			}
<span class="nc" id="L390">		}</span>
<span class="nc" id="L391">		return listConflicts;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>