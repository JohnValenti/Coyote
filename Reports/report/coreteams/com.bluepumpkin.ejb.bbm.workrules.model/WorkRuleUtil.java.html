<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WorkRuleUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.workrules.model</a> &gt; <span class="el_source">WorkRuleUtil.java</span></div><h1>WorkRuleUtil.java</h1><pre class="source lang-java linenums">/*
 * (c) 2001-2012 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.workrules.model;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.empworkrule.model.TimePeriodOfDay;
import com.bluepumpkin.ejb.bbm.shifts.model.ShiftsConflictData;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.verint.ejb.wfm.IWorkRuleUtil;

<span class="fc" id="L27">public class WorkRuleUtil implements IWorkRuleUtil {</span>
	
	public static LocalDate ExpandRuleWindowStartDate(ArrayList aWorkRules, LocalDate dtStartDate, LocalDate dtEndDate)
	throws WorkRuleException{
<span class="nc bnc" id="L31" title="All 2 branches missed.">		if (aWorkRules.isEmpty())</span>
<span class="nc" id="L32">			return dtStartDate;</span>
		
<span class="nc" id="L34">		LocalDate dtNewStartDate = new LocalDate(dtStartDate);</span>
<span class="nc" id="L35">		LocalDate dtLastDate = new LocalDate(dtStartDate);</span>
<span class="nc" id="L36">		int nLastPriority = -1;</span>
		
		//iterate over the rules in reverse priority order, expand the start window for each priority
<span class="nc" id="L39">		ListIterator i = aWorkRules.listIterator(aWorkRules.size() - 1);</span>
<span class="nc" id="L40">		WorkRule pWorkRule = (WorkRule)aWorkRules.get(aWorkRules.size() - 1);</span>
		while(true) {
<span class="nc" id="L42">			int nCurrentPriority = pWorkRule.getPriority();</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">			if (nCurrentPriority != nLastPriority) {</span>
<span class="nc" id="L44">				dtNewStartDate = new LocalDate(dtLastDate);</span>
<span class="nc" id="L45">				dtLastDate = pWorkRule.expandStartDate(dtNewStartDate,dtEndDate);</span>
			}
			else { //nCurrentPriority == nLastPriority
<span class="nc" id="L48">				LocalDate dtCurrentDate = pWorkRule.expandStartDate(dtNewStartDate,dtEndDate);</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">				if (dtCurrentDate.getTime().before(dtLastDate.getTime()))</span>
<span class="nc" id="L50">					dtLastDate = new LocalDate(dtCurrentDate);</span>
			}
<span class="nc" id="L52">			nLastPriority = nCurrentPriority;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">			if (i.hasPrevious())</span>
<span class="nc" id="L54">				pWorkRule = (WorkRule)i.previous();</span>
			else break;
<span class="nc" id="L56">		}</span>
		
<span class="nc" id="L58">		dtNewStartDate = new LocalDate(dtLastDate);</span>
<span class="nc" id="L59">		return dtNewStartDate;</span>
	}
	
	public static Pair&lt;LocalDate, LocalDate&gt; ExpandRuleWindow(ArrayList&lt;WorkRule&gt; aWorkRules, LocalDate dtInitialStart, LocalDate dtInitialEnd)
	throws WorkRuleException{
<span class="nc bnc" id="L64" title="All 2 branches missed.">		if (aWorkRules.isEmpty())</span>
<span class="nc" id="L65">			return new Pair&lt;LocalDate, LocalDate&gt;(dtInitialStart,dtInitialEnd);</span>
		
<span class="nc" id="L67">		LocalDate dtStartDate = new LocalDate(dtInitialStart);</span>
<span class="nc" id="L68">		LocalDate dtEndDate = new LocalDate(dtInitialEnd);</span>
		
<span class="nc" id="L70">		LocalDate dtMinStartDate = new LocalDate(dtStartDate);</span>
<span class="nc" id="L71">		LocalDate dtMaxEndDate = new LocalDate(dtEndDate);</span>
		
<span class="nc" id="L73">		int nLastPriority = -1;</span>
		
		//iterate over the rules in reverse priority order,
		//for each priority group: expand the window to the max window needed
<span class="nc" id="L77">		ListIterator&lt;WorkRule&gt; i = aWorkRules.listIterator(aWorkRules.size() - 1);</span>
<span class="nc" id="L78">		WorkRule pWorkRule = aWorkRules.get(aWorkRules.size() - 1);</span>
		while(true) {
			
<span class="nc bnc" id="L81" title="All 2 branches missed.">			if (pWorkRule.getPriority() != nLastPriority) {</span>
				//found a new priority group
<span class="nc" id="L83">				dtStartDate = new LocalDate(dtMinStartDate);</span>
<span class="nc" id="L84">				dtEndDate = new LocalDate(dtMaxEndDate);</span>
			}
			
<span class="nc" id="L87">			Pair pWindow = pWorkRule.expandWindow(dtStartDate,dtEndDate);</span>
<span class="nc" id="L88">			LocalDate dtRuleStart = (LocalDate)pWindow.getFirst();</span>
<span class="nc" id="L89">			LocalDate dtRuleEnd = (LocalDate)pWindow.getSecond();</span>
			
<span class="nc bnc" id="L91" title="All 2 branches missed.">			if (dtRuleStart.getTime().before(dtMinStartDate.getTime()))</span>
<span class="nc" id="L92">				dtMinStartDate = new LocalDate(dtRuleStart);</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">			if (dtRuleEnd.getTime().after(dtMaxEndDate.getTime()))</span>
<span class="nc" id="L94">				dtMaxEndDate = new LocalDate(dtRuleEnd);</span>
			
<span class="nc" id="L96">			nLastPriority = pWorkRule.getPriority();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">			if (i.hasPrevious())</span>
<span class="nc" id="L98">				pWorkRule = i.previous();</span>
			else break;
<span class="nc" id="L100">		}</span>
		
<span class="nc" id="L102">		return new Pair&lt;LocalDate, LocalDate&gt;(dtMinStartDate,dtMaxEndDate);</span>
	}
	
	/**
	 * 
	 * @param dtStartDate
	 * @param dtEndDate
	 * @param idWorkResource
	 * @param pOrganization
	 * @param hWorkRules
	 * @param pEvents
	 * @return
	 * @throws WorkRuleException
	 */
	public Collection&lt;CommonConflict&gt; getConflictsForEmployeeInt(Date dtStartDate, Date dtEndDate,
			ID idWorkResource, Organization pOrganization,
			HashMap hWorkRules, Collection&lt;? extends Event&gt; pEvents)
	throws WorkRuleException {
<span class="nc" id="L120">		return getConflictsForEmployee(new LocalDate(dtStartDate, pOrganization.getTimeZone()),</span>
<span class="nc" id="L121">				new LocalDate(dtEndDate,pOrganization.getTimeZone()), idWorkResource,</span>
<span class="nc" id="L122">				pOrganization, hWorkRules.values(), pEvents, false);</span>
	}

	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(ShiftsConflictData conflictData) throws WorkRuleException {
<span class="nc" id="L126">		return getConflictsForEmployee(conflictData.getPeriodStart(), conflictData.getPeriodEnd(), conflictData.getEmpID(),</span>
<span class="nc" id="L127">			conflictData.getEmpOrg(), new HashMap&lt;ID, WorkRule&gt;(), conflictData.getSortedEmpEvents(), conflictData.isMonthlyCampaign());</span>
	}
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(Date dtStartDate, Date dtEndDate,
			ID idWorkResource, Organization pOrganization,
			HashMap hWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
<span class="nc" id="L134">		return getConflictsForEmployee(new LocalDate(dtStartDate, pOrganization.getTimeZone()),</span>
<span class="nc" id="L135">				new LocalDate(dtEndDate,pOrganization.getTimeZone()),</span>
<span class="nc" id="L136">				idWorkResource, pOrganization, hWorkRules.values(), pEvents, isMonthlySP);</span>
	}
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(Date dtStartDate, Date dtEndDate,
			ID idWorkResource, Organization pOrganization,
			Collection&lt;WorkRule&gt; cWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
<span class="nc" id="L143">		return getConflictsForEmployee(new LocalDate(dtStartDate, pOrganization.getTimeZone()),</span>
<span class="nc" id="L144">				new LocalDate(dtEndDate,pOrganization.getTimeZone()),</span>
				idWorkResource, pOrganization,
				cWorkRules, pEvents, isMonthlySP);
	}
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(LocalDate dtStartDate, LocalDate dtEndDate,
			ID idWorkResource, Organization pOrganization,
			HashMap hWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
<span class="nc" id="L153">		return getConflictsForEmployee(dtStartDate,	dtEndDate,</span>
				idWorkResource, pOrganization,
<span class="nc" id="L155">				hWorkRules.values(), pEvents, isMonthlySP);</span>
	}
	
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(LocalDate dtStartDate, LocalDate dtEndDate,
			ID idWorkResource, Organization pOrganization,
			Collection&lt;WorkRule&gt; cWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
		
<span class="nc" id="L164">		LinkedList&lt;CommonConflict&gt; llAllConflicts = new LinkedList&lt;CommonConflict&gt;();</span>
		
		//sort WorkRules to priority order
<span class="nc" id="L167">		ArrayList&lt;WorkRule&gt; pWorkRules = new ArrayList&lt;WorkRule&gt;(cWorkRules);</span>
<span class="nc" id="L168">		Collections.sort(pWorkRules);</span>
		
		//LocalDate dtNewStartDate = WorkRuleUtil.ExpandRuleWindowStartDate(pWorkRules,dtStartDate,dtEndDate);
<span class="nc" id="L171">		int eOverlap = WorkRule.MAJORITYIN;</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">		for( Iterator&lt;WorkRule&gt; w = pWorkRules.iterator(); w.hasNext(); ) {</span>
<span class="nc" id="L173">			WorkRule pWorkRule = w.next();</span>
<span class="nc" id="L174">			eOverlap = pWorkRule.getOverlap();</span>
<span class="nc" id="L175">			Collection&lt;CommonConflict&gt; pConflicts = pWorkRule.getConflicts(idWorkResource,pOrganization,</span>
					dtStartDate,dtEndDate,pEvents, llAllConflicts, isMonthlySP);
<span class="nc" id="L177">			llAllConflicts.addAll(pConflicts);</span>
<span class="nc" id="L178">		}</span>
		
<span class="nc" id="L180">		Date dtOrgStartDate = TimeZoneUtil.getMidNightDate(dtStartDate.getTime(), pOrganization.getTimeZone());</span>
<span class="nc" id="L181">		Date dtOrgEndDate = TimeZoneUtil.getMidNightDate(dtEndDate.getTime(), pOrganization.getTimeZone());</span>
		
<span class="nc" id="L183">		return getConflictsInWindow(dtOrgStartDate,dtOrgEndDate,llAllConflicts,pEvents,eOverlap);</span>
	}
	
	
	public static Collection&lt;CommonConflict&gt; getConflictsInWindow(Date dtOrgStartDate, Date dtOrgEndDate,
			Collection&lt;CommonConflict&gt; apAllConflicts, Collection&lt;? extends Event&gt; pEvents, int eOverlap) {
		
<span class="nc" id="L190">		LinkedList&lt;CommonConflict&gt; llPeriodConflicts = new LinkedList&lt;CommonConflict&gt;();</span>
		
		//throw away conflicts outside time window, this is pretty inefficient
<span class="nc bnc" id="L193" title="All 2 branches missed.">		for (Iterator&lt;CommonConflict&gt; c = apAllConflicts.iterator(); c.hasNext(); ) {</span>
<span class="nc" id="L194">			CommonConflict pConflict = c.next();</span>
<span class="nc" id="L195">			ID idEvent = pConflict.getEventID();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">			if (idEvent == null) {</span>
				//check to see if the Conflict occurred inside the period
<span class="nc bnc" id="L198" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriod(pConflict.getStartDate(),pConflict.getEndDate(),</span>
						dtOrgStartDate, dtOrgEndDate,eOverlap))
<span class="nc" id="L200">					llPeriodConflicts.add(pConflict);</span>
			}
			else {
				//check to see if the Event occurred within the period
<span class="nc bnc" id="L204" title="All 2 branches missed.">				for (Iterator&lt;? extends Event&gt; e = pEvents.iterator(); e.hasNext(); ) {</span>
<span class="nc" id="L205">					Event pEvent = e.next();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">					if (pEvent.getID() != null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">						if (pEvent.getID().equals(idEvent)) {  //XXX what about event type</span>
							//found the event...
<span class="nc bnc" id="L209" title="All 2 branches missed.">							if (WorkRuleUtil.isInPeriod(pEvent.getStartTime(),pEvent.getEndTime(),</span>
									dtOrgStartDate, dtOrgEndDate,eOverlap))
<span class="nc" id="L211">								llPeriodConflicts.add(pConflict);</span>
							break;
						}
					}
<span class="nc" id="L215">				}</span>
			}
<span class="nc" id="L217">		}</span>
<span class="nc" id="L218">		return llPeriodConflicts;</span>
	}
	
	public static Collection&lt;TimeSpan&gt; getOverlap(TimeSpan pEvent, Collection&lt;TimeSpan&gt; pPeriods) {
<span class="nc" id="L222">		LinkedList&lt;TimeSpan&gt; llPeriods = new LinkedList&lt;TimeSpan&gt;();</span>
		
<span class="nc bnc" id="L224" title="All 2 branches missed.">		for( Iterator&lt;TimeSpan&gt; i = pPeriods.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L225">			TimeSpan pPeriod = i.next();</span>
			
			
			//check for overlap
<span class="nc bnc" id="L229" title="All 4 branches missed.">			if (pEvent.dtSpanStart.before(pPeriod.dtSpanEnd) &amp;&amp; pEvent.dtSpanEnd.after(pPeriod.dtSpanStart)) {</span>
				//there is an overlap, add it to the collection
<span class="nc" id="L231">				TimeSpan pOverlap = new TimeSpan();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">				if (pEvent.dtSpanStart.after(pPeriod.dtSpanStart))</span>
<span class="nc" id="L233">					pOverlap.dtSpanStart = pEvent.dtSpanStart;</span>
				else
<span class="nc" id="L235">					pOverlap.dtSpanStart = pPeriod.dtSpanStart;</span>
				
<span class="nc bnc" id="L237" title="All 2 branches missed.">				if (pEvent.dtSpanEnd.before(pPeriod.dtSpanEnd))</span>
<span class="nc" id="L238">					pOverlap.dtSpanEnd = pEvent.dtSpanEnd;</span>
				else
<span class="nc" id="L240">					pOverlap.dtSpanEnd = pPeriod.dtSpanEnd;</span>
				
<span class="nc" id="L242">				llPeriods.add(pOverlap);</span>
			}
<span class="nc" id="L244">		}</span>
<span class="nc" id="L245">		return llPeriods;</span>
	}
	
	public static boolean isInPeriod(Date dtStart,Date dtEnd,Date dtPeriodStart, Date dtPeriodEnd, int eOverlap) {
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">		if (eOverlap == WorkRule.STARTSIN) {</span>
<span class="fc bfc" id="L250" title="All 4 branches covered.">			return !dtStart.before(dtPeriodStart) &amp;&amp; dtStart.before(dtPeriodEnd);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">		} else if (eOverlap == WorkRule.ENDSIN) {</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">			return !dtEnd.before(dtPeriodStart) &amp;&amp; dtEnd.before(dtPeriodEnd);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">		} else if (eOverlap == WorkRule.MAJORITYIN) {</span>
<span class="nc" id="L254">			Date dtMidDate = new Date(dtStart.getTime() + (dtEnd.getTime() - dtStart.getTime())/2);</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">			return !dtMidDate.before(dtPeriodStart) &amp;&amp; dtMidDate.before(dtPeriodEnd);</span>
		} else {
			//eOverlap == WorkRule.PORTIONIN
<span class="nc bnc" id="L258" title="All 4 branches missed.">			return !(dtStart.after(dtPeriodEnd) || dtEnd.before(dtPeriodStart));</span>
		}
	}
	
	public static boolean isInPeriodAndApproved(Event pEvent,Date dtPeriodStart,
			Date dtPeriodEnd,int eOverlap) {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">		if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_RECORD &amp;&amp;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">				(!((TimeRecord)pEvent).getApprove() ||</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">						((TimeRecord)pEvent).getType() == Event.EVENT_TYPE_TIME_INTERVAL))</span>
<span class="nc" id="L267">			return false;</span>
		
<span class="fc" id="L269">		return isInPeriod(pEvent.getStartTime(),pEvent.getEndTime(),dtPeriodStart,</span>
				dtPeriodEnd,eOverlap);
	}
	
	public static boolean isShiftInPeriod(Event pEvent, Organization pOrg, Date dtPeriodStart,
			Date dtPeriodEnd,TimePeriodOfDay ePartOfDay) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">		if (pEvent.getEventType() != Event.EVENT_TYPE_SHIFT_ASSIGNMENT)</span>
<span class="nc" id="L276">			return false;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">		if (ePartOfDay != null) {</span>
			//not any time
<span class="nc" id="L279">			Calendar calendar = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L280">			calendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L281">			int startMinutesFromMidnight = (calendar.get(Calendar.HOUR_OF_DAY) * 60) + calendar.get(Calendar.MINUTE);</span>

<span class="nc" id="L283">			calendar.setTime(pEvent.getEndTime());</span>
<span class="nc" id="L284">			int endMinutesFromMidnight = (calendar.get(Calendar.HOUR_OF_DAY) * 60) + calendar.get(Calendar.MINUTE);</span>

<span class="nc" id="L286">			int pStart = ePartOfDay.getStartTime().getMinutesSinceMindnight();</span>
<span class="nc" id="L287">			int pEnd = ePartOfDay.getEndTime().getMinutesSinceMindnight();</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">			if (pEnd == 0) pEnd = 1440; //bug in TimeOfDay, 1440 will be set to 0 for end time.</span>

			// Evaluate if event start time does not overlap with specific time period of day
			// If event start does not overlap, it could still mean the end time does
<span class="nc bnc" id="L292" title="All 4 branches missed.">			if (!(startMinutesFromMidnight &gt;= pStart &amp;&amp; startMinutesFromMidnight &lt; pEnd)) {</span>
				// return false, only if the event end time does not overlap either
<span class="nc bnc" id="L294" title="All 4 branches missed.">				if (endMinutesFromMidnight &lt;= pStart || startMinutesFromMidnight &gt; pEnd) {</span>
<span class="nc" id="L295">					return false;</span>
				}
			}

		}
<span class="nc bnc" id="L300" title="All 4 branches missed.">		return (!pEvent.getStartTime().before(dtPeriodStart) &amp;&amp; pEvent.getStartTime().before(dtPeriodEnd));</span>
	}
	
	public static boolean isShiftInPartOfDay(Event pEvent, Organization pOrg, TimePeriodOfDay ePartOfDay) {
<span class="nc bnc" id="L304" title="All 2 branches missed.">		if (pEvent.getEventType() != Event.EVENT_TYPE_SHIFT_ASSIGNMENT)</span>
<span class="nc" id="L305">			return false;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">		if (ePartOfDay != null) {</span>
			//not any time
<span class="nc" id="L308">			Calendar calendar = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L309">			calendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L310">			int startMinutesFromMidNight = (calendar.get(Calendar.HOUR_OF_DAY) * 60) + calendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L311">			int pStart = ePartOfDay.getStartTime().getMinutesSinceMindnight();</span>
<span class="nc" id="L312">			int pEnd = ePartOfDay.getEndTime().getMinutesSinceMindnight();</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">			if (pEnd == 0) pEnd = 1440; //bug in TimeOfDay, 1440 will be set to 0 for end time.</span>
<span class="nc bnc" id="L314" title="All 4 branches missed.">			if (!(startMinutesFromMidNight &gt;= pStart &amp;&amp; startMinutesFromMidNight &lt; pEnd)) {</span>
				//not overlap with the specific time period of day
<span class="nc" id="L316">				return false;</span>
			}
		}
<span class="nc" id="L319">		return true;</span>
	}
	
	public static boolean isPreviousDay(Date dtFirst, Date dtSecond,Organization pOrg) {
<span class="nc" id="L323">		Calendar cCal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L324">		cCal.setTime(dtFirst);</span>
<span class="nc" id="L325">		cCal.add(Calendar.DAY_OF_YEAR,1);</span>
<span class="nc" id="L326">		int nFirstDay = cCal.get(Calendar.DAY_OF_YEAR);</span>
<span class="nc" id="L327">		int nFirstYear = cCal.get(Calendar.YEAR);</span>
<span class="nc" id="L328">		cCal.setTime(dtSecond);</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">		return (nFirstDay == cCal.get(Calendar.DAY_OF_YEAR) &amp;&amp; nFirstYear == cCal.get(Calendar.YEAR));</span>
	}
	
	public static boolean isPreviousWeekButOne(Date dtFirst, Date dtSecond,Organization pOrg) {
<span class="nc" id="L333">		Calendar cCal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L334">		cCal.setTime(dtFirst);</span>
<span class="nc" id="L335">		cCal.add(Calendar.DAY_OF_YEAR,6);</span>
<span class="nc" id="L336">		int nFirstDay = cCal.get(Calendar.DAY_OF_YEAR);</span>
<span class="nc" id="L337">		int nFirstYear = cCal.get(Calendar.YEAR);</span>
<span class="nc" id="L338">		cCal.setTime(dtSecond);</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">		return (nFirstDay == cCal.get(Calendar.DAY_OF_YEAR) &amp;&amp; nFirstYear == cCal.get(Calendar.YEAR));</span>
	}
	
	/*
	 public static Event splitEvent(Event pEvent, Date dtStart,Date dtEnd) {
	 //eventually this function should split other types of events as well...
	  TimeRecord pTimeRecord = (TimeRecord)pEvent;
	  
	  TimeRecord pNewTimeRecord = new TimeRecord(pTimeRecord.getID(),pTimeRecord.getEmployeeID(),
	  pTimeRecord.getRemarkEmployeeID(),pTimeRecord.getRemarkDate(),
	  &quot;&quot;,pTimeRecord.getApprove(),pTimeRecord.isLocked());
	  for( Iterator i = pTimeRecord.getChildren().iterator(); i.hasNext(); ) {
	  TimeRecordEntry pChild = (TimeRecordEntry)i.next();
	  TimeRecordEntry pChildCopy = new TimeRecordEntry(pChild.getActivityID(),pChild.getStartTime(),
	  pChild.getEndTime(),pChild.getTimeSourceCode(),pChild.getPaid(),&quot;&quot;);
	  
	  if (dtStart.after(pChildCopy.getStartTime()))
	  pChildCopy.setStartTime(dtStart);
	  
	  if (dtEnd.before(pChildCopy.getEndTime()))
	  pChildCopy.setEndTime(dtEnd);
	  
	  if (pChildCopy.getDuration() &gt; 0)
	  pNewTimeRecord.addEntry(pChildCopy);
	  }
	  return (Event)pNewTimeRecord;
	  }
	  */
	public static Event getEventInPeriod(Event pEvent,Date dtPeriodStart,
			Date dtPeriodEnd,int eOverlap) {
<span class="nc" id="L369">		Date dtStart = pEvent.getStartTime();</span>
<span class="nc" id="L370">		Date dtEnd = pEvent.getEndTime();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">		if (eOverlap == WorkRule.STARTSIN)</span>
<span class="nc bnc" id="L372" title="All 4 branches missed.">			if (!dtStart.before(dtPeriodStart) &amp;&amp; dtStart.before(dtPeriodEnd))</span>
<span class="nc" id="L373">				return pEvent;</span>
<span class="nc" id="L374">			else return null;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">		else if (eOverlap == WorkRule.ENDSIN)</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">			if (!dtEnd.before(dtPeriodStart) &amp;&amp; dtEnd.before(dtPeriodEnd))</span>
<span class="nc" id="L377">				return pEvent;</span>
<span class="nc" id="L378">			else return null;</span>
		else  { //if (eOverlap == WorkRule.MAJORITYIN) {
<span class="nc" id="L380">			Date dtMidDate = new Date(dtStart.getTime() + (dtEnd.getTime() - dtStart.getTime())/2);</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">			if (!dtMidDate.before(dtPeriodStart) &amp;&amp; dtMidDate.before(dtPeriodEnd))</span>
<span class="nc" id="L382">				return pEvent;</span>
<span class="nc" id="L383">			else return null;</span>
		}
//		else { //eOverlap == WorkRule.PORTIONIN
//		if (dtStart.after(dtPeriodEnd) || dtEnd.before(dtPeriodStart))
//		return null;
//		else if (!dtStart.before(dtPeriodStart) &amp;&amp; dtEnd.before(dtPeriodEnd))
//		return pEvent;
//		else
//		return splitEvent(pEvent,dtPeriodStart,dtPeriodEnd);
//		}
	}
	
	private static Collection&lt;TimeSpan&gt; GetUnpaidTimeSpans(Event pEvent, Collection&lt;CommonConflict&gt; pConflicts,
			int nPriority) {
<span class="nc" id="L397">		ArrayList&lt;TimeSpan&gt; aTimeSpans = new ArrayList&lt;TimeSpan&gt;();</span>
		
		//first iterate over the children of the event, add unpaid event to TimeSpan Collection
<span class="nc bnc" id="L400" title="All 2 branches missed.">		for( Iterator&lt;Event&gt; i = pEvent.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L401">			Event pChild = i.next();</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">			if (!pChild.getPaid()) {</span>
<span class="nc" id="L403">				Date dtStart = new Date(pChild.getStartTime().getTime());</span>
<span class="nc" id="L404">				Date dtEnd = new Date(pChild.getEndTime().getTime());</span>
<span class="nc" id="L405">				TimeSpan pTimeSpan = new TimeSpan(dtStart,dtEnd);</span>
<span class="nc" id="L406">				aTimeSpans.add(pTimeSpan);</span>
			}
<span class="nc" id="L408">		}</span>
		
		//next iterate over the entire conflict collection
		//this is somewhat inefficient
<span class="nc bnc" id="L412" title="All 2 branches missed.">		for( Iterator&lt;CommonConflict&gt; i = pConflicts.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L413">			CommonConflict pConflict = i.next();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">			if (pConflict.getStartDate().before(pEvent.getEndTime()) &amp;&amp;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">					pConflict.getEndDate().after(pEvent.getStartTime()) &amp;&amp;</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">					pConflict.getPriority() &lt; nPriority) {</span>
				
<span class="nc" id="L418">				Date dtStartTime = new Date(pConflict.getStartDate().getTime());</span>
<span class="nc" id="L419">				Date dtEndTime = new Date(pConflict.getEndDate().getTime());</span>
				//truncate conflicts longer then the event
<span class="nc bnc" id="L421" title="All 2 branches missed.">				if (dtStartTime.before(pEvent.getStartTime()))</span>
<span class="nc" id="L422">					dtStartTime = pEvent.getStartTime();</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">				if (dtEndTime.after(pEvent.getEndTime()))</span>
<span class="nc" id="L424">					dtEndTime = pEvent.getEndTime();</span>
				
<span class="nc" id="L426">				TimeSpan pTimeSpan = new TimeSpan(dtStartTime,dtEndTime);</span>
<span class="nc" id="L427">				aTimeSpans.add(pTimeSpan);</span>
			}
<span class="nc" id="L429">		}</span>
		
		
		//sort the timespans and remove overlaps
<span class="nc" id="L433">		Collections.sort(aTimeSpans);</span>
<span class="nc" id="L434">		Iterator&lt;TimeSpan&gt; i = aTimeSpans.iterator();</span>
<span class="nc" id="L435">		LinkedList&lt;TimeSpan&gt; llTimeSpans = new LinkedList&lt;TimeSpan&gt;();</span>
		
<span class="nc bnc" id="L437" title="All 2 branches missed.">		if (i.hasNext()) {</span>
<span class="nc" id="L438">			TimeSpan pTimeSpan = i.next();</span>
<span class="nc" id="L439">			Date dtStart = pTimeSpan.dtSpanStart;</span>
<span class="nc" id="L440">			Date dtEnd = pTimeSpan.dtSpanEnd;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">			while (i.hasNext()) {</span>
<span class="nc" id="L442">				pTimeSpan = i.next();</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">				if (pTimeSpan.dtSpanEnd.after(dtStart)) {</span>
					//found an overlapping timespan, we may need to extend the start time
<span class="nc bnc" id="L445" title="All 2 branches missed.">					if (pTimeSpan.dtSpanStart.before(dtStart))</span>
<span class="nc" id="L446">						dtStart = pTimeSpan.dtSpanStart;</span>
				}
				else {
					//found a non overlapping timespan, add previous timespan to collection
<span class="nc" id="L450">					llTimeSpans.addLast(new TimeSpan (dtStart,dtEnd));</span>
<span class="nc" id="L451">					dtStart = pTimeSpan.dtSpanStart;</span>
<span class="nc" id="L452">					dtEnd = pTimeSpan.dtSpanEnd;</span>
				}
			}
<span class="nc" id="L455">			llTimeSpans.addLast(new TimeSpan (dtStart,dtEnd));</span>
		}
		
<span class="nc" id="L458">		return llTimeSpans;</span>
	}
	
	public static int GetUnpaidDuration(Event pEvent, Collection&lt;CommonConflict&gt; pConflicts,
			int nPriority) {
		
<span class="nc" id="L464">		Collection&lt;TimeSpan&gt; cTimeSpans = GetUnpaidTimeSpans(pEvent,pConflicts,nPriority);</span>
		
<span class="nc" id="L466">		int nUnpaid = 0;</span>
		
		//iterate over timespans counting unPaidMinutes
<span class="nc bnc" id="L469" title="All 2 branches missed.">		for( Iterator&lt;TimeSpan&gt; i = cTimeSpans.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L470">			TimeSpan pTimeSpan = i.next();</span>
<span class="nc" id="L471">			nUnpaid += (pTimeSpan.dtSpanEnd.getTime() - pTimeSpan.dtSpanStart.getTime());</span>
<span class="nc" id="L472">		}</span>
		
<span class="nc" id="L474">		nUnpaid /= (60*1000);</span>
<span class="nc" id="L475">		return nUnpaid;</span>
	}
	
	public static int GetUnpaidDuration(Event pEvent) {
		
<span class="nc" id="L480">		int nUnpaid = 0;</span>
		//first iterate over the children of the event, add unpaid event to TimeSpan Collection
<span class="nc bnc" id="L482" title="All 2 branches missed.">		for( Iterator&lt;Event&gt; i = pEvent.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L483">			Event pChild = i.next();</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">			if (!pChild.getPaid()) {</span>
<span class="nc" id="L485">				nUnpaid += pChild.getDuration();</span>
			}
<span class="nc" id="L487">		}</span>
		
<span class="nc" id="L489">		return nUnpaid;</span>
	}
	
	public static Collection&lt;CommonConflict&gt; SplitConflicts(Event pEvent, Collection&lt;CommonConflict&gt; pConflicts, int nPriority,
			Date dtStartDate, Date dtEndDate, boolean bSpread) {
		
		//creates a collection of conflicts which do not overlap any unpaid timespans
		
<span class="nc" id="L497">		Collection&lt;TimeSpan&gt; cTimeSpans = GetUnpaidTimeSpans(pEvent,pConflicts,nPriority);</span>
		
<span class="nc" id="L499">		Collection&lt;CommonConflict&gt; cNewConflicts = new ArrayList&lt;CommonConflict&gt;();</span>
<span class="nc" id="L500">		Date dtCurrentEndDate = new Date(dtEndDate.getTime());</span>
<span class="nc" id="L501">		Date dtCurrentStartDate = new Date(dtStartDate.getTime());</span>
		
		//iterate over timespans creating conflicts
<span class="nc bnc" id="L504" title="All 2 branches missed.">		for( Iterator&lt;TimeSpan&gt; i = cTimeSpans.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L505">			TimeSpan pTimeSpan = i.next();</span>
			
<span class="nc bnc" id="L507" title="All 2 branches missed.">			if (!dtCurrentEndDate.after(pTimeSpan.dtSpanStart))</span>
<span class="nc" id="L508">				continue;</span>
			
<span class="nc bnc" id="L510" title="All 2 branches missed.">			if (bSpread) {</span>
				//check for overlap, then extend start date
<span class="nc bnc" id="L512" title="All 2 branches missed.">				if (pTimeSpan.dtSpanEnd.after(dtCurrentStartDate) &amp;&amp;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">						pTimeSpan.dtSpanStart.before(dtEndDate)) {</span>
<span class="nc" id="L514">					Date dtSpreadEnd = pTimeSpan.dtSpanEnd;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">					if (dtEndDate.before(dtSpreadEnd))</span>
<span class="nc" id="L516">						dtSpreadEnd = dtEndDate;</span>
<span class="nc" id="L517">					dtCurrentStartDate = new Date(dtCurrentStartDate.getTime() -</span>
<span class="nc" id="L518">							(dtSpreadEnd.getTime() - pTimeSpan.dtSpanStart.getTime()));</span>
				}
			}
			
<span class="nc bnc" id="L522" title="All 2 branches missed.">			if (pTimeSpan.dtSpanEnd.before(dtCurrentStartDate))</span>
<span class="nc" id="L523">				break;</span>
			
<span class="nc bnc" id="L525" title="All 2 branches missed.">			if (dtCurrentEndDate.after(pTimeSpan.dtSpanEnd)) {</span>
				//create a conflict from the end of this conflict
<span class="nc bnc" id="L527" title="All 2 branches missed.">				if (pTimeSpan.dtSpanEnd.before(dtCurrentEndDate)) {</span>
<span class="nc" id="L528">					CommonConflict pConflict = new CommonConflict(pTimeSpan.dtSpanEnd,dtCurrentEndDate,pEvent.getID());</span>
<span class="nc" id="L529">					cNewConflicts.add(pConflict);</span>
				}
			}
<span class="nc" id="L532">			dtCurrentEndDate = new Date(pTimeSpan.dtSpanStart.getTime());</span>
<span class="nc" id="L533">		}</span>
		
		//create the last conflict
<span class="nc bnc" id="L536" title="All 2 branches missed.">		if (dtCurrentStartDate.before(dtCurrentEndDate)) {</span>
<span class="nc" id="L537">			CommonConflict pConflict = new CommonConflict(dtCurrentStartDate,dtCurrentEndDate,pEvent.getID());</span>
<span class="nc" id="L538">			cNewConflicts.add(pConflict);</span>
		}
		
<span class="nc" id="L541">		return cNewConflicts;</span>
	}
	
	public static int getPeriodInDays(int ePeriodType, int nPeriodLength) {
<span class="nc bnc" id="L545" title="All 2 branches missed.">		if (ePeriodType == WorkRule.WORKDAY)</span>
<span class="nc" id="L546">			return nPeriodLength;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">		else if (ePeriodType == WorkRule.WORKWEEK)</span>
<span class="nc" id="L548">			return nPeriodLength * 7;</span>
		else //if (ePeriodType == WorkRule.MONTH)
<span class="nc" id="L550">			return nPeriodLength * 31;</span>
	}
/*	
	public static void main(String[] args) {
		try {
			Calendar cCalendar = Calendar.getInstance();
			cCalendar.set(1970,7,10,8,0,0);
			Date dtStart = cCalendar.getTime();
			cCalendar.set(1970,7,10,16,0,0);
			Date dtEnd = cCalendar.getTime();
			
			TestEvent pEvent = new TestEvent(dtStart,dtEnd);
			ArrayList pConflicts = new ArrayList();
			
			cCalendar.set(1970,7,10,12,0,0);
			Date dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,14,0,0);
			Date dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict1 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict1.setPriority(1);
			pConflicts.add(pConflict1);
			
			cCalendar.set(1970,7,10,7,0,0);
			dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,9,0,0);
			dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict2 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict2.setPriority(1);
			pConflicts.add(pConflict2);
			
			cCalendar.set(1970,7,10,7,30,0);
			dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,8,30,0);
			dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict3 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict2.setPriority(1);
			pConflicts.add(pConflict3);
			
			cCalendar.set(1970,7,10,13,0,0);
			dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,15,0,0);
			dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict4 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict1.setPriority(1);
			pConflicts.add(pConflict4);
			
			Collection pTimeSpans = GetUnpaidTimeSpans(pEvent,pConflicts,10);
			
			for( Iterator i = pTimeSpans.iterator(); i.hasNext(); ) {
				TimeSpan pPeriod = (TimeSpan)i.next();
				System.out.println(&quot;Unpaid TimeSpan &quot; + pPeriod.dtSpanStart + &quot; &quot; +pPeriod.dtSpanEnd);
			}
			
			int nUnpaid = GetUnpaidDuration(pEvent,pConflicts,10);
			System.out.println(&quot;unpaid minutes &quot; + nUnpaid);
			
			cCalendar.set(1970,7,10,10,0,0);
			dtStart1 = cCalendar.getTime();
			
			Collection pNewConflicts = SplitConflicts(pEvent,pConflicts,10,dtStart1,dtEnd,false);
			for( Iterator i = pNewConflicts.iterator(); i.hasNext(); ) {
				CommonConflict pConflict = (CommonConflict)i.next();
				System.out.println(&quot;Split Conflicts &quot; + pConflict.getStartDate() + &quot; &quot; +pConflict.getEndDate());
			}
			
			pNewConflicts = SplitConflicts(pEvent,pConflicts,10,dtStart1,dtEnd,true);
			for( Iterator i = pNewConflicts.iterator(); i.hasNext(); ) {
				CommonConflict pConflict = (CommonConflict)i.next();
				System.out.println(&quot;Spread Conflicts &quot; + pConflict.getStartDate() + &quot; &quot; +pConflict.getEndDate());
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
*/	
	
	public static StringBuffer appendCommaIfPassStringIsNotEmpty(StringBuffer orderByQuery) {
<span class="pc bpc" id="L632" title="1 of 2 branches missed.">		if (!orderByQuery.toString().trim().isEmpty())</span>
<span class="nc" id="L633">			orderByQuery.append(&quot;,&quot;);</span>
<span class="fc" id="L634">		return orderByQuery;</span>
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>