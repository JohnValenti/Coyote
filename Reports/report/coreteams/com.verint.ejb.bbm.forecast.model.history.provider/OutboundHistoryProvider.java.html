<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>OutboundHistoryProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.bbm.forecast.model.history.provider</a> &gt; <span class="el_source">OutboundHistoryProvider.java</span></div><h1>OutboundHistoryProvider.java</h1><pre class="source lang-java linenums">package com.verint.ejb.bbm.forecast.model.history.provider;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeContext;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.time.TimeIntervalAtTime;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workload.model.QueueList;
import com.verint.ejb.bbm.forecast.model.ForecastProfileList;
import com.verint.ejb.bbm.forecast.model.OutboundCallsList;
import com.verint.ejb.bbm.forecast.model.Profile;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntry;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntryHistoryPeriod;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntryIntervalType;
import com.verint.ejb.bbm.forecast.model.history.service.INotesDataService;
import com.verint.ejb.bbm.forecast.model.history.service.IOutboundHistoryDataService;

import java.util.*;


public class OutboundHistoryProvider extends QueueHistoryTimeSeriesProvider {

	private TimeContext timeContext;

	private final IOutboundHistoryDataService outboundHistoryDataService;
	public OutboundHistoryProvider(Queue queue, TimeContext timeContext, IOutboundHistoryDataService historyDataService,
			INotesDataService notesDataService) {
<span class="nc" id="L28">		super(queue, timeContext, historyDataService, notesDataService);</span>
<span class="nc" id="L29">		this.outboundHistoryDataService = historyDataService;</span>
<span class="nc" id="L30">		this.timeContext = timeContext;</span>
<span class="nc" id="L31">	}</span>

	private Collection&lt;QueueList&gt; getHistoricalOutboundCallLists() throws BbmFinderException {
<span class="nc" id="L34">		return outboundHistoryDataService.getHistoricalOutboundCallLists(queue);</span>
	}

	/**
	 * When a forecast is calculated, historical lists that are associated to the history periods in this profile
	 * are included as part of the forecast.  These are called &quot;forecasted lists&quot; and they are shown in the forecasted
	 * lists view.
	 */
	public Map&lt;TimeIntervalAtTime, List&lt;OutboundCallsList&gt;&gt; reforecastOutboundCallLists(
			Collection&lt;? extends Profile&gt; profiles) throws BbmFinderException {

<span class="nc" id="L45">		Map&lt;TimeIntervalAtTime, List&lt;OutboundCallsList&gt;&gt; retVal = new HashMap&lt;TimeIntervalAtTime, List&lt;OutboundCallsList&gt;&gt;();</span>

<span class="nc" id="L47">		Map&lt;ProfileEntry, List&lt;OutboundCallsList&gt;&gt; outboundCallsPerHistoricalWeek =</span>
				new HashMap&lt;ProfileEntry, List&lt;OutboundCallsList&gt;&gt;();
<span class="nc bnc" id="L49" title="All 2 branches missed.">		for (Profile profile : profiles) {</span>
			//For each profile, we need to keep track of the total weight of all the historical weeks in the profile.
<span class="nc" id="L51">			int totalWeight = 0;</span>
			//When creating the forecasted lists (based on the historical lists) we need to adjust the
			//length of that list based on a ratio of the associated week's weight versus the total weight
			//(see recalculateLengths).
<span class="nc" id="L55">			retVal.put(profile.getInterval(), new ArrayList&lt;OutboundCallsList&gt;());</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">			for (ProfileEntry historyWeek : profile.getProfileEntries()) {</span>
<span class="nc" id="L57">				List&lt;OutboundCallsList&gt; callList = createForecastedOutboundCallsList(profile.getInterval(),</span>
<span class="nc" id="L58">						historyWeek.getHistoryPeriod(), profile.getForecastProfile().getID());</span>
<span class="nc" id="L59">				retVal.get(profile.getInterval()).addAll(callList);</span>
<span class="nc" id="L60">				totalWeight += historyWeek.getWeight();</span>
<span class="nc" id="L61">				outboundCallsPerHistoricalWeek.put(historyWeek, callList);</span>
<span class="nc" id="L62">			}</span>
<span class="nc" id="L63">			recalculateLengths(outboundCallsPerHistoricalWeek, totalWeight);</span>
<span class="nc" id="L64">		}</span>
<span class="nc" id="L65">		return retVal;</span>
	}

	/**
	 * Calculates the number of calls in a forecasted list by taking the number of calls in the historical
	 * list and multiplying that by the associated history period's weight.
	 */
	private void recalculateLengths(Map&lt;ProfileEntry, List&lt;OutboundCallsList&gt;&gt; lists, int totalWeight) {
<span class="nc bnc" id="L73" title="All 2 branches missed.">		for (Map.Entry&lt;ProfileEntry, List&lt;OutboundCallsList&gt;&gt; entry : lists.entrySet()) {</span>
<span class="nc" id="L74">			List&lt;OutboundCallsList&gt; callsList = entry.getValue();</span>
			//When you add a historical week, the lists from that week if any are added to the forecasted list,
			//the lengths of the resulting forecasted lists are calculated by multiplication of each of the list's
			//length by (the weight of its historical week) / (total weight of the historical weeks in the profile).
<span class="nc bnc" id="L78" title="All 2 branches missed.">			for (OutboundCallsList list : callsList) {</span>
<span class="nc" id="L79">				list.setNumberOfCallsToMake((int) (list.getNumberOfCallsToMake() * entry.getKey().getWeight() / totalWeight));</span>
<span class="nc" id="L80">			}</span>
<span class="nc" id="L81">		}</span>
<span class="nc" id="L82">	}</span>

	/**
	 * Creates forecasted lists for the given profileWeek by finding the historical lists associated to the given history period
	 * and then translating those into forecasted lists for the given profileWeek.
	 */
	private List&lt;OutboundCallsList&gt; createForecastedOutboundCallsList(TimeIntervalAtTime profileWeek,
			ProfileEntryHistoryPeriod historyPeriod, ID forecastProfileId) throws BbmFinderException {
<span class="nc" id="L90">		List&lt;OutboundCallsList&gt; outboundCalls = new ArrayList&lt;OutboundCallsList&gt;();</span>
<span class="nc" id="L91">		List&lt;QueueList&gt; intersectingHistory = findIntersectingHistoricalLists(historyPeriod);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">		for (QueueList history : intersectingHistory) {</span>
<span class="nc" id="L93">			HashSet&lt;DateRange&gt; adjustedDateRanges = new HashSet&lt;DateRange&gt;();</span>

			//If the history period is a custom week, then if several days of the period intersect
			//with a historical list then we need to add a forecasted list for each day that intersects.
<span class="nc bnc" id="L97" title="All 2 branches missed.">			if (historyPeriod.getIntervalType().equals(ProfileEntryIntervalType.CustomWeek)) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">				for (TimeIntervalAtTime dayInterval : historyPeriod.getIntervalsInPeriod()) {</span>
<span class="nc bnc" id="L99" title="All 4 branches missed.">					if (dayInterval != null &amp;&amp; doesHistoryDayIntersectList(history, dayInterval)) {</span>
<span class="nc" id="L100">						adjustedDateRanges.add(createAdjustedDateRange(history, profileWeek,</span>
<span class="nc" id="L101">								dayInterval.getStartTime(), dayInterval.getEndTime()));</span>
					}
<span class="nc" id="L103">				}</span>
			} else {	//Regular week or monthly
<span class="nc" id="L105">				adjustedDateRanges.add(</span>
<span class="nc" id="L106">						createAdjustedDateRange(history, profileWeek,</span>
<span class="nc" id="L107">								historyPeriod.getEarliestDayIntervalInPeriod().getStartTime(),</span>
<span class="nc" id="L108">								historyPeriod.getLatestDayIntervalInPeriod().getEndTime()));</span>
			}

<span class="nc bnc" id="L111" title="All 2 branches missed.">			for (DateRange adjustedDateRange : adjustedDateRanges) {</span>
<span class="nc" id="L112">				ForecastProfileList list = createForecastedListFrom(adjustedDateRange.start,</span>
<span class="nc" id="L113">						adjustedDateRange.end, history.getLength(), history.getRetries(), forecastProfileId);</span>
<span class="nc" id="L114">				outboundCalls.add(new OutboundCallsList(queue, list));</span>
<span class="nc" id="L115">			}</span>
<span class="nc" id="L116">		}</span>
<span class="nc" id="L117">		return outboundCalls;</span>
	}

	/**
	 * Finds the historical lists that are associated to the given history period.
	 */
	private List&lt;QueueList&gt; findIntersectingHistoricalLists(ProfileEntryHistoryPeriod historyPeriod) throws BbmFinderException {
<span class="nc" id="L124">		List&lt;QueueList&gt; intersection = new ArrayList&lt;QueueList&gt;();</span>
<span class="nc" id="L125">		Collection&lt;QueueList&gt; historicalLists = getHistoricalOutboundCallLists();</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">		for (QueueList list : historicalLists) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (thereIsIntersectionBetween(list, historyPeriod)) {</span>
<span class="nc" id="L128">				intersection.add(list);</span>
			}
<span class="nc" id="L130">		}</span>
<span class="nc" id="L131">		return intersection;</span>
	}

	/**
	 * Determines if there is an intersection between the given historical list and historyPeriod.  It will
	 * check each day interval in the history period to see if any of the days in that period intersect with
	 * the date range of the forecasted list; if at least one day intersects this method returns true.
	 */
	private boolean thereIsIntersectionBetween(QueueList list, ProfileEntryHistoryPeriod historyPeriod) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">		for (TimeIntervalAtTime dayInterval : historyPeriod.getIntervalsInPeriod()) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">			if (dayInterval != null) {</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">				if (list.getStartTime().after(dayInterval.getEndTime()) ||</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">						list.getEndTime().before(dayInterval.getStartTime())) {</span>
<span class="nc" id="L144">					continue;</span>
				} else {
<span class="nc" id="L146">					return true;</span>
				}
			}
<span class="nc" id="L149">		}</span>

<span class="nc" id="L151">		return false;</span>
	}

	/**
	 * This method is used for custom week history periods to determine if a day in the custom week intersects
	 * with the given historical list (QueueList).
	 */
	private boolean doesHistoryDayIntersectList(QueueList list, TimeIntervalAtTime dayInterval) {
<span class="nc bnc" id="L159" title="All 2 branches missed.">		if (list.getStartTime().after(dayInterval.getEndTime()) ||</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">				list.getEndTime().before(dayInterval.getStartTime())) {</span>
<span class="nc" id="L161">			return false;</span>
		}
<span class="nc" id="L163">		return true;</span>
	}

	/**
	 * Creates a forecasted list value object with the given parameters.
	 */
	public ForecastProfileList createForecastedListFrom(Date startTime, Date endTime,
			int numberOfCallsToMake, int numberOfAllowedRetries, ID forecastProfileId) {
<span class="nc" id="L171">		ForecastProfileList listToWrap = new ForecastProfileList();</span>
<span class="nc" id="L172">		listToWrap.setQueueId(queue.getID());</span>
<span class="nc" id="L173">		listToWrap.setStartTime(startTime);</span>
<span class="nc" id="L174">		listToWrap.setEndTime(endTime);</span>
<span class="nc" id="L175">		listToWrap.setLength(numberOfCallsToMake);</span>
<span class="nc" id="L176">		listToWrap.setRetries(numberOfAllowedRetries);</span>
<span class="nc" id="L177">		listToWrap.setProfileId(forecastProfileId);</span>
<span class="nc" id="L178">		return listToWrap;</span>
	}

	/**
	 * Creates and returns a DateRange object that is used to create a new forecasted list.  For every history period
	 * that intersects with a historical list, we will create and return a DateRange object.  For custom week history
	 * periods, any day in the history period that intersects will have a DateRange object created.
	 * @param historyList
	 * @param profileWeek
	 * @param startOfHistoryPeriodInterval - The start of the history period.  In the case of a custom week history period,
	 * it is the start of the day in the period that intersects with the historical list.
	 * @param endOfHistoryPeriodInterval - The end of the history period.  In the case of a custom week history period,
	 * it is the end of the day in the period that intersects with the historical list.
	 * @return - DateRange object that is later used to create a forecasted list.
	 */
	private DateRange createAdjustedDateRange(QueueList historyList, TimeIntervalAtTime profileWeek,
			Date startOfHistoryPeriodInterval, Date endOfHistoryPeriodInterval) {
		/*
		If the history list starts X days before the picked history week, we subtract X many days from the start of
			the current SP week to calculate the start of the forecasted list.
		If the history list starts X days after the picked history week, we add X many days to the start of the
			current SP week to calculate the start of the forecasted list.
		If the history list ends X days before the picked history week, we subtract X many days from the end of
			the current SP week to calculate the end of the forecasted list.
		If the history list ends X days after the picked history week, we add X many days to the end of the
				current SP week to calculate the end of the forecasted list.
		 */
<span class="nc" id="L205">		TimeZone tz = timeContext.getTimeZone();</span>
<span class="nc" id="L206">		Calendar calListStart = Calendar.getInstance(tz);</span>
<span class="nc" id="L207">		Calendar calListEnd = Calendar.getInstance(tz);</span>
<span class="nc" id="L208">		calListStart.setTime(historyList.getStartTime());</span>
<span class="nc" id="L209">		calListEnd.setTime(historyList.getEndTime());</span>

<span class="nc" id="L211">		Calendar calHistoryWeekStart = createCalendarFreeOfTime(tz, startOfHistoryPeriodInterval);</span>
<span class="nc" id="L212">		Calendar calHistoryWeekEnd = createCalendarFreeOfTime(tz, endOfHistoryPeriodInterval);</span>

<span class="nc" id="L214">		Calendar calAdjustedPeriodStart = createCalendarFreeOfTime(tz, profileWeek.getStartTime());</span>
<span class="nc" id="L215">		Calendar calAdjustedPeriodEnd = createCalendarFreeOfTime(tz, profileWeek.getEndTime());</span>

<span class="nc" id="L217">		int days = getDaysBetween(calHistoryWeekStart, calListStart);</span>
<span class="nc" id="L218">		calAdjustedPeriodStart.add(Calendar.DATE, days);</span>

<span class="nc" id="L220">		int listStartHour = calListStart.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L221">		int listStartMinute = calListStart.get(Calendar.MINUTE);</span>

<span class="nc" id="L223">		int listEndHour = calListEnd.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L224">		int listEndMinute = calListEnd.get(Calendar.MINUTE);</span>

<span class="nc" id="L226">		calAdjustedPeriodStart.set(Calendar.HOUR_OF_DAY, listStartHour);</span>
<span class="nc" id="L227">		calAdjustedPeriodStart.set(Calendar.MINUTE, listStartMinute);</span>
<span class="nc" id="L228">		calAdjustedPeriodEnd.set(Calendar.HOUR_OF_DAY, listEndHour);</span>
<span class="nc" id="L229">		calAdjustedPeriodEnd.set(Calendar.MINUTE, listEndMinute);</span>

<span class="nc" id="L231">		Date start = calAdjustedPeriodStart.getTime();</span>
<span class="nc" id="L232">		days = getDaysBetween(calHistoryWeekEnd, calListEnd);</span>
<span class="nc" id="L233">		calAdjustedPeriodEnd.add(Calendar.DATE, days);</span>
<span class="nc" id="L234">		Date end = calAdjustedPeriodEnd.getTime();</span>
		// You need to keep the time portion of the intersecting history list!
<span class="nc" id="L236">		return new DateRange(start, end);</span>
	}

	/**
	 * Returns a Calendar with the specified date, but with the time values
	 * zeroed out (hours, minutes, seconds, and milliseconds).
	 */
	private Calendar createCalendarFreeOfTime(TimeZone tz, Date date) {
<span class="nc" id="L244">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L245">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L246">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L247">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L248">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L249">		cal.setTime(date);</span>
<span class="nc" id="L250">		return cal;</span>
	}

	private int getDaysBetween (Calendar d1, Calendar d2) {
<span class="nc" id="L254">		int multiplier = 1;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (d1.after(d2)) {  // swap dates so that d1 is start and d2 is end</span>
<span class="nc" id="L256">			java.util.Calendar swap = d1;</span>
<span class="nc" id="L257">			d1 = d2;</span>
<span class="nc" id="L258">			d2 = swap;</span>
<span class="nc" id="L259">			multiplier = -1;</span>
		}
<span class="nc" id="L261">		int days = d2.get(java.util.Calendar.DAY_OF_YEAR) -</span>
<span class="nc" id="L262">				d1.get(java.util.Calendar.DAY_OF_YEAR);</span>
<span class="nc" id="L263">		int y2 = d2.get(java.util.Calendar.YEAR);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">		if (d1.get(java.util.Calendar.YEAR) != y2) {</span>
<span class="nc" id="L265">			d1 = (java.util.Calendar) d1.clone();</span>
			do {
<span class="nc" id="L267">				days += d1.getActualMaximum(java.util.Calendar.DAY_OF_YEAR);</span>
<span class="nc" id="L268">				d1.add(java.util.Calendar.YEAR, 1);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">			} while (d1.get(java.util.Calendar.YEAR) != y2);</span>
		}
<span class="nc" id="L271">		return days * multiplier;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>