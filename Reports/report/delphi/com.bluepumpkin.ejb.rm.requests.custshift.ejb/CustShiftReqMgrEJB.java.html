<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CustShiftReqMgrEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.custshift.ejb</a> &gt; <span class="el_source">CustShiftReqMgrEJB.java</span></div><h1>CustShiftReqMgrEJB.java</h1><pre class="source lang-java linenums">/*
 * CustShiftReqMgrEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.custshift.ejb;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.AgentsGoodStandingValidationRule;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.CustShiftRequestGapBlocksNotChangedValidationRule;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.CustShiftValidationCache;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.ShiftExistValidationRule;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.VerifyOnlyOneShiftPerDay;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil;
import com.witness.ejb.core.security.PrivilegeKeys;


/**
 * EJB for CustShiftReq
 * &lt;p/&gt;
 * Caveats:
 * &lt;p&gt; If a series of interface methods are invoked, then any method that accepts a request,
 * instead of a request ID, needs to be used with caution.  For instance if after calling createRequest(),
 * the same request is passed to ApproveRequest(), it will still have the deleteAllChildren flag set.
 * Although this flag was reset during
 * the backend processing of the request during createRequest(), the updated request is not marshalled
 * back to the webtier and hence the request in the webtier still retains it.
 */
//OUTSIDE_CONTAINER
<span class="nc" id="L69">public class CustShiftReqMgrEJB extends RequestAggregateManager {</span>
<span class="nc" id="L70">    private static final String m_className = CustShiftReqMgrEJB.class.getName();</span>
<span class="nc" id="L71">    private static final Category m_cat = Log.initCategory(m_className);</span>

    /**
     * Array of hard validation classes
     */
<span class="nc" id="L76">    protected static final ValidatorDescriptor[] m_hardValidatorDescriptorArr = {</span>
    		//Ensure that the employee is in good standing
<span class="nc" id="L78">            new ValidatorDescriptor(AgentsGoodStandingValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, </span>
				null, CustShiftReq.DL_BASIC),

            //Ensure the shift assignment hasn't changed
<span class="nc" id="L82">            new ValidatorDescriptor(ShiftExistValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, </span>
				null, CustShiftReq.DL_BASIC),

            //Ensure the gap being used in the existing shift assignment hasn't changed
<span class="nc" id="L86">            new ValidatorDescriptor(CustShiftRequestGapBlocksNotChangedValidationRule.class.getName(), </span>
				RequestUtil.METHODTYPE_ALL, null, CustShiftReq.DL_BASIC),

            //Ensure only one shift per day per employee
<span class="nc" id="L90">            new ValidatorDescriptor(VerifyOnlyOneShiftPerDay.class.getName(), RequestUtil.METHODTYPE_ALL, </span>
				null, CustShiftReq.DL_BASIC)
    };

<span class="nc" id="L94">    private static final ValidatorDescriptor[] m_softValidatorDescMandArr = {};</span>

    {
<span class="nc" id="L97">        super.init(CustShiftReqMgrEJB.class.getName());</span>
<span class="nc" id="L98">    }</span>

    /**
     * override the base class to provide the appropriate logging category
     */
    @Override
	protected Category getCategory() {
<span class="nc" id="L105">        return m_cat;</span>
    }

    /**
     * Return the possible states for a request of this type.
     *
     * @return a List of the possible states for requests of this type.
     */
    @Override
	public List getPossibleStates() {
<span class="nc" id="L115">        return RequestAuditTrail.CS_POSSIBLE_STATES;</span>
    }

    @Override
	protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc" id="L120">        return m_hardValidatorDescriptorArr;</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidatorDescriptorsMandatory()
      */
    @Override
	protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc" id="L128">        return m_softValidatorDescMandArr;</span>
    }

    @Override
	protected RequestAggregateDAO getDAO(long detailLevel) {
<span class="nc" id="L133">        return new CustShiftReqDAO(detailLevel);</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestManager()
      */
    @Override
	protected IRequestType getRequestManager() throws Exception {
<span class="nc" id="L141">        return RequestUtil.getRmManagerFactory().getCustShiftReqMgr();</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestType()
      */
    @Override
	protected String getRequestType() {
<span class="nc" id="L149">        return Request.REQUESTTYPE_CUSTSHIFT;</span>
    }

    /**
     * /* (non-Javadoc)
     *
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#createRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    @Override
	protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L159">        updateExpiryDate((CustShiftReq) reqAgg);</span>
<span class="nc" id="L160">        super.createRequestPreProcess(reqAgg, reqAggDAO);</span>
<span class="nc" id="L161">    }</span>

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestPostProcess(java.util.Collection)
      */
    @Override
	protected void getRequestPostProcess(Collection reqAggs, long detailLevel) throws Exception {
        // Note: If this method is implemented, use the following code snippet to determine if
        // postProcessing must be done or not.
<span class="nc" id="L170">    }</span>

    //TODO: use the parameter loadedFromDB.
    @Override
	protected RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
                                                       boolean loadedFromDB) throws Exception {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        boolean needToAllocDAO = (reqAggDAO == null);</span>
        try {
<span class="nc" id="L178">            CustShiftReq custShiftReq = (CustShiftReq) reqAgg;</span>

            // ID must be set in objValue
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (custShiftReq.getID() == null) {</span>
<span class="nc" id="L182">                throw new IllegalArgumentException();</span>
            }

            // obtain old request
<span class="nc" id="L186">            long detailLevel = CustShiftReq.DL_BASIC;</span>
<span class="nc" id="L187">            CustShiftReq ssrFromDB = null;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null) ? getDAO(detailLevel) : reqAggDAO;</span>
<span class="nc" id="L189">            ssrFromDB = (CustShiftReq) reqAggDAO.getRequestByID(custShiftReq.getID(), detailLevel);</span>

            // Validate that the request is not changing EmployeeFor
<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (!custShiftReq.getEmployeeID().equals(ssrFromDB.getEmployeeID())) {</span>
<span class="nc" id="L193">                throw RequestUtil.createRmException(RmEjbLogBundleKey.CANNOT_CHANGE_EMPLOYEEID,</span>
<span class="nc" id="L194">                        custShiftReq.getID(), custShiftReq.getEmployeeID(), ssrFromDB.getEmployeeID(), m_cat);</span>
            }

            // Cannot modify approved requests
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (ssrFromDB.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L199">                throw RequestUtil.createRmException(RmEjbLogBundleKey.CANNOT_UPDATE_APPROVED_REQUESTS,</span>
<span class="nc" id="L200">                        custShiftReq.getID(), m_cat);</span>
            }

<span class="nc" id="L203">            updateExpiryDate(custShiftReq);</span>

            // If status is not set or empty, it is an error
<span class="nc" id="L206">            String status = custShiftReq.getRequestStatus();</span>
<span class="nc bnc" id="L207" title="All 4 branches missed.">            if (!StringUtil.isEmpty(status) &amp;&amp; !RequestAuditTrail.CS_POSSIBLE_STATES.contains(status)) {</span>
<span class="nc" id="L208">                throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_REQUEST_STATUS, new Object[]{status}, m_cat);</span>
            }
<span class="nc" id="L210">            return custShiftReq;</span>
        } finally {
<span class="nc bnc" id="L212" title="All 8 branches missed.">            if (needToAllocDAO &amp;&amp; reqAggDAO != null) {</span>
<span class="nc" id="L213">				reqAggDAO.cleanUp();</span>
			}
        }
    }

    /**
     * Note: This overrides RequestAggregateManager.changeRequestStateByID() and does not call
     * the overridden method.  Instead it calls _changeRequestStateByID() directly (which is also
     * called by ReqAggMgr.changeRequestStateByID()).
     * &lt;p/&gt;
     * Runs the request status modification and autoprocess in separate transactions.
     * TODO: change transaction attribute to Required (currently NotRequired).
     * &lt;p/&gt;
     * {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(ID, String, String, String) changeRequestStateByID}
     */
    @Override
	public void changeRequestStateByID(ID reqID, String newState, String objVerNum, String comment)
			throws Exception {
<span class="nc" id="L231">        String methodName = &quot;changeRequestStateByID&quot;;</span>
<span class="nc" id="L232">        methodStart(methodName, reqID, newState, objVerNum, comment);</span>

<span class="nc" id="L234">        CustShiftReqDAO csDao = null;</span>
<span class="nc" id="L235">        String setterID = m_className + '.' + methodName;</span>
<span class="nc" id="L236">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L238">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L240">            CustShiftReqMgr custShiftMgr = RequestUtil.getRmManagerFactory().getCustShiftReqMgr();</span>
<span class="nc" id="L241">			checkChangeRequestStatePrivilege(reqID, newState);</span>

            // call ReqAggMgr._changeRequestByID instead of ReqAggMgr.changeRequestByID().
            // ReqAggMgr.changeRequestByID() internally calls ReqAggMgr._changeRequestByID().
            // In effect this is the same as this overriding method calling the overridden method for
            // code reuse.
            // ********** Note: bracketed by its own transaction. *************
            // ********* Note: This takes care of notifications as well **********
<span class="nc" id="L249">            custShiftMgr._changeRequestStateByID(reqID, newState, objVerNum, comment);</span>

            // if new state is pending, do auto processing.
<span class="nc bnc" id="L252" title="All 4 branches missed.">            if ((newState != null) &amp;&amp; newState.equals(RequestAuditTrail.STATUS_PENDING)) {</span>
                // After creation, refetch to refresh ValueObjectRoot.objectVersionNumber.  Otherwise
                // a MultiUserException will be thrown during auto processing approve or deny.
                //TODO: this runs bare without a transaction
<span class="nc" id="L256">                long detailLevel = getDetailLevelForValidation();</span>
<span class="nc" id="L257">                csDao = new CustShiftReqDAO(detailLevel);</span>
<span class="nc" id="L258">                CustShiftReq custShiftReq = (CustShiftReq) csDao.getRequestByID(reqID, detailLevel);</span>

                //verify again, in case request marked invalid by _changeRequestStateByID() above.
<span class="nc bnc" id="L261" title="All 2 branches missed.">                if (custShiftReq.isPending()) {</span>
                    // this is bracketed by its own transaction.
<span class="nc" id="L263">                    custShiftMgr._autoProcess(custShiftReq, comment, true);</span>
                }
            }
<span class="nc" id="L266">        } catch (RmHardValidationException e) {</span>

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L271">            handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L272">            throw e;</span>
<span class="nc" id="L273">        } catch (MultiUserException e) {</span>
<span class="nc" id="L274">            handleException(e);</span>
<span class="nc" id="L275">            throw e;</span>
<span class="nc" id="L276">        } catch (Exception e) {</span>
			//not a transaction participant
<span class="nc" id="L278">            handleException(e, false);</span>
<span class="nc" id="L279">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L281" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L282">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L284" title="All 4 branches missed.">            if (csDao != null) {</span>
<span class="nc" id="L285">				csDao.cleanUp();</span>
			}
<span class="nc" id="L287">            methodFinish();</span>
<span class="nc" id="L288">        }</span>
<span class="nc" id="L289">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_undoRequestAndSchedule(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    @Override
	protected void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, Object[] optUndoData) throws Exception {
<span class="nc" id="L296">    }</span>

    /**
     * Approve a custom shift request. This entails deleting any old shift, scheduling the new shift (including any OT),
     * publishing, updating Adjusted FTE and Adjusted Staffing, and updating the request as approved.
     * @param reqAgg
     * @param choiceID
     * @param comment
     * @param suppressPrivChk
     * @param loadedFromDB
     * @throws Exception
     */
	@Override
	protected void _approveRequest(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment, boolean suppressPrivChk,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L311">        String methodName = &quot;_approveRequest&quot;;</span>
<span class="nc" id="L312">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, choiceIDs, comment, new Boolean(suppressPrivChk)));</span>

<span class="nc" id="L314">		CustShiftReq custShiftReq = (CustShiftReq) reqAgg;</span>
<span class="nc" id="L315">        _doApproveRequest(custShiftReq);</span>
<span class="nc" id="L316">        _updateRequest(reqAgg, RequestAuditTrail.STATUS_APPROVED, comment, RequestAuditTrail.STATUS_APPROVED, true, true, loadedFromDB);</span>
<span class="nc" id="L317">        m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L318">    }</span>
	public static ID _doApproveRequest(CustShiftReq custShiftReq) throws Exception {
<span class="nc" id="L320">		return _doApproveRequest(custShiftReq, false);</span>
	}
	public static ID _doApproveRequest(CustShiftReq custShiftReq, boolean forFlexMakeup) throws Exception {
        // perform status transistion validation, privilege checking, hard validations and then
        // update request status to approved.

        //_updateRequest(custShiftReq, RequestAuditTrail.STATUS_APPROVED, comment, RequestAuditTrail.STATUS_APPROVED, suppressPrivChk, loadedFromDB);
        /*start of cust shift creation*/
<span class="nc" id="L328">        CustShiftValidationCache cache = (CustShiftValidationCache) custShiftReq.getValidationCache();</span>
<span class="nc" id="L329">        TimeSeriesManager tsm = cache.getTimeSeriesManager();</span>
<span class="nc" id="L330">        ScheduleAccessManager sam = cache.getScheduleAccessManager();</span>

<span class="nc" id="L332">        ShiftAssignment shifttoDelete = cache.getExistingShiftAssignToBeDeleted(custShiftReq, sam);</span>
<span class="nc" id="L333">        ShiftAssignment shiftAssn = cache.getNewShiftAssignToBeCreated(forFlexMakeup, custShiftReq, sam);</span>

<span class="nc" id="L335">		Map recalAfterCreate = null;</span>
<span class="nc" id="L336">        boolean staffingExists = cache.doesStaffingExistForPeriod(custShiftReq);</span>
		// get the trace cubes only if staffingExists is true for the given period
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (staffingExists) {</span>
<span class="nc" id="L339">            NetStaffingCube nsCube = cache.getPostCSApprovalNetStaffingCube(custShiftReq);</span>
<span class="nc" id="L340">            recalAfterCreate = cache.getPostCustShiftReqTraceCube(custShiftReq, sam, tsm, nsCube.getTimeRange());</span>
        }

<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (shifttoDelete != null) {</span>
            // before deleting shift, get published schedule to recalc
            //note: the shift in unpub and pub must be in-sync
            //Collection events = sam.getPublishedEventsForWorkResource(custShiftReq.getEmployeeID(), timeSeriesRangeStart, timeSeriesRangeEnd);
            //recalcAfterDelete = tsm.reCalcAdjustedFTEAndStaffing(null, tmRange, events, shifttoDelete, true);
<span class="nc" id="L348">            ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L349">            list.add(shifttoDelete.getID());</span>
<span class="nc" id="L350">            sam.deleteShiftAssignments(list);</span>
            //sam.publishSchedule(shifttoDelete.getWorkResourceIDs(), shifttoDelete.getStartTime(), shifttoDelete.getEndTime());

        }

        //before creating shift, we have to clean up the overlapped unavailability if there is any, otherwise, creating shift will fail
<span class="nc" id="L356">        ShiftSwapRequestUtil.deleteUnderlyingUnavailabilities(custShiftReq.getEmployeeID(), shiftAssn.getStartTime(), </span>
<span class="nc" id="L357">			shiftAssn.getEndTime(), sam);</span>
<span class="nc" id="L358">        ID shiftAssignmentID = sam.createShiftAssignment(shiftAssn);</span>
        /*end of creation */

        // publish the changes
<span class="nc" id="L362">        sam.publishSchedule(shiftAssn.getWorkResourceIDs(), shiftAssn.getStartTime(), shiftAssn.getEndTime());</span>

        // QC138233, unPublish the shift assignment if the whole new time period is outside of the old new time period ( before the old start date or after the old endate)
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (shifttoDelete != null) {</span>
			//  before the old startdate
<span class="nc bnc" id="L367" title="All 2 branches missed.">        	boolean isNewEndTimeSmallerEqualOldStartTime= DateTimeUtil.compareDate(shiftAssn.getEndTime(), </span>
<span class="nc" id="L368">				shifttoDelete.getStartTime(), false) &lt;= 0;</span>
			//  after the old enddate
<span class="nc bnc" id="L370" title="All 2 branches missed.">            boolean isNewStartimeGreaterEqualOldEndTime= DateTimeUtil.compareDate(shiftAssn.getStartTime(), </span>
<span class="nc" id="L371">				shifttoDelete.getEndTime(), false) &gt;= 0; </span>
<span class="nc bnc" id="L372" title="All 6 branches missed.">        	if ( custShiftReq.getSubType()== CustShiftReq.REQUEST_SUB_TYPE_REG_SHIFT_CHANGE.toInt() &amp;&amp; </span>
				(isNewEndTimeSmallerEqualOldStartTime||isNewStartimeGreaterEqualOldEndTime)
        		) {
					// Shift Change
<span class="nc" id="L376">        			sam.unPublishSchedule(shifttoDelete.getWorkResourceIDs(), shifttoDelete.getStartTime(), </span>
<span class="nc" id="L377">						shifttoDelete.getEndTime());</span>
        		}
        }
        //recalc after publish the approval
        //Collection events = sam.getPublishedEventsForWorkResource(custShiftReq.getEmployeeID(), timeSeriesRangeStart, timeSeriesRangeEnd);
        //Collection recalAfterCreate = tsm.reCalcAdjustedFTEAndStaffing(recalcAfterDelete, tmRange, events, sam.getShiftAssignmentByID(shiftAssignmentID), false);
		// update the trace cubes only if staffingExists is true for the given period
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (staffingExists) {</span>
<span class="nc" id="L385">            tsm.updateAdjustedFTEAndStaffing(recalAfterCreate);</span>
        }
        // returning this Id to update the flexmakeuprequest table with latest shift assignment details
        // so that it can be used later to pull the approved flex requests through a filter
<span class="nc" id="L389">        return shiftAssignmentID;</span>
	}

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
      */
	@Override
	protected void _approveRequestPostProcess(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment) {
<span class="nc" id="L397">    }</span>

    @Override
	protected void _approveRequestTentatively(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceID, String comment, boolean loadedFromDB)
			throws Exception {
<span class="nc" id="L402">        throw new UnsupportedOperationException(m_tentativeNotImplemented + reqAgg);</span>
    }

    @Override
	protected void _denyRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) 
		throws Exception {
<span class="nc" id="L408">        String methodName = &quot;_denyRequest&quot;;</span>
<span class="nc" id="L409">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment, new Boolean(suppressPrivilegeChecking)));</span>
        // update status to denied (after status transistion validation, privilege checking and hard validations).
<span class="nc" id="L411">        _updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L412">        m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L413">    }</span>

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
      */
    @Override
	protected void _denyRequestPostProcess(RequestAggregate reqAgg, String comment) {
<span class="nc" id="L420">    }</span>

    @Override
	protected RequestAggregate _undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment) throws Exception {
<span class="nc" id="L424">        throw new UnsupportedOperationException(m_tentativeNotImplemented);</span>
    }

    /**
     * Compute the expiration date, The expiration is equal to start date.
     */
    protected static void updateExpiryDate(CustShiftReq custShiftReq) {
<span class="nc bnc" id="L431" title="All 4 branches missed.">    	if(LicenseUtil.isAdvancedRMLicense() &amp;&amp; custShiftReq.isInPastDate()) {</span>
<span class="nc" id="L432">            custShiftReq.setExpirationDate(new Date(RequestUtil.MAX_DATE.getTime()));</span>
    	} else {
<span class="nc" id="L434">            custShiftReq.setExpirationDate(custShiftReq.getStartTime());</span>
    	}
<span class="nc" id="L436">    }</span>

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDPurge()
      */
    @Override
	protected ID getPrivIDPurge() {
<span class="nc" id="L443">        return PrivilegeKeys.CS_PURGEREQUESTS_ID;</span>
    }

    /**
     * Add columns necessary to process a query governed by the given filter.  The caller has already
     * added columns from the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.  Columns from
     * new tables should start with D as a column synonym.  See
     * {@link #addToFromClause addToFromClause} for how the from clause is modified,
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Columns added by this
     * method should insert a leading comma.
     *
     * @param selectClause  the string buffer being constructed, the generic columns have already been
     *                      added, this method should append its columns.
     * @param requestFilter the request filter
     */
    @Override
	public void addToSelectColumns(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L463">        query.append(&quot;, CSR.STARTTIME, CSR.ENDTIME &quot;);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (sortColumn == Request.SORT_CS_CAMPAIGN) {</span>
<span class="nc" id="L465">            query.append(&quot;, CAMP.NAME &quot;);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SHIFTID) {</span>
<span class="nc" id="L467">            query.append(&quot;, SHIFT.NAME &quot;);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L469">            query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_STARTTIME) {</span>
<span class="nc" id="L471">            query.append(&quot;, CSR.STARTTIME &quot;);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ENDTIME) {</span>
<span class="nc" id="L473">            query.append(&quot;, CSR.ENDTIME &quot;);</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ISOT) {</span>
<span class="nc" id="L475">            query.append(&quot;, CSR.ISOT, CSR.SHIFTID &quot;);</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREID) {</span>
<span class="nc" id="L477">            query.append(&quot;, EXTS.NAME &quot;);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID) {</span>
<span class="nc" id="L479">            query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREISOT) {</span>
<span class="nc" id="L481">            query.append(&quot;, CSR.EXTBEFOREISOT, CSR.EXTBEFOREID  &quot;);</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTINGAPSID) {</span>
<span class="nc" id="L483">            query.append(&quot;, EXTS.NAME &quot;);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTINGAPSACTIVITYID) {</span>
<span class="nc" id="L485">            query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERID) {</span>
<span class="nc" id="L487">            query.append(&quot;, EXTS.NAME &quot;);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L489">            query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERISOT) {</span>
<span class="nc" id="L491">            query.append(&quot;, CSR.EXTAFTERISOT, CSR.EXTAFTERID  &quot;);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SUBTYPE) {</span>
<span class="nc" id="L493">            query.append(&quot;, CSR.SUBTYPE &quot;);</span>
        }
<span class="nc" id="L495">    }</span>

    /**
     * Add tables necessary to process a query governed by the given filter.  The caller has already
     * added the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.
     * New tables should start with D as a column synonym.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Tables added by this
     * method should insert a leading comma.
     *
     * @param fromClause    the string buffer being constructed, the generic tables have already been
     *                      added, this method should append its tables with a leading comma and start with D as a synonym.
     * @param requestFilter the request filter
     */
    @Override
	public void addToFromClause(StringBuffer fromClause, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L514">        fromClause.append(&quot;, CUSTSHIFTREQ CSR &quot;);</span>
        //join for the extension into gaps
<span class="nc bnc" id="L516" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">				|| requestFilter.isKeySet(RequestFilter.CS_ACTIVITYID_KEY)</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">				|| requestFilter.isKeySet(RequestFilter.CS_EXTID_KEY)</span>
<span class="nc bnc" id="L519" title="All 6 branches missed.">				|| &quot;0&quot;.equals(requestFilter.getValueForKey(RequestFilter.CS_ISOT_KEY))</span>
				|| sortColumn == Request.SORT_CS_EXTINGAPSID
				|| sortColumn == Request.SORT_CS_EXTINGAPSACTIVITYID) {
<span class="nc" id="L522">			fromClause.append(&quot; LEFT JOIN CUSTSHIFTREQGAP CSRG ON CSR.ID=CSRG.CUSTSHIFTREQID &quot;);</span>
		}
        //joins for sorts &amp; filter
<span class="nc bnc" id="L525" title="All 4 branches missed.">        if (sortColumn == Request.SORT_CS_CAMPAIGN || requestFilter.isKeySet(RequestFilter.CS_CAMPAIGNID_KEY)) {</span>
<span class="nc" id="L526">            fromClause.append(&quot; LEFT JOIN (SP INNER JOIN CAMPAIGN CAMP on CAMP.ID= CAMPAIGNID) on CSR.SPID=SP.SID &quot;);</span>
        }
<span class="nc bnc" id="L528" title="All 4 branches missed.">        if (sortColumn == Request.SORT_CS_SHIFTID || requestFilter.isKeySet(RequestFilter.CS_SHIFTID_KEY)) {</span>
<span class="nc" id="L529">            fromClause.append(&quot; LEFT JOIN SHIFT on SHIFT.SID = CSR.SHIFTID &quot;);</span>
        }

        //Joins for Sorts only
<span class="nc bnc" id="L533" title="All 8 branches missed.">        if (sortColumn == Request.SORT_CS_ACTIVITYID || sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID ||</span>
        		sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID || sortColumn == Request.SORT_CS_EXTINGAPSACTIVITYID) {
<span class="nc" id="L535">            fromClause.append(&quot; LEFT JOIN ACTIVITY ACTS on ACTS.ID = &quot;);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">            if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L537">                fromClause.append(&quot; ACTIVITYID &quot;);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">            } else if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID) {</span>
<span class="nc" id="L539">                fromClause.append(&quot; EXTBEFOREACTIVITYID &quot;);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            } else if (sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L541">                fromClause.append(&quot; EXTAFTERACTIVITYID &quot;);</span>
            } else {
<span class="nc" id="L543">            	fromClause.append(&quot; CSRG.EXTGAPACTIVITYID &quot;);</span>
            }
        }
<span class="nc bnc" id="L546" title="All 6 branches missed.">        if (sortColumn == Request.SORT_CS_EXTBEFOREID || sortColumn == Request.SORT_CS_EXTAFTERID || </span>
			sortColumn == Request.SORT_CS_EXTINGAPSID) {
            //fromClause.append(&quot;,SHIFTOTEXTENSION EXTS &quot;);
<span class="nc" id="L549">            fromClause.append(&quot; LEFT JOIN SHIFTOTEXTENSION EXTS on EXTS.SID = &quot;);</span>
<span class="nc bnc" id="L550" title="All 4 branches missed.">            fromClause.append(sortColumn == Request.SORT_CS_EXTBEFOREID ? &quot; EXTBEFOREID &quot; : </span>
				(sortColumn == Request.SORT_CS_EXTAFTERID ? &quot; EXTAFTERID &quot; : &quot; CSRG.SHIFTOTGAPID &quot;));
        }
        //joins for Filters only
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_ACTIVITYID_KEY)) {</span>
<span class="nc" id="L555">            fromClause.append(&quot;, ACTIVITY ACT &quot;);</span>
        }
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_EXTID_KEY)) {</span>
<span class="nc" id="L558">            fromClause.append(&quot;, SHIFTOTEXTENSION EXT &quot;);</span>
        }
<span class="nc" id="L560">    }</span>

    /**
     * Add conditions necessary to process a query governed by the given filter.  The caller has already
     * added the generic where conditions.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToFromClause addToFromClause} for how the from clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Conditions added by this
     * method should insert a leading comma.
     *
     * @param whereClause   the string buffer being constructed, the generic where clauses have already been
     *                      added, this method should append its conditions with a leading AND and both front and rear pad with a space.
     * @param requestFilter the request filter
     */
    @Override
	public void addToWhereClause(StringBuffer whereClause, RequestFilter requestFilter, int sortColumn) {
		// join to REQUEST
<span class="nc" id="L579">        whereClause.append(&quot; AND CSR.ID=REQ.ID &quot;);</span>
        //Filter by date range
<span class="nc" id="L581">        StringsPair filteredDateRange = null;</span>

<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)) {</span>
<span class="nc" id="L584">            filteredDateRange = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L585">            String rangeStart = filteredDateRange.getKey();</span>
<span class="nc" id="L586">            String rangeEnd = filteredDateRange.getValue();</span>
<span class="nc" id="L587">            Date dtNow = new Date();</span>
<span class="nc" id="L588">            String strDtNow = JdmoUtil.formatDBString(dtNow);</span>
<span class="nc" id="L589">            whereClause.append(&quot;AND &quot;);</span>
<span class="nc" id="L590">            RmUtil.appendRequestDateRangeClauses(whereClause, &quot;&quot;, &quot;CSR&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L591">            whereClause.append(&quot; &quot;);</span>
        }
        // Filter by Campaign Name
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_CAMPAIGNID_KEY)) {</span>
<span class="nc" id="L595">            whereClause.append(&quot; AND CAMP.SID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_CAMPAIGNID_KEY));</span>
        }
        //Filter by shift Name
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_SHIFTID_KEY)) {</span>
<span class="nc" id="L599">            whereClause.append(&quot; AND SHIFT.SID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_SHIFTID_KEY));</span>
        }

		// FILTER BY ACTIVITY NAME
<span class="nc bnc" id="L603" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.CS_ACTIVITYID_KEY)) {</span>
<span class="nc" id="L604">			whereClause.append(&quot; AND (ACT.ID  IN (CSR.EXTBEFOREACTIVITYID, CSR.EXTAFTERACTIVITYID, CSR.ACTIVITYID) OR (ACT.ID=CSRG.EXTGAPACTIVITYID))&quot;);</span>
<span class="nc" id="L605">			whereClause.append(&quot; AND ACT.ID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_ACTIVITYID_KEY));</span>
		}
        //Filter by Extn name
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_EXTID_KEY)) {</span>
<span class="nc" id="L609">            whereClause.append(&quot; AND (EXT.SID in (EXTAFTERID, EXTBEFOREID) OR (EXT.SID=CSRG.SHIFTOTGAPID))&quot;);</span>
<span class="nc" id="L610">            whereClause.append(&quot; AND EXT.SID=&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_EXTID_KEY));</span>
        }
        //Filter by ISOT
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_ISOT_KEY)) {</span>
<span class="nc" id="L614">			handleIsOvertimeFilter(whereClause, requestFilter.getValueForKey(RequestFilter.CS_ISOT_KEY));</span>
        }
        //Filter by date range on extension into gap
<span class="nc bnc" id="L617" title="All 4 branches missed.">        if (requestFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY) &amp;&amp; filteredDateRange != null) {</span>
<span class="nc" id="L618">            handleFilterDateRangeOnExtensionIntoGap(whereClause, filteredDateRange);</span>
        }
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_SUBTYPE_KEY)) {</span>
<span class="nc" id="L621">            String key = requestFilter.getValueForKey(RequestFilter.CS_SUBTYPE_KEY).toString();</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            whereClause.append(&quot; AND SUBTYPE in (&quot;).append(CustShiftReq.CS_SUBTYPE_NEW_SHIFT.equals(key) ? &quot;1,2&quot; : &quot;4,8&quot;).append(&quot;) &quot;);</span>
        }
<span class="nc" id="L624">    }</span>




	/**
	 * the date range in UI filter will be used to query again the table
	 * CUSTSHIFTREQGAP (which is extension into gap)
	 *
	 * @param whereClause
	 * @param filteredDateRange
	 */
    private void handleFilterDateRangeOnExtensionIntoGap(StringBuffer whereClause, StringsPair filteredDateRange) {
<span class="nc" id="L637">		String rangeStart = filteredDateRange.getKey();</span>
<span class="nc" id="L638">		String rangeEnd = filteredDateRange.getValue();</span>
<span class="nc" id="L639">		whereClause.append(&quot; AND (CSRG.ID IS NULL OR (DATEADD(MINUTE, CSRG.EXTGAPGAP, CSRG.EXTGAPSTARTTIME) &lt; '&quot;).append(rangeEnd)</span>
<span class="nc" id="L640">				.append(&quot;' AND DATEADD(MINUTE, CSRG.EXTGAPGAP + CSRG.EXTGAPDURATION, CSRG.EXTGAPSTARTTIME) &gt;'&quot;).append(rangeStart).append(&quot;')) &quot;);</span>
<span class="nc" id="L641">	}</span>

	private void handleIsOvertimeFilter(StringBuffer whereClause, Serializable value) { // NOSONAR
<span class="nc" id="L644">		boolean dontShowOvertime = &quot;0&quot;.equals(value);</span>
<span class="nc" id="L645">		whereClause.append(&quot; AND ( &quot; );</span>
		//consider as overtime if either an extension or the whole shift request is marked as overtime
<span class="nc bnc" id="L647" title="All 2 branches missed.">		whereClause.append(String.format(&quot;1 %s IN (EXTAFTERISOT, EXTBEFOREISOT,ISOT)&quot;, dontShowOvertime ? &quot;NOT&quot; : &quot;&quot;));</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">		if(dontShowOvertime){</span>
			//Extension in gap is NOT considered as overtime. If we are not showing overtime then show extension in gap
			//This clause was originally added in commit SHA-1: 538acd2a6be1bc19bca573d560301ea553b3cc4a
			//If we are showing overtime do we need to explicitly hide these?
			//Yes, when Overtime option is selected in the filter,
			//the shift change request with &quot;extension in gap&quot; should not return as it's not overtime
<span class="nc" id="L654">			whereClause.append(&quot; OR CSRG.ID IS NOT NULL &quot;);</span>
		}
<span class="nc" id="L656">		whereClause.append(&quot; )&quot;);</span>
<span class="nc" id="L657">    }</span>



    /**
     * Add conditions necessary to process a query governed by the given filter.  The caller has already
     * added everthing but the order by clause.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToFromClause addToFromClause} for how the from clause is modified, and
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Conditions added by this
     * method should insert a leading comma.
     *
     * @param query         the string buffer being constructed, the generic where clauses have already been
     *                      added, this method should append its conditions with a leading AND and both front and rear pad with a space.
     * @param requestFilter the request filter
     * @param sortColumn    identifies the column to use to sort the requests.
     *                      The constants that define the expected values are in
     *                      {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
     * @param sortDir       This string is either &quot; ASC &quot; or &quot; DESC &quot; depending on whether or not the
     *                      sort is ascending or descending.  (Note spaces around values for convenience.)
     */
    @Override
	public void addOrderByClause(StringBuffer query, RequestFilter requestFilter, int sortColumn, String sortDir) {
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (sortColumn == Request.SORT_CS_CAMPAIGN) {</span>
<span class="nc" id="L683">            query.append(&quot; ORDER BY CAMP.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SHIFTID) {</span>
<span class="nc" id="L685">            query.append(&quot; ORDER BY SHIFT.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L687">            query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_STARTTIME) {</span>
<span class="nc" id="L689">            query.append(&quot; ORDER BY CSR.STARTTIME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ENDTIME) {</span>
<span class="nc" id="L691">            query.append(&quot; ORDER BY CSR.ENDTIME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ISOT) {</span>
<span class="nc" id="L693">            query.append(&quot; ORDER BY CSR.ISOT &quot;).append(sortDir).append(&quot; , CSR.SHIFTID &quot;).append(sortDir);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREID) {</span>
<span class="nc" id="L695">            query.append(&quot; ORDER BY EXTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID) {</span>
<span class="nc" id="L697">            query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREISOT) {</span>
<span class="nc" id="L699">            query.append(&quot; ORDER BY CSR.EXTBEFOREISOT &quot;).append(sortDir).append(&quot; , CSR.EXTBEFOREID &quot;).append(sortDir);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERID) {</span>
<span class="nc" id="L701">            query.append(&quot; ORDER BY EXTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L703">            query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERISOT) {</span>
<span class="nc" id="L705">            query.append(&quot; ORDER BY CSR.EXTAFTERISOT &quot;).append(sortDir).append(&quot; , CSR.EXTAFTERID &quot;).append(sortDir);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SUBTYPE) {</span>
<span class="nc" id="L707">            query.append(&quot; ORDER BY CSR.SUBTYPE &quot;).append(sortDir);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTINGAPSID) {</span>
<span class="nc" id="L709">            query.append(&quot; ORDER BY EXTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTINGAPSACTIVITYID) {</span>
<span class="nc" id="L711">            query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
        }
<span class="nc" id="L713">    }</span>

    @Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
            throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L718">        String methodName = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L719">        methodStart(methodName, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L721">        CustShiftReqDAO toReqDao = null;</span>
<span class="nc" id="L722">        String setterID = m_className + '.' + methodName;</span>
<span class="nc" id="L723">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L725">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L727">            String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L729">            ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (privFailedOrgID != null) {</span>
<span class="nc" id="L731">                throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
            }

<span class="nc" id="L734">            toReqDao = new CustShiftReqDAO(CustShiftReq.DL_BASIC);</span>
<span class="nc" id="L735">            toReqDao.deleteRequestsByStartDateRange(organizationId, isForBranch, range, subType);</span>
<span class="nc" id="L736">        } catch (RmHardValidationException e) {</span>
            //RM exceptions are always logged at the point where they are thrown.
            //m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L743">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L744">            throw e;</span>
<span class="nc" id="L745">        } catch (BbmRemoveException e) {</span>
<span class="nc" id="L746">            m_cat.error(e, e);</span>
<span class="nc" id="L747">            handleException(e);</span>
<span class="nc" id="L748">            throw e;</span>
<span class="nc" id="L749">        } catch (Exception e) {</span>
<span class="nc" id="L750">            handleException(e);</span>
<span class="nc" id="L751">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {        	
<span class="nc bnc" id="L753" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L754">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L756" title="All 4 branches missed.">            if (toReqDao != null) {</span>
<span class="nc" id="L757">				toReqDao.cleanUp();</span>
			}
<span class="nc" id="L759">            methodFinish();</span>
<span class="nc" id="L760">        }</span>
<span class="nc" id="L761">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>