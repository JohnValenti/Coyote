<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOValidationCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.validation</a> &gt; <span class="el_source">TOValidationCache.java</span></div><h1>TOValidationCache.java</h1><pre class="source lang-java linenums">/*
 * TOValidationCache.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.timeoff.validation;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeMap;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculator;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculatorHelper;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffDefault;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffYearly;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.PeriodsWithStaffing;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.BlackoutDay;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignment;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.setup.validation.ejb.ValidationRuleManager;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;

//TODO: all logging category objects, m_cat, must be private final

/**
 * Specialized validation cache for Time Off requests.
 */
public class TOValidationCache extends ValidationCache {
    /**
     * Logging category
     */
<span class="nc" id="L73">    private static final Category m_cat = Log.initCategory(TOValidationCache.class.getName());</span>

<span class="nc" id="L75">	private static final ID AVOID_CALENDAR_EVENT_RULE_ID = new ID(-194006);</span>

    /**
     * Key for time range represented by this request.
     */
    private static final String REQUEST_TIME_RANGE = &quot;REQUEST_TIME_RANGE&quot;;

    /**
     * Key for the collection of blackout days for this request period.
     */
    private static final String REQUEST_BLACKOUT_DAYS = &quot;REQUEST_BLACKOUT_DAYS&quot;;

    /**
     * Key for blackout days TimeMap covering the period of this request.
     */
    private static final String BLACKOUT_TIMEMAP = &quot;BLACKOUT_TIMEMAP&quot;;

    /**
     * Key for time off year month and day for this employee
     */
    private static final String EMP_TO_YEAR_MONTH_DAY = &quot;EMP_TO_YEAR_MONTH_DAY&quot;;

    /**
     * Key for time off length calculator that covers period of request
     */
    private static final String TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP =
            &quot;TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP&quot;;


    /**
     * Key for time off length calculator for a given employee and given time range.
     */
    private static final String TIME_OFF_LENGTH_CALCULATOR_FOR_EMPID =
            &quot;TIME_OFF_LENGTH_CALCULATOR_FOR_EMPID&quot;;

    /**
     * Key for default time off allotment (for day and week)
     */
    private static final String TIME_OFF_ALLOTMENT_MAP_DEFAULT =
            &quot;TIME_OFF_ALLOTMENT_MAP_DEFAULT&quot;;

    /**
     * Key for yearly time off allotment
     */
    private static final String TIME_OFF_ALLOTMENT_MAP_YEARLY =
            &quot;TIME_OFF_ALLOTMENT_MAP_YEARLY&quot;;

    /**
     * Key for the collection of published schedule periods covering the request interval
     */
    private static final String PUBLISHED_PERIODS = &quot;PUBLISHED_PERIODS&quot;;

    /**
     * Key for the collection of scheduled time off events during the request interval
     */
    //private static final String TIME_OFF_EVENTS = &quot;TIME_OFF_EVENTS&quot;;

    /**
     * Key prefix for the single time off event (unpublished) associated with the given TOChoice
     */
    private static final String CALEVENTASSIGN_FOR_TOCHOICE_ALIGNED = &quot;CALEVENTASSIGN_FOR_TOCHOICE_ALIGNED&quot;;

    /**
     * Key prefix for the single time off event (published) associated with the given TOChoice.
     */
    private static final String CALEVENTASSIGNS_FOR_TOCHOICE_OVERLAPPED = &quot;CALEVENTASSIGNS_FOR_TOCHOICE_OVERLAPPED&quot;;

    /**
     * Key for the collection of calendar time off day objects during the request interval
     */
    private static final String CALENDAR_TIME_OFF_DAYS = &quot;CALENDAR_TIME_OFF_DAYS&quot;;

    /**
     * Key for the collection of time off events for the employees in the organization during the request interval
     */
    private static final String ORG_TIME_OFF_EVENTS = &quot;ORG_TIME_OFF_EVENTS&quot;;

    /**
     * Key for the collection of  emp ids in the organization during the request interval
     */
    private static final String ORG_EMPIDS = &quot;ORG_EMPIDS&quot;;

    /**
     * Key for last published shift for employee owning TORequest
     */
    private static final String LAST_PUB_SHIFT_EMP = &quot;LAST_PUB_SHIFT_EMP&quot;;

    /**
	 * Key for TOPOOL ID that request's employee belongs to on the request start
	 * date.
	 */
	private static final String TOPOOL_FOR_REQ = &quot;TOPOOL_FOR_REQ&quot;;

    /**
     * Key for Manager's &quot;timeoff workflow active&quot; setting in the organization config.
     */
    public static final String MANAGER_TIMEOFF_WORKFLOWACTIVE = &quot;MANAGER_TIMEOFF_WORKFLOWACTIVE&quot;;

<span class="nc" id="L173">    protected static final Date MAX_DATE = new Date(Long.MAX_VALUE); // any date will be earlier</span>
<span class="nc" id="L174">    protected static final Date MIN_DATE = new Date(0L); // any date (after 1970) will be later</span>
   
<span class="nc" id="L176">    private TORequest m_tor = null;</span>
	/**
	 * Key for storing post TO Approval Netstaffing Cube
	 */
	public static final String POST_TO_APPROVAL_NETSTAFFING_CUBE = &quot;POST_TO_APPROVAL_NETSTAFFING_CUBE&quot;;
	public static final String PRE_TO_APPROVAL_NETSTAFFING_CUBE = &quot;PRE_TO_APPROVAL_NETSTAFFING_CUBE&quot;;

	private Map&lt;String, Set&lt;ID&gt;&gt; calendarEventsToAvoidCache;
	PeriodsWithStaffing periodsWithStaffing;


    /**
     * Create a new validation cache for a time off request.
     */
    public TOValidationCache(TORequest tor) {
<span class="nc" id="L191">        super(tor);</span>
<span class="nc" id="L192">        m_tor = tor;</span>

<span class="nc" id="L194">        m_cat.debug(&quot;TOValidationCache created: &quot; + toString());</span>
<span class="nc" id="L195">    }</span>

    @Override
	public String toString() {
<span class="nc" id="L199">        return m_tor.toString();</span>
    }

	public Set&lt;ID&gt; getCalendarEventsToAvoid(TOChoice toChoice) throws Exception { // NOSONAR
<span class="nc" id="L203">		return getCalendarEventsToAvoid(toChoice.getStartDate(), toChoice.getEndDate());</span>
	}

	public Set&lt;ID&gt; getCalendarEventsToAvoid(Date start, Date end) throws Exception { // NOSONAR
<span class="nc" id="L207">		ID activityID = m_tor.getRequestSubType();</span>
<span class="nc" id="L208">		ID orgId = getOrgIDForEmployeeDuringPeriod(m_tor.getEmployeeID(), start, end);</span>
<span class="nc" id="L209">		return getCalendarEventsToAvoid(activityID, orgId);</span>
	}

	private Set&lt;ID&gt; getCalendarEventsToAvoid(ID activityId, ID orgId) throws Exception { // NOSONAR
<span class="nc bnc" id="L213" title="All 2 branches missed.">		if(calendarEventsToAvoidCache==null) {</span>
<span class="nc" id="L214">			calendarEventsToAvoidCache = new HashMap&lt;String, Set&lt;ID&gt;&gt;();</span>
		}

<span class="nc" id="L217">		String key = getKey(activityId, orgId);</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">		if (calendarEventsToAvoidCache.containsKey(key)) {</span>
<span class="nc" id="L220">			return calendarEventsToAvoidCache.get(key);</span>
		}

<span class="nc" id="L223">		Set&lt;ID&gt; eventsToAvoid =  getActivityIDsToAvoid(key,activityId,orgId);</span>
<span class="nc" id="L224">		calendarEventsToAvoidCache.put(key, eventsToAvoid);</span>
<span class="nc" id="L225">		return eventsToAvoid;</span>
	}
	
	private static Set&lt;ID&gt; getActivityIDsToAvoid(String key, ID activityId, ID orgId) throws Exception { // NOSONAR

<span class="nc" id="L230">		Map&lt;String, Set&lt;ID&gt;&gt; cache = ThreadLocalCache.getMap(&quot;TOValidationCache.getActivityIDsToAvoid&quot;);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (cache.containsKey(key)) {</span>
<span class="nc" id="L232">			return cache.get(key);</span>
		}

<span class="nc" id="L235">		Set&lt;ID&gt; result = getActivityIDsToAvoidFromDb(activityId, orgId);</span>
<span class="nc" id="L236">		cache.put(key, result);</span>
<span class="nc" id="L237">		return result;</span>
	}

	private static Set&lt;ID&gt; getActivityIDsToAvoidFromDb(ID activityId, ID orgId) throws Exception { // NOSONAR
<span class="nc" id="L241">		ValidationRuleManager valMan = RmManagerFactory.getInstance().getValidationRuleManager();</span>
<span class="nc" id="L242">		Map&lt;String, Integer&gt; ruleParams = valMan.getValidationRuleParams(orgId, AVOID_CALENDAR_EVENT_RULE_ID, activityId);</span>

<span class="nc bnc" id="L244" title="All 4 branches missed.">		if (ruleParams != null &amp;&amp; ruleParams.isEmpty()) {</span>
<span class="nc" id="L245">			return Collections.emptySet();</span>
		}

<span class="nc" id="L248">		Set&lt;ID&gt; result = new HashSet&lt;ID&gt;(ruleParams.size());</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">		for (Integer idToAvoid : ruleParams.values()) {</span>
<span class="nc" id="L251">			result.add(ID.fromInt(idToAvoid));</span>
<span class="nc" id="L252">		}</span>
<span class="nc" id="L253">		return result;</span>
	}

	private static String getKey(ID activityId, ID orgId) {
<span class="nc" id="L257">		return String.format(&quot;[%s][%s]&quot;, activityId, orgId);</span>
	}


    /**
     * Get the date range represented by the choices in the request.  The
     * range is defined to be from the earliest start time to the latest
     * end time of all the choices in the time off request.
     */
    @Override
	public TimeRange getDateRange() {
<span class="nc" id="L268">		TimeRange result = (TimeRange) get(REQUEST_TIME_RANGE);</span>

        // If range was in the cache, use it
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L272">            m_cat.debug(&quot;getDateRange: &quot; + result.getStartDate() + &quot; to &quot; + result.getEndDate());</span>
<span class="nc" id="L273">            return result;</span>
        }

        // Either one or both was not in the cache, recompute them.  It's as easy
        // to do both as to do one.

<span class="nc" id="L279">		result = m_tor.getChoiceRange();</span>
<span class="nc" id="L280">		put(REQUEST_TIME_RANGE, result);</span>
<span class="nc" id="L281">		m_cat.debug(&quot;getDateRange: &quot; + result.getStartDate() + &quot; to &quot; + result.getEndDate());</span>
<span class="nc" id="L282">		return result;</span>
	}



    /**
     * Get number of minutes offset for the organization day boundary.
     */
    public int getOrgDayOffset() throws Exception {
<span class="nc" id="L291">        Organization org = getOrg();</span>

<span class="nc" id="L293">        return org.getDayBoundaryOffset();</span>
    }

    //TODO: Cache will become stale when undoing(revert to pending), denying or approving a
    // tentatively approved TO Request.
    public CalendarEventAssignment getCalEventAssignForTOChoiceAligned(TORequest toReq,
                                                                       TOChoice apprChoice, boolean published, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L300">        String methodName = &quot;getCalEventAssignForTOChoiceAligned&quot;;</span>
<span class="nc" id="L301">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, toReq, apprChoice, new Boolean(published), sam));</span>

<span class="nc" id="L303">        String key = RequestUtil.makeCacheKey(CALEVENTASSIGN_FOR_TOCHOICE_ALIGNED, toReq.getID(), apprChoice.getID(), new Boolean(published));</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (containsKey(key)) {</span>
<span class="nc" id="L306">            CalendarEventAssignment event = (CalendarEventAssignment) get(key);</span>
<span class="nc" id="L307">            m_cat.debug(RmUtil.dumpExitMethod(methodName, event));</span>
<span class="nc" id="L308">            return event;</span>
        }

        // fetch the event.
<span class="nc" id="L312">        CalendarEventAssignment event =</span>
<span class="nc" id="L313">                TORequestUtil.getCalEventAssignForTOChoiceAligned(toReq, apprChoice, published, sam);</span>

<span class="nc" id="L315">        put(key, event);</span>

<span class="nc" id="L317">        return event;</span>
    }

    //  TODO: Cache may get stale if cached event updated. see above.
    public Collection getCalEventAssignsForTOChoiceOverlapped(TORequest toReq,
                                                              TOChoice apprChoice, boolean published, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L323">        String methodName = &quot;getCalEventAssignsForTOChoiceOverlapped&quot;;</span>
<span class="nc" id="L324">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, toReq, apprChoice, new Boolean(published), sam));</span>

<span class="nc" id="L326">        String key = RequestUtil.makeCacheKey(CALEVENTASSIGNS_FOR_TOCHOICE_OVERLAPPED,</span>
<span class="nc" id="L327">                toReq.getID(), apprChoice.getID(), new Boolean(published));</span>

<span class="nc" id="L329">        Collection events = null;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (containsKey(key)) {</span>
<span class="nc" id="L331">            events = (Collection) get(key);</span>
        } else {
<span class="nc" id="L333">            events = TORequestUtil.getCalEventAssignsForTOChoiceOverlapped(toReq, apprChoice, published, sam);</span>

<span class="nc" id="L335">            put(key, events);</span>
        }

<span class="nc" id="L338">        return events;</span>
    }
    /*TO CALC Performance Enhancement, Rel 7.8.1, Sameet, July 2007
         // For QA53725 (Silk 91831) - Request management page takes time to load
      // the below change provides feature to query the pub events for certain time range
      public Collection getOrgTimeoffEventsPub(TimeRange range,ArrayList  allotmentList) throws Exception {
          Date start = range.getStartDate();
          Date end = range.getEndDate();
          Collection empIDs =RmManagerFactory.getInstance().getTimeOffRequestManager().getEmployeesInOrganization(null, getOrgID(), true);
          Collection results = RmManagerFactory.getInstance().getTOHoursPerDayManager().
                  getHoursPerDayForCalendar(empIDs,    start,end   , allotmentList,true);
          return results;
      }*/
    /*TO CALC Performance Enhancement, Rel 7.8.1, Sameet, July 2007
    public Collection getEmployeeIDsForOrg()throws Exception {
        Collection empIDs = (Collection) get(ORG_EMPIDS);
        if (empIDs==null) {
            empIDs =RmManagerFactory.getInstance().getTimeOffRequestManager().getEmpIDsInOrganization(getOrgID(), startDate, endDate);
            put(ORG_EMPIDS, empIDs);
        }
        return empIDs;
    }*/

    /**
     * Get a time off calculator for the request's time range and employee
     */
    public TimeOffLengthCalculator getTimeOffLengthCalculator() throws Exception {
<span class="nc" id="L365">        TimeOffLengthCalculator result = (TimeOffLengthCalculator) get(TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP);</span>

<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L368">            m_cat.debug(&quot;getTimeOffLengthCalculator: &quot; + result);</span>
<span class="nc" id="L369">            return result;</span>
        }

<span class="nc" id="L372">        ShiftAssignment lastShift = null;</span>
<span class="nc" id="L373">        ID empID = m_tor.getEmployeeID();</span>
        try {
<span class="nc" id="L375">            lastShift = getLastPublishedShiftAssignment();</span>
<span class="nc" id="L376">        } catch (BbmObjectNotFoundException e) {</span>
            //TESTME handling exception from getLastPublishedShift()
<span class="nc" id="L378">            m_cat.l7dInfo(RmEjbLogBundleKey.USING_DEFAULT_LAST_SHIFT_FOR_EMP, new Object[]{empID}, e);</span>
<span class="nc" id="L379">            lastShift = TOCalcUtil.getDefaultLastShift();</span>
<span class="nc" id="L380">        }</span>
<span class="nc" id="L381">        TimeRange calcRange = getDateRange();</span>
<span class="nc" id="L382">        Collection timeOffDuringPeriod = TimeOffLengthCalculatorHelper.getTimeOffPubDuringInt(empID, calcRange.getStartDate(), calcRange.getEndDate(), null);</span>
<span class="nc" id="L383">        Date terminationDate = TimeOffLengthCalculatorHelper.getEmployeeTerminationDate(empID);</span>


<span class="nc" id="L386">        result = TimeOffLengthCalculatorHelper.getCalculator(empID,</span>
<span class="nc" id="L387">                getOrg(), calcRange,</span>
<span class="nc" id="L388">                getShiftsPubDuringPeriod(),</span>
<span class="nc" id="L389">                getUnavailabilityEventsPubAndUnpubDuringPeriod(),</span>
                timeOffDuringPeriod,
<span class="nc" id="L391">                getHOOAssignmentsDuringPeriod(),</span>
<span class="nc" id="L392">                getHolidaysDuringPeriod(),</span>
<span class="nc" id="L393">                lastShift, getTimeOffDefaultAllotmentMap(), terminationDate );</span>

<span class="nc" id="L395">        put(TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP, result);</span>

<span class="nc" id="L397">        m_cat.debug(&quot;getTimeOffLengthCalculator: &quot; + result);</span>

<span class="nc" id="L399">        return result;</span>
    }
    /*TO CALC Performance Enhancement, Rel 7.8.1, Sameet, July 2007
         public TimeOffLengthCalculator getTimeOffLengthCalcForEmp(ID empID, Date rangeStart, Date rangeEnd)
             throws BbmFinderException {

         // For QA53725 (Silk 91831) - Request management page takes time to load
         // The cache checks only for time range and reuses the TO calculator of one emp to another. This is fixed by caching by emp Id also
             String key = RequestUtil.makeCacheKey(TIME_OFF_LENGTH_CALCULATOR_FOR_EMPID, empID, rangeStart, rangeEnd);

             // check if calculator already cached.
             TimeOffLengthCalculator toCalc = (TimeOffLengthCalculator) get(key);
             // if found in cache
             if (toCalc != null) {
                 m_cat.debug(getCacheHitMsg(key, toCalc));
                 return toCalc;
             }

             // create calculator
             toCalc = TimeOffLengthCalculatorHelper.getCalculator(empID,null, rangeStart, rangeEnd,null);

             // cache calculator.
             put(key, toCalc);

             // return calculator
             m_cat.debug(getCacheMissMsg(key, toCalc));
             return toCalc;
         }
      */
    /**
     * Get the time off allotment map for this employee.  Returns a map of 'TO activity ID'
     * to TO allotment data (weekly and daily default for this activityID).
     */
    public Map getTimeOffDefaultAllotmentMap() throws Exception {
<span class="nc" id="L433">        Map result = (Map) get(TIME_OFF_ALLOTMENT_MAP_DEFAULT);</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L436">            m_cat.debug(&quot;getTimeOffDefaultAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>
<span class="nc" id="L437">            return result;</span>
        }

<span class="nc" id="L440">        Employee emp = getEmployee(Employee.DETAIL_LEVEL_EMPLOYEE_BASIC | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFDEFAULT);</span>
<span class="nc" id="L441">        result = new HashMap();</span>

<span class="nc bnc" id="L443" title="All 2 branches missed.">        for (Iterator it = emp.getTimeOffDefaults().iterator(); it.hasNext();) {</span>
<span class="nc" id="L444">            EmployeeTimeOffDefault toallot = (EmployeeTimeOffDefault) it.next();</span>
<span class="nc" id="L445">            result.put(toallot.getActivityID(), toallot);</span>
<span class="nc" id="L446">        }</span>

<span class="nc" id="L448">        put(TIME_OFF_ALLOTMENT_MAP_DEFAULT, result);</span>

<span class="nc" id="L450">        m_cat.debug(&quot;getTimeOffDefaultAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>

<span class="nc" id="L452">        return result;</span>
    }

    /**
     * Get the time off allotment map for this employee
     */
    public Map getTimeOffYearlyAllotmentMap() throws Exception {
<span class="nc" id="L459">        Map result = (Map) get(TIME_OFF_ALLOTMENT_MAP_YEARLY);</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L462">            m_cat.debug(&quot;getTimeOffYearlyAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>
<span class="nc" id="L463">            return result;</span>
        }

<span class="nc" id="L466">        Employee emp = getEmployee(Employee.DETAIL_LEVEL_EMPLOYEE_BASIC | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFYEARLY);</span>
<span class="nc" id="L467">        result = new HashMap();</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (Iterator it = emp.getTimeOffYearlys().iterator(); it.hasNext();) {</span>
<span class="nc" id="L470">            EmployeeTimeOffYearly toallot = (EmployeeTimeOffYearly) it.next();</span>
<span class="nc" id="L471">            result.put(toallot.getActivityID().toString() + toallot.getCalendarYear(), toallot);</span>
<span class="nc" id="L472">        }</span>

<span class="nc" id="L474">        put(TIME_OFF_ALLOTMENT_MAP_YEARLY, result);</span>

<span class="nc" id="L476">        m_cat.debug(&quot;getTimeOffYearlyAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>

<span class="nc" id="L478">        return result;</span>
    }

    /**
     * The date range for the returned CalendarTimeOffDay objects collection
     * will include the date range for the time off request.
     * &lt;p/&gt;
     * &lt;p&gt; For example if the date range for the TO request is:
     * Sun Dec 21 06:00:00 GMT 2003, ends at: Wed Dec 31 06:00:00 GMT 2003;
     * then the CalendarTimeOffDay VOs returned will span from
     * 12/21/2003 00:00:00.0 to 1/1/2004 00:00:00.0.  Note that the date field
     * for CalendarTimeOffDay is a {@link LocalDate LocalDate}
     * &lt;p/&gt;
     * Get the collection of CalendarTimeOffDay objects for the requested range.
     */

    /*
     public Collection getTOAllocationCalendarDays() throws Exception {
         Collection result = (Collection) get(CALENDAR_TIME_OFF_DAYS);

          if (result != null) {
               m_cat.debug(&quot;getCTOs: &quot; + RmUtil.dumpCollection(result));
              return result;
          }

         getTOAllocationCalendarDays(getDateRange());
         put(CALENDAR_TIME_OFF_DAYS, result);

          m_cat.debug(&quot;getCTOs: &quot; + RmUtil.dumpCollection(result));

         return result;

     } */
    // For QA53725 (Silk 91831) - Request management page takes time to load
    //TODO Caching of the data to be done
    public Collection getTOAllocationCalendarDays(TimeRange range) throws Exception {
<span class="nc" id="L514">        Organization org = getOrg();</span>
<span class="nc" id="L515">        TimeZone tz = org.getTimeZone();</span>
<span class="nc" id="L516">        Calendar cal = RequestUtil.getCalendarForDayStart(range.getStartDate(), tz);</span>
        // get allocation hours for start date -1 for day boundary orgs; Sameet Jan 2009, Bug fix for
        // QC 26396 ;[7.8.3 - TO]TO request for agent is auto deny, evenif organization still have enought TO available for request.
<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (org.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L520">            TOCalcUtil.addDaysToCalendar(cal, -1);</span>
        }
<span class="nc" id="L522">        LocalDate strt = new LocalDate(cal);</span>

<span class="nc" id="L524">        cal = RequestUtil.getCalendarForDayStart(range.getEndDate(), tz);</span>
<span class="nc" id="L525">        TOCalcUtil.addDaysToCalendar(cal, 1);</span>
        //cal.add(Calendar.DAY_OF_MONTH, 1); // Point to the following day
<span class="nc" id="L527">        LocalDate end = new LocalDate(cal);</span>
<span class="nc" id="L528">        return getTOAllocationCalendarDays(strt, end);</span>
    }

    private Collection getTOAllocationCalendarDays(LocalDate startDate, LocalDate endDate) throws Exception {
<span class="nc" id="L532">        CalendarTimeOffDayFacade ctodf = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (getTOPool() != null) {</span>
<span class="nc" id="L534">            return ctodf.getCalendarTimeOffDays(getTOPool().getID(), startDate, endDate, false);</span>
        } else {
<span class="nc" id="L536">            return Collections.emptyList();</span>
        }
    }

    /**
     * Method declared 'private' to enforce the fact that a request can be associated with
     * multiple org IDs.  For this reason getOrgIDs() is exposed instead.
     *
     * @return
     */
    protected ID getOrgID() throws Exception {
<span class="nc" id="L547">		return getOrgIDs().iterator().next();</span>
    }

    public ShiftAssignment getLastPublishedShiftAssignment() throws Exception {
<span class="nc" id="L551">        ShiftAssignment lastShift = (ShiftAssignment) get(LAST_PUB_SHIFT_EMP);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if ((lastShift) == null) {</span>
<span class="nc" id="L553">            lastShift = TOCalcUtil.getLastShiftAssignment(m_tor.getEmployeeID(), true);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if(lastShift==null){</span>
<span class="nc" id="L555">                m_cat.debug(TOCalcUtil.formatEjbBundleMsg(BbmEjbBundleKey.TOCALC_USING_DEFAULT_LAST_SHIFT_FOR_EMP, m_tor.getEmployeeID()));</span>
<span class="nc" id="L556">                lastShift = TOCalcUtil.getDefaultLastShift();</span>
            }
<span class="nc" id="L558">            put(LAST_PUB_SHIFT_EMP, lastShift);</span>
        }
<span class="nc" id="L560">        m_cat.debug(&quot;getLastPublishedShiftAssignment: &quot; + lastShift);</span>
<span class="nc" id="L561">        return lastShift;</span>
    }


    /**
     * Get a TimeMap for blackout days for the organization during
     * the request time range
     *
     * @return TimeMap (resolution=15 minutes) of shifts during request period
     *         which require a shift.
     */
    public TimeMap getBlackoutDaysTimeMap() throws Exception {
        // Check to see if its in the cache already
<span class="nc" id="L574">        TimeMap bdTimeMapForReqTimeRange = (TimeMap) get(BLACKOUT_TIMEMAP);</span>
        // If it is not in the cache, then get it
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (bdTimeMapForReqTimeRange == null) {</span>
<span class="nc" id="L577">            CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L578">            boolean orgBlktOutEnabled = TORequestUtil.isBlackOutDaySettingEnabledForOrg();</span>
            //set 1 minute resolution if Black out days are enabled for Org else set it to one hour
<span class="nc bnc" id="L580" title="All 2 branches missed.">            long resolution = orgBlktOutEnabled ? TimeMap.ONE_MINUTE : TimeMap.ONE_HOUR;</span>
<span class="nc" id="L581">            ID orgID = getOrgID();</span>
<span class="nc" id="L582">            Organization org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc" id="L583">            TimeRange range = getDateRange();</span>
<span class="nc" id="L584">            TimeZone tz = org.getTimeZone();</span>
            // Get the collection of blackout days that fall within the request period
<span class="nc" id="L586">            LocalDate strt = new LocalDate(RequestUtil.getCalendarForDayStart(range.getStartDate(), tz));</span>
<span class="nc" id="L587">            Calendar cal = RequestUtil.getCalendarForDayStart(range.getEndDate(), tz);</span>
<span class="nc" id="L588">            TOCalcUtil.addDaysToCalendar(cal, 1);</span>
<span class="nc" id="L589">            LocalDate end = new LocalDate(cal);</span>
<span class="nc" id="L590">            Collection blackouts = toCalFacade.getBlackoutDays(getTOPool().getID(), strt, end);</span>

            // Build the TimeMap for blackouts. The time map will use a resolution of 1 hour, so we know how many bits we'll need
<span class="nc" id="L593">            Date reqTimeRangeStartDate = range.getStartDate();</span>
<span class="nc" id="L594">            Date reqTimeRangeEndDate = range.getEndDate();</span>
<span class="nc" id="L595">            bdTimeMapForReqTimeRange = new TimeMap(resolution, reqTimeRangeStartDate, reqTimeRangeEndDate);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">            if (blackouts != null) {</span>
                // Loop through the blackout days and build the map
<span class="nc bnc" id="L598" title="All 2 branches missed.">                for (Iterator it = blackouts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L599">                    BlackoutDay bd = (BlackoutDay) it.next();</span>
                    // The hours/minutes/seconds for the blackout day is always 00:00:00 (midnight).
                    // Get the start of the organization day on which blackout day falls,
                    // taking into account the organization's day offset.
                    //QC106371 changes starts
<span class="nc" id="L604">                    TimeRange timeRange = TOCalcUtil.getTimeRangeForOrgDay(org.getTimeZone(), org.getDayBoundaryOffset(), bd.getBlackoutLocalDate().getTime(org.getTimeZone())) ;</span>
<span class="nc" id="L605">                    Date bdStart = timeRange.getStartDate();</span>
<span class="nc" id="L606">                    Date bdEnd = timeRange.getEndDate();</span>
                    //QC106371 changes ends
                    // get overlap between req's time range and blackout date.
<span class="nc" id="L609">                    TimeRange overlapTimeRange = RequestUtil.getOverlapTimeRange(reqTimeRangeStartDate, reqTimeRangeEndDate, bdStart, bdEnd);</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">                    if (overlapTimeRange == null) {</span>
<span class="nc" id="L611">						continue;</span>
					}
<span class="nc" id="L613">                    bdTimeMapForReqTimeRange.setRange(overlapTimeRange.getStartDate(), overlapTimeRange.getEndDate());</span>
<span class="nc" id="L614">                }</span>
            }
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (orgBlktOutEnabled) {</span>
<span class="nc" id="L617">                Collection cHolidays = BbmManagerFactory.getHolidayManager().getHolidays(orgID, strt, end, new int[]{Holiday.DAYTYPE_BLACKOUTDAY});</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                if (cHolidays != null) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                    for (Iterator h = cHolidays.iterator(); h.hasNext();) {</span>
<span class="nc" id="L620">                        Holiday blktDay = (Holiday) h.next();</span>
<span class="nc" id="L621">                        Date bdStart = blktDay.getStartDate().getTime(org.getTimeZone());</span>
<span class="nc" id="L622">                        Date bdEnd = blktDay.getEndDate().getTime(org.getTimeZone());</span>
<span class="nc" id="L623">                        TimeRange overlapTimeRange = RequestUtil.getOverlapTimeRange(reqTimeRangeStartDate, reqTimeRangeEndDate, bdStart, bdEnd);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                        if (overlapTimeRange == null) {</span>
<span class="nc" id="L625">							continue;</span>
						}
<span class="nc" id="L627">                        bdTimeMapForReqTimeRange.setRange(overlapTimeRange.getStartDate(), overlapTimeRange.getEndDate());</span>
<span class="nc" id="L628">                    }</span>
                }
            }

<span class="nc" id="L632">            m_cat.debug(getCacheMissMsg(BLACKOUT_TIMEMAP, bdTimeMapForReqTimeRange));</span>
<span class="nc" id="L633">            put(BLACKOUT_TIMEMAP, bdTimeMapForReqTimeRange);// Save in cache</span>
        }
<span class="nc" id="L635">        return bdTimeMapForReqTimeRange;</span>
    }


    /**
     * Get the collection of soft validations for this requst
     */
    @Override
	public Collection&lt;String&gt; getValidators() throws Exception {
<span class="nc" id="L644">        return super.getValidators(getOrgID(), Request.REQUESTTYPE_TIMEOFF, m_tor.getTimeOffType());</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache#getEmployeeID()
      */
    @Override
	public ID getEmployeeID() {
<span class="nc" id="L652">        return m_tor.getEmployeeID();</span>
    }

    /**
     * Get the published periods for this employee
     */

    //JT
	public Collection&lt;PublishingPeriod&gt; getPublishedPeriods() throws Exception {

<span class="nc" id="L662">		Collection&lt;PublishingPeriod&gt; result = (Collection) get(PUBLISHED_PERIODS);</span>

<span class="nc bnc" id="L664" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L665">			return result;</span>
		}

<span class="nc" id="L668">		ScheduleAccessManager sam = getScheduleAccessManager();</span>

<span class="nc" id="L670">		TimeRange range = getDateRange();</span>
<span class="nc" id="L671">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; listOfPublishedPeriods = sam.getPublishedPeriods(Collections.singleton(m_tor.getEmployeeID()),</span>
<span class="nc" id="L672">				range.getStartDate(), range.getEndDate());</span>

<span class="nc" id="L674">		result = listOfPublishedPeriods.get(0);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L676">			result = Collections.emptyList();</span>
		}

<span class="nc" id="L679">		put(PUBLISHED_PERIODS, result);</span>

<span class="nc" id="L681">		return result;</span>
	}



    public boolean getManagerTimeOffWorkflowActive() throws Exception {
<span class="nc" id="L687">        String methodName = &quot;getManagerTimeOffWorkflowActive: &quot;;</span>

<span class="nc" id="L689">        Boolean workflowActive = (Boolean) get(MANAGER_TIMEOFF_WORKFLOWACTIVE);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (workflowActive != null) {</span>
<span class="nc" id="L691">            m_cat.debug(methodName + workflowActive);</span>
<span class="nc" id="L692">            return workflowActive.booleanValue();</span>
        }

<span class="nc" id="L695">        workflowActive = new Boolean(RequestUtil.getOrgSetting(getOrgID(), null).getManagerTimeOffWorkflowActive());</span>
<span class="nc" id="L696">        m_cat.debug(methodName + workflowActive);</span>

<span class="nc" id="L698">        put(MANAGER_TIMEOFF_WORKFLOWACTIVE, workflowActive);</span>

<span class="nc" id="L700">        return workflowActive.booleanValue();</span>
	}

	//v11.1 new validation and trace cube fix

	public Map getPostTOReqTraceCube(TORequest tor, TOChoice toc, TimeRange tr) throws Exception {
<span class="nc" id="L706">		String key = RequestUtil.makeCacheKey(RECALC_TRACECUBE, tor.getEmployeeID()+&quot;:&quot;+toc.getID()); //combined to choice id here todo</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
			//get shift assignments overlaps with this to choice. it could be more that one shift assignment, but the most a tochoice can be 7 days long

<span class="nc" id="L710">			Collection pubShifts= getPublishedShiftAssignments(tor, toc);</span>
			//for each shift assignment, find the sp linked to it, and adjust Qs
<span class="nc" id="L712">			ShiftAssignment sa = null;</span>
<span class="nc" id="L713">			Collection events = null;</span>
<span class="nc" id="L714">			Map traceCubesMap = new HashMap();</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">			for (Iterator i = pubShifts.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L716">				sa = (ShiftAssignment)i.next();</span>
<span class="nc" id="L717">				events = getScheduleAccessManager().getPublishedEventsForWorkResource(tor.getEmployeeID(), sa.getStartTime(), sa.getEndTime());</span>
<span class="nc" id="L718">				traceCubesMap = getTimeSeriesManager().reCalcAdjustedFTEAndStaffing(traceCubesMap, tr, events, sa, true);</span>
			}
<span class="nc" id="L720">			put(key, traceCubesMap);</span>
		}
<span class="nc" id="L722">		return (Map) get(key);</span>
	}

	public Collection getPublishedShiftAssignments(TORequest tor, TOChoice toc) throws Exception {
<span class="nc" id="L726">		String key = &quot;&quot;;</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">		if (toc.getID() != null) {</span>
<span class="nc" id="L729">			key = RequestUtil.makeCacheKey(EVENT_TYPE_SHIFT_ASSIGNMENT, toc.getID());</span>
		} else {
<span class="nc" id="L731">			key = RequestUtil.makeCacheKey(EVENT_TYPE_SHIFT_ASSIGNMENT, toc.getStartDate(), toc.getEndDate());</span>
		}

<span class="nc bnc" id="L734" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
<span class="nc" id="L735">			Collection pubShifts = getScheduleAccessManager().getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, tor.getEmployeeID(), toc.getStartDate(), toc.getEndDate());</span>
<span class="nc" id="L736">			put(key, pubShifts);</span>
		}
<span class="nc" id="L738">		return (Collection) get(key);</span>
	}

	/**
	 * returns a NetStaffingCube as it would look after the Time-Off apporval.
	 * this is used for validation of under staffing / overstaffing.
	 * IMP*** The Netsaffing cube is not a reflection of what is in the DB
	 *
	 * @param tor
	 * @param toc
	 * @return
	 * @throws Exception
	 */
	public NetStaffingCube getPostTOApprovalNetStaffingCube(TORequest tor, TOChoice toc) throws Exception {
<span class="nc" id="L752">		String key = RequestUtil.makeCacheKey(POST_TO_APPROVAL_NETSTAFFING_CUBE, tor.getEmployeeID() + &quot;:&quot; + toc.getID());</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
<span class="nc" id="L754">			TimeRange range = new TimeRange(toc.getStartDate(), toc.getEndDate());</span>
<span class="nc" id="L755">			ID empID = tor.getEmployeeID();</span>
<span class="nc" id="L756">			NetStaffingCube nsCube = getTimeSeriesManager().getNetStaffing(empID, range.getStartDate(), range.getEndDate());</span>
<span class="nc bnc" id="L757" title="All 4 branches missed.">			if (nsCube == null || nsCube.getPredictTraceCubeMap().isEmpty()) {</span>
<span class="nc" id="L758">				m_cat.error(&quot;No Queues Found that match the skill set of EMP: range=&quot; + range + &quot;\tnsCube=&quot; + nsCube );</span>
<span class="nc" id="L759">				return null;</span>
			}


			//TimeRange netStaffingRange = nsCube.getMaxLeastTimeInterval()==SPQueue.LEAST_TIME_INTERVAL_WEEKLY?nsCube.getTimeRange():range;
<span class="nc" id="L764">			Map traceCubesMap = getPostTOReqTraceCube(tor, toc, nsCube.getTimeRange());</span>
<span class="nc" id="L765">			getAdjustedNetStaffingCube( traceCubesMap, nsCube);</span>
<span class="nc bnc" id="L766" title="All 4 branches missed.">			if (nsCube == null || traceCubesMap == null) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">				m_cat.error(&quot;No Queues Found that match the skill set of EMP: TO CHOICE=&quot; + toc</span>
				        + &quot;\tnsCube=&quot; + nsCube + &quot;\ttraceCubesMap=&quot; +
<span class="nc" id="L769">				        traceCubesMap != null ? &quot;&quot; + traceCubesMap.size() : &quot; null &quot;);</span>
			}
<span class="nc" id="L771">			put(key, nsCube);</span>
		}
<span class="nc" id="L773">		return (NetStaffingCube) get(key);</span>
	}

	/**
	 * returns a NetStaffingCube as it currently looks (before the Time-Off apporval).
	 * this is used for validation of under staffing / overstaffing.
	 * @param tor
	 * @param toc
	 * @return
	 * @throws Exception
	 */
	public NetStaffingCube getPreTOApprovalNetStaffingCube(TORequest tor, TOChoice toc) throws Exception {
<span class="nc" id="L785">		String key = RequestUtil.makeCacheKey(PRE_TO_APPROVAL_NETSTAFFING_CUBE, tor.getEmployeeID() + &quot;:&quot; + toc.getID());</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
<span class="nc" id="L787">			TimeRange range = new TimeRange(toc.getStartDate(), toc.getEndDate());</span>
<span class="nc" id="L788">			ID empID = tor.getEmployeeID();</span>
<span class="nc" id="L789">			NetStaffingCube nsCube = getTimeSeriesManager().getNetStaffing(empID, range.getStartDate(), range.getEndDate());</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">			if (nsCube == null) {</span>
<span class="nc" id="L791">				m_cat.error(&quot;No Queues Found that match the skill set of EMP: range=&quot; + range + &quot;\tnsCube=&quot; + nsCube );</span>
<span class="nc" id="L792">				return null;</span>
			}
<span class="nc" id="L794">			put(key, nsCube);</span>
		}
<span class="nc" id="L796">		return (NetStaffingCube) get(key);</span>
	}

	/**
	 * Checks if Forecasted staffing &amp; FTE exists for the given Cuast-Shift Request for the said employee
	 *
	 * @param csr
	 * @return
	 * @throws Exception
	 */
	public boolean doesStaffingExistForPeriod(TORequest tor, TOChoice toc) {

<span class="nc bnc" id="L808" title="All 2 branches missed.">		if (periodsWithStaffing == null) {</span>
<span class="nc" id="L809">			periodsWithStaffing = new PeriodsWithStaffing();</span>
		}

<span class="nc" id="L812">		return periodsWithStaffing.doesStaffingExistForPeriod(tor, toc);</span>
    }
	
	
	/** Returns the pool effective on the earliest start date of the request choices for the particular activity */
	public TOPool getTOPool() throws Exception {
		//JT
<span class="nc" id="L819">		return getTOPool(null);</span>
	}
	
	public TOPool getTOPool(Date effectiveDate) throws Exception {
<span class="nc" id="L823">		ID activityID = null;</span>
		
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L826">		List&lt;EmpTOPoolAssignment&gt; empTOPoolAssignments = getTimeOffPoolAssignments();</span>
<span class="nc" id="L827">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
		
<span class="nc" id="L829">		Date dateForPool = effectiveDate;</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">		if(effectiveDate==null){</span>
<span class="nc" id="L831">			dateForPool = getDateRange().getStartDate();</span>
		}
		
<span class="nc bnc" id="L834" title="All 2 branches missed.">		if (LicenseUtil.isAdvancedRMLicense()) {</span>
<span class="nc" id="L835">			activityID = this.m_tor.getTimeOffType();</span>
		}
<span class="nc" id="L837">		ID empTOPoolID = TOCalendarUtil.getTOPoolIDforDate(dateForPool, empTOPoolAssignments, activityID);</span>
		//It may be null if no pool is set up
<span class="nc bnc" id="L839" title="All 2 branches missed.">		if(empTOPoolID==null){</span>
<span class="nc" id="L840">			return null;</span>
		}
<span class="nc" id="L842">		return toCalFacade.getTOPool(empTOPoolID);</span>
	}
	
	public List&lt;TOPool&gt; getAllTimeoffPools() throws Exception {
<span class="nc" id="L846">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
		
<span class="nc" id="L848">		ArrayList&lt;TOPool&gt; pools = new ArrayList&lt;TOPool&gt;();</span>
<span class="nc" id="L849">		List&lt;EmpTOPoolAssignment&gt; empTOPoolAssignments = getTimeOffPoolAssignments();</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">		for(EmpTOPoolAssignment assignment : empTOPoolAssignments){</span>
<span class="nc" id="L851">			pools.add(toCalFacade.getTOPool(assignment.getTOPoolID()));</span>
<span class="nc" id="L852">		}</span>
		
<span class="nc" id="L854">		return pools;</span>
		
	}

	private List&lt;EmpTOPoolAssignment&gt; getTimeOffPoolAssignments() throws Exception {//NOSONAR

		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L861">		List&lt;EmpTOPoolAssignment&gt; empTOPoolAssignments = (List&lt;EmpTOPoolAssignment&gt;) get(TOPOOL_FOR_REQ);</span>
		
<span class="nc bnc" id="L863" title="All 2 branches missed.">		if (empTOPoolAssignments == null) {</span>
<span class="nc" id="L864">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
			
<span class="nc" id="L866">			Date startDate = getDateRange().getStartDate();</span>
<span class="nc" id="L867">			ID activityID = null;</span>

<span class="nc bnc" id="L869" title="All 2 branches missed.">			if (LicenseUtil.isAdvancedRMLicense()) {</span>
				// Pools are by activity (or default)
<span class="nc" id="L871">				activityID = this.m_tor.getTimeOffType();</span>
<span class="nc" id="L872">				empTOPoolAssignments = toCalFacade</span>
<span class="nc" id="L873">						.getAllEmpTOPoolAssignments(getEmployeeID(),</span>
<span class="nc" id="L874">								startDate, getDateRange().getEndDate(),</span>
								activityID);
			} else {
				// Pools are not by activity
<span class="nc" id="L878">				empTOPoolAssignments = toCalFacade</span>
<span class="nc" id="L879">						.getDefaultEmpTOPoolAssignments(getEmployeeID(),</span>
<span class="nc" id="L880">								startDate, getDateRange().getEndDate());</span>
			}
			
<span class="nc" id="L883">			put(TOPOOL_FOR_REQ, empTOPoolAssignments);</span>
		}
		
<span class="nc" id="L886">		return empTOPoolAssignments;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>