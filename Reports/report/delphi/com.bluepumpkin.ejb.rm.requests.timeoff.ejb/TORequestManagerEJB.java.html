<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TORequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.ejb</a> &gt; <span class="el_source">TORequestManagerEJB.java</span></div><h1>TORequestManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * TORequestManagerEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.timeoff.ejb;

import java.rmi.RemoteException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.TreeSet;

import javax.naming.Context;
import javax.naming.InitialContext;

import org.apache.log4j.Level;
import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityCategory;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityCategoryFilter;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityProperties;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.ReportDumpStatistic;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTimeOffYearlyDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffAccrued;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffYearly;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.core.CoreEJBCreateException;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.base.RmRuntimeException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.notification.model.EmpTOAccruedNotificationDetail;
import com.bluepumpkin.ejb.rm.notification.model.RequestNotificationDetail;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.ejb.Timeline;
import com.bluepumpkin.ejb.rm.requests.common.ejb.param.RequestCountParam;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.AutoProcessingRuleChecker;
import com.bluepumpkin.ejb.rm.requests.common.validation.RequestNotExpiredOnCreateHV;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidatorForMultiChoice;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDayFieldInfo;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.FlexRequestMakeup;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOAccrual;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOIntervalCalendar;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequestFieldInfo;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TimeOffActivitySummary;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TimeOffEventSummary;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AgentGoodStandingValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AgentGoodStandingValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AvaliableHoursValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.ComplyMinRequiredPayPeriodHoursRuleTimeOff;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.EmployeeHoursValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.RequiredPublishedScheduleHardValidator;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TOValidationCache;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TentativeRequestHardValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidMaxWeeksValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidPeriodPerChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidPeriodPerChoiceHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidRequestNotOverlapValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceApprOrTentAppNotZeroLengthHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceContainsHoliday;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceContainsOrgChange;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLength;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLengthHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffRequestsPerQuarterValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationPublishedStatusRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationReferenceScheduleRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.ValidTimeOffChoicesValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeWithinScheduleTimeOff;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeWithinScheduleTimeOffHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.advancedvto.AdvancedVtoCalculator;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb.TOWaitlistManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.model.TOWaitlist;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.ejb.TOWithdrawManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.model.TOWithdraw;
import com.bluepumpkin.ejb.rm.security.RequestAction;
import com.bluepumpkin.ejb.rm.security.RmTimeOffSecurityManager;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.ejb.TimeOffBidDAO;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.model.TimeOffBid;
import com.bluepumpkin.ejb.rm.util.DAOUtil;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TOIntervalCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TONotifyMessageClient;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.SuperUserFacade;
import com.witness.ejb.core.security.model.User;

/**
 * @author Raja Rajendran
 *         &lt;p/&gt;
 *         &lt;p&gt;
 *         see {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest#getTimeOffDebitType() getTimeOffDebitType} for
 *         information about TO debit types and how they map to CalendarEventAssignments in the schedule.
 *         &lt;p/&gt;
 *         &lt;p&gt;
 *         see {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest#getTimeOffType() getTimeOffType} for information about
 *         activities and their attributes used in timeOff events.
 *         &lt;p/&gt;
 *         Tentative approvals require special hard validations
 *         &lt;p/&gt;
 *         if soft validations are disabled when fetching a request, time off lengths will not be computed.
 *         &lt;p/&gt;
 */
<span class="nc" id="L181">public class TORequestManagerEJB extends RequestAggregateManager { // OUTSIDE_CONTAINER</span>
<span class="nc" id="L182">	private static final String CLASS_NAME = TORequestManagerEJB.class.getName();</span>
<span class="nc" id="L183">	private static Category m_cat = Log.initCategory(CLASS_NAME);</span>

	public static final String TABLE_EMPLOYEEAM_ALIAS = RequestUtil.TABLE_EMPLOYEEAM_ALIAS;

<span class="nc" id="L187">	private boolean WhatIfMode = false;</span>
<span class="nc" id="L188">	private static int REPORTDUMP_MAX_RETRY = 10;</span>
<span class="nc" id="L189">	private static int USERTRANSACTION_TIMEOUT = 600;</span>

	@Override
	public void onEjbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="nc" id="L195">			Context initialContext = new InitialContext();</span>
<span class="nc" id="L196">			Boolean WIF = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">			if (WIF != null) {</span>
<span class="nc" id="L198">				WhatIfMode = WIF.booleanValue();</span>
			}
<span class="nc" id="L200">		} catch (Exception e) {</span>
<span class="nc" id="L201">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="nc" id="L202">		}</span>
<span class="nc" id="L203">	}</span>

	/**
	 * Array of hard validation classes
	 */
<span class="nc" id="L208">	protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArr = {</span>
<span class="nc" id="L209">			new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L211">			new ValidatorDescriptor(WorkableTimeValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L213">			new ValidatorDescriptor(WorkableTimeWithinScheduleTimeOffHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L215">			new ValidatorDescriptor(AgentGoodStandingValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC),</span>
<span class="nc" id="L216">			new ValidatorDescriptor(ValidTimeOffChoicesValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC),</span>
<span class="nc" id="L217">			new ValidatorDescriptor(TentativeRequestHardValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
			// validator run only when updating a requests as approved or tentatively approved and has the specified detail level.
<span class="nc" id="L220">			new ValidatorDescriptor(TimeOffChoiceApprOrTentAppNotZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_MODIFIER,</span>
					new String[] { RequestAuditTrail.STATUS_APPROVED, RequestAuditTrail.STATUS_TENTATIVE }, TORequest.DL_BASIC
							| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L223">			new ValidatorDescriptor(TimeOffChoiceHasZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC),</span>


	};

<span class="nc" id="L228">	protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArrWithAdvancedLicense = {</span>
<span class="nc" id="L229">			new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L231">			new ValidatorDescriptor(WorkableTimeValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L233">			new ValidatorDescriptor(WorkableTimeWithinScheduleTimeOffHV.class.getName(), RequestUtil.METHODTYPE_ALL_EXCEPT_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L235">			new ValidatorDescriptor(AgentGoodStandingValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL_EXCEPT_FINDER, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L237">			new ValidatorDescriptor(ValidTimeOffChoicesValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC),</span>
<span class="nc" id="L238">			new ValidatorDescriptor(TentativeRequestHardValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
			// validator run only when updating a requests as approved or tentatively approved and has the specified detail level.
<span class="nc" id="L241">			new ValidatorDescriptor(TimeOffChoiceApprOrTentAppNotZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_MODIFIER,</span>
					new String[] { RequestAuditTrail.STATUS_APPROVED, RequestAuditTrail.STATUS_TENTATIVE }, TORequest.DL_BASIC
							| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L244">			new ValidatorDescriptor(TimeoffIntervalAllocationPublishedStatusRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L246">			new ValidatorDescriptor(TimeoffIntervalAllocationReferenceScheduleRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L248">			new ValidatorDescriptor(TimeOffChoiceHasZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC),</span>

			//Time off Bid hard validation=&gt; Should move to Time Off Bid areas when TOB Enhancement is added.

<span class="nc" id="L252">			new ValidatorDescriptor(TimeOffBidPeriodPerChoiceHV.class.getName(), RequestUtil.METHODTYPE_ALL_EXCEPT_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
			// Validator for only advanced VTO currently
<span class="nc" id="L255">			new ValidatorDescriptor(RequiredPublishedScheduleHardValidator.class.getName(),</span>
					RequestUtil.METHODTYPE_CREATOR | RequestUtil.METHODTYPE_MODIFIER, null, TORequest.DL_BASIC)


	};

<span class="nc" id="L261">	private final static ValidatorDescriptor[] m_softValidatorDescMandArr = {</span>
			// validator run only when fetching a request with the specified detail level.
<span class="nc" id="L263">			new ValidatorDescriptor(TimeOffChoiceHasZeroLength.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L265">			new ValidatorDescriptor(TimeOffChoiceContainsHoliday.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L267">			new ValidatorDescriptor(TimeOffChoiceContainsOrgChange.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH) };

<span class="nc" id="L270">	private final static ValidatorDescriptor[] m_softValidatorDescMandArrWithAdvanceLicense = {</span>
			// validator run only when fetching a request with the specified detail level.
<span class="nc" id="L272">			new ValidatorDescriptor(TimeOffChoiceHasZeroLength.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L274">			new ValidatorDescriptor(TimeOffChoiceContainsHoliday.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L276">			new ValidatorDescriptor(TimeOffChoiceContainsOrgChange.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L278">			new ValidatorDescriptor(WorkableTimeWithinScheduleTimeOff.class.getName(), RequestUtil.METHODTYPE_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L280">			new ValidatorDescriptor(AgentGoodStandingValidationRule.class.getName(), RequestUtil.METHODTYPE_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L282">			new ValidatorDescriptor(TimeOffBidPeriodPerChoice.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH) };

<span class="nc" id="L285">	private final static String[] softValidatorsForMultiChoice = {</span>
<span class="nc" id="L286">			TimeOffBidRequestNotOverlapValidationRule.class.getName(),</span>
<span class="nc" id="L287">			TimeOffBidMaxWeeksValidationRule.class.getName(),</span>
<span class="nc" id="L288">			AvaliableHoursValidationRule.class.getName(),</span>
<span class="nc" id="L289">			EmployeeHoursValidationRule.class.getName(),</span>
<span class="nc" id="L290">			ComplyMinRequiredPayPeriodHoursRuleTimeOff.class.getName(),</span>
<span class="nc" id="L291">			TimeOffRequestsPerQuarterValidationRule.class.getName()</span>
		};


	{
<span class="nc" id="L296">		super.init(TORequestManagerEJB.class.getName());</span>
<span class="nc" id="L297">	}</span>

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="nc" id="L304">		return m_cat;</span>
	}

	/**
	 * Return the possible states for a request of this type.
	 *
	 * @return a List of the possible states for requests of this type.
	 */
	@Override
	public List getPossibleStates() {
<span class="nc" id="L314">		return RequestAuditTrail.TO_POSSIBLE_STATES;</span>
	}

	@Override
	protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc bnc" id="L319" title="All 2 branches missed.">		return hasAdvanceLicense() ? m_hardValidatorDescriptorArrWithAdvancedLicense : m_hardValidatorDescriptorArr;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidatorDescriptorsMandatory()
	 */
	@Override
	protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc bnc" id="L329" title="All 2 branches missed.">		return hasAdvanceLicense() ? m_softValidatorDescMandArrWithAdvanceLicense : m_softValidatorDescMandArr;</span>
	}


	@Override
	protected RequestAggregateDAO getDAO(long detailLevel) {
<span class="nc" id="L335">		return new TORequestDAO(detailLevel);</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestManager()
	 */
	@Override
	protected IRequestType getRequestManager() throws Exception {
<span class="nc" id="L345">		return RequestUtil.getTORequestMgr(null, null);</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestType()
	 */
	@Override
	protected String getRequestType() {
<span class="nc" id="L355">		return Request.REQUESTTYPE_TIMEOFF;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#processBeforeCreate(com.bluepumpkin.ejb.rm.requests.common
	 * .model.RequestAggregate)
	 */
	@Override
	protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L367">		super.createRequestPreProcess(reqAgg, reqAggDAO);</span>

<span class="nc" id="L369">		TORequest tor = (TORequest) reqAgg;</span>

<span class="nc" id="L371">		tor.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>

		// validate debit type
<span class="nc" id="L374">		String debittype = tor.getTimeOffDebitType();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">		if (debittype == null) {</span>
<span class="nc" id="L376">			tor.setTimeOffDebitType(TORequest.DEBITTYPE_DEBIT);</span>
		}
<span class="nc bnc" id="L378" title="All 2 branches missed.">		if (!TORequest.VALID_DEBITTYPES.contains(debittype)) {</span>
<span class="nc" id="L379">			throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_DEBIT_TYPE, new Object[] { debittype }, m_cat);</span>
		}

		// Check if Employee and activity are not null. They are defined as foreign keys in the
		// database, so let that constraint check that they are valid.
<span class="nc bnc" id="L384" title="All 2 branches missed.">		if (tor.getEmployeeID() == null) {</span>
<span class="nc" id="L385">			throw RequestUtil.createRmException(RmEjbLogBundleKey.REQUESTED_FOR_NULL, m_cat);</span>
		}

<span class="nc bnc" id="L388" title="All 2 branches missed.">		if (tor.getTimeOffType() == null) {</span>
<span class="nc" id="L389">			throw RequestUtil.createRmException(RmEjbLogBundleKey.ACTIVITY_NULL, m_cat);</span>
		}

		// Check that the request at least has choices specified. The validity
		// of the choices themselves will be checked in the TOChoiceDAO
<span class="nc" id="L394">		Collection&lt;TOChoice&gt; choices = tor.getRequestChoiceList();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">		if (choices.isEmpty()) {</span>
<span class="nc" id="L396">			throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_CHOICE_LIST, null, m_cat);</span>
		}

		// validate flex type
<span class="nc" id="L400">		int flextype = tor.getFlexType();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (!TORequest.VALID_FLEXTYPES.contains(flextype)) {</span>
<span class="nc" id="L402">			throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_FLEX_TYPE, new Object[] { flextype }, m_cat);</span>
		}

		// Check that the request at least has flex makeups specified if FLEXTYPE is flex with makeup.
		// The validity of the makeups themselves will be checked in the FlexRequestMakeupDAO.
<span class="nc bnc" id="L407" title="All 2 branches missed.">		if (flextype == TORequest.FLEXTYPE_FLEXWITHMAKEUP) {</span>
<span class="nc" id="L408">			Collection&lt;FlexRequestMakeup&gt; makeups = tor.getFlexRequestMakeupList();</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">			if (makeups.isEmpty()) {</span>
<span class="nc" id="L410">				throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_FLEXMAKEUP_LIST, null, m_cat);</span>
			}
		}

<span class="nc" id="L414">		updateExpiration(tor);</span>
<span class="nc" id="L415">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestPostProcess(java.util.Collection)
	 */
	@Override
	protected void getRequestPostProcess(Collection reqAggs, long detailLevel) throws Exception {
<span class="nc bnc" id="L424" title="All 2 branches missed.">		for (Iterator iter = reqAggs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L425">			TORequest toReq = (TORequest) iter.next();</span>

			// if no 'getRequestPostProcess' is needed, skip this.
<span class="nc bnc" id="L428" title="All 2 branches missed.">			if (!toReq.isGetRequestPostProcNeeded()) {</span>
<span class="nc" id="L429">				continue;</span>
			}

			// compute TO choices length only if the detail level is enabled.
<span class="nc bnc" id="L433" title="All 2 branches missed.">			if ((detailLevel &amp; TORequest.DL_TIMEOFF_CHOICES_LENGTH) != 0) {</span>
<span class="nc" id="L434">				TORequestUtil.fillTOChoicesLengthIfNecess(toReq, false);</span>
			}
<span class="nc bnc" id="L436" title="All 4 branches missed.">			if (toReq.isEligibleForAcceptWithdrawAction() || toReq.isEligibleForRejectWithdrawAction()) {</span>
<span class="nc" id="L437">				getTOWithdrawManager().runSoftValidationsForTOWithdrawRequest(toReq);</span>
			}
<span class="nc" id="L439">		}</span>
<span class="nc" id="L440">	}</span>

	@Override
	protected void getRequestPreValidationProcess(RequestAggregateDAO dao, Collection reqAggs, long detailLevel) throws Exception {
<span class="nc" id="L444">		getTOHoursPerDayManager().getTOHoursPerDaysByTimeOffRequestIds(reqAggs);</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">		for (Iterator iter = reqAggs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L446">			TORequest toReq = (TORequest) iter.next();</span>
			// allow waitlisting any number of times;
			// if (toReq.getWaitlistInfo() == null) {
<span class="nc" id="L449">			toReq.setEligibleForWaitlist(isRequestEligibleForWaitlist(toReq));</span>
			// }
<span class="nc" id="L451">		}</span>
<span class="nc" id="L452">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestWorkFlow(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String, boolean, boolean)
	 */
	@Override
	protected void _approveRequestWorkFlow(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment,
			boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {

		// not clean but necessary. if specified choiceID is null, maps it
		// to the right TOChoice ID and set the ID in the request.
<span class="nc bnc" id="L468" title="All 2 branches missed.">		if (choiceIDs == null) {</span>
<span class="nc" id="L469">			choiceIDs = getApprChoiceIDIfNull(reqAgg, choiceIDs);</span>
		}

<span class="nc" id="L472">		super._approveRequestWorkFlow(reqAgg, choiceIDs, comment, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L473">	}</span>

	/**
	 * @param apprChoiceID if null, see {@link #getApprChoiceIDIfNull(RequestAggregate, ID) getApprChoiceIDIfNull()} method.
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#
	 *      _approveRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID,
	 *      java.lang.String, boolean)
	 */
	@Override
	protected void _approveRequest(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
		// handle the case if the specified apprChoiceID == null.
<span class="nc" id="L485">		Collection&lt;ID&gt; apprChoiceIDs = getApprChoiceIDIfNull(reqAgg, choiceIDs);</span>
<span class="nc" id="L486">		String methodName = &quot;_approveRequest&quot;; // passed to other methods</span>
<span class="nc" id="L487">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, apprChoiceIDs, comment, new Boolean(suppressPrivilegeChecking)));</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">		if(reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L489">			approveTORequestChoice(reqAgg, apprChoiceIDs, comment, suppressPrivilegeChecking, loadedFromDB, false);</span>
		} else { //normal Time off requests
<span class="nc" id="L491">			approveTORequestChoice(reqAgg, choiceIDs, comment, suppressPrivilegeChecking, loadedFromDB, hasAdvanceLicense());</span>
		}

<span class="nc" id="L494">		m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L495">	}</span>

	private void approveTORequestChoice(RequestAggregate reqAgg, Collection&lt;ID&gt; apprChoiceIDs, String comment,
			boolean suppressPrivilegeChecking,
			boolean loadedFromDB, boolean skipSomeHardRulesWhenUpdate) throws Exception {
<span class="nc" id="L500">		TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L501">		calculateAdvancedVtoTimeOffChoices(toReq);</span>
		// to indicate that lengths are used in hard validator TimeOffChoiceApprOrTentApprNotZeroLengthHV.java.
<span class="nc" id="L503">		toReq.addDetailLevel(TORequest.DL_TIMEOFF_CHOICES_LENGTH);</span>
<span class="nc" id="L504">		toReq.addDetailLevel(TORequest.DL_AUDIT_TRAIL);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">		if(toReq.isAdvancedVTORequest()) {</span>
<span class="nc" id="L506">			toReq.setTOChoiceForValidation(toReq.getTOChoicesAdjustedForCalculatedVto(apprChoiceIDs));</span>
		} else{ //it could be Time off bidding case or normal case
<span class="nc" id="L508">			toReq.setTOChoiceForValidation(toReq.getTOChoices(apprChoiceIDs));</span>
		}
<span class="nc" id="L510">		String oldStatus = toReq.getRequestStatus();</span>
		/*
		 * Only The choices that are being Approved should be validated. This is done to ensure that Hard validations are run only on
		 * the TO choices that are being approved. We are not interested in Hard validating other choices, since they are redundant
		 * here. The user picked these choices to be approved, why validate anything else.
		 */
<span class="nc" id="L516">		List&lt;TOChoice&gt; apprChoices = updateRequestWithApprovedChoice(toReq, apprChoiceIDs, RequestAuditTrail.STATUS_APPROVED, comment,</span>
				RequestAuditTrail.STATUS_APPROVED, suppressPrivilegeChecking, loadedFromDB, skipSomeHardRulesWhenUpdate);

<span class="nc bnc" id="L519" title="All 2 branches missed.">		for (TOChoice apprChoice : apprChoices) {</span>
<span class="nc" id="L520">			adjustScheduleAndNetStaffing(reqAgg, toReq, oldStatus, apprChoice);</span>
<span class="nc" id="L521">		}</span>

<span class="nc" id="L523">	}</span>

	private void adjustScheduleAndNetStaffing(RequestAggregate reqAgg, TORequest toReq, String oldStatus, TOChoice apprChoice)
			throws Exception {

		// if approving a non tentatively approved request, create a new event in the schedule
		// if approving a tentatively approved request, no need to do anything since event already exists in unpublished schedule
		// This reqd for updating the requests comments in the TOEvent Description field

<span class="nc" id="L532">		TOValidationCache cache = (TOValidationCache) toReq.getValidationCache();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">		if (!oldStatus.equals(RequestAuditTrail.STATUS_TENTATIVE)) {</span>
<span class="nc" id="L534">			RequestUtil.createCalendarEventAssignment(toReq, apprChoice, true);</span>
		} else {
<span class="nc" id="L536">			CalendarEventAssignment event = TORequestUtil.getCalEventAssignForTOChoiceAligned(toReq, apprChoice, false, null);</span>
<span class="nc bnc" id="L537" title="All 4 branches missed.">			if (event != null &amp;&amp; event.getStartTime().equals(apprChoice.getStartDate())</span>
<span class="nc bnc" id="L538" title="All 4 branches missed.">					&amp;&amp; event.getEndTime().equals(apprChoice.getEndDate()) &amp;&amp; event.getActivityID().equals(toReq.getTimeOffType())) {</span>
<span class="nc" id="L539">				String com = RequestUtil.getAuditTrailStr(toReq);</span>
<span class="nc" id="L540">				event.setDescription(com);</span>
<span class="nc" id="L541">				ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L542">				sam.updateCalendarEventAssignment(event);</span>
			}
		}
<span class="nc bnc" id="L545" title="All 4 branches missed.">		boolean stafingExists = !RequestUtil.isNetStaffingUpdateForTOMDisabled() &amp;&amp; cache.doesStaffingExistForPeriod(toReq, apprChoice);</span>
<span class="nc" id="L546">		Map postTracecubes = null;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">		if (stafingExists) {</span>
<span class="nc" id="L548">			NetStaffingCube nsCube = cache.getPostTOApprovalNetStaffingCube(toReq, apprChoice);</span>
<span class="nc bnc" id="L549" title="All 4 branches missed.">			if (nsCube != null &amp;&amp; !nsCube.getPredictTraceCubeMap().isEmpty()) {</span>
<span class="nc" id="L550">				postTracecubes = cache.getPostTOReqTraceCube(toReq, apprChoice, nsCube.getTimeRange());</span>
<span class="nc" id="L551">				cache.getTimeSeriesManager().updateAdjustedFTEAndStaffing(postTracecubes);</span>
			}
		}
		// publish event.
<span class="nc" id="L555">		publishTOChoiceTimeRange(toReq, apprChoice);</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">		if (stafingExists &amp;&amp; postTracecubes != null) {</span>
<span class="nc" id="L557">			cache.getTimeSeriesManager().updateAdjustedFTEAndStaffing(postTracecubes);</span>
		}
<span class="nc" id="L559">    }</span>
	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestPostProcess(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
	 */
	@Override
	protected void _approveRequestPostProcess(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment) {
<span class="nc" id="L569">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestTentatively(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String, boolean)
	 */
	@Override
	protected void _approveRequestTentatively(RequestAggregate reqAgg, Collection&lt;ID&gt; givenChoiceIdToApprove, String comment,
			boolean loadedFromDB)
			throws Exception {

		// handle the case if the specified apprChoiceID == null.

<span class="nc" id="L585">		Collection&lt;ID&gt; approvedChoices = getApprChoiceIDIfNull(reqAgg, givenChoiceIdToApprove);</span>

<span class="nc bnc" id="L587" title="All 2 branches missed.">		if (approvedChoices.isEmpty()) {</span>
<span class="nc" id="L588">			throw new RmRuntimeException(&quot;No choices found to tentatively approve&quot;);</span>
		}


<span class="nc" id="L592">		String methodName = &quot;_approveRequestTentatively&quot;;</span>
<span class="nc" id="L593">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, &quot;&quot;, comment));</span>

<span class="nc" id="L595">		TORequest toReq = (TORequest) reqAgg;</span>

<span class="nc" id="L597">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
		// check for overlapping calendar events

<span class="nc bnc" id="L600" title="All 2 branches missed.">		for (ID apprChoiceID : approvedChoices) {</span>
<span class="nc" id="L601">			Collection overlapEvents = TORequestUtil.getCalEventAssignsForTOChoiceOverlapped(toReq, toReq.getTOChoice(apprChoiceID), false,</span>
					sam);

			// if found overlapping events, throw exception
<span class="nc bnc" id="L605" title="All 4 branches missed.">			if (overlapEvents != null &amp;&amp; !overlapEvents.isEmpty()) {</span>
<span class="nc" id="L606">				throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.TO_UNABLE_TO_UNDO_TENTAPPR, m_cat);</span>
			}
<span class="nc" id="L608">		}</span>

		// to indicate that lengths are used in hard validator TimeOffChoiceApprOrTentApprNotZeroLengthHV.java.
<span class="nc" id="L611">		toReq.addDetailLevel(TORequest.DL_TIMEOFF_CHOICES_LENGTH);</span>
<span class="nc" id="L612">		toReq.addDetailLevel(TORequest.DL_AUDIT_TRAIL);</span>
		List&lt;TOChoice&gt; apprChoices;

<span class="nc bnc" id="L615" title="All 2 branches missed.">		if(reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L616">			apprChoices = updateRequestWithApprovedChoice(toReq, approvedChoices, RequestAuditTrail.STATUS_TENTATIVE,</span>
					comment,
				RequestAuditTrail.STATUS_TENTATIVE, false, loadedFromDB, false);
		} else {
<span class="nc" id="L620">			apprChoices = updateRequestWithApprovedChoice(toReq, approvedChoices, RequestAuditTrail.STATUS_TENTATIVE,</span>
					comment,
<span class="nc" id="L622">					RequestAuditTrail.STATUS_TENTATIVE, false, loadedFromDB, hasAdvanceLicense());</span>

		}


<span class="nc bnc" id="L627" title="All 2 branches missed.">		for (TOChoice apprChoice : apprChoices) {</span>
<span class="nc" id="L628">			RequestUtil.createCalendarEventAssignment(toReq, apprChoice, false);</span>
<span class="nc" id="L629">		}</span>



<span class="nc" id="L633">		m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L634">	}</span>

	/**
	 * If the givenApprChoiceID is null: &lt;li&gt;first checks the approved choiceID in the request. if non-null, returns it. This is
	 * necessary since cofirm_all_tentative group action passes a tentatively approved request with a proper approvedChoiceID but
	 * specifies 'null' for the givenChoiceID. &lt;li&gt;If null, then returns the first TOChoice ID.
	 *
	 * @param reqAgg
	 * @param givenApprChoiceID
	 * @return
	 */
	private Collection&lt;ID&gt; getApprChoiceIDIfNull(RequestAggregate reqAgg, Collection&lt;ID&gt; givenApprChoiceIDs) {
		// if the given approved choice ID is not null, simply return.
<span class="nc bnc" id="L647" title="All 4 branches missed.">		if (givenApprChoiceIDs != null &amp;&amp; !givenApprChoiceIDs.isEmpty()) {</span>
<span class="nc" id="L648">			return givenApprChoiceIDs;</span>
		}

<span class="nc" id="L651">		TORequest toReq = (TORequest) reqAgg;</span>

		// check if the approved choice ID is set in the request when the givenApprChoiceID == null
		//
		// Happens when using CONFIRM_TENT_ALL group processing. In this case,
		// the request has the approved choice ID but the group processing logic specifies 'null'
		// for the choiceID to be approved.

<span class="nc" id="L659">		Collection&lt;ID&gt; approvedChoices = toReq.getApprovedChoiceIDs();</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">		if (!approvedChoices.isEmpty()) {</span>
<span class="nc" id="L661">			return approvedChoices;</span>
		}

<span class="nc" id="L664">		TOChoice firstRankOneChoice = toReq.getFirstTOChoice();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">		if (firstRankOneChoice == null) {</span>
<span class="nc" id="L666">			return Collections.emptySet();</span>
		}

		// use the first choice with rank set to 1. This was existing behavior
<span class="nc" id="L670">		return Collections.singleton(firstRankOneChoice.getID());</span>
	}

	@Override
	protected void _denyRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB)
			throws Exception {
<span class="nc" id="L676">		String oldStatus = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">		if(reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L678">			_updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null,suppressPrivilegeChecking, loadedFromDB);</span>
		}else {
<span class="nc" id="L680">			_updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null, false, suppressPrivilegeChecking, loadedFromDB,</span>
<span class="nc" id="L681">					hasAdvanceLicense());</span>
		}
<span class="nc bnc" id="L683" title="All 2 branches missed.">		if (oldStatus.equals(RequestAuditTrail.STATUS_TENTATIVE)) {</span>
<span class="nc" id="L684">			TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">			for (TOChoice toChoice : toReq.getApprovedChoices()) {</span>
<span class="nc" id="L686">				TORequestUtil.deleteCalendarEventAssignment(toReq, toChoice);</span>
<span class="nc" id="L687">			}</span>
		}
<span class="nc" id="L689">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequestPostProcess(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, java.lang.String)
	 */
	@Override
	protected void _denyRequestPostProcess(RequestAggregate reqAgg, String comment) {
<span class="nc" id="L700">	}</span>

	@Override
	protected RequestAggregate _undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment) throws Exception {
<span class="nc" id="L704">		String methodName = &quot;_undoTentativeApprovalByID&quot;;</span>
<span class="nc" id="L705">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqID, objectVersionNumber, comment));</span>
<span class="nc" id="L706">		RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">		if (objectVersionNumber != null) {</span>
<span class="nc" id="L708">			reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
		}

		// change status to pending
<span class="nc" id="L712">		TORequest toReq = (TORequest) reqAgg;</span>

		// perform hard validation. Note that this is a hack. If hard validations are performed within
		// the _updateRequest() method below, a call to TORequest.getTOChoice(TORequest.getApprChoiceID()) fails in the
		// hardValidator TentativeRequestHardValidationRule. This is because TOReq.setApprovedChoiceID(null) is
		// invoked below before the hard validator is run. To get around this problem, the hard validations are
		// performed outside the _updateRequest() method. Note that 'true' is passed for the suppressHardVal
		// parameter in the _updateRequest() call below. Code needs to be refactored to fix this.
		//
		// All update operations need to perform the following:
		// load the entire request or fill the fields in a partial request (webtier passes an incomplete
		// VO when updating just one or two fields in the VO. for example when updating the
		// shiftBidRequest's usePoints field.).
		// checkStateTransistion
		// checkPrivilege
		// perform hardValidations
		// do other operations related to update (for example, on approval create TOEvent.
		// finally perform the update.
		//
		// The current logic does the following which is flawed.
		// load the entire request if necessary.
		// update part of the request (in this case apprChoice is set to null).
		// fill up the fields if the request is partial
		// checkStateTransitionAndPriv.
		// runHardValiations (Note, the request is in a partially updated state).
		// perform update
		// perform other operations related to update (Note this may happen before or after the above update operation).
<span class="nc" id="L739">		doHardValidationsRaiseException(reqAgg, RequestUtil.METHODTYPE_MODIFIER, null, false);</span>

<span class="nc" id="L741">		List&lt;TOChoice&gt; oldApprChoices = new ArrayList&lt;TOChoice&gt;(toReq.getApprovedChoices());</span>

<span class="nc" id="L743">		_updateRequest(toReq, RequestAuditTrail.STATUS_PENDING, comment, null, true, false, true);</span>

<span class="nc" id="L745">		toReq.emptyApprovedChoices(); // clear approved TOChoice</span>

<span class="nc" id="L747">		TORequestUtil.deleteCalendarEventAssignments(toReq, oldApprChoices);</span>

<span class="nc" id="L749">		m_cat.debug(RmUtil.dumpExitMethod(methodName, reqAgg));</span>
<span class="nc" id="L750">		return reqAgg;</span>
	}

	/**
	 * &lt;li&gt;For TORequests, the TOChoices can be updated. This update is not done in place by updating the fields of the existing
	 * TOChoices. Instead existing TOChoices are deleted and the new ones are added.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#updateRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate,
	 *      com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO, boolean)
	 */
	@Override
	protected RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, boolean loadedFromDB)
			throws Exception {
<span class="nc bnc" id="L763" title="All 2 branches missed.">		boolean needToAllocDAO = (reqAggDAO == null);</span>
		try {
<span class="nc" id="L765">			TORequest tor = (TORequest) reqAgg;</span>

<span class="nc" id="L767">			long detailLevel = getDetailLevelForValidation();</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">			reqAggDAO = (reqAggDAO == null) ? getDAO(detailLevel) : reqAggDAO;</span>
<span class="nc" id="L769">			TORequest TOReqFromDB = (TORequest) reqAggDAO.getRequestByID(tor.getID(), detailLevel);</span>

			// Validate that the request still belongs to the same employee
<span class="nc bnc" id="L772" title="All 2 branches missed.">			if (!tor.getEmployeeID().equals(TOReqFromDB.getEmployeeID())) {</span>
<span class="nc" id="L773">				throw RequestUtil.createRmException(RmEjbLogBundleKey.CANNOT_CHANGE_EMPLOYEEID,</span>
<span class="nc" id="L774">						new Object[] { tor.getID(), tor.getEmployeeID(), TOReqFromDB.getEmployeeID() }, m_cat);</span>
			}

<span class="nc" id="L777">			updateExpiration(tor);</span>

<span class="nc" id="L779">			return tor;</span>
		} finally {
<span class="nc bnc" id="L781" title="All 8 branches missed.">			if (needToAllocDAO &amp;&amp; reqAggDAO != null) {</span>
<span class="nc" id="L782">				reqAggDAO.cleanUp();</span>
			}
		}
	}

	@Override
	protected void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, Object[] optionalUndoData) throws Exception {

<span class="nc" id="L790">		TORequest toReq = (TORequest) reqAgg;</span>

		// if approved or tentatively approved
<span class="nc bnc" id="L793" title="All 4 branches missed.">		if (toReq.isApproved() || toReq.isTentative()) {</span>
<span class="nc" id="L794">			Collection&lt;TOChoice&gt; apprChoices = toReq.getApprovedChoices();</span>
			// delete calendar event assignment
<span class="nc" id="L796">			TORequestUtil.deleteCalendarEventAssignments(toReq, apprChoices);</span>

			// erase event in published schedule
<span class="nc bnc" id="L799" title="All 2 branches missed.">			if (toReq.isApproved()) {</span>
<span class="nc" id="L800">				unPublishTOChoiceTimeRange(toReq, apprChoices);</span>
			}
		}

<span class="nc" id="L804">	}</span>


	protected void updateExpiration(TORequest toReq) throws Exception {
		// Update expiration date for this request from the list of associated TOChoices.
<span class="nc" id="L809">		Date expDate = getExpiryDate(toReq);</span>
<span class="nc" id="L810">		toReq.setExpirationDate(expDate);</span>
<span class="nc" id="L811">	}</span>

	private Date getExpiryDate(TORequest toReq) throws RmException, BbmFinderException, RmHardValidationException {

<span class="nc bnc" id="L815" title="All 2 branches missed.">		if (toReq.isAdvancedVTORequest()) {</span>
<span class="nc" id="L816">			return new Date(RequestUtil.MAX_DATE.getTime());</span>
		}

<span class="nc" id="L819">		List&lt;TOChoice&gt; choices = toReq.getTOChoicesAdjustedForCalculatedVto();</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">		if (choices.isEmpty()) {</span>
<span class="nc" id="L821">			throw new RmRuntimeException(&quot;This request has no valid choices&quot;);</span>
		}

<span class="nc" id="L824">		Collection&lt;ID&gt; apprChoiceIDs = getApprChoiceIDIfNull(toReq, null);</span>

<span class="nc bnc" id="L826" title="All 2 branches missed.">		if (hasValidChoiceIDs(apprChoiceIDs)) {</span>
			//Expiry date for approved requests
			//Do something different for approved choices was first introduced in commit
			//SHA-1: f52bc039a22737ffadd03adc04219b3771e8712b. Not sure why we are doing this
<span class="nc" id="L830">			return getMinStartDate(toReq, apprChoiceIDs);</span>

		}

<span class="nc" id="L834">		Date expDate = getExpiryDateForNonApprovedRequest(toReq);</span>
<span class="nc bnc" id="L835" title="All 4 branches missed.">		if (toReq.getWaitlistInfo() != null &amp;&amp; toReq.getWaitlistInfo().getTOWaitlistExpiryDate() == null) {</span>
<span class="nc" id="L836">				toReq.getWaitlistInfo().setTOWaitlistExpiryDate(expDate);</span>
		}

<span class="nc" id="L839">		return expDate;</span>
	}

	private boolean hasValidChoiceIDs(Collection&lt;ID&gt; choiceIds) {

<span class="nc bnc" id="L844" title="All 4 branches missed.">		if (choiceIds == null || choiceIds.isEmpty()) {</span>
<span class="nc" id="L845">			return false;</span>
		}

<span class="nc bnc" id="L848" title="All 2 branches missed.">		for (ID choiceId : choiceIds) {</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">			if (choiceId != null) {</span>
<span class="nc" id="L850">				return true;</span>
			}
<span class="nc" id="L852">		}</span>

<span class="nc" id="L854">		return false;</span>
	}

	private Date getExpiryDateForNonApprovedRequest(TORequest toReq) throws BbmFinderException, RmHardValidationException {

		// Expiration date is earliest start date among the TOChoices
		// OR
		// Waitlist Choice start date if request is waitlisted

<span class="nc" id="L863">		Date expDate = new Date(Long.MAX_VALUE);</span>

<span class="nc bnc" id="L865" title="All 2 branches missed.">		for (TOChoice choice : toReq.getTOChoicesAdjustedForCalculatedVto()) {</span>

<span class="nc bnc" id="L867" title="All 4 branches missed.">			if (choice.isWaitlist() &amp;&amp; toReq.getWaitlistInfo() != null) {</span>
<span class="nc" id="L868">				return choice.getStartDate();</span>
			}

<span class="nc" id="L871">			Date start = choice.getStartDate();</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">			if (start.before(expDate)) {</span>
<span class="nc" id="L873">				expDate = start;</span>
			}

			// Allow TO in the Past. Sameet Feb 2009
<span class="nc bnc" id="L877" title="All 2 branches missed.">			if (isTimeOffChoiceForPastDate(toReq, choice)) {</span>
				// really big date...akin to never expires
<span class="nc" id="L879">				return new Date(RequestUtil.MAX_DATE.getTime());</span>
			}
<span class="nc" id="L881">		}</span>

<span class="nc" id="L883">		return expDate;</span>

	}

	private Date getMinStartDate(TORequest toReq, Collection&lt;ID&gt; apprChoiceIDs) throws RmException, BbmFinderException,
			RmHardValidationException {

<span class="nc" id="L890">		long minStart = Long.MAX_VALUE;</span>

<span class="nc bnc" id="L892" title="All 2 branches missed.">		for (ID apprChoiceID : apprChoiceIDs) {</span>

<span class="nc bnc" id="L894" title="All 2 branches missed.">			if (apprChoiceID == null) {</span>
<span class="nc" id="L895">				continue;</span>
			}

<span class="nc" id="L898">			TOChoice approvedChoice = toReq.getTOChoice(apprChoiceID);</span>

<span class="nc bnc" id="L900" title="All 2 branches missed.">			if (isTimeOffChoiceForPastDate(toReq, approvedChoice)) {</span>
				// really big date...akin to never expires
<span class="nc" id="L902">				return new Date(RequestUtil.MAX_DATE.getTime());</span>
			}

<span class="nc" id="L905">			Date start = approvedChoice.getStartDate();</span>

<span class="nc" id="L907">			minStart = Math.min(minStart, start.getTime());</span>
<span class="nc" id="L908">		}</span>

<span class="nc bnc" id="L910" title="All 2 branches missed.">		return minStart == Long.MAX_VALUE ? new Date(RequestUtil.MAX_DATE.getTime()) : new Date(minStart);</span>

	}

	private boolean isTimeOffChoiceForPastDate(TORequest req, TOChoice choice) throws BbmFinderException, RmHardValidationException {
<span class="nc bnc" id="L915" title="All 2 branches missed.">		if (req.getSubmittedOn() == null) {</span>
<span class="nc" id="L916">			RequestAggregate reqFromDB = getRequestByID(req.getID(), true, false, Request.DL_BASIC);</span>
<span class="nc" id="L917">			req.setSubmittedOn(reqFromDB.getSubmittedOn());</span>
		}
<span class="nc" id="L919">		return TORequestUtil.isTimeOffChoiceForPastDate(req, choice);</span>
	}

	private List&lt;TOChoice&gt; updateRequestWithApprovedChoice(TORequest toReq, Collection&lt;ID&gt; choiceIds, String newState, String comment,
			String methodSubType, boolean suppressPrivilegeChecking, boolean loadedFromDB, boolean skipSomeHardRulesWhenUpdate)
			throws Exception { // NOSONAR
		// obtain the 1st timeoff choice if none specified

<span class="nc" id="L927">		List&lt;TOChoice&gt; approved = new ArrayList&lt;TOChoice&gt;();</span>
<span class="nc" id="L928">		Set&lt;ID&gt; apprChoiceIDs = new HashSet&lt;ID&gt;(choiceIds);</span>

<span class="nc" id="L930">		Collection&lt;TOChoice&gt; choices = toReq.getTOChoicesAdjustedForCalculatedVto();</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">		if (choices != null) {</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">			for (TOChoice choice : choices) {</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">				if (apprChoiceIDs.contains(choice.getID())) {</span>
<span class="nc" id="L934">					choice.setRank(1);</span>
<span class="nc" id="L935">					choice.setIsApproved(true);</span>
<span class="nc" id="L936">					toReq.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
<span class="nc" id="L937">					approved.add(choice);</span>
				} else {
<span class="nc" id="L939">					choice.setRank(0);</span>
<span class="nc" id="L940">					choice.setIsApproved(false);</span>
<span class="nc" id="L941">					toReq.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
				}
<span class="nc" id="L943">			}</span>
		}

		// do hard validation for the choices that we are going to approve.
		// This only validates that each approved choice pass validation.
		// It does not handle the case that approving a choice causes the other choices to be come invalid.
		// _updateRequest takes care of the hard validations
<span class="nc" id="L950">		toReq.setTOChoiceForValidation(approved);</span>

<span class="nc" id="L952">		_updateRequest(toReq, newState, comment, methodSubType, false,</span>
				suppressPrivilegeChecking, loadedFromDB, skipSomeHardRulesWhenUpdate);

<span class="nc" id="L955">		return approved;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDPurge()
	 */
	@Override
	protected ID getPrivIDPurge() {
<span class="nc" id="L965">		return PrivilegeKeys.TOM_PURGEREQUESTS_ID;</span>
	}

	private void publishTOChoiceTimeRange(TORequest reqAgg, TOChoice apprChoice) throws Exception { // NOSONAR
<span class="nc" id="L969">		m_cat.debug(&quot;Publishing TOReq, apprvChoice: &quot; + reqAgg + '\n' + apprChoice);</span>
<span class="nc" id="L970">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L971">		sam.publishTimeOffEvents(Collections.singleton(reqAgg.getEmployeeID()), apprChoice.getStartDate(), apprChoice.getEndDate());</span>
<span class="nc" id="L972">	}</span>

	private void unPublishTOChoiceTimeRange(RequestAggregate reqAgg, Collection&lt;TOChoice&gt; apprChoices) throws Exception {
<span class="nc" id="L975">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">		for (TOChoice choice : apprChoices) {</span>
<span class="nc" id="L977">			unPublishTOChoiceTimeRange(reqAgg, choice, sam);</span>
<span class="nc" id="L978">		}</span>

<span class="nc" id="L980">	}</span>


	private void unPublishTOChoiceTimeRange(RequestAggregate reqAgg, TOChoice apprChoice, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L984">		m_cat.debug(&quot;Un-Publishing TOReq, apprvChoice: &quot; + reqAgg + '\n' + apprChoice);</span>

<span class="nc" id="L986">		sam.unPublishTimeOffEvents(Collections.singleton(reqAgg.getEmployeeID()), apprChoice.getStartDate(), apprChoice.getEndDate());</span>
<span class="nc" id="L987">	}</span>

	/**
	 * Add columns necessary to process a query governed by the given filter. The caller has already added columns from the REQUEST
	 * (as A), EMPLOYEE (as B) and PERSON (as C) tables. Columns from new tables should start with D as a column synonym. See
	 * {@link #addToFromClause addToFromClause} for how the from clause is modified, {@link #addToWhereClause addToWhereClause} for
	 * how the where clause is modified, and {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by a
	 * request manager to reflect type-specific filtered queries. Columns added by this method should insert a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic columns have already been added, this method should append its
	 *            columns.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToSelectColumns(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc bnc" id="L1002" title="All 4 branches missed.">		if (Request.SORT_CS_STARTTIME == sortColumn || Request.SORT_CS_ENDTIME == sortColumn) {</span>
<span class="nc" id="L1003">			query.append(&quot;, max(TOR.FLEXTYPE) AS FLEXTYPE &quot;);</span>
		} else {
<span class="nc" id="L1005">			query.append(&quot;, TOR.FLEXTYPE &quot;);</span>
		}

		// Note: Since a 'SELECT DISTINCT' clause may be used in the query, any columns used for sorting must be
		// listed in the 'SELECT' statement.
		//
		// Add TimeOff specific columns to result set. The result set columns
		// need to contain any column that might be sorted on. For TIME OFF
		// requests, we might want to sort on the start or end date of the
		// first choice. We add the TIMEOFFREQUESTCHOICE choice table twice
		// but when referred to as E, it represents only the first choice
<span class="nc bnc" id="L1016" title="All 2 branches missed.">		if (sortColumn == Request.SORT_TO_ACTIVITY) {</span>
<span class="nc" id="L1017">			query.append(&quot;, TOR.ACTIVITYID &quot;);</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_DEBIT_TYPE) {</span>
<span class="nc" id="L1019">			query.append(&quot;, TOR.DEBITTYPE &quot;);</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_START) {</span>
<span class="nc" id="L1021">			query.append(&quot;, TORC1.STARTTIME &quot;);</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_END) {</span>
<span class="nc" id="L1023">			query.append(&quot;, TORC1.ENDTIME &quot;);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_SENIORITY) {</span>
<span class="nc" id="L1025">			query.append(&quot;, &quot; + TABLE_EMPLOYEEAM_ALIAS + &quot;.STARTTIME &quot;);</span>
		} // else if (sortColumn == Request.SORT_ORGANIZATION_NAME){
			// query.append(&quot;, &quot;).append(&quot; ORG.NAME &quot;);
			// }
<span class="nc" id="L1029">	}</span>

	/**
	 * Add tables necessary to process a query governed by the given filter. The caller has already added the REQUEST (as A),
	 * EMPLOYEE (as B) and PERSON (as C) tables. New tables should start with D as a column synonym. See
	 * {@link #aaddToSelectColumns addToSelectColumns} for how the column list is modified, {@link #addToWhereClause
	 * addToWhereClause} for how the where clause is modified, and {@link #addOrderByClause addOrderByClause} for how the order by
	 * clause is modified by a request manager to reflect type-specific filtered queries. Tables added by this method should insert
	 * a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic tables have already been added, this method should append its
	 *            tables with a leading comma and start with D as a synonym.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToFromClause(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
		// Add tables for TimeOff specific columns to result set. The result set columns
		// need to contain any column that might be sorted on. For TIME OFF
		// requests, we might want to sort on the start or end date of the
		// first choice. Since we also want to look at the date information
		// in other choices, we include the TIMEOFFREQUESTCHOICE table twice
<span class="nc" id="L1050">		boolean hasActivityInQuery= false;</span>
<span class="nc" id="L1051">		query.append(&quot;, TIMEOFFREQUEST TOR, TIMEOFFREQUESTCHOICE TORC1, V_TIMEOFFREQUESTCHOICE TORC2 &quot;);</span>

		// If we need to filter on full or partial day, then we'll need the EMPLOYEETIMEOFF
		// table as well
<span class="nc bnc" id="L1055" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.TO_FULL_OR_PARTIAL_DAY_KEY)) {</span>
<span class="nc" id="L1056">			query.append(&quot;, EMPLOYEETIMEOFF ET &quot;);</span>
		}
<span class="nc bnc" id="L1058" title="All 2 branches missed.">		if (RequestAuditTrail.isRequestForWithdrawalStates((String) requestFilter.getValueForKey(RequestFilter.STATUS_KEY))) {</span>
<span class="nc" id="L1059">			query.append(&quot;, TIMEOFFWITHDRAWALREQUEST TWR &quot;);</span>
		}

<span class="nc bnc" id="L1062" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">			if(hasActivityInQuery) {</span>
<span class="nc" id="L1064">				query.append(&quot;, TIMEOFFBID TOB, TIMEOFFBIDDER TOBD, TIMEOFFBIDACTIVITY TBA&quot;);</span>
			} else {
<span class="nc" id="L1066">				query.append(&quot;, TIMEOFFBID TOB, TIMEOFFBIDDER TOBD, TIMEOFFBIDACTIVITY TBA, ACTIVITY ACT&quot;);</span>
<span class="nc" id="L1067">				hasActivityInQuery = true;</span>
			}
		}
<span class="nc bnc" id="L1070" title="All 4 branches missed.">		if (!hasActivityInQuery&amp;&amp;requestFilter.isKeySet(RequestFilter.TO_ACTIVITIES_KEY)) {</span>
<span class="nc" id="L1071">			 query.append(&quot;, ACTIVITY ACT &quot;);</span>
<span class="nc" id="L1072">			 hasActivityInQuery = true;</span>
	    }

<span class="nc" id="L1075">	}</span>

	/**
	 * Add conditions necessary to process a query governed by the given filter. The caller has already added the generic where
	 * conditions. See {@link #aaddToSelectColumns addToSelectColumns} for how the column list is modified, {@link #addToFromClause
	 * addToFromClause} for how the from clause is modified, and {@link #addOrderByClause addOrderByClause} for how the order by
	 * clause is modified by a request manager to reflect type-specific filtered queries. Conditions added by this method should
	 * insert a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic where clauses have already been added, this method should
	 *            append its conditions with a leading AND and both front and rear pad with a space.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToWhereClause(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L1090">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1091">		StringsPair dates = null;</span>
<span class="nc" id="L1092">		String rangeStart = &quot;&quot;;</span>
<span class="nc" id="L1093">		String rangeEnd = &quot;&quot;;</span>

		try {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L1097">				TimeOffBidDAO dao = new TimeOffBidDAO();</span>

				try {
<span class="nc" id="L1100">					ID bidID = new ID(requestFilter.getValueForKey(RequestFilter.TOBID_KEY).toString());</span>
<span class="nc" id="L1101">					TimeOffBid bid = dao.getObjectByID(bidID);</span>
					/*We need to get the intersect cua request date range on UI and request bid date range*/
<span class="nc" id="L1103">					List dateRange = (List) requestFilter.getValueForKey(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L1104">			        Date start = null;</span>
<span class="nc" id="L1105">			        Date end = null;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">				    if (dateRange != null){</span>
<span class="nc" id="L1107">				    	start = (Date) dateRange.get(0);</span>
<span class="nc" id="L1108">					    end  = (Date) dateRange.get(1);</span>
				    }
<span class="nc bnc" id="L1110" title="All 2 branches missed.">				    if (start == null) {</span>
<span class="nc" id="L1111">						start = new Date();</span>
					}
<span class="nc bnc" id="L1113" title="All 2 branches missed.">				    if (end == null) {</span>
<span class="nc" id="L1114">						end = new Date();</span>
					}
<span class="nc" id="L1116">				    Timeline timeLine = (new Timeline(start,end)).intersect(new Timeline(bid.getRequestStartTime(),bid.getRequestEndTime()));</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">				    TimeRange newRange = timeLine.isEmpty()? new TimeRange(start,end):timeLine.getTimeRanges().get(0);</span>

<span class="nc" id="L1119">					rangeStart = JdmoUtil.formatDBString(newRange.getStartDate());</span>
<span class="nc" id="L1120">					rangeEnd = JdmoUtil.formatDBString(newRange.getEndDate());</span>
<span class="nc" id="L1121">				} catch (Exception e) {</span>
<span class="nc" id="L1122">					dates = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L1123">					rangeStart = dates.getKey();</span>
<span class="nc" id="L1124">					rangeEnd = dates.getValue();</span>
<span class="nc" id="L1125">					m_cat.debug(&quot;Unable to retrieve Bid for ID &quot;);</span>
				} finally {
<span class="nc bnc" id="L1127" title="All 6 branches missed.">					if (dao != null) {</span>
<span class="nc" id="L1128">						dao.cleanUp();</span>
					}
				}
<span class="nc" id="L1131">			} else {</span>
				// QA 95168
<span class="nc" id="L1133">				dates = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L1134">				rangeStart = dates.getKey();</span>
<span class="nc" id="L1135">				rangeEnd = dates.getValue();</span>
			}

<span class="nc" id="L1138">			Date dtNow = new Date();</span>
<span class="nc" id="L1139">			String strDtNow = JdmoUtil.formatDBString(dtNow);</span>
			// END QA 95168

<span class="nc" id="L1142">			query.append(&quot; AND TOR.ID=REQ.ID &quot;)// join TIMEOFFREQUEST to REQUEST</span>
<span class="nc" id="L1143">					.append(&quot; AND TORC1.TIMEOFFREQUESTID=REQ.ID &quot;)// join TIMEOFFREQUESTID to REQUEST</span>
<span class="nc" id="L1144">					.append(&quot; AND TORC2.TIMEOFFREQUESTID=REQ.ID &quot;)// join TIMEOFFREQUESTID to REQUEST</span>
<span class="nc" id="L1145">					.append(&quot; AND TORC1.RANK=1 &quot;)// table E is only the first choices</span>
					// .append(&quot; AND ORG.ID = WRO.ORGANIZATIONID &quot;) //TO get the Organization Name
					// QA 94310: Get Request within Organization assignment only! This prevent duplicate/triplicate/...
					// if agent was assigned to more than 1 Organization during the time window
					// QA 95168: fix date restrictions in query
<span class="nc" id="L1150">					.append(&quot;AND &quot;);</span>
<span class="nc" id="L1151">			RmUtil.appendRequestDateRangeClauses(query, &quot;&quot;, &quot;TORC2&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L1152">			query.append(&quot; &quot;);</span>
			// query.append(&quot; AND (TORC2.STARTTIME &gt;= WRO.STARTTIME AND (WRO.ENDTIME IS NULL OR TORC2.STARTTIME &lt; WRO.ENDTIME ))&quot;);
			// query.append(&quot; AND &quot;);

<span class="nc" id="L1156">			String filterStatus = (String) requestFilter.getValueForKey(RequestFilter.STATUS_KEY);</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">			if (RequestAuditTrail.isRequestForWithdrawalStates(filterStatus)) { // include the Join to the WIthdrawal request tabel</span>
																				// only if the withdraw states are queried.
<span class="nc" id="L1159">				query.append(&quot; AND TWR.TIMEOFFREQUESTID = REQ.ID &quot;);</span>
<span class="nc" id="L1160">				query.append(&quot; AND TWR.REQUESTSTATUS='&quot;).append(filterStatus).append(&quot;' &quot;);</span>
			}

			// See if we're only interested in the first choices
<span class="nc" id="L1164">			String numChoicesFromFilter = (String) requestFilter.getValueForKey(RequestFilter.TO_NUMBER_OF_CHOICES_KEY);</span>

<span class="nc bnc" id="L1166" title="All 2 branches missed.">			if (RequestFilter.FIRST_ONLY_TO_CHOICE.equals(numChoicesFromFilter)) {</span>
				// restrict the second TIMEOFFREQUESTCHOICE choice table to first choices
<span class="nc" id="L1168">				query.append(&quot; AND TORC2.RANK=1 &quot;);</span>
			}

			// If we need to filter on full or partial day, add that filter
<span class="nc bnc" id="L1172" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TO_FULL_OR_PARTIAL_DAY_KEY)) {</span>
<span class="nc" id="L1173">				query.append(&quot; AND ET.EMPLOYEEID=REQ.EMPLOYEEID AND ET.ACTIVITYID=TOR.ACTIVITYID &quot;);</span>

<span class="nc" id="L1175">				String fullOrPartial = (String) requestFilter.getValueForKey(RequestFilter.TO_FULL_OR_PARTIAL_DAY_KEY);</span>

<span class="nc bnc" id="L1177" title="All 2 branches missed.">				if (RequestFilter.TO_PARTIAL_DAY.equals(fullOrPartial)) {</span>
					// Partial day
<span class="nc" id="L1179">					query.append(&quot; AND TORC2.DURATIONHOURS &lt;  ET.HOURSPERDAY &quot;);</span>
				} else {
					// Full day
<span class="nc" id="L1182">					query.append(&quot; AND TORC2.DURATIONHOURS &gt;= ET.HOURSPERDAY &quot;);</span>
				}
			}

			// if filtering by timeoff activity is necessary
<span class="nc bnc" id="L1187" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TO_ACTIVITY_ID_KEY)) {</span>
				// obtain the activity ID
<span class="nc" id="L1189">				ID activityID = (ID) requestFilter.getValueForKey(RequestFilter.TO_ACTIVITY_ID_KEY);</span>
				// append to the where clause.
<span class="nc" id="L1191">				query.append(&quot; AND TOR.ACTIVITYID = &quot;).append(activityID).append(' ');</span>
			}

<span class="nc" id="L1194">			appendFlexTypeWhereClause(query, requestFilter, sortColumn);</span>

<span class="nc" id="L1196">			appendTimeOffPoolWhereClause(query, requestFilter, rangeStart, rangeEnd);</span>

			// Add Where for Time Off Bid Selection
<span class="nc bnc" id="L1199" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L1200">				query.append(&quot; AND ACT.ID = TOR.ACTIVITYID AND TBA.ACTIVITYID = ACT.ID AND TOB.ID = TBA.TIMEOFFBIDID&quot;)</span>
<span class="nc" id="L1201">						.append(&quot; AND TOB.ID = TOBD.TIMEOFFBIDID AND (TOB.BIDSTARTTIME&lt;=REQ.SUBMITTEDON and REQ.SUBMITTEDON&lt;=TOB.BIDENDTIME)&quot;)</span>
<span class="nc" id="L1202">						.append(&quot; AND (TOB.REQUESTSTARTTIME&lt;=TORC2.STARTTIME and TORC2.ENDTIME&lt;=TOB.REQUESTENDTIME)&quot;)</span>
<span class="nc" id="L1203">						.append(&quot; AND TOBD.EMPLOYEEID = REQ.EMPLOYEEID&quot;).append(&quot; AND TOB.ID = &quot;)</span>
<span class="nc" id="L1204">						.append(requestFilter.getValueForKey(RequestFilter.TOBID_KEY)).append(&quot; &quot;);</span>
			}
<span class="nc bnc" id="L1206" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TO_ACTIVITIES_KEY)) {</span>
				String activitiesInClauseList;
				try {
<span class="nc" id="L1209">					activitiesInClauseList = dmo.createInClause(</span>
<span class="nc" id="L1210">					(Collection) requestFilter.getValueForKey(RequestFilter.TO_ACTIVITIES_KEY));</span>
<span class="nc" id="L1211">					query.append(&quot; AND ACT.ID = TOR.ACTIVITYID AND TOR.ACTIVITYID IN &quot;).append(activitiesInClauseList);</span>
<span class="nc" id="L1212">				} catch (JdmoException e) {</span>
<span class="nc" id="L1213">					m_cat.debug(&quot;Unable to retrieve time off activitys IDs &quot;);</span>
<span class="nc" id="L1214">				}</span>
	        }

		} finally {
<span class="nc bnc" id="L1218" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1219">				dmo.cleanUp();</span>
			}
		}
<span class="nc" id="L1222">	}</span>

	private void appendTimeOffPoolWhereClause(StringBuffer query, RequestFilter requestFilter, String sqlStart, String sqlEnd) {

<span class="nc bnc" id="L1226" title="All 4 branches missed.">		if (!requestFilter.isKeySet(RequestFilter.TOPOOL_KEY) || !requestFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)) {</span>
<span class="nc" id="L1227">			return;</span>
		}
<span class="nc" id="L1229">		ID poolID = (ID) requestFilter.getValueForKey(RequestFilter.TOPOOL_KEY);</span>

<span class="nc bnc" id="L1231" title="All 2 branches missed.">		if (poolID != null) {</span>
			//The pool shown for the time off request is the pool associated with the request choice that starts earliest
			//This is not seem correct, but it is what was being done before this change.
<span class="nc" id="L1234">			String sql = String.format(&quot; AND REQ.ID in (&quot;</span>
					+ &quot; select RequestID &quot; +
					&quot; from ( select CP.RequestID, ROW_NUMBER() over (partition by RequestID order by StartTime asc)  RN&quot; +
					&quot; from V_RM_RequestChoiceTOPOOL CP &quot; +
					&quot; where CP.STARTTIME &lt; '%s'  and CP.ENDTIME &gt; '%s'  and CP.TOPOOLID = %d  &quot; +
<span class="nc" id="L1239">					&quot; ) A where A.RN = 1  ) &quot;, sqlEnd, sqlStart, poolID.toInt());</span>

<span class="nc" id="L1241">			query.append(sql);</span>
		}
<span class="nc" id="L1243">	}</span>

	/**
	 * Add the appropriate FLEXTYPE clause to the query (either FLEXTYPE_NONE or FLEXTYPE_FLEXWITHMAKEUP).
	 */
	protected void appendFlexTypeWhereClause(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L1249">		query.append(&quot; AND TOR.FLEXTYPE = &quot;).append(TORequest.FLEXTYPE_NONE).append(' ');</span>
<span class="nc" id="L1250">	}</span>

	/**
	 * Add conditions necessary to process a query governed by the given filter. The caller has already added everthing but the
	 * order by clause. See {@link #aaddToSelectColumns addToSelectColumns} for how the column list is modified,
	 * {@link #addToFromClause addToFromClause} for how the from clause is modified, and {@link #addToWhereClause addToWhereClause}
	 * for how the where clause is modified by a request manager to reflect type-specific filtered queries. Conditions added by this
	 * method should insert a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic where clauses have already been added, this method should
	 *            append its conditions with a leading AND and both front and rear pad with a space.
	 * @param requestFilter the request filter
	 * @param sortColumn identifies the column to use to sort the requests. The constants that define the expected values are in
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
	 * @param sortDir This string is either &quot; ASC &quot; or &quot; DESC &quot; depending on whether or not the sort is ascending or descending.
	 *            (Note spaces around values for convenience.)
	 */
	@Override
	public void addOrderByClause(StringBuffer query, RequestFilter requestFilter, int sortColumn, String sortDir) {
<span class="nc bnc" id="L1269" title="All 2 branches missed.">		if (sortColumn == Request.SORT_TO_ACTIVITY) {</span>
<span class="nc" id="L1270">			query.append(&quot; ORDER BY TOR.ACTIVITYID &quot;).append(sortDir);</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_DEBIT_TYPE) {</span>
<span class="nc" id="L1272">			query.append(&quot; ORDER BY TOR.DEBITTYPE &quot;).append(sortDir);</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_START) {</span>
<span class="nc" id="L1274">			query.append(&quot; ORDER BY TORC1.STARTTIME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_END) {</span>
<span class="nc" id="L1276">			query.append(&quot; ORDER BY TORC1.ENDTIME &quot;).append(sortDir);</span>
		}
<span class="nc" id="L1278">	}</span>

	/**
	 * Return a collection of {@link com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName EmployeeName} objects for all employees
	 * in the given organization that have a time off event scheduled beginning during the organization day which contains the given
	 * date. If an employee id is supplied, the returned list of EmployeeNames is further restrcited to just those employees that
	 * are supervised by the manager with the given employee id.
	 *
	 * @param mgrEmpID employee id of manager that supervises employees, can be null. If null, then all employees in the
	 *            organization with time off on the date will be returned.
	 * @param orgID the organization id
	 * @param date a date (in the organization's time zone) that identifies the range of time off events to search for. The specific
	 *            range used is the organization day (as defined by the organization day boundary) that contains the given date.
	 * @return Collection of {@link com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName EmployeeName} objects
	 * @throws BbmFinderException
	 */
	public Collection getEmpNamesForScheduledTO(ID mgrEmpID, ID orgID, ID pTOPoolID, Date date) throws BbmFinderException {
<span class="nc" id="L1295">		methodStart(&quot;getEmpNamesForScheduledTO&quot;, mgrEmpID, orgID, date);</span>
		try {
<span class="nc" id="L1297">			Map nameMap = new HashMap();</span>
			// Get the organization object so that we have the timezone and day offset
<span class="nc" id="L1299">			Organization org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc" id="L1300">			Collection allotmentList = TOCalendarUtil.getListOfAllAllotmentActivities();</span>
<span class="nc" id="L1301">			Date start = null;</span>
<span class="nc" id="L1302">			Date end = null;</span>
<span class="nc" id="L1303">			HashSet empIds = new HashSet();</span>
<span class="nc" id="L1304">			Date empStartDate = TOCalendarUtil.getBackAyearforDate(date);</span>

<span class="nc" id="L1306">			Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1307">			cal.setTime(date);</span>
<span class="nc" id="L1308">			cal.add(Calendar.DAY_OF_MONTH, -2);</span>
<span class="nc" id="L1309">			start = cal.getTime();</span>
<span class="nc" id="L1310">			cal.add(Calendar.DAY_OF_MONTH, 4);</span>
<span class="nc" id="L1311">			end = cal.getTime();</span>
<span class="nc" id="L1312">			Collection childOrgs = Collections.emptyList();</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">			if (pTOPoolID == null) {</span>
<span class="nc" id="L1314">				Pair pair = getEmpIdsInOrgForMgr(null, orgID, true, empStartDate, end);</span>
<span class="nc" id="L1315">				empIds.addAll((Collection) pair.getFirst());</span>
<span class="nc" id="L1316">				childOrgs = (Collection) pair.getSecond();</span>
<span class="nc" id="L1317">			} else {</span>
<span class="nc" id="L1318">				CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L1319">				empIds.addAll(toCalFacade.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, end));</span>
			}
<span class="nc" id="L1321">			TimeRange range = new TimeRange(start, end);</span>
			//JT, adding activityID = null
<span class="nc" id="L1323">			DailyHoursBuckets bkts = TOCalendarUtil.getTOScheduledData(pTOPoolID, org, childOrgs, empIds, range, allotmentList, true, null);</span>

<span class="nc" id="L1325">			List toHrsPerDayCol = bkts.getTOHoursPerDayForDate(date);</span>
<span class="nc" id="L1326">			double totalHrsForTheDate = bkts.getBucketHours(date);</span>
<span class="nc bnc" id="L1327" title="All 4 branches missed.">			if (toHrsPerDayCol != null &amp;&amp; !toHrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L1328">				Set empIdsSet = new HashSet();</span>
<span class="nc" id="L1329">				empIdsSet.addAll(ValueObjectUtil.getFieldObjectCol(TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_EMPLOYEEID, toHrsPerDayCol));</span>
<span class="nc" id="L1330">				WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1331">				nameMap = wrm.getEmployeeNamesByIDs(empIdsSet);</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1333">					TORequestUtil.formatEmpNames(date, empIds, orgID, nameMap, range, allotmentList, totalHrsForTheDate);</span>
				}
			}
<span class="nc" id="L1336">			return RequestUtil.getMapValues(nameMap);</span>
<span class="nc" id="L1337">		} catch (Exception e) {</span>
<span class="nc" id="L1338">			handleException(e);</span>
<span class="nc" id="L1339">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1341">			methodFinish();</span>
		}
	}

	/**
	 * Get the time off activity summary data for an employee for the given time off year.
	 * &lt;p/&gt;
	 * &lt;p&gt;
	 * For the given TOYear (start and end of the TOYear is based on orgConfig settings which can either be 'use employee's anniv
	 * date' or 'use fixed date') summarize the time off statistics for each activity which is marked (requesttable, timeoff and
	 * hasAllocations). The summary includes the fields in {@link TimeOffActivitySummary TimeOffActivitySummary} class which are:
	 * &lt;li&gt;total allocated hours
	 * &lt;li&gt;used hours
	 * &lt;li&gt;scheduled hours
	 * &lt;li&gt;remaining hours
	 * &lt;li&gt;pending hours.
	 *
	 * @param empID the employee for whom the time off activity data is returned.
	 * @param year the employee year in question. The time off year that begins on a date in this year will be used.
	 * @param requestableOnly - If true, we will include activities only if they are enabled for the &quot;Is Requestable&quot; attribute.
	 * @param withAllotmentOnly - If true, we will include activities only if they are enabled for the
	 *            &quot;Is Time Off With Allottment/Accrual&quot; attribute.
	 * @return an array of TimeOffActivitySummary objects
	 * @throws BbmFinderException when errors encountered during the construction of the TimeOffActivitySummary objects
	 * @see TimeOffActivitySummary
	 */
	public HashMap getTOActivitySummaryData(Collection empIDs, int year, ID activityID, Date dt, boolean requestableOnly,
			boolean withAllotmentOnly) throws BbmFinderException {
<span class="nc" id="L1369">		HashMap empSummaryMap = new HashMap();</span>
		try {
<span class="nc" id="L1371">			long startTime = new Date().getTime();</span>
<span class="nc" id="L1372">			ReportDumpStatistic statistic = new ReportDumpStatistic();</span>
<span class="nc" id="L1373">			HashMap dataForAllEmps = getEmployeeData(statistic, empIDs, activityID, year, dt, requestableOnly, withAllotmentOnly,</span>
					null, null);
<span class="nc bnc" id="L1375" title="All 2 branches missed.">			for (Iterator iterator = dataForAllEmps.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1376">				ID empId = (ID) iterator.next();</span>
<span class="nc" id="L1377">				HashMap empData = (HashMap) dataForAllEmps.get(empId);</span>
<span class="nc" id="L1378">				empSummaryMap.put(empId, getTOActivitySummaryData(statistic, empId, empData, true));</span>
<span class="nc" id="L1379">			}</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1381">				m_cat.info(&quot;getTOActivitySummaryData Total Time for &quot; + empIDs.size() + &quot; Emps = &quot; + (new Date().getTime() - startTime)</span>
						+ &quot;MSecs&quot;);
			}
<span class="nc" id="L1384">		} catch (Exception e) {</span>
<span class="nc" id="L1385">			handleException(e);</span>
<span class="nc" id="L1386">		}</span>
<span class="nc" id="L1387">		return empSummaryMap;</span>
	}

	private TimeOffActivitySummary[] getTOActivitySummaryData(ReportDumpStatistic statistic, ID empID, HashMap empData,
			boolean computeSchedAndPending) throws BbmFinderException {
<span class="nc" id="L1392">		String _method_ = &quot;getTOActivitySummaryData&quot;;</span>
<span class="nc" id="L1393">		methodStart(_method_, empID);</span>
<span class="nc" id="L1394">		long timeStart = System.currentTimeMillis();</span>

		try {
<span class="nc" id="L1397">			Calendar empTOYearStCal = (Calendar) empData.get(&quot;empTOYearStCal&quot;);</span>
<span class="nc" id="L1398">			Calendar empTOYearEnCal = (Calendar) empData.get(&quot;empTOYearEnCal&quot;);</span>
<span class="nc" id="L1399">			Employee emp = (Employee) empData.get(&quot;Employee&quot;);</span>
<span class="nc" id="L1400">			Organization org = (Organization) empData.get(&quot;Organization&quot;);</span>
<span class="nc" id="L1401">			HashMap orgActivityMap = (HashMap) empData.get(&quot;ActivityMap&quot;);</span>
<span class="nc" id="L1402">			HashMap actCatMap = (HashMap) empData.get(&quot;ActivityCatMap&quot;);</span>
			// if no org activities are found, short circuit.
<span class="nc bnc" id="L1404" title="All 2 branches missed.">			if (orgActivityMap.isEmpty()) {</span>
<span class="nc" id="L1405">				m_cat.debug(&quot;No activities found with the attributes: (requestable, timeoff, withallotment) for orgID: &quot; + org.getID());</span>
<span class="nc" id="L1406">				return new TimeOffActivitySummary[0];</span>
			}
			// Use the returned set of activities to build a map of summaries for this employee
			// Later, we'll add to the counters in each summary element
			// for each activity, retrieve yearly allocation.
<span class="nc" id="L1411">			Map actIDToTOActSummMap = new HashMap();</span>
<span class="nc" id="L1412">			setTOActSummWithColorAndYearlyAlloc(empID, empTOYearStCal.getTime(), empTOYearEnCal.getTime(), orgActivityMap.values(),</span>
					actIDToTOActSummMap, actCatMap, empData);
<span class="nc" id="L1414">			long timeAfterGetRemaining = System.currentTimeMillis();</span>
<span class="nc" id="L1415">			statistic.add(&quot;m_TimeSpentOnGetRemaining&quot;, timeAfterGetRemaining - timeStart);</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">			if (computeSchedAndPending) {</span>
<span class="nc" id="L1417">				fillPendingAndScheduledHoursForSummary(empData, actIDToTOActSummMap);</span>
			}
<span class="nc" id="L1419">			long timeAfterGetPendAndSched = System.currentTimeMillis();</span>
<span class="nc" id="L1420">			statistic.add(&quot;m_TimeSpentOnGetPendAndSched&quot;, timeAfterGetPendAndSched - timeAfterGetRemaining);</span>
<span class="nc" id="L1421">			return (TimeOffActivitySummary[]) actIDToTOActSummMap.values().toArray(</span>
<span class="nc" id="L1422">					new TimeOffActivitySummary[actIDToTOActSummMap.values().size()]);</span>
<span class="nc" id="L1423">		} catch (Exception e) {</span>
<span class="nc" id="L1424">			handleException(e);</span>
<span class="nc" id="L1425">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1427">			methodFinish();</span>
		}
	}

	private HashMap getEmployeeData(ReportDumpStatistic statistic, Collection empIDs, ID activityID, int year, Date date,
			boolean requestableOnly, boolean withAllotmentOnly, HashMap orgActivityMap, HashMap orgActCatMap) throws Exception { // NOSONAR
<span class="nc" id="L1433">		long timeStart = System.currentTimeMillis();</span>
<span class="nc" id="L1434">		HashMap dataForAllEmps = new HashMap();</span>
		// Get the organization id
<span class="nc" id="L1436">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1437">		ActivityManager actMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L1438">		Collection emps = wrm.getEmployeesByIDs(empIDs, new Date(), Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
<span class="nc" id="L1439">		long timeAfterGetEmps = System.currentTimeMillis();</span>
<span class="nc" id="L1440">		statistic.add(&quot;m_TimeSpentOnGetEmps&quot;, timeAfterGetEmps - timeStart);</span>
<span class="nc" id="L1441">		HashMap empOrgMap = getEmpOrgIDs(wrm, empIDs);</span>
<span class="nc" id="L1442">		Set&lt;ID&gt; orgIDSet = new TreeSet&lt;&gt;(empOrgMap.values());</span>
<span class="nc" id="L1443">		HashMap orgIDMap = ValueObjectUtil.getIDObjectMap(wrm.getOrganizationsByIDs(orgIDSet));</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">		if (activityID == null) {</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">			if (orgActivityMap == null) {</span>
<span class="nc" id="L1446">				orgActivityMap = getOrgActivitiesMap(orgIDSet, requestableOnly, withAllotmentOnly);</span>
			}
<span class="nc bnc" id="L1448" title="All 2 branches missed.">			if (orgActCatMap == null) {</span>
<span class="nc" id="L1449">				orgActCatMap = getOrgActivityCategoryMap(orgIDSet);</span>
			}
		}
<span class="nc bnc" id="L1452" title="All 2 branches missed.">		Collection singActivityList = activityID != null ? Collections.singleton(activityID) : null;</span>
		// ActivityTimeOff Balance
<span class="nc" id="L1454">		HashMap empTOYearStDateMap = new HashMap();</span>
<span class="nc" id="L1455">		HashMap empTOYearEnDateMap = new HashMap();</span>
<span class="nc" id="L1456">		int stYear = 0;</span>
<span class="nc" id="L1457">		int enYear = 0;</span>
<span class="nc" id="L1458">		Calendar now = Calendar.getInstance();</span>
<span class="nc" id="L1459">		TreeSet empIdsRequestingCurYear = new TreeSet();</span>
<span class="nc" id="L1460">		long timeAfterGetActivity = System.currentTimeMillis();</span>
<span class="nc" id="L1461">		statistic.add(&quot;m_TimeSpentOnGetActivity&quot;, timeAfterGetActivity - timeAfterGetEmps);</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">		for (Iterator iterator = emps.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1463">			Employee emp = (Employee) iterator.next();</span>
<span class="nc" id="L1464">			Organization org = (Organization) orgIDMap.get(empOrgMap.get(emp.getID()));</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">			if (activityID != null) {</span>
<span class="nc" id="L1466">				Activity act = WfmManagerFactory.getActivityManager().findActivityById(activityID);</span>
<span class="nc" id="L1467">				orgActivityMap = new HashMap();</span>
<span class="nc" id="L1468">				HashMap actIDMap = new HashMap();</span>
<span class="nc" id="L1469">				actIDMap.put(act.getID(), act);</span>
<span class="nc" id="L1470">				orgActivityMap.put(org.getID(), actIDMap);</span>
<span class="nc" id="L1471">				orgActCatMap = new HashMap();</span>
			}
			// Get the month and day for the employee's time off year
<span class="nc" id="L1474">			int[] empTOYrStArr = RequestUtil.getEmployeeTimeOffYearStart(emp, org);</span>
			// Compute the range to use for building the summary
<span class="nc" id="L1476">			HashMap empData = new HashMap();</span>
<span class="nc" id="L1477">			empData.put(&quot;AnniverseryMonthYear&quot;, empTOYrStArr);</span>

<span class="nc" id="L1479">			Calendar empTOYearStCal = null;</span>
<span class="nc" id="L1480">			Calendar empTOYearEnCal = null;</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">			if (date != null) {</span>
				/*
				 * empTOYearStCal = Calendar.getInstance(org.getTimeZone()); empTOYearStCal.setTime(date); empTOYearStCal =
				 * RequestUtil.getCalendar(empTOYearStCal.get(Calendar.YEAR), md[0], md[1], org.getTimeZone()); if
				 * (empTOYearStCal.getTime().after(date)) { empTOYearStCal.add(Calendar.YEAR, -1); }
				 */
<span class="nc" id="L1487">				empTOYearStCal = RequestUtil.getEmployeeTimeOffYearStart(date, org, empTOYrStArr);</span>
<span class="nc" id="L1488">				empTOYearEnCal = RequestUtil.getEmployeeTimeOffYearEnd(date, org, empTOYrStArr);</span>
			} else {
<span class="nc" id="L1490">				empTOYearStCal = RequestUtil.getCalendar(year, empTOYrStArr[0], empTOYrStArr[1], org.getTimeZone());</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">				if (org.getDayBoundaryOffset() != 0) {</span>
<span class="nc" id="L1492">					empTOYearStCal.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
				}
<span class="nc" id="L1494">				empTOYearEnCal = RequestUtil.getCalendarForwardOneYear(year, empTOYrStArr[0], empTOYrStArr[1], org.getTimeZone());</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">				if (org.getDayBoundaryOffset() != 0) {</span>
<span class="nc" id="L1496">					empTOYearEnCal.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
				}
			}
<span class="nc bnc" id="L1499" title="All 2 branches missed.">			if (empTOYearEnCal.after(now)) {</span>
<span class="nc" id="L1500">				empIdsRequestingCurYear.add(emp.getID());</span>
			}
<span class="nc" id="L1502">			empData.put(&quot;empTOYearStCal&quot;, empTOYearStCal);</span>
<span class="nc" id="L1503">			empTOYearStDateMap.put(emp.getID(), empTOYearStCal);</span>
<span class="nc bnc" id="L1504" title="All 4 branches missed.">			if (stYear == 0 || stYear &gt; empTOYearStCal.get(Calendar.YEAR)) {</span>
<span class="nc" id="L1505">				stYear = empTOYearStCal.get(Calendar.YEAR);</span>
			}

<span class="nc" id="L1508">			empData.put(&quot;empTOYearEnCal&quot;, empTOYearEnCal);</span>
<span class="nc" id="L1509">			empTOYearEnDateMap.put(emp.getID(), empTOYearEnCal);</span>
<span class="nc bnc" id="L1510" title="All 4 branches missed.">			if (enYear == 0 || enYear &lt; empTOYearEnCal.get(Calendar.YEAR)) {</span>
<span class="nc" id="L1511">				enYear = empTOYearEnCal.get(Calendar.YEAR);</span>
			}

<span class="nc" id="L1514">			empData.put(&quot;Employee&quot;, emp);</span>
<span class="nc" id="L1515">			empData.put(&quot;Organization&quot;, org);</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">			if (orgActivityMap.get(org.getID()) == null) {</span>
<span class="nc" id="L1517">				m_cat.info(&quot;orgActivityMap null for org= &quot; + org.getID());</span>
			}

<span class="nc" id="L1520">			empData.put(&quot;ActivityMap&quot;, orgActivityMap.get(org.getID()));</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">			if (orgActCatMap != null) {</span>
<span class="nc" id="L1522">				empData.put(&quot;ActivityCatMap&quot;, orgActCatMap.get(org.getID()));</span>
			}
<span class="nc" id="L1524">			dataForAllEmps.put(emp.getID(), empData);</span>
<span class="nc" id="L1525">		}</span>
<span class="nc" id="L1526">		long timeAfterGetTOYearRange = System.currentTimeMillis();</span>
<span class="nc" id="L1527">		statistic.add(&quot;m_timeForGetTOYearRange&quot;, timeAfterGetTOYearRange - timeAfterGetActivity);</span>
		// Need to get Last updated balance date before start of year (Starting balance)
<span class="nc" id="L1529">		HashMap minDateMap = new HashMap();</span>
<span class="nc" id="L1530">		minDateMap.putAll(empTOYearStDateMap);</span>
		if (true) {// TOAccrualCalculator.hasLicenseForAccrual()) {
<span class="nc" id="L1532">			HashMap empActTOBalMap = actMgr.getActivityTOBalanceMap(empIDs, singActivityList, null);</span>
<span class="nc" id="L1533">			HashMap empTOAccruedMap = new HashMap();</span>

			// get latest Last updated balance date for current TO Year and future Years.
<span class="nc" id="L1536">			empTOAccruedMap.putAll(wrm.getLastUpdatedTOAccrued(empTOYearEnDateMap, singActivityList, null));</span>
<span class="nc" id="L1537">			HashMap empTOAccruedForStBalMap = wrm.getLastUpdatedTOAccrued(empTOYearStDateMap, singActivityList, null);</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">			for (Iterator iterator = empTOYearStDateMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1539">				ID empID = (ID) iterator.next();</span>
<span class="nc" id="L1540">				HashMap hashMap = (HashMap) empTOAccruedForStBalMap.get(empID);</span>
				// update the MinDate to query only if balance is available hence ; the carry over will be zero anyways.
<span class="nc bnc" id="L1542" title="All 4 branches missed.">				if (hashMap != null &amp;&amp; !hashMap.isEmpty()) {</span>
<span class="nc" id="L1543">					Calendar minDateCal = (Calendar) empTOYearStDateMap.get(empID);</span>
<span class="nc" id="L1544">					Date minDate = new Date(minDateCal.getTime().getTime());</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">					for (Iterator iterator1 = hashMap.values().iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L1546">						EmployeeTimeOffAccrued accrued = (EmployeeTimeOffAccrued) iterator1.next();</span>
<span class="nc bnc" id="L1547" title="All 4 branches missed.">						if (minDate == null || accrued.getAccruedAtDate().before(minDate)) {</span>
<span class="nc" id="L1548">							minDate = accrued.getAccruedAtDate();</span>
						}
<span class="nc" id="L1550">					}</span>
<span class="nc" id="L1551">					minDateCal = Calendar.getInstance(); // Need a copy here</span>
<span class="nc" id="L1552">					minDateCal.setTime(minDate);</span>
<span class="nc" id="L1553">					minDateMap.put(empID, minDateCal);</span>
<span class="nc bnc" id="L1554" title="All 4 branches missed.">					if (stYear == 0 || stYear &gt; minDateCal.get(Calendar.YEAR)) {</span>
<span class="nc" id="L1555">						stYear = minDateCal.get(Calendar.YEAR);</span>
					}
				}
<span class="nc" id="L1558">				HashMap empData = (HashMap) dataForAllEmps.get(empID);</span>
<span class="nc" id="L1559">				HashMap actTOBalMap = (HashMap) empActTOBalMap.get(empID);</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">				if (actTOBalMap == null) {</span>
<span class="nc" id="L1561">					actTOBalMap = new HashMap();</span>
				}
<span class="nc" id="L1563">				empData.put(&quot;actTOBalMap&quot;, actTOBalMap);</span>
<span class="nc" id="L1564">				HashMap tOAccruedMap = (HashMap) empTOAccruedMap.get(empID);</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">				if (tOAccruedMap == null) {</span>
<span class="nc" id="L1566">					tOAccruedMap = new HashMap();</span>
				}
<span class="nc" id="L1568">				empData.put(&quot;tOAccruedMap&quot;, tOAccruedMap);</span>

<span class="nc" id="L1570">				HashMap tOAccruedStBalMap = (HashMap) empTOAccruedForStBalMap.get(empID);</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">				if (tOAccruedStBalMap == null) {</span>
<span class="nc" id="L1572">					tOAccruedStBalMap = new HashMap();</span>
				}
<span class="nc" id="L1574">				empData.put(&quot;tOAccruedStBalMap&quot;, tOAccruedStBalMap);</span>

<span class="nc" id="L1576">			}</span>
		}
<span class="nc" id="L1578">		long timeAfterGetSTBal = System.currentTimeMillis();</span>
<span class="nc" id="L1579">		statistic.add(&quot;m_timeForGetSTBal&quot;, timeAfterGetSTBal - timeAfterGetTOYearRange);</span>

		// EmployeeTimeOFF Allotment based on the latest balance
<span class="nc" id="L1582">		HashMap empToYearlyAllotmentMap = wrm.getEmployeeTimeOffYearlyMap(empIDs, singActivityList, null, stYear - 2, enYear);</span>
<span class="nc" id="L1583">		long timeAfterYrlyAllotMap = System.currentTimeMillis();</span>
<span class="nc" id="L1584">		statistic.add(&quot;m_timeForYrlyAllotMap&quot;, timeAfterYrlyAllotMap - timeAfterGetSTBal);</span>

		// TimeOff Events based on last updated date before TO year
<span class="nc bnc" id="L1587" title="All 2 branches missed.">		Map&lt;ID, List&lt;TOHoursPerDay&gt;&gt; empHrsPerDayMap = getTOHoursPerDayManager().getHoursPerDayForRange(minDateMap,</span>
				empTOYearEnDateMap,
				(activityID != null ? singActivityList : null));

<span class="nc bnc" id="L1591" title="All 2 branches missed.">		for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1592">			ID empID = (ID) iterator.next();</span>
<span class="nc" id="L1593">			HashMap empData = (HashMap) dataForAllEmps.get(empID);</span>
<span class="nc" id="L1594">			List&lt;TOHoursPerDay&gt; hrsPerDayCol = empHrsPerDayMap.get(empID);</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">			if (hrsPerDayCol == null) {</span>
<span class="nc" id="L1596">				hrsPerDayCol = new ArrayList();</span>
			}
<span class="nc" id="L1598">			empData.put(&quot;hrsPerDayCol&quot;, hrsPerDayCol);</span>
<span class="nc" id="L1599">			HashMap yearlyAllotmentMap = (HashMap) empToYearlyAllotmentMap.get(empID);</span>
<span class="nc bnc" id="L1600" title="All 2 branches missed.">			if (yearlyAllotmentMap == null) {</span>
<span class="nc" id="L1601">				yearlyAllotmentMap = new HashMap();</span>
			}
<span class="nc" id="L1603">			empData.put(&quot;yearlyAllotmentMap&quot;, yearlyAllotmentMap);</span>
<span class="nc" id="L1604">		}</span>
<span class="nc" id="L1605">		long timeAfterHrsPerDay = System.currentTimeMillis();</span>
<span class="nc" id="L1606">		statistic.add(&quot;m_timeForHrsPerDay&quot;, timeAfterHrsPerDay - timeAfterYrlyAllotMap);</span>
<span class="nc" id="L1607">		return dataForAllEmps;</span>
	}

	public HashMap getOrgActivitiesMap(Collection orgIDs, boolean requestableOnly, boolean withAllotmentOnly) throws Exception {
<span class="nc" id="L1611">		HashMap orgActMap = new HashMap();</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">		for (Iterator iterator = orgIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1613">			ID orgId = (ID) iterator.next();</span>
			// HashMap actMap
<span class="nc" id="L1615">			orgActMap.put(orgId, ValueObjectUtil.getIDObjectMap(getTimeOffActs(orgId, requestableOnly, withAllotmentOnly)));</span>
<span class="nc" id="L1616">		}</span>
<span class="nc" id="L1617">		return orgActMap;</span>
	}

	public HashMap getOrgActivityCategoryMap(Collection orgIDs) throws Exception {
<span class="nc" id="L1621">		HashMap orgActCatMap = new HashMap();</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">		for (Iterator iterator = orgIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1623">			ID orgId = (ID) iterator.next();</span>
			// HashMap actCatMap
<span class="nc" id="L1625">			orgActCatMap.put(orgId, getActivityCategoryWithAlloc(orgId));</span>
<span class="nc" id="L1626">		}</span>
<span class="nc" id="L1627">		return orgActCatMap;</span>
	}

	public HashMap getEmpOrgIDs(WorkResourceManager wrm, Collection empIDs) throws Exception {
<span class="nc" id="L1631">		HashMap empOrgMap = new HashMap();</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">		if (wrm == null) {</span>
<span class="nc" id="L1633">			wrm = BbmManagerFactory.getWorkResourceManager();</span>
		}
		// get organization at the start of the given calc date range.
<span class="nc" id="L1636">		Map wrOrgMap = wrm.getValidWorkResourceAssignments(empIDs, new LocalDate(new Date()), new LocalDate(new Date()), false);</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">		for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1638">			ID empId = (ID) iterator.next();</span>
<span class="nc" id="L1639">			ID orgId = null;</span>
<span class="nc" id="L1640">			Collection wrOrg = (Collection) wrOrgMap.get(empId);</span>
<span class="nc bnc" id="L1641" title="All 4 branches missed.">			if (wrOrg != null &amp;&amp; !wrOrg.isEmpty()) {</span>
<span class="nc" id="L1642">				WorkResourceAssignment wra = (WorkResourceAssignment) wrOrg.iterator().next();</span>
<span class="nc" id="L1643">				orgId = wra.getOrganizationID();</span>
			}
<span class="nc bnc" id="L1645" title="All 2 branches missed.">			if (orgId == null) {</span>
<span class="nc" id="L1646">				orgId = Organization.ROOT_ORG_ID_OBJ;</span>
			}
<span class="nc" id="L1648">			empOrgMap.put(empId, orgId);</span>
<span class="nc" id="L1649">		}</span>
<span class="nc" id="L1650">		return empOrgMap;</span>
	}

	private void fillPendingAndScheduledHoursForSummary(HashMap empData, Map actIDToTOActSummMap) throws Exception {

<span class="nc" id="L1655">		Calendar empTOYearStCal = (Calendar) empData.get(&quot;empTOYearStCal&quot;);</span>
<span class="nc" id="L1656">		Calendar empTOYearEnCal = (Calendar) empData.get(&quot;empTOYearEnCal&quot;);</span>
<span class="nc" id="L1657">		Employee emp = (Employee) empData.get(&quot;Employee&quot;);</span>
<span class="nc" id="L1658">		Organization org = (Organization) empData.get(&quot;Organization&quot;);</span>
<span class="nc" id="L1659">		Collection hrsPerDayCol = (Collection) empData.get(&quot;hrsPerDayCol&quot;);</span>
<span class="nc" id="L1660">		Calendar nowCal = Calendar.getInstance(org.getTimeZone());</span>
		// process scheduled/taken time- off
<span class="nc bnc" id="L1662" title="All 2 branches missed.">		if (hrsPerDayCol != null) {</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">			for (Iterator it = hrsPerDayCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1664">				TOHoursPerDay hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">				if (!hoursPerDay.getStartTime().before(empTOYearEnCal.getTime())</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">						|| !hoursPerDay.getEndTime().after(empTOYearStCal.getTime())) {</span>
<span class="nc" id="L1667">					continue; // this event is not even relevant</span>
				}
<span class="nc" id="L1669">				float duration = 0.0f;</span>
<span class="nc" id="L1670">				boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(empTOYearStCal.getTime());</span>
<span class="nc" id="L1671">				boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(empTOYearEnCal.getTime());</span>
<span class="nc bnc" id="L1672" title="All 4 branches missed.">				if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc" id="L1673">					DailyHoursBuckets dailyBuckets = null;</span>
					try {
<span class="nc bnc" id="L1675" title="All 2 branches missed.">						dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">								isToEvtStartBeforeStart ? empTOYearStCal.getTime() : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L1677">								isToEvtEndAfterEnd ? empTOYearEnCal.getTime() : hoursPerDay.getEndTime());</span>
<span class="nc" id="L1678">					} catch (Exception e) {</span>
<span class="nc" id="L1679">						e.printStackTrace(); // To change body of catch statement use File | Settings | File Templates.</span>
<span class="nc" id="L1680">					}</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">					duration += dailyBuckets == null ? 0 : dailyBuckets.getTotalHours();</span>
<span class="nc" id="L1682">				} else {</span>
<span class="nc" id="L1683">					duration += (hoursPerDay.getTotalMinutes() / 60f);</span>
				}
				// Get the summary object for this activity
<span class="nc" id="L1686">				ID timeOffEvtActID = hoursPerDay.getActivityID();</span>
<span class="nc" id="L1687">				TimeOffActivitySummary summary = (TimeOffActivitySummary) actIDToTOActSummMap.get(Activity.getActivity_ActCategoryComb(</span>
						timeOffEvtActID, null));

				// Note: if no yearly timeoff allocation is specified for the timeoff event's activity,
				// then the summary for this activity will not be found in the map above. Refer to the comments
				// associated iwth activityManager.findOrganizationActivities() call above. As a result, the
				// time off summary screen in the UI will not list the proper hours for 'pending', 'scheduled' etc
				// for the timeoff event's activity.
<span class="nc bnc" id="L1695" title="All 4 branches missed.">				if (summary == null || summary.getActivityID() == null) {</span>
<span class="nc" id="L1696">					continue;</span>
				}
<span class="nc bnc" id="L1698" title="All 4 branches missed.">				if (hoursPerDay.getTOChoiceID() != null &amp;&amp; hoursPerDay.getExpiryDate().after(nowCal.getTime())) {</span>
<span class="nc" id="L1699">					summary.addToPending(duration);</span>
				} else {
					// If it is in the past, it represents time off
					// taken, if it is in the future, it's scheduled.
					// for these purposes, use the start date of the event
<span class="nc bnc" id="L1704" title="All 2 branches missed.">					if (!hoursPerDay.getEndTime().after(nowCal.getTime())) {// used</span>
<span class="nc" id="L1705">						summary.addToUsed(duration);</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">					} else if (!hoursPerDay.getStartTime().before(nowCal.getTime())) {// scheduled</span>
<span class="nc" id="L1707">						summary.addToScheduled(duration);</span>
					} else {// overlaps current time
						// get the daily break down and allocate accordingly
						// used
<span class="nc" id="L1711">						DailyHoursBuckets usedDailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc" id="L1712">								hoursPerDay.getStartTime(), nowCal.getTime());</span>
<span class="nc" id="L1713">						summary.addToUsed(usedDailyBuckets.getTotalHours());</span>

						// scheduled
<span class="nc" id="L1716">						org = TOHoursPerDayUtil.getOrganization(hoursPerDay);</span>
<span class="nc" id="L1717">						Date nowOrgStartDate = TOCalcUtil.getDateForOrgDayStart(org.getTimeZone(), org.getDayBoundaryOffset(),</span>
<span class="nc" id="L1718">								nowCal.getTime());</span>
						// forward one day, because current day is calculated for used hours as above
<span class="nc" id="L1720">						Date nextOrgStartDate = TOCalcUtil.getDateForwardOneDay(nowOrgStartDate, org.getTimeZone());</span>

<span class="nc bnc" id="L1722" title="All 2 branches missed.">						if (nextOrgStartDate.before(hoursPerDay.getEndTime())) {</span>
<span class="nc" id="L1723">							DailyHoursBuckets schedDailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc" id="L1724">									nextOrgStartDate, hoursPerDay.getEndTime());</span>
<span class="nc" id="L1725">							summary.addToScheduled(schedDailyBuckets.getTotalHours());</span>
						}
					}
				}
<span class="nc" id="L1729">			}</span>
		}
		// Compute total hours for all &amp;
		// compute the Pending , used and sched hours for activity category
<span class="nc bnc" id="L1733" title="All 2 branches missed.">		for (Iterator iterator = actIDToTOActSummMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1734">			TimeOffActivitySummary summary = (TimeOffActivitySummary) iterator.next();</span>
<span class="nc bnc" id="L1735" title="All 2 branches missed.">			if (summary.getActivityID() == null) { // this is Activity category</span>
<span class="nc" id="L1736">				float usedHrs = 0f;</span>
<span class="nc" id="L1737">				float schedHrs = 0f;</span>
<span class="nc" id="L1738">				float pendHrs = 0f;</span>
<span class="nc bnc" id="L1739" title="All 2 branches missed.">				for (Iterator iterator1 = actIDToTOActSummMap.values().iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L1740">					TimeOffActivitySummary activitySummary = (TimeOffActivitySummary) iterator1.next();</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">					if (activitySummary.getActivityCategory() != null</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">							&amp;&amp; activitySummary.getActivityCategory().getID().equals(summary.getActivityCategory().getID())) {</span>
<span class="nc" id="L1743">						usedHrs += activitySummary.getUsed();</span>
<span class="nc" id="L1744">						schedHrs += activitySummary.getScheduled();</span>
<span class="nc" id="L1745">						pendHrs += activitySummary.getPending();</span>
					}
<span class="nc" id="L1747">				}</span>
<span class="nc" id="L1748">				summary.setPending(pendHrs);</span>
<span class="nc" id="L1749">				summary.setScheduled(schedHrs);</span>
<span class="nc" id="L1750">				summary.setUsed(usedHrs);</span>
<span class="nc" id="L1751">				summary.setTotal(usedHrs + schedHrs + summary.getRemaining());</span>
			}
<span class="nc bnc" id="L1753" title="All 2 branches missed.">			if (summary.getActivityCategory() == null) {</span>
				if (true) {// TOAccrualCalculator.hasLicenseForAccrual()) {
<span class="nc" id="L1755">					summary.setTotal(summary.getUsed() + summary.getScheduled() + summary.getRemaining());</span>
				} else {
					summary.setRemaining(summary.getTotal() - (summary.getUsed() + summary.getScheduled()));
				}
			}
<span class="nc" id="L1760">		}</span>
<span class="nc" id="L1761">	}</span>

	/**
	 * @param requestableOnly - If true, we will include activities only if they are enabled for the &quot;Is Requestable&quot; attribute.
	 * @param withAllotmentOnly - If true, we will include activities only if they are enabled for the
	 *            &quot;Is Time Off With Allottment/Accrual&quot; attribute.
	 */
	public TimeOffActivitySummary[] getTOActivitySummaryData(ID empID, int year, ID activityID, boolean requestableOnly,
			boolean withAllotmentOnly) throws BbmFinderException {
<span class="nc" id="L1770">		TimeOffActivitySummary[] summary = null;</span>
<span class="nc" id="L1771">		HashMap summaryMap = getTOActivitySummaryData(Collections.singleton(empID), year, activityID, null, requestableOnly,</span>
				withAllotmentOnly);
<span class="nc bnc" id="L1773" title="All 2 branches missed.">		if (!summaryMap.isEmpty()) {</span>
<span class="nc" id="L1774">			summary = (TimeOffActivitySummary[]) summaryMap.values().iterator().next();</span>
		}
<span class="nc" id="L1776">		return summary;</span>
	}

	/**
	 * Get the time off activities for the given employee for the given time frame.
	 *
	 * @param empID the employee for whom the time off activity data is returned.
	 * @param start the start of the period
	 * @param end the end of the period
	 * @return a Collection of TimeOffEvents
	 * @throws BbmFinderException when errors encountered during the construction of the TimeOffActivitySummary
	 */
	public Collection getTOActivities(ID empID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L1789">		String _method_ = &quot;getTOActivities&quot;;</span>
<span class="nc" id="L1790">		methodStart(_method_, empID, start, end);</span>

<span class="nc" id="L1792">		TORequestDAO toDAO = null;</span>
<span class="nc" id="L1793">		ArrayList toActivities = new ArrayList();</span>
<span class="nc" id="L1794">		String setterID = CLASS_NAME + '.' + _method_;</span>

		try {

			// Get the organization id
<span class="nc" id="L1799">			ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(empID);</span>

<span class="nc" id="L1801">			TOHoursPerDayManager hoursPerDayManager = getTOHoursPerDayManager();</span>
<span class="nc" id="L1802">			ArrayList empIds = new ArrayList(1);</span>
<span class="nc" id="L1803">			empIds.add(empID);</span>

<span class="nc" id="L1805">			Collection orgActivities = getTimeOffActs(orgID, false, false);</span>
<span class="nc" id="L1806">			ArrayList activityIds = new ArrayList();</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">			for (Iterator it = orgActivities.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1808">				Activity activity = (Activity) it.next();</span>
<span class="nc" id="L1809">				activityIds.add(activity.getID());</span>
<span class="nc" id="L1810">			}</span>

<span class="nc" id="L1812">			Collection scheduleOrTakenTimeOffEvents = hoursPerDayManager.getHoursPerDayForCalendar(empIds, start, end, activityIds, true);</span>

			// Process the returned time off events from schedule and add it to summary.
			// TODO: must process &quot;debit&quot; and &quot;debit-if-necessary&quot; properly.
<span class="nc bnc" id="L1816" title="All 2 branches missed.">			if (scheduleOrTakenTimeOffEvents != null) {</span>
				// get activityname collection
<span class="nc" id="L1818">				HashMap actNameMap = getActivityNameMap(scheduleOrTakenTimeOffEvents);</span>

<span class="nc bnc" id="L1820" title="All 2 branches missed.">				for (Iterator it = scheduleOrTakenTimeOffEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1821">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) it.next();</span>

<span class="nc" id="L1823">					float duration = (hoursPerDay.getTotalMinutes() / 60f);</span>

<span class="nc" id="L1825">					toActivities.add(new TimeOffEventSummary(hoursPerDay.getStartTime(), hoursPerDay.getEndTime(), (String) actNameMap</span>
<span class="nc" id="L1826">							.get(hoursPerDay.getActivityID()), duration));</span>
<span class="nc" id="L1827">				}</span>
			}
<span class="nc" id="L1829">			return toActivities;</span>
<span class="nc" id="L1830">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1831">			handleException(e);</span>
<span class="nc" id="L1832">			throw (e);</span>
<span class="nc" id="L1833">		} catch (Exception e) {</span>
<span class="nc" id="L1834">			handleException(e);</span>
<span class="nc" id="L1835">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {

<span class="nc bnc" id="L1838" title="All 4 branches missed.">			if (toDAO != null) {</span>
<span class="nc" id="L1839">				toDAO.cleanUp();</span>
			}
<span class="nc" id="L1841">			methodFinish();</span>
		}
	}

	private HashMap getActivityNameMap(Collection scheduleOrTakenTimeOffEvents) throws Exception {
<span class="nc" id="L1846">		ArrayList actList = new ArrayList();</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">		for (Iterator it = scheduleOrTakenTimeOffEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1848">			TOHoursPerDay timeoffEvt = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L1849" title="All 2 branches missed.">			if (!actList.contains(timeoffEvt.getActivityID())) {</span>
<span class="nc" id="L1850">				actList.add(timeoffEvt.getActivityID());</span>
			}
<span class="nc" id="L1852">		}</span>

		// get the activity names for display
<span class="nc" id="L1855">		Collection activityColl = WfmManagerFactory.getActivityManager().findActivities(actList);</span>
<span class="nc" id="L1856">		HashMap activityNameMap = new HashMap(activityColl.size());</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">		for (Iterator actIt = activityColl.iterator(); actIt.hasNext();) {</span>
<span class="nc" id="L1858">			Activity act = (Activity) actIt.next();</span>
<span class="nc" id="L1859">			activityNameMap.put(act.getID(), act.getName());</span>
<span class="nc" id="L1860">		}</span>
<span class="nc" id="L1861">		return activityNameMap;</span>
	}

	private void setTOActSummWithColorAndYearlyAlloc(ID empID, Date stDate, Date asOfDate, Collection orgActivities,
			Map actIDToTOActSummMap, HashMap actCatMap, HashMap empDataMap) throws Exception { // NOSONAR

<span class="nc" id="L1867">		Date now = new Date();</span>
<span class="nc" id="L1868">		Date adjustedStartDate = null;</span>
<span class="nc" id="L1869">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1870">		cal.setTime(stDate);</span>
<span class="nc" id="L1871">		cal.add(Calendar.SECOND, 1);</span>
<span class="nc" id="L1872">		Date nextDate = cal.getTime(); // This date is required for calculating the carry over</span>
<span class="nc" id="L1873">		boolean calculateAccrued = true;</span>
		// As Of Date is End Date so this applies only for TO Summary for Past year.
<span class="nc bnc" id="L1875" title="All 2 branches missed.">		if (asOfDate.before(now)) {</span>
<span class="nc" id="L1876">			Employee emp = (Employee) empDataMap.get(&quot;Employee&quot;);</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">			adjustedStartDate = (emp.getStartTime().after(stDate) ? emp.getStartTime() : stDate);</span>
			// No need to calculate carryover if emp start date falls after start date of the TO year.
<span class="nc bnc" id="L1879" title="All 2 branches missed.">			if (emp.getStartTime().after(stDate)) {</span>
<span class="nc" id="L1880">				nextDate = null;</span>
			}
<span class="nc bnc" id="L1882" title="All 2 branches missed.">			calculateAccrued = !(emp.getStartTime().after(asOfDate));</span>
		}
<span class="nc" id="L1884">		EmployeeTimeOffAccrued accruedTO = null;</span>
<span class="nc" id="L1885">		HashMap tOAccruedMap = (HashMap) empDataMap.get(&quot;tOAccruedMap&quot;);</span>
<span class="nc" id="L1886">		HashMap tOAccruedStBalMap = (HashMap) empDataMap.get(&quot;tOAccruedStBalMap&quot;);</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">		for (Iterator it = orgActivities.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1888">			Activity orgAct = (Activity) it.next();</span>
			// TimeOffActivitySummary represents the details about a time off activity for the given employee.
<span class="nc" id="L1890">			TimeOffActivitySummary summary = new TimeOffActivitySummary();</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">			ActivityCategory aCat = actCatMap != null ? (ActivityCategory) actCatMap.get(orgAct.getActivityCategoryId()) : null;</span>
<span class="nc bnc" id="L1892" title="All 4 branches missed.">			if (aCat != null &amp;&amp; aCat.isTOAllotment()) {</span>
<span class="nc" id="L1893">				summary = new TimeOffActivitySummary(null, aCat, aCat.getName(), null);</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">				if (!actIDToTOActSummMap.containsKey(summary.getActivity_ActCategoryComb())) {</span>
<span class="nc" id="L1895">					TOAccrual accrual = null;</span>
<span class="nc" id="L1896">					accruedTO = null;</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">					if (calculateAccrued) {</span>
<span class="nc bnc" id="L1898" title="All 4 branches missed.">						if (tOAccruedMap != null &amp;&amp; !tOAccruedMap.isEmpty()) {</span>
<span class="nc" id="L1899">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedMap.get(summary.getActivity_ActCategoryComb());</span>
						}
<span class="nc" id="L1901">						accrual = calculateAccruedTO(empID, null, aCat.getID(), adjustedStartDate, asOfDate, accruedTO, empDataMap);</span>

					} else {
<span class="nc" id="L1904">						m_cat.debug(&quot;Skipping this ActivityCategory:&quot; + aCat.getID() + &quot; ; &quot; + adjustedStartDate + &quot; ; &quot; + asOfDate);</span>
					}
<span class="nc bnc" id="L1906" title="All 2 branches missed.">					summary.setRemaining((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">					summary.setEmployeeTimeOffAccrued((accrual != null) ? accrual.getAccruedTO() : null); // Story 5861 - Time</span>
																											// Summary/My Schedule
																											// Summary Time-Off
																											// Changes

					// no need to Calculate carry over for First TO year of employee
<span class="nc" id="L1913">					accrual = null;</span>
<span class="nc" id="L1914">					accruedTO = null;</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">					if (nextDate != null) {</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">						if (tOAccruedStBalMap != null) {</span>
<span class="nc" id="L1917">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedStBalMap.get(summary.getActivity_ActCategoryComb());</span>
						}
						// accrual = calculateAccruedTO(empID, null, aCat.getID(), stDate, nextDate, accruedTO, empDataMap);
<span class="nc" id="L1920">						accrual = TOAccrualCalculator.getTOAccrdForGivenDtWthOverlapTOAtStofYr(empID, null, aCat.getID(), stDate, nextDate,</span>
								accruedTO, empDataMap);
					}
<span class="nc bnc" id="L1923" title="All 2 branches missed.">					summary.setCarryOver((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
<span class="nc" id="L1924">					actIDToTOActSummMap.put(summary.getActivity_ActCategoryComb(), summary);</span>
				}
				// TODO:

				/**
				 * This was found during the FIX for QC# This is wrong instantiation of the object here, but UI is using it to
				 * display the Time Off Summary records by activity category. The Activity ID and Activity Category are mutually
				 * exclusive, so only one of them should be not null while creating the TimeOffActivitySummary object
				 */

<span class="nc" id="L1934">				summary = new TimeOffActivitySummary(orgAct.getID(), aCat, orgAct.getName(), orgAct.getColor());</span>
<span class="nc" id="L1935">				actIDToTOActSummMap.put(Activity.getActivity_ActCategoryComb(orgAct.getID(), null), summary);</span>
			} else {
<span class="nc" id="L1937">				summary = new TimeOffActivitySummary(orgAct.getID(), null, orgAct.getName(), orgAct.getColor());</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">				if (orgAct.isTimeoffWithAllotment()) {</span>
<span class="nc" id="L1939">					TOAccrual accrual = null;</span>
<span class="nc" id="L1940">					accruedTO = null;</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">					if (calculateAccrued) {</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">						if (tOAccruedMap != null) {</span>
<span class="nc" id="L1943">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedMap.get(summary.getActivity_ActCategoryComb());</span>
						}
<span class="nc" id="L1945">						accrual = calculateAccruedTO(empID, orgAct.getID(), null, adjustedStartDate, asOfDate, accruedTO, empDataMap);</span>

					} else {
<span class="nc" id="L1948">						m_cat.debug(&quot;Skipping this activityID&quot; + orgAct.getID() + &quot; ; &quot; + adjustedStartDate + &quot; ; &quot; + asOfDate);</span>
					}
<span class="nc bnc" id="L1950" title="All 2 branches missed.">					summary.setRemaining((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
<span class="nc bnc" id="L1951" title="All 2 branches missed.">					summary.setEmployeeTimeOffAccrued((accrual != null) ? accrual.getAccruedTO() : null); // Story 5861 - Time</span>
																											// Summary/My Schedule
																											// Summary Time-Off
																											// Changes

					// no need to Calculate carry over for First TO year of employee
<span class="nc" id="L1957">					accrual = null;</span>
<span class="nc" id="L1958">					accruedTO = null;</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">					if (nextDate != null) {</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">						if (tOAccruedStBalMap != null) {</span>
<span class="nc" id="L1961">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedStBalMap.get(summary.getActivity_ActCategoryComb());</span>
						}
						// accrual = calculateAccruedTO(empID, orgAct.getID(), null, stDate, nextDate, accruedTO, empDataMap);
<span class="nc" id="L1964">						accrual = TOAccrualCalculator.getTOAccrdForGivenDtWthOverlapTOAtStofYr(empID, orgAct.getID(), null, stDate,</span>
								nextDate, accruedTO, empDataMap);
					}
<span class="nc bnc" id="L1967" title="All 2 branches missed.">					summary.setCarryOver((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
				}
<span class="nc" id="L1969">				actIDToTOActSummMap.put(summary.getActivity_ActCategoryComb(), summary);</span>
			}
<span class="nc" id="L1971">		}</span>
<span class="nc" id="L1972">	}</span>

	/**
	 * Returns a collection of organization activities with the attributes TimeOffWithAllocation and requestable for the specified
	 * orgID.
	 *
	 * @param orgID
	 * @return
	 * @throws BbmEJBCreateException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */

	// QC44912 requests don't appear in My Time Off Report tab if non-requestable, without allotment
	private Collection getTimeOffActs(ID orgID, boolean requestableOnly, boolean withAllotmentOnly) throws BbmEJBCreateException,
			BbmFinderException, RemoteException {
		// Get organizational activities of type timeoff for given employee.
		// Optionally only activities that are requestable and/or only with allotments will be returned.
		// see javadoc for TORequestManagerEJB for more information about activity attributes.
		// Note: if timeoff allotment is not specified for an activity, then this activity will not be
		// returned by the following filter.
<span class="nc" id="L1993">		ActivityFilter activityFilter = new ActivityFilter();</span>
<span class="nc" id="L1994">		activityFilter.setTimeoff(true);</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">		if (withAllotmentOnly) {</span>
<span class="nc" id="L1996">			activityFilter.setTimeoffWithAllotment(true);</span>
		}
<span class="nc bnc" id="L1998" title="All 2 branches missed.">		if (requestableOnly) {</span>
<span class="nc" id="L1999">			activityFilter.setRequestable(true);</span>
		}

<span class="nc" id="L2002">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2003">		return activityMgr.findOrganizationActivities(orgID, activityFilter);</span>

	}

	/**
	 * Returns a collection of organization activity categories that support Time-Off allocation by groups requestable for the
	 * specified orgID.
	 *
	 * @param orgID
	 * @return
	 * @throws BbmEJBCreateException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private HashMap getActivityCategoryWithAlloc(ID orgID) throws BbmEJBCreateException, BbmFinderException, RemoteException {
<span class="nc" id="L2018">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2019">		ActivityCategoryFilter filter = new ActivityCategoryFilter();</span>
<span class="nc" id="L2020">		filter.setTimeoffWithAllotment(true);</span>
<span class="nc" id="L2021">		ArrayList list = new ArrayList();</span>
<span class="nc" id="L2022">		list.add(orgID);</span>
<span class="nc" id="L2023">		return ValueObjectUtil.getIDObjectMap(activityMgr.findOrganizationActivityCategories(list, filter, true));</span>
	}

	/**
	 * Return an array of {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData} objects that
	 * contain time off calendar data for the given employee. The TOCalendarDayData objects contain, for each organization day in
	 * the range: - the allocated hours for the employee's organization - the pending hours (first choice only) for the employee -
	 * the hours scheduled in time off events for the employee - the hours remaining for the employee's organization =(allocated -
	 * scheduledForAllEmployees)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the scheduled time off for all employees
	 * in the organization) for each day in the range.
	 *
	 * @param empID the employee id
	 * @param startDate the beginning of the range. This is the beginning of an organization day in the organization's local time
	 *            zone.
	 * @param endDate the end of the range.
	 * @param TOPoolID of interest. If null, we use employee's default.
	 * @return an array of TOCalendarDayData objects
	 * @throws BbmFinderException
	 */
	public TOCalendarDayData[] getTOCalendarDetailData(ID empID, Date startDate, Date endDate, boolean isTOPoolView,Organization currentEmpOrg, ID TOPoolID, ID activityID)
			throws BbmFinderException {
<span class="nc" id="L2046">		return TOCalendarUtil.getTOCalendarForEmp(empID, startDate, endDate, isTOPoolView,currentEmpOrg, TOPoolID, activityID);</span>
	}

	/**
	 * Gets the time off interval calendar for the employee. See getTOCalendarDetailData.
	 *
	 * @param empID The employee's ID.
	 * @param startDate The start of the range.
	 * @param endDate The exclusive end of the range.
	 * @param timeZone The viewing time zone.
	 * @param isTOPoolView True if we are viewing the time off pool. Otherwise, only the employee's data will be returned
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public TOIntervalCalendar getTOIntervalCalendarForEmp(ID empID, Date startDate, Date endDate,
			TimeZone timeZone, boolean isTOPoolView, ID timeoffPoolID, ID activityID)
			throws BbmFinderException {
<span class="nc" id="L2064">		return TOIntervalCalendarUtil.getTOIntervalCalendarForEmp(empID, startDate, endDate, timeZone,</span>
				isTOPoolView, timeoffPoolID, activityID);
	}

	/**
	 * Return an array of {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData} objects that
	 * contain time off calendar data for employees in the given organization. The optional empID input is the employee id of a
	 * supervisor for the organization. If it is not null, then the interest set of employees is all employees in the organization
	 * that the given supervisor supervises. If the supervisor id is null, then the interest set is all the employees in the
	 * organization.
	 * &lt;p/&gt;
	 * The returned TOCalendarDayData objects contain, for each organization day in the range: - the allocated hours for the
	 * organization, - the pending hours (first choice only) for the employees in the interest set - the hours scheduled in time off
	 * events for the employees in the interest set - the hours remaining for the organization =(allocated - scheduled)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the scheduled time off for all employees
	 * in the organization) for each day in the range.
	 *
	 * @param empID the employee id of a supervisor or null
	 * @param orgID the organization id
	 * @param startDate the beginning of the range. This is the beginning of an organization day in the organization's local time
	 *            zone.
	 * @param endDate the end of the range.
	 * @return an array of TOCalendarDayData objects
	 * @throws BbmFinderException
	 */
	public TOCalendarDayData[] getTOCalendarDetailDataForManager(ID mgrEmpID, ID orgID, ID pTOPoolID, Date startDate, Date endDate)
			throws BbmFinderException {
		try {
<span class="nc" id="L2093">			Collection empIds = getTOCalendarEmpIdsInOrgForMgr(orgID, pTOPoolID, startDate, endDate);</span>
<span class="nc" id="L2094">			return TOCalendarUtil.getTOCalendarForManager(orgID, pTOPoolID, empIds, startDate, endDate);</span>
<span class="nc" id="L2095">		} catch (Exception e) {</span>
<span class="nc" id="L2096">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		}
	}

	/**
	 * If a TOP ID is specified, this gets a collection of employees that are assigned to it during the range. Otherwise, null is
	 * returned. This was extracted from getTOCalendarDetailDataForManager so it can be used with getTOIntervalCalendarForManager.
	 *
	 * @param orgID The organization's ID.
	 * @param pTOPoolID If specified the employee's belonging to this TOP will be returned.
	 * @param startDate
	 * @param endDate
	 * @return
	 * @throws Exception
	 */
	private Collection getTOCalendarEmpIdsInOrgForMgr(ID orgID, ID pTOPoolID, Date startDate, Date endDate) throws Exception {
<span class="nc" id="L2112">		Collection empIds = null;</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">		if (pTOPoolID == null) {</span>
<span class="nc" id="L2114">			Date empStartDate = TOCalendarUtil.getBackAyearforDate(startDate);</span>
<span class="nc" id="L2115">			Pair pair = getEmpIdsInOrgForMgr(null, orgID, true, empStartDate, endDate);</span>
<span class="nc" id="L2116">			empIds = (Collection) pair.getFirst();</span>
		}
<span class="nc" id="L2118">		return empIds;</span>
	}

	/**
	 * Build a set of the employee IDs using &lt;li&gt;all employees in the specified organization which the currently logged in user has
	 * privilege to 'view' (AM employeeFilter implicitly uses this view privilege). &lt;li&gt;**and** restrict further to employee IDs
	 * which the specified manager supervises (if mgrEmpID is specified).
	 */
	private Pair getEmpIdsInOrgForMgr(ID mgrEmpID, ID orgID, boolean suppressPrivilege, Date startDate, Date endDate) throws Exception { // NOSONAR
<span class="nc" id="L2127">		ArrayList alParameters = new ArrayList();</span>
<span class="nc" id="L2128">		Collection colOrganizationIDs = new ArrayList();</span>
		// always get child orgs
<span class="nc" id="L2130">		colOrganizationIDs.add(orgID);</span>
<span class="nc" id="L2131">		colOrganizationIDs.addAll(BbmManagerFactory.getWorkResourceManager().getOrganizationsChildrenByIDs(Collections.singleton(orgID)));</span>
		/* colOrganizationIDs = DAOUtil.getChildOrganizations(orgID, new Jdmo()); */
<span class="nc" id="L2133">		alParameters.add(colOrganizationIDs);</span>
		// Build an employee filter using what we know to get a collection
		// of employee ids. The filter is made of compounding sub filter
		// objects.
<span class="nc" id="L2137">		ArrayList filters = new ArrayList();</span>
		// Build the organization subfilter
<span class="nc" id="L2139">		ArrayList parms = new ArrayList(1);</span>
<span class="nc" id="L2140">		parms.add(orgID);</span>
<span class="nc" id="L2141">		com.bluepumpkin.ejb.bbm.employeefilter.model.Filter f = new com.bluepumpkin.ejb.bbm.employeefilter.model.Filter(</span>
				com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.ORGANIZATIONID,
				com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.OPERATOR_EQUALS, parms);

<span class="nc bnc" id="L2145" title="All 2 branches missed.">		if (suppressPrivilege) {</span>
<span class="nc" id="L2146">			f.setPriviledge(null);</span>
		}
<span class="nc bnc" id="L2148" title="All 4 branches missed.">		if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="nc" id="L2149">			f.setTimePeriodType(com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2150">			f.setStartTime(startDate);</span>
<span class="nc" id="L2151">			f.setEndTime(endDate);</span>
		}
<span class="nc" id="L2153">		filters.add(f);</span>

		// Do we want to further restrict by supervisor?
<span class="nc bnc" id="L2156" title="All 2 branches missed.">		if (mgrEmpID != null) {</span>
<span class="nc" id="L2157">			ArrayList sups = new ArrayList(1);</span>
<span class="nc" id="L2158">			sups.add(mgrEmpID);</span>

			// add supervisor subfilter to filters
<span class="nc" id="L2161">			com.bluepumpkin.ejb.bbm.employeefilter.model.Filter fsup = new com.bluepumpkin.ejb.bbm.employeefilter.model.Filter(</span>
					com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.MANAGERID,
					com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.OPERATOR_EQUALS, sups);
<span class="nc bnc" id="L2164" title="All 2 branches missed.">			if (suppressPrivilege) {</span>
<span class="nc" id="L2165">				fsup.setPriviledge(null);</span>
			}

<span class="nc" id="L2168">			filters.add(fsup);</span>
		}

		// Now make the compound filter we'll use to get the list of
		// employee ids
<span class="nc" id="L2173">		com.bluepumpkin.ejb.bbm.employeefilter.model.Filter cmpFltr = new com.bluepumpkin.ejb.bbm.employeefilter.model.Filter(0, // not</span>
																																	// used
																																	// for
																																	// AND
																																	// filters
				com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.OPERATOR_AND, filters);
<span class="nc bnc" id="L2179" title="All 2 branches missed.">		if (suppressPrivilege) {</span>
<span class="nc" id="L2180">			cmpFltr.setPriviledge(null);</span>
		}
<span class="nc bnc" id="L2182" title="All 4 branches missed.">		if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="nc" id="L2183">			cmpFltr.setTimePeriodType(com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2184">			cmpFltr.setStartTime(startDate);</span>
<span class="nc" id="L2185">			cmpFltr.setEndTime(endDate);</span>
		}
		// Use the compound filter to get a collection of employee ids
<span class="nc" id="L2188">		Collection empIds = null;</span>
<span class="nc" id="L2189">		com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter empFltr = BbmManagerFactory.getEmployeeFilter();</span>
<span class="nc" id="L2190">		User user = RequestUtil.getLoginUser(m_sessionContext);</span>
<span class="nc bnc" id="L2191" title="All 2 branches missed.">		if (user == null) {</span>
			/*
			 * If User Object is null then this is defintely invoked from a CRON or BACKGROUND process Setting it to
			 * SuperUserFacade() is OK here.
			 */
<span class="nc" id="L2196">			user = new SuperUserFacade();</span>
		}
<span class="nc" id="L2198">		empIds = empFltr.getEmployeeIDs(cmpFltr, // Filter</span>
				user, // User
<span class="nc" id="L2200">				Collections.emptyList(), // sort fields</span>
				false, // is ascending, don't care about order
				0, // offset
				Integer.MAX_VALUE); // max number of ids

		// The employee ids cannot be an empty set, or else we'll find nothing.
<span class="nc bnc" id="L2206" title="All 4 branches missed.">		if ((empIds == null) || (empIds.isEmpty())) {</span>
<span class="nc" id="L2207">			m_cat.debug(&quot;&gt;&gt;&gt;getEmployeesInOrganization: No users in organizations!.&quot;);</span>
<span class="nc" id="L2208">			empIds = Collections.emptySet();</span>
		}
<span class="nc" id="L2210">		return new Pair(empIds, colOrganizationIDs);</span>
	}

	/**
	 * Gets the time off interval calendar for a manager.
	 *
	 * @param orgID The selected organization's ID.
	 * @param toPoolID The time off pool's ID to view. Null will return the organization's TOIC.
	 * @param startDate The start of the range.
	 * @param endDate The exclusive end of the range.
	 * @throws BbmFinderException
	 */
	public TOIntervalCalendar getTOIntervalCalendarForManager(ID orgID, ID toPoolID, Date startDate, Date endDate)
			throws BbmFinderException {
		try {
<span class="nc" id="L2225">			return TOIntervalCalendarUtil.getTOIntervalCalendarForManager(orgID, toPoolID, startDate, endDate);</span>
<span class="nc" id="L2226">		} catch (Exception e) {</span>
<span class="nc" id="L2227">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		}
	}

	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attributes 'Requestable' and
	 * ('Timeoff' or 'Unavailability')
	 *
	 * @param pOrganizationId- Id for the organization.
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection&lt;Activity&gt; getTimeOffTypes(ID pOrganizationId) throws BbmFinderException {
<span class="nc" id="L2240">		String _method_ = &quot;getTimeOffTypes&quot;;</span>
<span class="nc" id="L2241">		methodStart(_method_, pOrganizationId);</span>

		// create filter.
<span class="nc" id="L2244">		ActivityFilter filter = new ActivityFilter();</span>
		// gets active by default

<span class="nc" id="L2247">		filter.setRequestable(true);</span>
		// filter 'Requestable' activities.
		// Since 'Requestable' activities are automatically 'timeoff' or 'Unavailability',
		// they are not explicitly specified
		try {
<span class="nc" id="L2252">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2253">			return am.findOrganizationActivities(pOrganizationId, filter);</span>
<span class="nc" id="L2254">		} catch (Exception e) {</span>
<span class="nc" id="L2255">			handleException(e);</span>
<span class="nc" id="L2256">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2258">			methodFinish();</span>
		}
	}

	public List&lt;Activity&gt; getTimeOffTypesExcludingVto(ID organizationId, int flexType) throws BbmFinderException {
<span class="nc" id="L2263">		Collection&lt;Activity&gt; activities = getTimeOffTypes(organizationId, flexType);</span>
<span class="nc" id="L2264">		Set&lt;ID&gt; activitiesIds = DAOUtil.valueObjectsToIdSet(activities);</span>
<span class="nc bnc" id="L2265" title="All 2 branches missed.">		if (activitiesIds.isEmpty()) {</span>
<span class="nc" id="L2266">			return Collections.emptyList();</span>
		}
		try {
<span class="nc" id="L2269">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2270">			Map&lt;ID, ActivityProperties&gt; activityProperties = DAOUtil.valueObjectsToMap(am.findPropertiesForActivities(activitiesIds));</span>

<span class="nc" id="L2272">			List&lt;Activity&gt; result = new ArrayList&lt;Activity&gt;(activities.size());</span>
<span class="nc bnc" id="L2273" title="All 2 branches missed.">			for (Activity activity : activities) {</span>
<span class="nc" id="L2274">				ActivityProperties prop = activityProperties.get(activity.getID());</span>
<span class="nc bnc" id="L2275" title="All 4 branches missed.">				if (prop != null &amp;&amp; prop.isUseAdvancedVTOOptions()) {</span>
					//exclude VTO
<span class="nc" id="L2277">					continue;</span>
				}
<span class="nc" id="L2279">				result.add(activity);</span>
<span class="nc" id="L2280">			}</span>
<span class="nc" id="L2281">			return result;</span>
<span class="nc" id="L2282">		} catch (Exception e) {</span>
<span class="nc" id="L2283">			handleException(e);</span>
<span class="nc" id="L2284">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2286">			methodFinish();</span>
		}

	}

	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attributes 'Requestable' and
	 * ('Timeoff' or 'Unavailability')
	 *
	 * @param pOrganizationId- Id for the organization.
	 * @param flexType - to identify if it's a flex or TO request
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection&lt;Activity&gt; getTimeOffTypes(ID pOrganizationId, int flexType) throws BbmFinderException {
<span class="nc" id="L2301">		String methodName = &quot;getTimeOffTypes&quot;;</span>
<span class="nc" id="L2302">		methodStart(methodName, pOrganizationId, flexType);</span>

		// create filter.
<span class="nc" id="L2305">		ActivityFilter filter = new ActivityFilter();</span>
		// gets active by default
<span class="nc" id="L2307">		filter.setRequestable(true);</span>
		// filter 'Requestable' activities.
		// Since 'Requestable' activities are automatically 'timeoff' or 'Unavailability',
		// they are not explicitly specified
		try {
<span class="nc" id="L2312">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2313">			return am.findOrganizationActivities(pOrganizationId, filter, flexType);</span>
<span class="nc" id="L2314">		} catch (Exception e) {</span>
<span class="nc" id="L2315">			handleException(e);</span>
<span class="nc" id="L2316">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2318">			methodFinish();</span>
		}
	}

	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attribute 'TimeoffWithAllotment'.
	 *
	 * @param pOrganizationId- Id for the organization.
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection getAccruableTimeOffTypes(ID pOrganizationId) throws BbmFinderException {
<span class="nc" id="L2330">		String _method_ = &quot;getAccruableTimeOffTypes&quot;;</span>
<span class="nc" id="L2331">		methodStart(_method_, pOrganizationId);</span>

		// create filter.
<span class="nc" id="L2334">		ActivityFilter filter = new ActivityFilter(); // gets active by default</span>
		// filter 'Time Off With Accrual' activities (they must be time off)
<span class="nc" id="L2336">		filter.setTimeoffWithAllotment(true);</span>
		// NOTE: There is a problem with this filter. It is supposed to get aall activities with accrual.
		// But the ActivityFilter doesn't return those that fall under an accruable activity category because
		// those activities internally do not have the ISTIMEOFFWITHALLOTTMENT flag set in the ACTIVITY table.
		// We need to add code that checks the activity's category as well. If the category is for accrual,
		// then the activity should be too and we would include it in the result.

<span class="nc" id="L2343">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L2344">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2346">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2348">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2349">			return am.findOrganizationActivities(pOrganizationId, filter);</span>
<span class="nc" id="L2350">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2351">			m_cat.error(e, e);</span>
<span class="nc" id="L2352">			handleException(e);</span>
<span class="nc" id="L2353">			throw (e);</span>
<span class="nc" id="L2354">		} catch (Exception e) {</span>
<span class="nc" id="L2355">			handleException(e);</span>
<span class="nc" id="L2356">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2358" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L2359">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2361">			methodFinish();</span>
		}
	}

	public TOWaitlistManager getTOWaitlistManager() throws BbmCreateException {
<span class="nc" id="L2366">		return RmManagerFactory.getInstance(true).getTOWaitlistManager(null, null);</span>
	}

	public void createTOWaitlistRequest(TOWaitlist pTOWaitlist) throws Exception {
<span class="nc" id="L2370">		getTOWaitlistManager().createTOWaitlistRequest(pTOWaitlist);</span>
<span class="nc" id="L2371">	}</span>

	public void removeTORequestFromWaitlist(ID toReqID) {
<span class="nc" id="L2374">		RequestAggregateDAO reqAggDao = null;</span>
<span class="nc" id="L2375">		long detailLevel = Request.DL_BASIC;</span>
		try {
<span class="nc" id="L2377">			reqAggDao = getDAO(detailLevel);</span>
<span class="nc" id="L2378">			RequestAggregate reqAgg = reqAggDao.getRequestByID(toReqID, detailLevel);</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">			if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L2380">				reqAgg.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>
<span class="nc" id="L2381">				updateRequest(reqAgg, &quot;Removed Request from Waitlist&quot;);</span>
			}
<span class="nc" id="L2383">			deleteTOWaitlistRequestSetting(toReqID);</span>
<span class="nc" id="L2384">		} catch (Exception e) {</span>
<span class="nc" id="L2385">		}</span>
<span class="nc" id="L2386">	}</span>

	public void deleteTOWaitlistRequestSetting(ID toRequestId) throws BbmRemoveException {
		try {
<span class="nc" id="L2390">			getTOWaitlistManager().deleteTOWaitlistRequestSetting(toRequestId);</span>
<span class="nc" id="L2391">		} catch (Exception e) {</span>
<span class="nc" id="L2392">			m_cat.error(e, e);</span>
<span class="nc" id="L2393">			handleException(e);</span>
<span class="nc" id="L2394">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L2395">		}</span>
<span class="nc" id="L2396">	}</span>

	public void addRequestTOWaitlist(ID userID, TORequest request, String comment, Date expiryDate, boolean isManager)
			throws RmException, RmHardValidationException, RemoteException {
<span class="nc" id="L2400">		String _method_ = &quot;waitlistRequest&quot;;</span>
<span class="nc" id="L2401">		methodStart(_method_, userID, request, comment, expiryDate);</span>
		try {
<span class="nc" id="L2403">			TOWaitlist waitlist = request.getWaitlistInfo();</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">			if (waitlist == null) {</span>
<span class="nc" id="L2405">				waitlist = new TOWaitlist();</span>
<span class="nc" id="L2406">				waitlist.setTOWaitlistCreatorID(userID);</span>
<span class="nc" id="L2407">				waitlist.setTOWaitlistCreationDate(new Date());</span>
			}
<span class="nc bnc" id="L2409" title="All 2 branches missed.">			if (expiryDate == null) {</span>
<span class="nc" id="L2410">				expiryDate = request.getExpirationDate();</span>
			}
<span class="nc" id="L2412">			waitlist.setTOWaitlistExpiryDate(expiryDate);</span>
<span class="nc" id="L2413">			request.setWaitlistInfo(waitlist);</span>
<span class="nc" id="L2414">			String oldStatus = request.getRequestStatus();</span>

<span class="nc" id="L2416">			User user = getUserManager().getUserByID(userID);</span>
<span class="nc" id="L2417">			RmTimeOffSecurityManager securityMgr = new RmTimeOffSecurityManager();</span>

<span class="nc bnc" id="L2419" title="All 2 branches missed.">			if (securityMgr.isAllowedAction(user, request, RequestAction.MANUALLYADDTOWAITLIST, null)) {</span>
				// Set manually added to true if request is not eligible for waitlist and manager is forcing it to waitlist
<span class="nc bnc" id="L2421" title="All 4 branches missed.">				waitlist.setManuallyAdded(!isRequestEligibleForWaitlist(request) &amp;&amp; RequestAuditTrail.STATUS_DENIED.equals(oldStatus));</span>
<span class="nc" id="L2422">				comment = RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.MANUALLY_WAITLISTED) + &quot; &quot; + comment;</span>
<span class="nc" id="L2423">				_waitlistRequestWorkFlow(request, request.getFirstTOChoice().getID(), comment, true, true);</span>
			} else {
<span class="nc" id="L2425">				securityMgr.assertAllowedAction(user, request, RequestAction.ADDTOWAITLIST, null);</span>
				// update the request to trigger auto validation rules
<span class="nc bnc" id="L2427" title="All 2 branches missed.">				if (RequestAuditTrail.STATUS_DENIED.equals(request.getRequestStatus())) {</span>
<span class="nc" id="L2428">					request.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>
				}
<span class="nc" id="L2430">				RmManagerFactory.getInstance().getTimeOffRequestManager().updateRequest(request, comment);</span>
			}
<span class="nc" id="L2432">		} catch (RmHardValidationException e) {</span>
			// the exception was already logged
<span class="nc" id="L2434">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L2435">			throw e;</span>
<span class="nc" id="L2436">		} catch (Exception e) {</span>
<span class="nc" id="L2437">			handleException(e);</span>
<span class="nc" id="L2438">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2440">			methodFinish();</span>
<span class="nc" id="L2441">		}</span>
<span class="nc" id="L2442">	}</span>

	@Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDsSorted, RequestFilter reqFilter, int sortColumn,
			int sortDirection, boolean inclExpired, long detailLevel, boolean runSoftValids, boolean runNetStaffingSoftVal)
			throws RmException, RmHardValidationException {
<span class="nc bnc" id="L2448" title="All 2 branches missed.">		String sortDirStr = sortDirection == SupportNavigation.SORT_DESCENDING ? RequestUtil.SORTDIR_DESC : RequestUtil.SORTDIR_ASC;</span>
<span class="nc" id="L2449">		String _method_ = &quot;applyFilterAndSortCriteriaForRequests&quot;;</span>
<span class="nc" id="L2450">		methodStart(_method_, reqIDsSorted, reqFilter, new Integer(sortColumn), sortDirStr);</span>
<span class="nc" id="L2451">		Pair returnPair = new Pair(reqIDsSorted, null);</span>
		try {
			// this API should be called only if in memory sorting is required.
			// This is true when we need to get waitlist priority order which is applicable to the waitlisted requests only.
<span class="nc bnc" id="L2455" title="All 2 branches missed.">			if (RequestAuditTrail.STATUS_WAITLIST.equals(reqFilter.getValueForKey(RequestFilter.STATUS_KEY))) {</span>
				// Compute the waitlist priority order only if TOPool Key is set
<span class="nc bnc" id="L2457" title="All 2 branches missed.">				if (reqFilter.isKeySet(RequestFilter.TOPOOL_KEY)) {</span>
<span class="nc" id="L2458">					ID pTOPoolID = (ID) reqFilter.getValueForKey(RequestFilter.TOPOOL_KEY);</span>
<span class="nc" id="L2459">					returnPair = getTOWaitlistManager().sortAndSetPriortyOrderForWaitlists(reqIDsSorted, pTOPoolID, sortColumn, sortDirStr,</span>
							detailLevel, runSoftValids);
				}
				// IF the sort column requires an in memory sort
<span class="nc bnc" id="L2463" title="All 2 branches missed.">				if (Request.getMethodForSortOrderColumn(sortColumn) != null) {</span>
<span class="nc" id="L2464">					Pair[] sortSeqPairArray = new Pair[1];</span>
<span class="nc" id="L2465">					sortSeqPairArray[0] = new Pair(&quot;&quot; + sortColumn, sortDirStr);</span>
					// get the request from DB again only if the Requests are not available here
					// we get all the requests in the earlier call made to compute the Waitlist priorty Order
<span class="nc" id="L2468">					List sbReqsList = (List) returnPair.getSecond();</span>
<span class="nc bnc" id="L2469" title="All 4 branches missed.">					if (sbReqsList == null || sbReqsList.isEmpty()) {</span>
<span class="nc" id="L2470">						detailLevel |= TORequest.DL_AUDIT_TRAIL | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH</span>
								| TORequest.DL_TIMEOFF_WAITLIST;
<span class="nc" id="L2472">						System.out.println(&quot;===TORequestmanager, VALIDATE REQUEST RunRequest by ID in applyFilterAndSortCriteriaForReqIDs&quot;);</span>
<span class="nc" id="L2473">						Collection sbReqs = getRequestsById(reqIDsSorted, inclExpired, runSoftValids, runNetStaffingSoftVal, detailLevel);</span>
<span class="nc" id="L2474">						sbReqsList = RequestUtil.getListFromCollection(sbReqs);</span>
					}
<span class="nc bnc" id="L2476" title="All 2 branches missed.">					if (sbReqsList.size() &gt; 1) { // throws UnsupportedOperationException if the size is one</span>
<span class="nc" id="L2477">						Collections.sort(sbReqsList, new TORequestUtil.TOWailistComparator(sortSeqPairArray));</span>
					}
<span class="nc bnc" id="L2479" title="All 4 branches missed.">					if (sbReqsList != null &amp;&amp; !sbReqsList.isEmpty()) {</span>
<span class="nc" id="L2480">						returnPair = new Pair(RequestUtil.getListOfIDsFromVOBases(sbReqsList), sbReqsList);</span>
					}
				}
			}
<span class="nc" id="L2484">		} catch (Exception e) {</span>
<span class="nc" id="L2485">			handleException(e);</span>
<span class="nc" id="L2486">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2488">			methodFinish();</span>
<span class="nc" id="L2489">		}</span>
<span class="nc" id="L2490">		return returnPair;</span>
	}

	/**
	 * overridden by TORequestManagerEJB only.
	 *
	 * @param reqAgg for further information.
	 * @param toChoiceID
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected boolean _waitlistRequest(RequestAggregate reqAgg, ID toChoiceID, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2506">		boolean result = false;</span>
		try {
<span class="nc bnc" id="L2508" title="All 2 branches missed.">			if (!RequestAuditTrail.STATUS_WAITLIST.equals(reqAgg.getRequestStatus())) { // no point in changing the status from</span>
																						// waitlist to waitlist again.
<span class="nc" id="L2510">				reqAgg.setRequestStatus(RequestAuditTrail.STATUS_WAITLIST);</span>
<span class="nc" id="L2511">				TORequest toRequest = (TORequest) reqAgg;</span>
<span class="nc bnc" id="L2512" title="All 2 branches missed.">				if (toChoiceID == null) {</span>
<span class="nc" id="L2513">					TOChoice toChoice = toRequest.getWaitlistTOChoice();</span>
<span class="nc" id="L2514">					toChoiceID = toChoice.getID();</span>
				}
<span class="nc" id="L2516">				Collection col = toRequest.getRequestChoiceList();</span>
<span class="nc bnc" id="L2517" title="All 2 branches missed.">				for (Iterator iterator = col.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2518">					TOChoice choice = (TOChoice) iterator.next();</span>
<span class="nc bnc" id="L2519" title="All 2 branches missed.">					if (choice.getID().equals(toChoiceID)) {</span>
<span class="nc" id="L2520">						choice.setRank(1);</span>
<span class="nc" id="L2521">						choice.setIsWaitlist(true);</span>
<span class="nc" id="L2522">						toRequest.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
					} else {
<span class="nc bnc" id="L2524" title="All 4 branches missed.">						if (choice.getRank() == 1 || choice.isWaitlist()) {</span>
<span class="nc" id="L2525">							choice.setRank(0);</span>
<span class="nc" id="L2526">							choice.setIsWaitlist(false);</span>
<span class="nc" id="L2527">							toRequest.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
						}
					}
<span class="nc" id="L2530">				}</span>
<span class="nc" id="L2531">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L2532">				result = true; // returns true if update is successful ; else exception is thrown</span>
			}
			// QA 94537 - timeoff go from pending to waitlisted state alert is sending mutiple emails to timeoff requester when a
			// schedule is published.
			// keep result = false because there isn't any update here and prevent the alert email will be sent out
<span class="nc" id="L2537">		} catch (Exception e) {</span>
<span class="nc" id="L2538">			handleException(e);</span>
<span class="nc" id="L2539">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
<span class="nc" id="L2540">		}</span>
<span class="nc" id="L2541">		return result;</span>
	}

	/**
	 * implemented for TORequestManagerEJB only
	 *
	 * @param reqAgg for further information.
	 */
	@Override
	public boolean areWaitlistPreferencesSetForRequest(RequestAggregate reqAgg) throws BbmException {

		try {
<span class="nc bnc" id="L2553" title="All 2 branches missed.">			if (!reqAgg.isTimeOffRequest()) {</span>
<span class="nc" id="L2554">				return false; // return False for all other types of requests</span>
			}
<span class="nc" id="L2556">			TOWaitlist toWaitlist = getTOWaitlistManager().getTOWaitlistByTimeOffRequestId(((TORequest) reqAgg).getID());</span>
<span class="nc bnc" id="L2557" title="All 2 branches missed.">			return (toWaitlist != null);// Return false if user did not opt for waitlist</span>
<span class="nc" id="L2558">		} catch (Exception e) {</span>
<span class="nc" id="L2559">			handleException(e);</span>
<span class="nc" id="L2560">			throw new BbmException(e);</span>
		}
	}

	@Override
	public boolean canRequestBeWaitlistedBasedOnValidations(int[] apprDenyResult1, Collection[] apprDenyValResults1) throws BbmException {
		try {
			// Return False if
			// 1&gt; Waitlist result is not available
			// 2&gt; Waitlist Result = DONT Waitlist
			// 3&gt; Waitlist Result = No Violations found.
			// 4&gt; Waitlist Validation Result for Violations is null or empty.
<span class="nc bnc" id="L2572" title="All 8 branches missed.">			if (apprDenyResult1.length &lt; 3</span>
					|| apprDenyResult1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == AutoProcessingRuleChecker.AUTOPROC_WAITLIST_CLAUSE_DONOT_WAITLIST
					|| apprDenyResult1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == AutoProcessingRuleChecker.AUTOPROC_WAITLIST_CLAUSE_NO_VIOLATIONS
					|| apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == null
<span class="nc bnc" id="L2576" title="All 2 branches missed.">					|| apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST].isEmpty()) {</span>
<span class="nc" id="L2577">				return false;</span>
			}
<span class="nc bnc" id="L2579" title="All 2 branches missed.">			if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == AutoProcessingRuleChecker.AUTOPROC_WAITLIST_CLAUSE_VIOLATIONS_FOUND) {</span>
				// return True if no violations for Denial are found
<span class="nc bnc" id="L2581" title="All 4 branches missed.">				if (apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY] == null || apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].isEmpty()) {</span>
<span class="nc" id="L2582">					return true;</span>
				}
				// return False if Denial violation count exceeds the Waitlist violation count
<span class="nc bnc" id="L2585" title="All 2 branches missed.">				if (apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].size() &gt; apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST].size()) {</span>
<span class="nc" id="L2586">					return false;</span>
				}
				// Compare the Denial violations &amp; waitlist violations.
				// If Denial Violations are different from Waitlist then return False; else True.
<span class="nc" id="L2590">				HashSet denySet = new HashSet(apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].size());</span>
<span class="nc bnc" id="L2591" title="All 2 branches missed.">				for (Iterator iterator = apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2592">					ValidationResult validationResult = (ValidationResult) iterator.next();</span>
<span class="nc" id="L2593">					denySet.add(validationResult.getValidatorName());</span>
<span class="nc" id="L2594">				}</span>
<span class="nc bnc" id="L2595" title="All 2 branches missed.">				for (Iterator iterator = apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST].iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2596">					ValidationResult validationResult = (ValidationResult) iterator.next();</span>
<span class="nc" id="L2597">					denySet.remove(validationResult.getValidatorName());</span>
<span class="nc" id="L2598">				}</span>
<span class="nc" id="L2599">				return denySet.isEmpty(); // Return True if no denial clause is left ; else return False.</span>
			}
<span class="nc" id="L2601">			return true;</span>
<span class="nc" id="L2602">		} catch (Exception e) {</span>
<span class="nc" id="L2603">			handleException(e);</span>
<span class="nc" id="L2604">			throw new BbmException(e);</span>
		}
	}

	/**
	 * overridden by TORequestManagerEJB only, returns true for the waitlist feature.
	 *
	 * @param reqAgg for further information.
	 */
	@Override
	public boolean ignoreAmbiguousAutoProcessResults(RequestAggregate reqAgg) {
<span class="nc" id="L2615">		return false;</span>
	}

	@Override
	public boolean isRequestEligibleForWaitlist(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L2620">		String _method_ = &quot;isRequestEligibleForWaitlist&quot;;</span>
<span class="nc" id="L2621">		methodStart(_method_, reqAgg);</span>
		// we want to check the &quot;add to waitlist&quot; eligibilty in this method so setting it to true;
<span class="nc" id="L2623">		boolean checkForWaitlist = true;</span>
		try {
<span class="nc bnc" id="L2625" title="All 6 branches missed.">			if (reqAgg != null &amp;&amp; reqAgg.isElgibleForWaitlist() &amp;&amp; TORequestUtil.isTOWaitlistEnabled(reqAgg)) {</span>
				// Need to get all the Time Range Pairs to decide if any one Choice Can be waitlisted.
<span class="nc" id="L2627">				Pair pair = ((TORequest) reqAgg).getAllEmpIDTimeRangePairs();</span>
<span class="nc" id="L2628">				Collection empIDTimeRangePairs = (Collection) pair.getFirst();</span>
<span class="nc" id="L2629">				ArrayList toChoiceList = (ArrayList) pair.getSecond();</span>
<span class="nc" id="L2630">				Iterator iter = empIDTimeRangePairs.iterator();</span>
<span class="nc" id="L2631">				int counter = 0;</span>
<span class="nc bnc" id="L2632" title="All 2 branches missed.">				for (; iter.hasNext(); counter++) {</span>
<span class="nc" id="L2633">					Collection[] apprDenyValResults1 = new Collection[3];</span>
<span class="nc" id="L2634">					Map ruleNameToValResultsMap = new HashMap(19);</span>
<span class="nc" id="L2635">					Pair empIDTimeRangePair = (Pair) iter.next();</span>
<span class="nc" id="L2636">					ID empID = (ID) empIDTimeRangePair.getFirst();</span>
<span class="nc" id="L2637">					TimeRange timeRange = (TimeRange) empIDTimeRangePair.getSecond();</span>
<span class="nc" id="L2638">					TOChoice toChoice = (TOChoice) toChoiceList.get(counter);</span>
<span class="nc" id="L2639">					((TORequest) reqAgg).setTOChoiceForValidation(toChoice);</span>
<span class="nc" id="L2640">					int[] apprDenyResult1 = runAutoProcessForTimeRange(empID, timeRange, true, true, apprDenyValResults1, reqAgg,</span>
							ruleNameToValResultsMap);
<span class="nc" id="L2642">					String requestStatus = getDecisionBasedOnAutProcessRuleEngineResult(reqAgg, apprDenyResult1, apprDenyValResults1,</span>
							checkForWaitlist);
<span class="nc" id="L2644">					((TORequest) reqAgg).clearTOChoiceForValidation();</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">					if (requestStatus.equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L2646">						((TORequest) reqAgg).setTOChoiceEligibleForWaitlist(toChoice);</span>
<span class="nc" id="L2647">						return true;</span>
<span class="nc bnc" id="L2648" title="All 2 branches missed.">					} else if (requestStatus.equals(RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="nc" id="L2649">						break;</span>
					}
				}
			}
<span class="nc" id="L2653">			return false;</span>
<span class="nc" id="L2654">		} catch (Exception e) {</span>
<span class="nc" id="L2655">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2657">			methodFinish();</span>
		}
	}

	public TOWithdrawManager getTOWithdrawManager() throws BbmCreateException {
<span class="nc" id="L2662">		return RmManagerFactory.getInstance(true).getTOWithdrawManager(null, null);</span>
	}

	@Override
	protected boolean _acceptWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2668">		String methodName = &quot;_acceptWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2669">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2671">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
			// set the original TORequest to withdrawan as one transaction
<span class="nc" id="L2673">			TORequest toRequest = (TORequest) reqAgg;</span>
<span class="nc" id="L2674">			_undoSchedule(reqAgg, null, null);</span>

			// set the underlying TimeOffWithdrawRequest to Accepted
<span class="nc" id="L2677">			TOWithdraw toWithdraw = toRequest.getWithdrawInfo();</span>
<span class="nc" id="L2678">			toWithdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_ACCEPT);</span>
<span class="nc" id="L2679">			toWithdraw.setLastModifiedDate(new Date());</span>
<span class="nc bnc" id="L2680" title="All 2 branches missed.">			if (user != null) {</span>
<span class="nc" id="L2681">				toWithdraw.setModifierID(user.getID());</span>
			}
<span class="nc" id="L2683">			setAuditTrail(reqAgg, comment, toWithdraw.getRequestStatus(), false);</span>
<span class="nc" id="L2684">			_updateRequest(reqAgg, RequestAuditTrail.STATUS_WITHDRAWN, comment, null, false, suppressPrivilegeChecking, loadedFromDB, true);</span>
<span class="nc" id="L2685">			getTOWithdrawManager().updateTOWithdrawRequest(toWithdraw);</span>
<span class="nc" id="L2686">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, toWithdraw.getRequestStatus()));</span>
<span class="nc" id="L2687">			TONotifyMessageClient.scanTOWaitlist(toRequest, toRequest.getApprovedChoices());</span>
<span class="nc" id="L2688">			return true;</span>
<span class="nc" id="L2689">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L2690">			handleException(e);</span>
<span class="nc" id="L2691">			throw e;</span>
<span class="nc" id="L2692">		} catch (Exception e) {</span>
<span class="nc" id="L2693">			handleException(e);</span>
<span class="nc" id="L2694">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2696">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	@Override
	protected boolean _rejectWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2703">		String methodName = &quot;_rejectWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2704">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2706">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
			// leave the original TORequest unchanged
<span class="nc" id="L2708">			TORequest toRequest = (TORequest) reqAgg;</span>
			// set the underlying TimeOffWithdrawRequest to rejected
<span class="nc" id="L2710">			TOWithdraw toWithdraw = toRequest.getWithdrawInfo();</span>
<span class="nc" id="L2711">			toWithdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_REJECT);</span>
<span class="nc" id="L2712">			toWithdraw.setLastModifiedDate(new Date());</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">			if (user != null) {</span>
<span class="nc" id="L2714">				toWithdraw.setModifierID(user.getID());</span>
			}
<span class="nc" id="L2716">			setAuditTrail(reqAgg, comment, toWithdraw.getRequestStatus(), true);</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">			if (reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L2718">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, suppressPrivilegeChecking, loadedFromDB);</span>
			} else {
<span class="nc" id="L2720">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, suppressPrivilegeChecking, loadedFromDB,</span>
<span class="nc" id="L2721">						hasAdvanceLicense());</span>
			}
<span class="nc" id="L2723">			getTOWithdrawManager().updateTOWithdrawRequest(toWithdraw);</span>
<span class="nc" id="L2724">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, toWithdraw.getRequestStatus()));</span>
<span class="nc" id="L2725">			return true;</span>
<span class="nc" id="L2726">		} catch (Exception e) {</span>
<span class="nc" id="L2727">			handleException(e);</span>
<span class="nc" id="L2728">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2730">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	// Check if request is eligible for accepting the withdraw
	@Override
	public boolean isEligibleForAcceptWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L2737" title="All 4 branches missed.">		return reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForAcceptWithdrawAction();</span>
	}

	/*
	 * //Check if request is eligible for requesting the withdraw public Pair
	 * isEligibleForRequestWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException { Pair pair = new Pair(new
	 * Boolean(&quot;true&quot;), null); if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED)) {
	 * TimeOffChoiceHasNoUnderlyingEvent validator = new TimeOffChoiceHasNoUnderlyingEvent(); try { ValidationResult result =
	 * validator.validate(reqAgg); if (result != null) { //mark request as invalid in all other cases if
	 * (!result.getMessageResource().equals(RmEjbBundleKey.TIMEOFF_WITHDRAW_UNDERLYING_EVENT_NOT_EXIST_IN_UNPUB)) {
	 * markRequestAsInvalid(reqAgg, result, null); } String hardValLocalizedMsg =
	 * result.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), reqAgg.getValidationCache().getTimeZoneForOrg()); pair
	 * = new Pair(new Boolean(&quot;false&quot;), hardValLocalizedMsg); } } catch (Exception e) { e.printStackTrace(); //To change body of
	 * catch statement usen File | Settings | File Templates. } } return pair; }
	 */
	public Pair&lt;Boolean, String&gt; isEligibleForRequestWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L2753">		Pair&lt;Boolean, String&gt; pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;true&quot;), null);</span>
<span class="nc bnc" id="L2754" title="All 2 branches missed.">		if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
			// QA-103536 -- Skipped the TimeOffChoiceHasNoUnderlyingEvent validator and created a new
			// validateApprovedRequestForWithdraw() method in TORequestUtil.java

			// TimeOffChoiceHasNoUnderlyingEvent validator = new TimeOffChoiceHasNoUnderlyingEvent();
			try {
				// QA-103536 fix .
<span class="nc" id="L2761">				ValidationResult result = TORequestUtil.validateApprovedRequestForWithdraw(reqAgg);</span>
<span class="nc bnc" id="L2762" title="All 2 branches missed.">				if (result != null) {</span>
					// mark request as invalid in all other cases
<span class="nc bnc" id="L2764" title="All 2 branches missed.">					if (!result.getMessageResource().equals(RmEjbBundleKey.TIMEOFF_WITHDRAW_UNDERLYING_EVENT_NOT_EXIST_IN_UNPUB)) {</span>
<span class="nc" id="L2765">						markRequestAsInvalid(reqAgg, result, null);</span>
					}
<span class="nc" id="L2767">					String hardValLocalizedMsg = result.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), reqAgg</span>
<span class="nc" id="L2768">							.getValidationCache().getTimeZoneForOrg());</span>
<span class="nc" id="L2769">					pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;false&quot;), hardValLocalizedMsg);</span>
				}
<span class="nc" id="L2771">			} catch (Exception e) {</span>
<span class="nc" id="L2772">				e.printStackTrace(); // To change body of catch statement usen File | Settings | File Templates.</span>
<span class="nc" id="L2773">			}</span>
		}
<span class="nc" id="L2775">		return pair;</span>
	}

	// Check if request is eligible for rejecting the withdraw
	@Override
	public boolean isEligibleForRejectWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L2781" title="All 4 branches missed.">		return reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForRejectWithdrawAction();</span>
	}

	@Override
	public boolean requestWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment)
			throws BbmUpdateException, RmHardValidationException {
<span class="nc" id="L2787">		String methodName = &quot;requestWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2788">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2790">			TORequest request = (TORequest) reqAgg;</span>
<span class="nc" id="L2791">			TOWithdraw withdraw = new TOWithdraw();</span>
<span class="nc" id="L2792">			withdraw.setTORequestID(request.getID());</span>
<span class="nc" id="L2793">			withdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_REQUEST);</span>
<span class="nc" id="L2794">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L2795">			withdraw.setCreatorID(user.getID());</span>
<span class="nc" id="L2796">			withdraw.setCreationDate(new Date());</span>
<span class="nc" id="L2797">			request.setWithdrawInfo(withdraw);</span>
<span class="nc" id="L2798">			setAuditTrail(reqAgg, comment, withdraw.getRequestStatus(), true);</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">			if (reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L2800">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, false, false, false);</span>
			} else {
<span class="nc" id="L2802">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, false, false, hasAdvanceLicense());</span>
			}
<span class="nc" id="L2804">			reqAgg = getRequestByID(reqAgg.getID(), false, false, reqAgg.getDetailLevel());</span>
<span class="nc" id="L2805">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, withdraw.getRequestStatus()));</span>
<span class="nc" id="L2806">			_autoProcessWithdraw(reqAgg, &quot;auto-process&quot;, true);</span>
<span class="nc" id="L2807">			return true;</span>
<span class="nc" id="L2808">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L2809">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L2810">			throw e;</span>
<span class="nc" id="L2811">		} catch (Exception e) {</span>
<span class="nc" id="L2812">			handleException(e);</span>
<span class="nc" id="L2813">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2815">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	@Override
	protected boolean isEligibleForCancelWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L2821" title="All 4 branches missed.">		return reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForCancelWithdrawAction();</span>
	}

	/**
	 * applies to Cancelling Withdrawal of approved Requests
	 *
	 * @param reqAgg
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected boolean _cancelWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2836">		String methodName = &quot;requestWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2837">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2839">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
			// leave the original TORequest unchanged ; just update the comments
<span class="nc" id="L2841">			TORequest toRequest = (TORequest) reqAgg;</span>
			// set the underlying TimeOffWithdrawRequest to cancelled
<span class="nc" id="L2843">			TOWithdraw toWithdraw = toRequest.getWithdrawInfo();</span>
<span class="nc" id="L2844">			toWithdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_CANCEL);</span>
<span class="nc" id="L2845">			toWithdraw.setLastModifiedDate(new Date());</span>
<span class="nc bnc" id="L2846" title="All 2 branches missed.">			if (user != null) {</span>
<span class="nc" id="L2847">				toWithdraw.setModifierID(user.getID());</span>
			}
<span class="nc" id="L2849">			setAuditTrail(reqAgg, comment, toWithdraw.getRequestStatus(), true);</span>
<span class="nc" id="L2850">			_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, suppressPrivilegeChecking, loadedFromDB,</span>
<span class="nc" id="L2851">					hasAdvanceLicense());</span>
<span class="nc" id="L2852">			getTOWithdrawManager().updateTOWithdrawRequest(toWithdraw);</span>
<span class="nc" id="L2853">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, toWithdraw.getRequestStatus()));</span>
<span class="nc" id="L2854">			return true;</span>
<span class="nc" id="L2855">		} catch (Exception e) {</span>
<span class="nc" id="L2856">			handleException(e);</span>
<span class="nc" id="L2857">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2859">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	public void setAuditTrail(RequestAggregate request, String comment, String status, boolean setAuditTrailState) throws Exception {
<span class="nc" id="L2864">		User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L2865">		RequestAuditTrail raTrail = RequestDAO.createAuditTrailObject(status, new Date(), comment, RmEjbBundleKey.UPDATED, user.getID());</span>
<span class="nc" id="L2866">		raTrail.setIsStatusChange(true);</span>
<span class="nc" id="L2867">		request.setAuditTrail(raTrail);</span>
<span class="nc" id="L2868">		request.setAuditTrailSet(setAuditTrailState);</span>
<span class="nc" id="L2869">	}</span>

	@Override
	protected void updateRequestPostProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, boolean loadedFromDB, String origState)
			throws Exception {

<span class="nc bnc" id="L2875" title="All 2 branches missed.">		getTOHoursPerDayManager().updateTOHoursPerDayForTORequest((TORequest) reqAgg, !RequestAuditTrail.STATUS_APPROVED.equals(origState));</span>

<span class="nc" id="L2877">		getTimeOffIntervalAllocationManager().onUpdateTORequest((TORequest) reqAgg);</span>
<span class="nc" id="L2878">	}</span>

	@Override
	protected void createRequestPostProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L2882">		getTOHoursPerDayManager().updateTOHoursPerDayForTORequest((TORequest) reqAgg, true);</span>
<span class="nc" id="L2883">		getTimeOffIntervalAllocationManager().onCreateTORequest((TORequest) reqAgg);</span>
<span class="nc" id="L2884">	}</span>

	@Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L2889">		String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L2890">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L2892">		TORequestDAO toReqDao = null;</span>
<span class="nc" id="L2893">		String setterID = CLASS_NAME + '.' + _method_;</span>

		try {

<span class="nc bnc" id="L2897" title="All 2 branches missed.">			if (!canDeleteRequest(organizationId)) {</span>
<span class="nc" id="L2898">				return;</span>
			}



<span class="nc" id="L2903">			toReqDao = new TORequestDAO(TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES);</span>
<span class="nc" id="L2904">			toReqDao.deleteRequestsByStartDateRange(organizationId, isForBranch, range, getRequestType(), subType);</span>
<span class="nc" id="L2905">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2910">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2911">			throw e;</span>
<span class="nc" id="L2912">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L2913">			m_cat.error(e, e);</span>
<span class="nc" id="L2914">			handleException(e);</span>
<span class="nc" id="L2915">			throw e;</span>
<span class="nc" id="L2916">		} catch (Exception e) {</span>
<span class="nc" id="L2917">			handleException(e);</span>
<span class="nc" id="L2918">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {

<span class="nc bnc" id="L2921" title="All 6 branches missed.">			if (toReqDao != null) {</span>
<span class="nc" id="L2922">				toReqDao.cleanUp();</span>
			}
<span class="nc" id="L2924">			methodFinish();</span>
<span class="nc" id="L2925">		}</span>
<span class="nc" id="L2926">	}</span>

	@Override
	protected void invalidateRequestPostProcess(Jdmo jdmo, RequestAggregate reqAgg, String comment) throws BbmUpdateException {
		try {
<span class="nc" id="L2931">			getTOHoursPerDayManager().updateTOHoursPerDayForTORequest((TORequest) reqAgg, false);</span>
<span class="nc" id="L2932">			getTimeOffIntervalAllocationManager().onUpdateTORequest((TORequest) reqAgg);</span>
<span class="nc" id="L2933">		} catch (Exception e) {</span>
<span class="nc" id="L2934">			handleException(e);</span>
<span class="nc" id="L2935">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L2936">		}</span>
<span class="nc" id="L2937">		super.invalidateRequestPostProcess(jdmo, reqAgg, comment);</span>
<span class="nc" id="L2938">	}</span>

	/**
	 * Calculate the accrued Time-off for an employee of given activity at given date
	 *
	 * @return number of hours
	 * @throws BbmFinderException
	 */
	public TOAccrual calculateAccruedTO(ID empID, ID activityID, ID actCatID, Date asOfDate) throws RmException {
<span class="nc" id="L2947">		return TOAccrualCalculator.getTOAccruedForGivenDate(empID, activityID, actCatID, null, asOfDate, null, null);</span>
	}

	private TOAccrual calculateAccruedTO(ID empID, ID activityID, ID actCatID, Date startDate, Date asOfDate,
			EmployeeTimeOffAccrued accruedTO, HashMap empActivityDataMap) {
<span class="nc" id="L2952">		return TOAccrualCalculator</span>
<span class="nc" id="L2953">				.getTOAccruedForGivenDate(empID, activityID, actCatID, startDate, asOfDate, accruedTO, empActivityDataMap);</span>
	}

	/**
	 * Dump the Remaining and Carryover hours into the EmployeeTimeOffAllotment table for Time Off Summary reports. This method
	 * breaks the employee ids into chunks, so that each chunk can be updated in its own transaction. If the chunkSize, lookBack or
	 * lookForward parameters are -1, then their value is gotten from a BPCONFIG setting.
	 *
	 * @param ids - a collection of employee id's to dump the data for.
	 * @param threadID - The thread number. Employees are dumped in multiple threads, and each thread is given a number, starting
	 *            with 1.
	 * @param lookBack - How manay years back to dump. Pass -1 to get the value from the BPCONFIG table.
	 * @param lookForward - How manay years forward to dump. Pass -1 to get the value from the BPCONFIG table.
	 * @param start - Used to determine the lookBack. If not null, this date overrides lookBack.
	 * @param end - Used to determine the lookForward. If not null, this date overrides lookForward.
	 */
	public Collection dumpTOReportDataWithResult(Collection ids, int threadID, int lookBack, int lookForward, Date start, Date end)
			throws BbmUpdateException {
<span class="nc" id="L2971">		methodStart(&quot;dumpTOReportDataWithResult&quot;, ids, new Integer(threadID), new Integer(lookBack), new Integer(lookForward));</span>
<span class="nc" id="L2972">		long starttime = System.currentTimeMillis();</span>
<span class="nc" id="L2973">		ReportDumpStatistic statistic = new ReportDumpStatistic();</span>
<span class="nc" id="L2974">		int chunkSize = -1; // no longer a parameter</span>
<span class="nc" id="L2975">		boolean bShowPrintln = RequestUtil.isRMDebugEnabled();</span>
<span class="nc" id="L2976">		m_cat.info(&quot;TOReportDump threadID=&quot; + threadID + &quot; chunkSize=&quot; + chunkSize + &quot; lookBack=&quot; + lookBack + &quot; lookForward=&quot;</span>
				+ lookForward);
		try {
<span class="nc" id="L2979">			Collection colEmployeeIDs = null;</span>
<span class="nc bnc" id="L2980" title="All 2 branches missed.">			if (ids == null) {</span>
				// dump all employees
<span class="nc" id="L2982">				EmployeeFilter employeeFilter = BbmManagerFactory.getEmployeeFilter(WhatIfMode);</span>
<span class="nc" id="L2983">				colEmployeeIDs = employeeFilter.getEmployeeIDs(Filter.createAllFilter(User.SUPER_USERID), -1, true, 0, Integer.MAX_VALUE);</span>
<span class="nc" id="L2984">			} else {</span>
<span class="nc" id="L2985">				colEmployeeIDs = ids;</span>
			}

			try {
				// get the lookback and lookforward values from db if necessary
<span class="nc" id="L2990">				DBConfigManager m_dbConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">				if (lookBack &lt; 0) {</span>
<span class="nc" id="L2992">					lookBack = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_TIME_OFF_LOOKBACK_YEARS);</span>
				}
<span class="nc bnc" id="L2994" title="All 2 branches missed.">				if (lookBack &lt; 0) {</span>
<span class="nc" id="L2995">					lookBack = 1; // default is 1 year</span>
				}

<span class="nc bnc" id="L2998" title="All 2 branches missed.">				if (lookForward &lt; 0) {</span>
<span class="nc" id="L2999">					lookForward = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_TIME_OFF_LOOKFORWARD_YEARS);</span>
				}
<span class="nc bnc" id="L3001" title="All 2 branches missed.">				if (lookForward &lt; 0) {</span>
<span class="nc" id="L3002">					lookForward = 1; // default is 1 year</span>
				}

				// //start and end dates override lookBack and lookForward
<span class="nc bnc" id="L3006" title="All 4 branches missed.">				if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L3007">					Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L3008">					cal.setTime(new Date());</span>
<span class="nc" id="L3009">					int curYear = cal.get(Calendar.YEAR);</span>

<span class="nc" id="L3011">					cal.setTime(start);</span>
<span class="nc" id="L3012">					int startYear = cal.get(Calendar.YEAR);</span>

<span class="nc" id="L3014">					cal.setTime(end);</span>
<span class="nc" id="L3015">					int endYear = cal.get(Calendar.YEAR);</span>

<span class="nc" id="L3017">					lookBack = curYear - startYear;</span>
<span class="nc" id="L3018">					lookForward = endYear - curYear;</span>
				}

				// get the transaction timeout from db
<span class="nc" id="L3022">				int nUserTransactionTimeOut = m_dbConfigManager.getIntValue(ConfigKey.REPORTDUMP_USER_TRANSACTION_TIMEOUT);</span>
<span class="nc bnc" id="L3023" title="All 4 branches missed.">				if (nUserTransactionTimeOut &gt;= 120 &amp;&amp; nUserTransactionTimeOut &lt;= 1200) {</span>
<span class="nc" id="L3024">					USERTRANSACTION_TIMEOUT = nUserTransactionTimeOut;</span>
				}

				// get the max number of retries from db
<span class="nc" id="L3028">				int nReportDumpMaxRetry = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_DUMP_MAX_RETRY);</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">				if (nReportDumpMaxRetry &gt; 0) {</span>
<span class="nc" id="L3030">					REPORTDUMP_MAX_RETRY = nReportDumpMaxRetry;</span>
				}

				// get chunk size from db if necessary
<span class="nc bnc" id="L3034" title="All 2 branches missed.">				if (chunkSize &lt;= 0) {</span>
<span class="nc" id="L3035">					chunkSize = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_TIME_OFF_DUMP_CHUNK_SIZE);</span>
<span class="nc bnc" id="L3036" title="All 2 branches missed.">					if (chunkSize &lt; 0) {</span>
<span class="nc" id="L3037">						chunkSize = 100;</span>
					}
				}

<span class="nc" id="L3041">			} catch (Exception e) {</span>
<span class="nc" id="L3042">				m_cat.error(e);</span>
<span class="nc" id="L3043">			}</span>

<span class="nc" id="L3045">			Collection colEmployeeIDsChunk = new LinkedList();</span>
<span class="nc" id="L3046">			Collection colEmployeeIDsFailed = new LinkedList();</span>
<span class="nc" id="L3047">			int nTotalEmployees = colEmployeeIDs.size();</span>
<span class="nc" id="L3048">			int nNumEmployeesDumped = 0;</span>
<span class="nc" id="L3049">			syncTOAllocation();</span>
			// break the employees up into chunks, and dump each chunk
<span class="nc" id="L3051">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L3052">			HashSet orgIDSet = new HashSet();</span>
<span class="nc" id="L3053">			orgIDSet.add(Organization.ROOT_ORG_ID_OBJ);</span>
<span class="nc" id="L3054">			orgIDSet.addAll(wrm.getOrganizationsChildrenByIDs(Collections.singleton(Organization.ROOT_ORG_ID_OBJ)));</span>
<span class="nc" id="L3055">			HashMap orgActCatMap = null;</span>
<span class="nc" id="L3056">			HashMap orgActivityMap = null;</span>

<span class="nc bnc" id="L3058" title="All 2 branches missed.">			for (Iterator i2 = colEmployeeIDs.iterator(); i2.hasNext();) {</span>
<span class="nc" id="L3059">				ID idEmployee = (ID) i2.next();</span>
<span class="nc" id="L3060">				colEmployeeIDsChunk.add(idEmployee);</span>
<span class="nc bnc" id="L3061" title="All 4 branches missed.">				if (colEmployeeIDsChunk.size() &lt; chunkSize &amp;&amp; i2.hasNext()) {</span>
<span class="nc" id="L3062">					continue;</span>
				}
<span class="nc" id="L3064">				int nMaxRetry = REPORTDUMP_MAX_RETRY;</span>
<span class="nc" id="L3065">				int nRetry = 0;</span>
<span class="nc" id="L3066">				for (; true; nRetry++) {</span>
					try {
<span class="nc bnc" id="L3068" title="All 2 branches missed.">						if (orgActivityMap == null) {</span>
<span class="nc" id="L3069">							orgActivityMap = getOrgActivitiesMap(orgIDSet, false, false);</span>
						}
<span class="nc bnc" id="L3071" title="All 2 branches missed.">						if (orgActCatMap == null) {</span>
<span class="nc" id="L3072">							orgActCatMap = getOrgActivityCategoryMap(orgIDSet);</span>
						}
<span class="nc bnc" id="L3074" title="All 2 branches missed.">						if (isTemporarilyStopReportDump()) {</span>
							// stop report dump as is if this flag is set; user wants to suspend and start again.
<span class="nc" id="L3076">							return colEmployeeIDsFailed;</span>
						}
<span class="nc" id="L3078">						dumpTOReportDataForChunk(statistic, colEmployeeIDsChunk, lookBack, lookForward, bShowPrintln, orgActivityMap,</span>
								orgActCatMap);
<span class="nc" id="L3080">					} catch (Exception e) {</span>
<span class="nc" id="L3081">						handleException(e);</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">						if (nRetry &lt; nMaxRetry) {</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3084">								m_cat.debug(&quot;Exception in dumpTOReportDataChunk: retry count = &quot; + new Integer(nRetry));</span>
							}
<span class="nc" id="L3086">							continue;</span>
						}
<span class="nc" id="L3088">						colEmployeeIDsFailed.addAll(colEmployeeIDsChunk);</span>
<span class="nc" id="L3089">						m_cat.info(&quot;TO ReportChunk failed for EmployeeIDs: &quot; + colEmployeeIDsChunk);</span>
<span class="nc" id="L3090">					}</span>
<span class="nc" id="L3091">					break;</span>
				}
<span class="nc bnc" id="L3093" title="All 2 branches missed.">				if (nRetry &lt; nMaxRetry) {</span>
<span class="nc" id="L3094">					nNumEmployeesDumped += colEmployeeIDsChunk.size();</span>
				}

<span class="nc" id="L3097">				m_cat.info(&quot;Stats: TO Chunk Dumped, Size = &quot; + nTotalEmployees + &quot;Dumped: &quot; + nNumEmployeesDumped + &quot; Failed Emps: &quot;</span>
<span class="nc" id="L3098">						+ RmUtil.dumpCommaSeparated(colEmployeeIDsFailed));</span>
<span class="nc" id="L3099">				colEmployeeIDsChunk.clear();</span>
<span class="nc" id="L3100">			}</span>
<span class="nc" id="L3101">			long endtime = System.currentTimeMillis();</span>
<span class="nc" id="L3102">			long lTotalTime = endtime - starttime;</span>
<span class="nc" id="L3103">			m_cat.info(&quot;Stats: TOReportDump Complete; Total time=&quot; + (lTotalTime / 60000) + &quot; Mins: Total=&quot; + nTotalEmployees + &quot;: Dumped=&quot;</span>
<span class="nc" id="L3104">					+ nNumEmployeesDumped + &quot;: Failed=&quot; + colEmployeeIDsFailed.size() + &quot;\n\t\tTimeSpentOnGetRemaining: &quot;</span>
<span class="nc" id="L3105">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetRemaining&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tTimeSpentOnGetPendAndSched: &quot;
<span class="nc" id="L3107">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetPendAndSched&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tTimeSpentOnGetEmps: &quot;
<span class="nc" id="L3109">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetEmps&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tTimeSpentOnGetActivity: &quot;
<span class="nc" id="L3111">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetActivity&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\ttimeForGetTOYearRange: &quot;
<span class="nc" id="L3113">					+ decFormat.format(((double) statistic.get(&quot;m_timeForGetTOYearRange&quot;) / lTotalTime) * 100.0)</span>
<span class="nc" id="L3114">					+ &quot;\n\t\ttimeForGetSTBal: &quot; + decFormat.format(((double) statistic.get(&quot;m_timeForGetSTBal&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\ttimeForYrlyAllotMap: &quot;
<span class="nc" id="L3116">					+ decFormat.format(((double) statistic.get(&quot;m_timeForYrlyAllotMap&quot;) / lTotalTime) * 100.0) + &quot;\n\t\ttimeForHrsPerDay: &quot;</span>
<span class="nc" id="L3117">					+ decFormat.format(((double) statistic.get(&quot;m_timeForHrsPerDay&quot;) / lTotalTime) * 100.0) + &quot;\n\t\ttimeForExecuteBatch: &quot;</span>
<span class="nc" id="L3118">					+ decFormat.format(((double) statistic.get(&quot;m_timeForExecuteBatch&quot;) / lTotalTime) * 100.0));</span>
<span class="nc" id="L3119">			AuditTrailEntry entry = new AuditTrailEntry(</span>
					AuditTrailEntry.MODULE_ADAPTER,
					AuditTrailEntry.ACTION_TO_DUMP,
					new ID(0),
					&quot;Time Off Dump&quot;,
					new Date(starttime), new Date(endtime));
<span class="nc" id="L3125">			Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L3126">			cal.setTime(new Date());</span>
<span class="nc" id="L3127">			int curYear = cal.get(Calendar.YEAR);</span>
<span class="nc" id="L3128">			entry.addProperty(&quot;Duration&quot;, &quot;&quot; + (endtime - starttime) / 60000, &quot;minutes&quot;, false);</span>
<span class="nc" id="L3129">			entry.addProperty(&quot;Time Range&quot;, &quot;&quot; + (curYear - lookBack) + &quot; to &quot; + (curYear + lookForward), &quot;string&quot;, false);</span>
<span class="nc" id="L3130">			entry.addProperty(&quot;Number of Employees&quot;, &quot;&quot; + nTotalEmployees, &quot;int&quot;, false);</span>
			try {
<span class="nc" id="L3132">				BbmManagerFactory.getEventAuditTrailManager().createAuditEntry(entry);</span>
<span class="nc" id="L3133">			} catch (Exception e) {</span>
<span class="nc" id="L3134">				m_cat.warn(&quot;Exception occurred during Time Off Dump audit.&quot;);</span>
<span class="nc" id="L3135">			}</span>
<span class="nc" id="L3136">			return colEmployeeIDsFailed;</span>
<span class="nc" id="L3137">		} catch (Exception e) {</span>
<span class="nc" id="L3138">			e.printStackTrace();</span>
<span class="nc" id="L3139">			handleException(e, false);</span>
<span class="nc" id="L3140">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3142">			methodFinish();</span>
		}
	}

<span class="nc" id="L3146">	private static DecimalFormat decFormat = new DecimalFormat(&quot;#.#&quot;);</span>

	/**
	 * Insert missing rows in EMPLOYEETIMEOFFALLOTMENT table.
	 */
	private void syncTOAllocation() throws BbmFinderException {
<span class="nc" id="L3152">		Jdmo jdmo = null;</span>
		try {
<span class="nc" id="L3154">			jdmo = new Jdmo();</span>
<span class="nc" id="L3155">			jdmo.executeCommand(&quot;ins_miss_empallotment&quot;);</span>
<span class="nc" id="L3156">		} catch (Exception e) {</span>
<span class="nc" id="L3157">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L3159" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L3160">				jdmo.cleanUp();</span>
			}
		}
<span class="nc" id="L3163">	}</span>

	private boolean isTemporarilyStopReportDump() {
		try {
<span class="nc" id="L3167">			return BbmManagerFactory.getDBConfigManager().isTemporarilyStopReportDump();</span>
			// stop report dump as is if this flag is set; user wants to suspend and start again.
<span class="nc" id="L3169">		} catch (Exception e) {</span>
<span class="nc" id="L3170">			m_cat.error(e, e);// To change body of catch statement use File | Settings | File Templates.</span>
<span class="nc" id="L3171">			return false;</span>
		}
	}

	/**
	 * Dump the Remaining and Carryover hours into the EmployeeTimeOffAllotment table for Time Off Summary reports for a single
	 * employee.
	 *
	 * @param empIDs - Collection of employees whose time off data needs updating.
	 * @param lookBack - How manay years back to dump.
	 * @param lookForward - How manay years forward to dump.
	 * @param bShowPrintln - true if we were launched from the DumpReportDataServlet. False otherwise.
	 */
	public void dumpTOReportDataForChunk(ReportDumpStatistic statistic, Collection empIDs, int lookBack, int lookForward,
			boolean bShowPrintln, HashMap orgActivityMap, HashMap orgActCatMap) throws BbmUpdateException {
<span class="nc" id="L3186">		methodStart(&quot;dumpTOReportDataForEmployee&quot;, empIDs, new Integer(lookBack), new Integer(lookForward));</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">		if (isTemporarilyStopReportDump()) {</span>
			// stop report dump as is if this flag is set; user wants to suspend and start again.
<span class="nc" id="L3189">			return;</span>
		}
<span class="nc bnc" id="L3191" title="All 2 branches missed.">		if (bShowPrintln) {</span>
<span class="nc" id="L3192">			m_cat.info(&quot;dumpTOReportDataForEmployee empID=&quot; + RmUtil.dumpCommaSeparated(empIDs) + &quot; lookBack=&quot; + lookBack + &quot; lookForward=&quot;</span>
					+ lookForward);
		}
<span class="nc" id="L3195">		Jdmo jdmo = null;</span>
<span class="nc" id="L3196">		long starttime = System.currentTimeMillis();</span>
<span class="nc" id="L3197">		long timeForFetch = 0;</span>
<span class="nc" id="L3198">		long timeForCompare = 0;</span>
<span class="nc" id="L3199">		long timeForExecuteBatch = 0;</span>
<span class="nc" id="L3200">		EmployeeTimeOffYearlyDAO dao = null;</span>
<span class="nc" id="L3201">		int updateCounter = 0;</span>
<span class="nc" id="L3202">		ArrayList empTOYrlyList = new ArrayList();</span>
		try {
<span class="nc" id="L3204">			dao = new EmployeeTimeOffYearlyDAO();</span>
<span class="nc" id="L3205">			jdmo = dao.getDMO();</span>
			// Get the years to be dumped for this employee
<span class="nc" id="L3207">			Calendar nowCal = Calendar.getInstance();</span>
<span class="nc" id="L3208">			int curYear = nowCal.get(Calendar.YEAR);</span>
<span class="nc" id="L3209">			int startYear = curYear - lookBack;</span>
<span class="nc" id="L3210">			int endYear = curYear + lookForward;</span>
<span class="nc bnc" id="L3211" title="All 2 branches missed.">			for (int yeartoDump = startYear; yeartoDump &lt;= endYear; yeartoDump++) {</span>
<span class="nc" id="L3212">				int count = 0;</span>
<span class="nc" id="L3213">				long timeBeforeFetch = System.currentTimeMillis();</span>
<span class="nc" id="L3214">				HashMap dataForAllEmps = getEmployeeData(statistic, empIDs, null, yeartoDump, null, false, false, orgActivityMap,</span>
						orgActCatMap);
<span class="nc" id="L3216">				timeForFetch += (System.currentTimeMillis() - timeBeforeFetch);</span>
<span class="nc" id="L3217">				long timeBeforeCompare = System.currentTimeMillis();</span>
<span class="nc" id="L3218">				String lookupKeyForActivityComb = null;</span>
<span class="nc bnc" id="L3219" title="All 2 branches missed.">				for (Iterator iterator = dataForAllEmps.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L3220">					ID empId = (ID) iterator.next();</span>
<span class="nc" id="L3221">					HashMap empData = (HashMap) dataForAllEmps.get(empId);</span>
<span class="nc" id="L3222">					HashMap yearlyAllotmentMap = (HashMap) empData.get(&quot;yearlyAllotmentMap&quot;);</span>
<span class="nc" id="L3223">					count++;</span>

<span class="nc" id="L3225">					TimeOffActivitySummary[] toActSummaries = getTOActivitySummaryData(statistic, empId, empData, true);</span>

<span class="nc bnc" id="L3227" title="All 4 branches missed.">					for (int i = 0; (toActSummaries != null) &amp;&amp; i &lt; toActSummaries.length; i++) {</span>
<span class="nc" id="L3228">						TimeOffActivitySummary sumry = toActSummaries[i];</span>

<span class="nc bnc" id="L3230" title="All 4 branches missed.">						if (sumry.getActivityID() != null &amp;&amp; sumry.getActivityCategory() != null) {</span>
<span class="nc" id="L3231">							lookupKeyForActivityComb = Activity.getActivity_ActCategoryComb(sumry.getActivityID(), null);</span>
						} else {
<span class="nc" id="L3233">							lookupKeyForActivityComb = sumry.getActivity_ActCategoryComb();</span>
						}

<span class="nc" id="L3236">						HashMap yrlMap = (HashMap) yearlyAllotmentMap.get(lookupKeyForActivityComb);</span>
<span class="nc bnc" id="L3237" title="All 2 branches missed.">						EmployeeTimeOffYearly yrly = (yrlMap != null ? (EmployeeTimeOffYearly) yrlMap.get(&quot;&quot; + yeartoDump) : null);</span>
						// Finally, update the etoa row in the database with the new remaining, carryover values
						// If it has changed from last update
<span class="nc bnc" id="L3240" title="All 4 branches missed.">						if (yrly != null &amp;&amp; !sumry.compareWithTimeOffYearly(yrly)) {</span>
<span class="nc" id="L3241">							updateCounter++;</span>
<span class="nc" id="L3242">							String strQuery = &quot;UPDATE EMPLOYEETIMEOFFALLOTMENT SET remaining=&quot; + sumry.getRemaining() + &quot;, carryover=&quot;</span>
<span class="nc" id="L3243">									+ sumry.getCarryOver() + &quot;,USED=&quot; + sumry.getUsed() + &quot;,SCHEDULED=&quot; + sumry.getScheduled()</span>
<span class="nc" id="L3244">									+ &quot;, PENDING=&quot; + sumry.getPending() + &quot; WHERE ID=&quot; + yrly.getID();</span>
<span class="nc bnc" id="L3245" title="All 2 branches missed.">							if (bShowPrintln) {</span>
<span class="nc" id="L3246">								m_cat.info(&quot;strQuery for batch=&quot; + strQuery + &quot;\t YRLY=&quot; + yrly);</span>
							}
<span class="nc" id="L3248">							jdmo.addBatch(strQuery);</span>
<span class="nc bnc" id="L3249" title="All 4 branches missed.">						} else if (yrly == null</span>
								&amp;&amp; sumry != null
<span class="nc bnc" id="L3251" title="All 6 branches missed.">								&amp;&amp; !(sumry.getRemaining() == 0 &amp;&amp; sumry.getCarryOver() == 0 &amp;&amp; sumry.getScheduled() == 0</span>
<span class="nc bnc" id="L3252" title="All 4 branches missed.">										&amp;&amp; sumry.getPending() == 0 &amp;&amp; sumry.getUsed() == 0)) {</span>
<span class="nc" id="L3253">							m_cat.info(&quot;EmployeeTimeOffYearly Not found; EMPID=&quot; + empId + &quot;:ACT=&quot; + sumry.getActivity_ActCategoryComb()</span>
									+ &quot; :year=&quot; + yeartoDump + &quot;: summary=&quot; + sumry);
<span class="nc" id="L3255">							yrly = new EmployeeTimeOffYearly();</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">							if (sumry.getActivityID() == null) {</span>
<span class="nc" id="L3257">								yrly.setActivityCategoryID(sumry.getActivityCategory().getID());</span>
							} else {
<span class="nc" id="L3259">								yrly.setActivityID(sumry.getActivityID());</span>
							}
<span class="nc" id="L3261">							yrly.setCalendarYear(yeartoDump);</span>
<span class="nc" id="L3262">							yrly.setEmployeeID(empId);</span>
<span class="nc" id="L3263">							yrly.setPending(sumry.getPending());</span>
<span class="nc" id="L3264">							yrly.setUsed(sumry.getUsed());</span>
<span class="nc" id="L3265">							yrly.setScheduled(sumry.getScheduled());</span>
<span class="nc" id="L3266">							yrly.setRemaining(sumry.getRemaining());</span>
<span class="nc" id="L3267">							yrly.setCarryover(sumry.getCarryOver());</span>
<span class="nc" id="L3268">							empTOYrlyList.add(yrly);</span>
						}
					}
<span class="nc" id="L3271">				}</span>
<span class="nc" id="L3272">				timeForCompare += (System.currentTimeMillis() - timeBeforeCompare);</span>
			}
<span class="nc" id="L3274">			long timeBeforeExecuteBatch = System.currentTimeMillis();</span>
<span class="nc" id="L3275">			jdmo.executeBatch();</span>
<span class="nc bnc" id="L3276" title="All 4 branches missed.">			if (empTOYrlyList != null &amp;&amp; !empTOYrlyList.isEmpty()) {</span>
<span class="nc" id="L3277">				dao.createObjects(empTOYrlyList);</span>
			}
<span class="nc" id="L3279">			timeForExecuteBatch = (System.currentTimeMillis() - timeBeforeExecuteBatch);</span>
<span class="nc" id="L3280">			statistic.add(&quot;m_timeForExecuteBatch&quot;, timeForExecuteBatch);</span>
<span class="nc" id="L3281">		} catch (Exception e) {</span>
<span class="nc" id="L3282">			e.printStackTrace();</span>
<span class="nc" id="L3283">			handleException(e);</span>
<span class="nc" id="L3284">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3286">			methodFinish();</span>
<span class="nc bnc" id="L3287" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L3288">				dao.cleanUp();</span>
			}
<span class="nc bnc" id="L3290" title="All 4 branches missed.">			m_cat.info(&quot;dumpTOReportDataForChunk EMPSIZE =&quot; + (empIDs != null ? empIDs.size() : 0) + &quot;,updates=&quot; + updateCounter + &quot;,ins=&quot;</span>
<span class="nc" id="L3291">					+ empTOYrlyList.size() + &quot;,TOTALTime=&quot; + ((System.currentTimeMillis() - starttime) / 1000) + &quot;,&quot; + timeForFetch + &quot;,&quot;</span>
					+ timeForCompare + &quot;,&quot; + timeForExecuteBatch);
<span class="nc" id="L3293">		}</span>
<span class="nc" id="L3294">	}</span>

	public void notifyOnChangeInEmpTOAccrued(Collection colEmpTOAccrued) {
		try {
<span class="nc" id="L3298">			JMSNotifyUtil.notifyOnUserAction(new EmpTOAccruedNotificationDetail(colEmpTOAccrued));</span>
<span class="nc" id="L3299">		} catch (Exception e) {</span>
<span class="nc" id="L3300">			handleException(e);</span>
<span class="nc" id="L3301">		}</span>
<span class="nc" id="L3302">	}</span>

	/**
	 * Count number of request type, and status per employeeID within a time range of time off request dates
	 *
	 * @param countParam
	 * @return
	 * @throws RmException
	 */
	public Map&lt;ID, Integer&gt; getNumberOfRequestPerPeriod(RequestCountParam countParam) throws RmException {
<span class="nc" id="L3312">		methodStart(&quot;countNumberOfRequest&quot;, countParam);</span>
<span class="nc" id="L3313">		RequestDAO requestDAO = null;</span>

		try {
<span class="nc" id="L3316">			requestDAO = new RequestDAO(countParam.getRequestType(), TORequest.DL_BASIC);</span>
<span class="nc" id="L3317">			return requestDAO.getNumberOfRequestPerPeriod(countParam);</span>
<span class="nc" id="L3318">		} catch (Exception e) {</span>
<span class="nc" id="L3319">			handleException(e);</span>
<span class="nc" id="L3320">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3322" title="All 4 branches missed.">			if (requestDAO != null) {</span>
<span class="nc" id="L3323">				requestDAO.cleanUp();</span>
			}
		}
	}

	private boolean hasAdvanceLicense() {
<span class="nc" id="L3329">		return LicenseUtil.isAdvancedRMLicense();</span>
	}

	/**It serves for new Group Action: Approve Time Off Choice without violations
	 * @param reqAgg
	 * @param apprChoiceID will be replaced by valid ChoiceId based on user rank.Choice is valid if it does not have any validations
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected void _approveRequestChoice(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment,
			boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L3344">		String methodName = &quot;_approveRequestChoice&quot;; // passed to other methods</span>
<span class="nc" id="L3345">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment, new Boolean(suppressPrivilegeChecking)));</span>
<span class="nc" id="L3346">		TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L3347">		Collection&lt;ID&gt; apprChoiceIDs= getValidChoiceIdsForMultiApproval(toReq);</span>
<span class="nc bnc" id="L3348" title="All 2 branches missed.">		if (!apprChoiceIDs.isEmpty()) { //Only approve if the TO request has choice does not have violations.</span>
<span class="nc" id="L3349">			approveTORequestChoice(reqAgg, apprChoiceIDs, comment, suppressPrivilegeChecking, loadedFromDB, hasAdvanceLicense());</span>
		}
<span class="nc" id="L3351">		m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>

<span class="nc" id="L3353">	}</span>

	private  Collection&lt;ID&gt; getValidChoiceIdsForMultiApproval(TORequest toReq) throws Exception {
<span class="nc" id="L3356">		Collection&lt;ID&gt; apprChoiceIDs= new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L3357">		Collection&lt;TOChoice&gt; apprChoices= new ArrayList&lt;TOChoice&gt;();</span>
<span class="nc" id="L3358">		doValidationsForMultiChoiceTOB(toReq);</span>
<span class="nc" id="L3359">		apprChoices= toReq.getTOChoicesWillBeApproved();</span>
        //After all validators done, we have final apprChoices, then we just get Ids
<span class="nc bnc" id="L3361" title="All 2 branches missed.">        if(!apprChoices.isEmpty()){</span>
<span class="nc" id="L3362">	        apprChoiceIDs= new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L3363" title="All 2 branches missed.">	        for(TOChoice choice:apprChoices){</span>
<span class="nc" id="L3364">	        	apprChoiceIDs.add(choice.getID());</span>
<span class="nc" id="L3365">	        }</span>
        }
<span class="nc" id="L3367">		return apprChoiceIDs;</span>
	}
	private Collection&lt;TOChoice&gt; getValidChoicesAfterSoftValidatiors(TORequest toReq){
<span class="nc" id="L3370">		Collection&lt;TOChoice&gt; apprChoices= new ArrayList&lt;TOChoice&gt;();</span>
<span class="nc" id="L3371">		List&lt;TOChoice&gt; choiceList = toReq.getRequestChoiceList();</span>
<span class="nc" id="L3372">		int maxChoiceNumber = choiceList.size();</span>
<span class="nc" id="L3373">		int indexUserRank = 0;</span>
		//First: get choices that does not have any violated validation rules
<span class="nc bnc" id="L3375" title="All 2 branches missed.">		while (indexUserRank &lt; maxChoiceNumber) {</span>
<span class="nc" id="L3376">			TOChoice choice = choiceList.get(indexUserRank);</span>
<span class="nc" id="L3377">			Collection&lt;ValidationResult&gt; listValidator = choice.getValidationResults(true);</span>
<span class="nc bnc" id="L3378" title="All 2 branches missed.">			if (listValidator.isEmpty()) {</span>
<span class="nc" id="L3379">				apprChoices.add(choice);</span>
			}
<span class="nc" id="L3381">			indexUserRank++;</span>
<span class="nc" id="L3382">		}</span>
<span class="nc" id="L3383">		return apprChoices;</span>
	}

	public void doValidationsForMultiChoiceTOB(TORequest toReq) throws Exception{
		//First: get choices that does not have any violated validation rules
<span class="nc" id="L3388">		Collection&lt;TOChoice&gt; validChoicesAfterSoftValidators = getValidChoicesAfterSoftValidatiors(toReq);</span>
<span class="nc bnc" id="L3389" title="All 2 branches missed.">		if(!validChoicesAfterSoftValidators.isEmpty()){</span>
<span class="nc" id="L3390">			Map&lt;String,ValidatorForMultiChoice&gt; validatorsMap = new HashMap&lt;String,ValidatorForMultiChoice&gt;();</span>
			//RUN ALL VALIDATORS FOR EACH CHOICE=&gt; to find out the real valid choice.
			//The validators should consider all approved choices of the request when evaluating a choice
<span class="nc bnc" id="L3393" title="All 2 branches missed.">			for (TOChoice toChoice: validChoicesAfterSoftValidators) {</span>
<span class="nc" id="L3394">				toReq.setTOChoiceForValidation(toChoice); //Set the considering choice for each validator</span>
<span class="nc" id="L3395">				Collection&lt;String&gt; validatorNames =  toReq.getValidationCache().getValidators();</span>
<span class="nc" id="L3396">				String validatorName=&quot;&quot;;</span>
<span class="nc" id="L3397">				Collection&lt;String&gt; necessaryValidators = Arrays.asList(softValidatorsForMultiChoice);</span>
<span class="nc bnc" id="L3398" title="All 2 branches missed.">		        for (Iterator&lt;String&gt; it = validatorNames.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3399">		            validatorName = it.next();</span>
<span class="nc bnc" id="L3400" title="All 2 branches missed.">		            if (necessaryValidators.contains(validatorName)) {</span>
<span class="nc" id="L3401">		            	ValidationUtil.doValidationForMultiChoice(validatorName, toReq, validatorsMap);</span>
		            }
		        }
		        //After all validation rules done, if the choice violate one of validation rule, it is not in the list of
<span class="nc bnc" id="L3405" title="All 2 branches missed.">		        if(toChoice.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L3406">		        	toReq.addTOChoiceWillBeApproved(toChoice);</span>
		        }
<span class="nc" id="L3408">	        }</span>
		}
<span class="nc" id="L3410">	}</span>

	@Override
	public void changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment)
			throws Exception {
<span class="nc" id="L3415">		checkChangeRequestStatePrivilege(reqID, newState);</span>
<span class="nc" id="L3416">		_changeRequestStateByID(reqID, newState, objectVersionNumber, comment, hasAdvanceLicense());</span>
<span class="nc" id="L3417">	}</span>

	@Override
	protected void markRequestViolateSpecialRulesAsInValidIfNeeded(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc bnc" id="L3421" title="All 2 branches missed.">		if (LicenseUtil.isAdvancedRMLicense()) {</span>
<span class="nc" id="L3422">			TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L3423">			List&lt;TOChoice&gt; choiceList = toReq.getRequestChoiceList();</span>
<span class="nc" id="L3424">			boolean checkHasSomeSpecificHardRulesViolated = false;</span>
<span class="nc" id="L3425">			ValidationResult hardValResult = null;</span>
<span class="nc bnc" id="L3426" title="All 2 branches missed.">			for (Iterator&lt;TOChoice&gt; iter = choiceList.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3427">				TOChoice choice = iter.next();</span>
<span class="nc" id="L3428">				Collection&lt;ValidationResult&gt; listValidator = choice.getValidationResults(true);</span>
<span class="nc bnc" id="L3429" title="All 2 branches missed.">				if (!listValidator.isEmpty()) {</span>
<span class="nc bnc" id="L3430" title="All 2 branches missed.">					for (Iterator&lt;ValidationResult&gt; vIter = listValidator.iterator(); vIter.hasNext();) {</span>
<span class="nc" id="L3431">						ValidationResult vResult = vIter.next();</span>
<span class="nc" id="L3432">						checkHasSomeSpecificHardRulesViolated = TORequestUtil.checkHasSomeSpecificHardRulesViolated(vResult);</span>
<span class="nc bnc" id="L3433" title="All 2 branches missed.">						if (checkHasSomeSpecificHardRulesViolated) {</span>
<span class="nc" id="L3434">							hardValResult = vResult;</span>
<span class="nc" id="L3435">							break;</span>
						}
<span class="nc" id="L3437">					}</span>
				}
<span class="nc" id="L3439">			}</span>

			//Only mark it as Invalid if it is not a TOB request which has mulit-choices can be approved since
			//the special soft rule here is really hard validation rule
<span class="nc bnc" id="L3443" title="All 4 branches missed.">			if (toReq.getTimeOffBidInfo()==null&amp;&amp;hardValResult!=null) {</span>
<span class="nc" id="L3444">				super.markRequestAsInvalid(reqAgg, hardValResult, reqAggDAO);</span>
			}
		}
<span class="nc" id="L3447">	}</span>


	public void calculateAdvancedVtoTimeOffChoices(TORequest toRequest) {

<span class="nc bnc" id="L3452" title="All 4 branches missed.">		if (toRequest.isTimeoffChoicesForAdvancedVtoInitialized() || !toRequest.isPendingAdvancedVto()) {</span>
			//already calculated or no need to calculate
<span class="nc" id="L3454">			return;</span>
		}

<span class="nc" id="L3457">		AdvancedVtoCalculator calc = new AdvancedVtoCalculator();</span>
<span class="nc" id="L3458">		List&lt;TOChoice&gt; calculatedChoices = calc.calculateAdvancedVtoTimeOffChoices(toRequest);</span>
<span class="nc" id="L3459">		toRequest.setCalculatedTimeoffChoicesForAdvancedVto(calculatedChoices);</span>
<span class="nc" id="L3460">	}</span>
	/*Process VTO request which has Multiple VTO Options checked :
     * 1) Approve requests that has valid choices after calculated
     * based on rules :avoid scheduled calendar event activities as defined,
     *  time off pool hours availability,
     *  do not allow the employee to go below minimum required hours.
 	 *2) Otherwise, deny requests that no choice meets those above rules: */
	@Override
	protected boolean _processVTORequest(RequestAggregate reqAgg, String comment) throws Exception{
<span class="nc" id="L3469">		TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L3470">		calculateAdvancedVtoTimeOffChoices(toReq);</span>
<span class="nc" id="L3471">		Collection&lt;TOChoice&gt; approvedChoices = toReq.getCalculatedTimeoffChoicesForAdvancedVto();</span>
<span class="nc" id="L3472">		String oldStatus = toReq.getRequestStatus();</span>
<span class="nc" id="L3473">		boolean isSuccessful=false;</span>
<span class="nc bnc" id="L3474" title="All 2 branches missed.">		if (!approvedChoices.isEmpty()) {</span>
			//Success
			try {
<span class="nc" id="L3477">				updateRequestWithApprovedCalculatedChoice(toReq, RequestAuditTrail.STATUS_APPROVED,</span>
<span class="nc" id="L3478">						comment,RequestAuditTrail.STATUS_APPROVED,hasAdvanceLicense());</span>
<span class="nc" id="L3479">				isSuccessful= true;</span>
<span class="nc" id="L3480">			} catch (Exception e) {</span>
<span class="nc" id="L3481">				m_cat.debug(&quot;Error when updateRequestWithApprovedCalculatedChoice &quot; +e.getLocalizedMessage());</span>
<span class="nc" id="L3482">			}</span>
		}
<span class="nc bnc" id="L3484" title="All 2 branches missed.">		if(!isSuccessful) {</span>
<span class="nc" id="L3485">			_updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null, false, false, true, hasAdvanceLicense());</span>
		} else{
<span class="nc bnc" id="L3487" title="All 2 branches missed.">			for (TOChoice approvedChoice : approvedChoices) {</span>
<span class="nc" id="L3488">				adjustScheduleAndNetStaffing(reqAgg, toReq, oldStatus, approvedChoice);</span>
<span class="nc" id="L3489">			}</span>
		}

<span class="nc" id="L3492">		return isSuccessful;</span>
	}
	/*Approve 1 single choice for options: Full, Partial Day, Late Start, Early Off*/
	private void updateRequestWithApprovedCalculatedChoice(TORequest toReq,String newState, String comment,
			String methodSubType, boolean skipSomeHardRulesWhenUpdate)
			throws Exception {

<span class="nc" id="L3499">		toReq.setToApprovedAllCalculatedTimeOffChoicesForAdvanceVto();</span>
		//_updateRequest will run validations and set the request state to approved.
<span class="nc" id="L3501">		_updateRequest(toReq, newState, comment, methodSubType, false, false,true, skipSomeHardRulesWhenUpdate);</span>
<span class="nc" id="L3502">	}</span>
	
	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attributes 'Requestable' and
	 * ('Timeoff' or 'Unavailability')
	 *
	 * @param orgIds- Id for the organization.
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection&lt;Activity&gt; getTimeOffTypes(Collection&lt;ID&gt; orgIds) throws BbmFinderException {
<span class="nc" id="L3513">		String _method_ = &quot;getTimeOffTypes&quot;;</span>
<span class="nc" id="L3514">		methodStart(_method_, orgIds);</span>

		// create filter.
<span class="nc" id="L3517">		ActivityFilter filter = new ActivityFilter();</span>
		// gets active by default

<span class="nc" id="L3520">		filter.setRequestable(true);</span>
		// filter 'Requestable' activities.
		// Since 'Requestable' activities are automatically 'timeoff' or 'Unavailability',
		// they are not explicitly specified
		try {
<span class="nc" id="L3525">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L3526">			return am.findOrganizationActivities(orgIds, filter,true);</span>
<span class="nc" id="L3527">		} catch (Exception e) {</span>
<span class="nc" id="L3528">			handleException(e);</span>
<span class="nc" id="L3529">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L3531">			methodFinish();</span>
		}
	}

	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attributes 'Requestable' and
	 * ('Timeoff' or 'Unavailability').  If flexType is 1 or greater, flexType activities are returned in the query.
	 * If flexType is -1 or 0, flexType are not included.
	 * 
	 *
	 * @param orgIds- Id for the organization.
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection&lt;Activity&gt; getTimeOffTypes(Collection&lt;ID&gt; orgIds, int flexType) throws BbmFinderException {
<span class="nc" id="L3546">		String _method_ = &quot;getTimeOffTypes&quot;;</span>
<span class="nc" id="L3547">		methodStart(_method_, orgIds);</span>

		// create filter.
<span class="nc" id="L3550">		ActivityFilter filter = new ActivityFilter();</span>
		// gets active by default

<span class="nc" id="L3553">		filter.setRequestable(true);</span>
		// filter 'Requestable' activities.
		// Since 'Requestable' activities are automatically 'timeoff' or 'Unavailability',
		// they are not explicitly specified
		try {
<span class="nc" id="L3558">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L3559">			return am.findOrganizationActivities(orgIds, filter,true, flexType);</span>
<span class="nc" id="L3560">		} catch (Exception e) {</span>
<span class="nc" id="L3561">			handleException(e);</span>
<span class="nc" id="L3562">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L3564">			methodFinish();</span>
		}
	}

	public RequestAggregate approveTOBChoicesWithoutViolations(ID reqID) throws Exception{
<span class="nc" id="L3569">		return super.groupApproveTOChoiceWithoutViolations(reqID);</span>
	}

	public RequestAggregate processAllVTORequests(ID reqID) throws Exception{
<span class="nc" id="L3573">		return super.groupApproveVTORequest(reqID);</span>
	}

	public List&lt;Activity&gt; getTOActivitiesForEmp(ID employeeID, ID orgID, boolean requestableOnly, boolean withAllotmentOnly)
			throws BbmFinderException, BbmEJBCreateException, RemoteException {

<span class="nc" id="L3579">		String methodName = &quot;getTOActivitiesForEmp&quot;;</span>
<span class="nc" id="L3580">		methodStart(methodName, employeeID, orgID);</span>

		// Get the organization id
<span class="nc" id="L3583">		List&lt;Activity&gt; list = (List&lt;Activity&gt;) getTimeOffActs(orgID, requestableOnly, withAllotmentOnly);</span>

<span class="nc" id="L3585">		methodFinish();</span>
<span class="nc" id="L3586">		return list;</span>
	}

	protected UserManager getUserManager() throws CoreEJBCreateException {
<span class="nc" id="L3590">		return CoreManagerFactory.getUserManager(WhatIfMode);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>