<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RequestAggregateManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.ejb</a> &gt; <span class="el_source">RequestAggregateManager.java</span></div><h1>RequestAggregateManager.java</h1><pre class="source lang-java linenums">/*
 * RequestAggregateManager.java
 *
 * Created on February 25, 2003, 2:10 AM
 */

package com.bluepumpkin.ejb.rm.requests.common.ejb;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import org.apache.log4j.Level;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.notification.model.RequestNotificationDetail;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.AutoProcessingRuleChecker;
import com.bluepumpkin.ejb.rm.requests.common.validation.AutoProcessingRuleCheckerHelper;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManager;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.TimeOffIntervalAllocationManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AgentGoodStandingValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AvaliableHoursValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AvoidCalendarEventsValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.ComplyMinRequiredPayPeriodHoursRuleTimeOff;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.EmployeeHoursValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidMaxWeeksValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidPeriodPerChoiceHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffRequestsPerQuarterValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeWithinScheduleTimeOffHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.model.TOWaitlist;
import com.bluepumpkin.ejb.rm.security.RequestAction;
import com.bluepumpkin.ejb.rm.security.RmSecurityManager;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.ejb.TimeOffBiddingManager;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;

/**
 * @author RRajendran
 *
 * To change the template for this generated type comment go to
 * Window&amp;gt;Preferences&amp;gt;Java&amp;gt;Code Generation&amp;gt;Code and Comments
 */
/**
 *
 * @author  Raja Rajendran.
 */
<span class="nc bnc" id="L101" title="All 2 branches missed.">public abstract class RequestAggregateManager extends SessionEJBBase implements IRequestType //OUTSIDE_CONTAINER</span>
//public abstract class RequestAggregateManager extends SessionEjbBaseForTest implements IRequestType //OUTSIDE_CONTAINER
{
<span class="nc" id="L104">    private static final String m_className = RequestAggregateManager.class.getName();</span>
<span class="nc" id="L105">    private static final Category m_cat = Log.initCategory(m_className);</span>

<span class="nc" id="L107">	private static final ConcurrentMap&lt;String, Boolean&gt; doNotCacheValidatorNames = getDoNotCacheValidatorNames();</span>

<span class="nc" id="L109">    protected HashMap 	validatorMap = new HashMap();</span>
<span class="nc" id="L110">	public static short ARRAY_INDEX_FOR_AUTO_APPROVE=0;</span>
<span class="nc" id="L111">	public static short ARRAY_INDEX_FOR_AUTO_DENY=1;</span>
<span class="nc" id="L112">	public static short ARRAY_INDEX_FOR_AUTO_WAITLIST=2;</span>
	public final static String m_tentativeNotImplemented = &quot;Tentative approval/denial/withdrawal processing not supported for this request type:&quot;;

    /** Creates a new instance of RequestAggregateManager */
<span class="nc" id="L116">    public RequestAggregateManager() {</span>
<span class="nc" id="L117">    }</span>

	//TODO: remove incExpired.  detailLevel must be sufficient.
    protected RequestAggregate _getRequestByID(ID reqID, boolean incExpired,
        boolean runHardValids, boolean runSoftValids, long detailLevel) throws Exception {
<span class="nc" id="L122">        return _getRequestByID(reqID,incExpired,runHardValids,runSoftValids, detailLevel, false);</span>
    }
    protected RequestAggregate _getRequestByID(ID reqID, boolean incExpired,
            boolean runHardValids, boolean runSoftValids, long detailLevel, boolean shouldRunSpecialSoftRulesForAnytimeRequests) throws Exception {
<span class="nc" id="L126">            String methodName = &quot;_getRequestByID&quot;;</span>
<span class="nc" id="L127">            m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqID, new Boolean(incExpired), new Boolean(runHardValids),</span>
                new Boolean(runSoftValids)));

<span class="nc" id="L130">            RequestAggregateDAO reqAggDAO = null;</span>
            try {
<span class="nc" id="L132">                reqAggDAO = getDAO(detailLevel);</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                if (incExpired) {</span>
<span class="nc" id="L134">    				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
    			}

<span class="nc" id="L137">                RequestAggregate reqAgg = null;</span>
                try {
<span class="nc" id="L139">                	reqAgg = reqAggDAO.getRequestByID(reqID, detailLevel);</span>
<span class="nc" id="L140">                } catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L141">                	m_cat.error(&quot;BbmObjectNotFoundException caught and not propogated: Unable to load request with ID: &quot; + reqID, e);</span>
<span class="nc" id="L142">                }</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                if (reqAgg == null) {</span>
<span class="nc" id="L144">    				return null;</span>
    			}


<span class="nc" id="L148">                getRequestPreValidationProcess(reqAggDAO, Collections.singleton(reqAgg), detailLevel);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                if (runHardValids) {</span>
<span class="nc bnc" id="L150" title="All 6 branches missed.">                	boolean runSpecialRulesForAnytimeTORequests=shouldRunSpecialSoftRulesForAnytimeRequests&amp;&amp;reqAgg.isAdvancedVTORequest() &amp;&amp; LicenseUtil.isAdvancedRMLicense();</span>
<span class="nc" id="L151">                	m_managerFactory.getRequestManagerByType(getRequestTypeWithFlexTimeFix(reqAgg))._validateRequest(reqAgg, runSoftValids, true,runSpecialRulesForAnytimeTORequests);</span>
                }

<span class="nc" id="L154">                getRequestPostProcess(Collections.singleton(reqAgg), detailLevel);</span>

<span class="nc" id="L156">                m_cat.debug(RmUtil.dumpExitMethod(methodName, reqAgg));</span>
<span class="nc" id="L157">                return reqAgg;</span>
            } finally {
<span class="nc bnc" id="L159" title="All 6 branches missed.">    	        if (reqAggDAO != null) {</span>
<span class="nc" id="L160">    				reqAggDAO.cleanUp();</span>
    			}
            }
        }

<span class="nc" id="L165">	private final RmManagerFactory m_managerFactory = RmManagerFactory.getInstance(true);</span>

    // returns a Request
    @Override
	public RequestAggregate getRequestByID(ID reqID, boolean incExpired, boolean runSoftValids, long detailLevel)
            throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L171">        String _method_ = &quot;getRequestByID&quot;;</span>
<span class="nc" id="L172">        methodStart(_method_, reqID, new Boolean(incExpired), new Boolean(runSoftValids), new Long(detailLevel));</span>

<span class="nc" id="L174">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L175">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L177">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            // Note: we need these detail levels for doing hard and soft validations.  Otherwise
            // the validators will crash.
<span class="nc" id="L181">            detailLevel |= getDetailLevelForValidation();</span>

<span class="nc" id="L183">            return _getRequestByID(reqID, incExpired, true, runSoftValids, detailLevel);</span>
<span class="nc" id="L184">        } catch (RmHardValidationException e) {</span>
        	//RM exceptions are always logged at the point where they are thrown.
        	//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L191">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L192">        	throw e;</span>
<span class="nc" id="L193">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L194">			m_cat.error(e, e);</span>
<span class="nc" id="L195">			handleException(e);</span>
<span class="nc" id="L196">			throw e;</span>
<span class="nc" id="L197">        } catch (Exception e) {</span>
<span class="nc" id="L198">            handleException(e);</span>
<span class="nc" id="L199">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L201" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L202">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L204">            methodFinish();</span>
        }
    }
<span class="nc" id="L207">	public static Integer USER_TRANSACTION_TIMEOUT = null;</span>

	public int getUserTransactionTimeOut() throws Exception {
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (USER_TRANSACTION_TIMEOUT == null) {</span>
<span class="nc" id="L211">			String transTimeOut = BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.REQUEST_MANAGEMENT + &quot;USER_TRANSACTION_TIMEOUT&quot;);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">			USER_TRANSACTION_TIMEOUT = new Integer(StringUtil.isEmpty(transTimeOut) ? 300 : Integer.parseInt(transTimeOut));</span>
		}
<span class="nc" id="L214">		return USER_TRANSACTION_TIMEOUT.intValue();</span>
	}
    // returns a Collection of validated specific Requests (e.g. TO, SS, SB)
	@Override
	public Collection getRequestsById(Collection requestIds, boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal, long detailLevel)
	        throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L220">        String _method_ = &quot;getRequestsById&quot;;</span>
<span class="nc" id="L221">        methodStart(_method_, requestIds, new Boolean(incExpired), new Boolean(runSoftValids),</span>
                new Long(detailLevel));

<span class="nc" id="L224">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L225">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L226">        boolean cacheEnabled = false;</span>
<span class="nc" id="L227">		boolean threadCacheEnabled = false;</span>
        try {
<span class="nc" id="L229">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L230">			threadCacheEnabled = ThreadLocalCache.enable();</span>

            // Note: we need these detail levels for doing hard and soft validations.  Otherwise
            // the validators will crash.
<span class="nc" id="L234">            detailLevel |= getDetailLevelForValidation();</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (incExpired) {</span>
<span class="nc" id="L236">				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
			}
<span class="nc" id="L238">	        RmManagerFactory m_managerFactory = RmManagerFactory.getInstance();</span>
<span class="nc" id="L239">            reqAggDAO = getDAO(detailLevel);</span>
<span class="nc" id="L240">            Collection reqAggs = reqAggDAO.getRequestsByIDs(requestIds, detailLevel);</span>
<span class="nc" id="L241">			getRequestPreValidationProcess(reqAggDAO, reqAggs, detailLevel);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            for (Iterator it = reqAggs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L243">		        RequestAggregate reqAgg = null;</span>
		        try {
<span class="nc" id="L245">			        reqAgg = (RequestAggregate) it.next();</span>
<span class="nc" id="L246">			        m_managerFactory.getRequestManagerByType(getRequestTypeWithFlexTimeFix(reqAgg))._validateRequest(reqAgg, runSoftValids, runNetStaffingSoftVal);</span>
<span class="nc" id="L247">		        } catch (Exception e) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">			        m_cat.error(&quot;Thrown exception in User Transaction REQID=:&quot; + (reqAgg != null ? reqAgg.getID().toString() : &quot; IS NULL&quot;), e);</span>
<span class="nc" id="L249">            }</span>
<span class="nc" id="L250">	        }</span>
<span class="nc" id="L251">            getRequestPostProcess(reqAggs, detailLevel);</span>

<span class="nc" id="L253">            return reqAggs;</span>
<span class="nc" id="L254">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L261">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L262">			throw e;</span>
<span class="nc" id="L263">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L264">			m_cat.error(e, e);</span>
<span class="nc" id="L265">			handleException(e);</span>
<span class="nc" id="L266">			throw e;</span>
<span class="nc" id="L267">        } catch (Exception e) {</span>
<span class="nc" id="L268">            handleException(e);</span>
<span class="nc" id="L269">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L271" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L272">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L274" title="All 4 branches missed.">			if (reqAggDAO != null) {</span>
<span class="nc" id="L275">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L277">			ThreadLocalCache.clear(threadCacheEnabled);</span>
<span class="nc" id="L278">            methodFinish();</span>
        }
    }

	/**
	 * Get a collection of RequestAggregate from Request IDs
	 * @param requestIDs
	 * @param detailLevel
	 * @return
	 * @throws RmException
	 */
    @Override
	public Collection&lt;RequestAggregate&gt; getRequestsByIDs(Collection requestIDs, long detailLevel) throws RmException {
<span class="nc" id="L291">		RequestAggregateDAO reqAggDao = null;</span>
		try {
<span class="nc" id="L293">			reqAggDao = getDAO(detailLevel);</span>
<span class="nc" id="L294">			return reqAggDao.getRequestsByIDs(requestIDs, detailLevel);</span>
<span class="nc" id="L295">		} catch (Exception e) {</span>
<span class="nc" id="L296">			handleException(e);</span>
<span class="nc" id="L297">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		}
		finally {
<span class="nc bnc" id="L300" title="All 4 branches missed.">			if(reqAggDao != null) {</span>
<span class="nc" id="L301">				reqAggDao.cleanUp();</span>
			}
		}
    }

    /**
     * Get a Map&lt;ID, RequestAggregate&gt; of RequestAggregate from Request IDs
     * @param requestIDs
     * @param detailLevel
     * @return
     * @throws RmException
     */
    @Override
	public Map&lt;ID, RequestAggregate&gt; getRequestMapByIDs(Collection requestIDs, long detailLevel) throws RmException {
<span class="nc" id="L315">    	Collection&lt;RequestAggregate&gt; reqs = getRequestsByIDs(requestIDs, detailLevel);</span>
<span class="nc" id="L316">    	Map&lt;ID, RequestAggregate&gt; map = new HashMap&lt;ID, RequestAggregate&gt;();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">    	for(RequestAggregate req: reqs) {</span>
<span class="nc" id="L318">    		map.put(req.getID(), req);</span>
<span class="nc" id="L319">    	}</span>

<span class="nc" id="L321">    	return map;</span>
    }

	private String getRequestTypeWithFlexTimeFix(RequestAggregate reqAgg) {
<span class="nc" id="L325">		String requestType = reqAgg.getRequestType();</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">		if (Request.REQUESTTYPE_TIMEOFF.equals(requestType) &amp;&amp; ((TORequest) reqAgg).isFlexTimeRequest()) {</span>
<span class="nc" id="L327">			requestType = Request.REQUESTTYPE_FLEXTIME;</span>
		}
<span class="nc" id="L329">		return requestType;</span>
	}

    // returns a Collection of Request IDs for a given employee
    @Override
	public Collection getRequestIdsByEmployee(ID employeeId, boolean incExpired)
    	throws BbmFinderException, RmHardValidationException
    {
<span class="nc" id="L337">        String _method_ = &quot;getRequestIdsByEmployee&quot;;</span>
<span class="nc" id="L338">        methodStart(_method_, employeeId, new Boolean(incExpired));</span>

<span class="nc" id="L340">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L341">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L342">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L344">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            /*
            if (!isTimeOffWorkflowActiveForEmp(employeeId)) {
                return Collections.emptyList();
            } */

<span class="nc" id="L351">            long detailLevel = RequestDetailLevel.DL_BASIC;</span>
<span class="nc" id="L352">            reqAggDAO = getDAO(detailLevel);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (incExpired) {</span>
<span class="nc" id="L354">				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
			}

<span class="nc" id="L357">            return reqAggDAO.getRequestIDsByEmployee(employeeId, detailLevel);</span>
<span class="nc" id="L358">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L365">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L366">			throw e;</span>
<span class="nc" id="L367">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L368">			m_cat.error(e, e);</span>
<span class="nc" id="L369">			handleException(e);</span>
<span class="nc" id="L370">			throw e;</span>
<span class="nc" id="L371">        } catch (Exception e) {</span>
<span class="nc" id="L372">            handleException(e);</span>
<span class="nc" id="L373">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L375" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L376">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L378" title="All 4 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L379">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L381">            methodFinish();</span>
        }
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#getRequestsByEmployee(com.bluepumpkin.common.datatypes.ID, boolean, boolean, long)
     */
    @Override
	public Collection getRequestsByEmployee(ID employeeId, boolean incExpired, boolean runSoftValids, long detailLevel)
            throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L391">	    String _method_ = &quot;getRequestsByEmployee&quot;;</span>
<span class="nc" id="L392">	    methodStart(_method_, employeeId, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="nc" id="L394">	    RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L395">	    String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L396">	    boolean cacheEnabled = false;</span>
	    try {
<span class="nc" id="L398">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

		    /*
		    // if &quot;timeoff workflow active&quot; org setting for employee is disabled, return empty list.
		    if (!isTimeOffWorkflowActiveForEmp(employeeId)) {
		        return Collections.emptyList();
		    } */
		    // Note: we need these detail levels for doing hard and soft validations.  Otherwise
		    // the validators will crash.
<span class="nc" id="L407">		    detailLevel |= getDetailLevelForValidation();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">		    if (incExpired) {</span>
<span class="nc" id="L409">				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
			}
<span class="nc" id="L411">		    RmManagerFactory m_managerFactory = RmManagerFactory.getInstance();</span>
<span class="nc" id="L412">		    reqAggDAO = getDAO(detailLevel);</span>
<span class="nc" id="L413">		    Collection reqAggs = reqAggDAO.getRequestsByEmployee(employeeId, detailLevel);</span>
<span class="nc" id="L414">			getRequestPreValidationProcess(reqAggDAO, reqAggs, detailLevel);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">		    for (Iterator it = reqAggs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L416">			    RequestAggregate req = null;</span>
			    try {
<span class="nc" id="L418">				    req = (RequestAggregate) it.next();</span>
<span class="nc" id="L419">				    m_managerFactory.getRequestManagerByType(getRequestTypeWithFlexTimeFix(req))._validateRequest(req, runSoftValids, true);</span>
<span class="nc" id="L420">			    } catch (Exception e) {</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">				    m_cat.error(&quot;Thrown exception in User Transaction REQID=:&quot; + (req != null ? req.getID().toString() : &quot; IS NULL&quot;), e);</span>
<span class="nc" id="L422">			    }</span>
<span class="nc" id="L423">		    }</span>
<span class="nc" id="L424">		    getRequestPostProcess(reqAggs, detailLevel);</span>
<span class="nc" id="L425">		    return reqAggs;</span>
<span class="nc" id="L426">	    } catch (RmHardValidationException e) {</span>
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L430">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L431">		    throw e;</span>
<span class="nc" id="L432">	    } catch (BbmFinderException e) {</span>
<span class="nc" id="L433">		    m_cat.error(e, e);</span>
<span class="nc" id="L434">		    handleException(e);</span>
<span class="nc" id="L435">		    throw e;</span>
<span class="nc" id="L436">	    } catch (Exception e) {</span>
<span class="nc" id="L437">		    handleException(e);</span>
<span class="nc" id="L438">		    throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="nc bnc" id="L440" title="All 4 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L441">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L443" title="All 4 branches missed.">		    if (reqAggDAO != null) {</span>
<span class="nc" id="L444">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L446">		    methodFinish();</span>
	    }
    }

    /**
     * Called after requests are loaded from DB and after validations are run.
     *
     * @param reqAggs
     */
    protected abstract void getRequestPostProcess(Collection reqAggs, long detailLevel) throws Exception;
 /**
     * Called after requests are loaded from DB and before validations are run.
     *
     * @param reqAggs
     */

	protected void getRequestPreValidationProcess(RequestAggregateDAO dao, Collection reqAggs, long detailLevel) throws Exception {

<span class="nc" id="L464">    }</span>

    /**
     * Preprocess request before creation. verify if request fields have valid values.
     * only checks outside the hard validations need be done.
     *
     * &lt;p&gt; Note: overridden by subclasses
     *
     * @param reqAgg
     */
    protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO)
    	throws Exception {

		/*
		 * Fields in Request table.
			ID
			REQUESTTYPE
			REQUESTSTATUS
			SUBMITTEDON
			CREATORID
			CHANGECOUNTER
			MODIFIEDBY
			LASTMODIFIEDAT
			EMPLOYEEID
			EXPIRATIONDATE
		 *
		 */

		// If creatorID is set in Request object, ensure it's the same as
		// the employeeID from the logged in user. If it's not set,
		// set it to the user's employeeID.
<span class="nc" id="L495">		User loginUserBasic = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">		if (loginUserBasic == null) {</span>
<span class="nc" id="L497">		  throw RequestUtil.createRmException(RmEjbLogBundleKey.CREATE_INVALID_LOGINUSERID,</span>
<span class="nc" id="L498">					new Object[] { m_sessionContext.getCallerPrincipal().getName()}, m_cat);</span>
		}
<span class="nc" id="L500">		ID loginUserID = loginUserBasic.getID();</span>

		// if creator ID not set, assign login user ID
<span class="nc" id="L503">		Request aggdReq = reqAgg.getAggregatedRequest();</span>
<span class="nc" id="L504">		ID creatorUserID = aggdReq.getCreatorID();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">		if ( creatorUserID == null ) {</span>
<span class="nc" id="L506">			aggdReq.setCreatorID(creatorUserID = loginUserID);</span>
		}

		// validate creatorID == login user ID.
<span class="nc bnc" id="L510" title="All 2 branches missed.">		if ( !creatorUserID.equals(loginUserID)) {</span>
<span class="nc" id="L511">			throw RequestUtil.createRmException(RmEjbLogBundleKey.CREATE_INVALID_CREATORID,</span>
				new Object[] { creatorUserID, loginUserID }, m_cat);
		}

		// Do not set the employeeID using the login user's empID as a manager can create reqs for an emp.
		// aggdReq.setEmployeeID(loginUserBasic.getEmployeeID());

		// Set submittedon field if necessary
<span class="nc bnc" id="L519" title="All 2 branches missed.">		if (aggdReq.getSubmittedOn() == null) {</span>
<span class="nc" id="L520">			aggdReq.setSubmittedOn(new Date());</span>
		}
<span class="nc" id="L522">	}</span>

    /**
     * Create a new request with the given 'comment' in the audit trail
     *
     * &lt;p&gt;This method starts a new transaction since createRequest()'s transaction
     * attribute is 'Not Required'.
     *
     * &lt;p&gt; Method visibility is public since it is exposed in the remtoe interface (for
     * specifying a transaction attribute in ejb-jar.xml).
     *
     * @param request - TORequest for creation.
     * @param comment - string comment for creation
     * @return ID - Id for the newly created timeoof request.
     * @return To check if any hard vaidations failed, check validation results in the request.
     * @throws - BbmCreateException
     * @throws - RmHardValidationException is any hardValidations fail.
     */
    @Override
	public ID _createRequest(RequestAggregate reqAgg, String comment)
        throws RmHardValidationException, BbmCreateException
    {
<span class="nc" id="L544">        String _method_ = &quot;_createRequest&quot;;</span>

<span class="nc" id="L546">        methodStart(_method_, reqAgg, comment);</span>

<span class="nc" id="L548">        RequestAggregateDAO reqAggDao = null;</span>
<span class="nc" id="L549">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L550">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L552">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L554">            reqAggDao = getDAO(RequestDetailLevel.DL_BASIC);</span>

<span class="nc" id="L556">            assignDefaultsForReqAgg(reqAgg);</span>

<span class="nc" id="L558">            createRequestPreProcess(reqAgg, reqAggDao);</span>

            // do hard validations.
<span class="nc" id="L561">            doHardValidationsRaiseException(reqAgg, RequestUtil.METHODTYPE_CREATOR, null, false);</span>

			// verify security
<span class="nc" id="L564">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L565">			secMgr.assertCanModifyRequest(getUser(), reqAgg, null);</span>

            // Validations sucessful, create object
<span class="nc" id="L568">            User loginUserBasic = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L569">			reqAgg.setID(reqAggDao.createRequest(reqAgg, comment, loginUserBasic));</span>
<span class="nc" id="L570">            createRequestPostProcess(reqAgg,reqAggDao);</span>
<span class="nc" id="L571">            return reqAgg.getID();</span>
<span class="nc" id="L572">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L579">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L580">			throw e;</span>
<span class="nc" id="L581">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L582">			m_cat.error(e, e);</span>
<span class="nc" id="L583">			handleException(e);</span>
<span class="nc" id="L584">			throw e;</span>
<span class="nc" id="L585">        } catch (Exception e) {</span>
<span class="nc" id="L586">            handleException(e);</span>
<span class="nc" id="L587">            throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L589" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L590">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L592" title="All 4 branches missed.">            if ( reqAggDao != null ) {</span>
<span class="nc" id="L593">				reqAggDao.cleanUp();</span>
			}
<span class="nc" id="L595">            methodFinish();</span>
        }
    }

    /**
     * Creates a request with the given comment in the audit trail and does autoProcessing. &lt;br&gt;
     * To check if any hard vaidation failed, check validation results in the request.
     *
     * &lt;p&gt;Request creation and autoprocessing runs in its own transaction.  If not, an exception raised
     * during autoprocessing will undo the newly created request.
     *
     * TODO: this method has the transaction attribute &quot;Not Required&quot;.  Change it to &quot;Required&quot;
     * and mark _createRequest and _autoProcess with &quot;RequiresNew&quot;.  This ensures database operations
     * by this method are bracketed by a transaction while _createRequest() and _autoProcess() run within
     * a nested transaction.
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#createRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
     */
    @Override
	public ID createRequest(RequestAggregate reqAgg, String comment)
    	throws BbmCreateException, RmHardValidationException,MultiUserException {

<span class="nc" id="L617">        String _method_ = &quot;createRequest&quot;;</span>
<span class="nc" id="L618">        methodStart(_method_, reqAgg, comment);</span>

<span class="nc" id="L620">        RequestAggregateDAO reqAggDao = null;</span>
<span class="nc" id="L621">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L622">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L624">	        cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L626">	        IRequestType reqMgr = getRequestManager();</span>
	        // creation logic is bracketed by its own transaction. So not included as part of this method.
<span class="nc" id="L628">	        ID createdReqID = reqMgr._createRequest(reqAgg, comment);</span>
<span class="nc" id="L629">	        long detailLevel = getDetailLevelForValidation();</span>
<span class="nc" id="L630">	        boolean reqStatusChanged = false;</span>
	        // autoprocessing done if state is pending (SS request can be created with 'pending' if picked up from SSPosting).
<span class="nc bnc" id="L632" title="All 2 branches missed.">	        if (reqAgg.isPending()) {</span>
		        // reload object to refresh objectVersionNumber (or column 'changeCounter' in DB used
		        // for optimistic locking to prevent multi-user updates).
<span class="nc" id="L635">		        RequestAggregate reqAggOld = reqAgg;</span>
<span class="nc" id="L636">		        reqAggDao = getDAO(detailLevel);</span>
<span class="nc" id="L637">		        reqAgg = reqAggDao.getRequestByID(createdReqID, detailLevel);</span>
<span class="nc" id="L638">		        setTOHoursPerDayForRequest(reqAggOld, reqAgg);</span>
		        // autoprocessing bracketed by its own transaction.
<span class="nc" id="L640">		        Pair pair = reqMgr._autoProcess(reqAgg, comment, true);</span>
<span class="nc bnc" id="L641" title="All 4 branches missed.">		        reqStatusChanged = (pair != null &amp;&amp; Boolean.getBoolean(pair.getFirst().toString()));</span>
	        }
<span class="nc bnc" id="L643" title="All 2 branches missed.">	        if (!reqStatusChanged) {</span>
<span class="nc" id="L644">		        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_PENDING, reqAgg);</span>
	        }
<span class="nc" id="L646">	        return createdReqID;</span>
<span class="nc" id="L647">        } catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L654">			handleException(Level.DEBUG, e, false);</span>
<span class="nc" id="L655">			throw e;</span>
<span class="nc" id="L656">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L657">			m_cat.error(e, e);</span>
<span class="nc" id="L658">			handleException(e, false);</span>
<span class="nc" id="L659">			throw e;</span>
<span class="nc" id="L660">        }catch (MultiUserException e) {</span>
<span class="nc" id="L661">			handleException(e);</span>
<span class="nc" id="L662">			throw e;</span>
<span class="nc" id="L663">    	} catch (Exception e) {</span>
<span class="nc" id="L664">            handleException(e, false);</span>
<span class="nc" id="L665">            throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L667" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L668">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L670" title="All 4 branches missed.">            if ( reqAggDao != null ) {</span>
<span class="nc" id="L671">				reqAggDao.cleanUp();</span>
			}
<span class="nc" id="L673">            methodFinish();</span>
        }
    }

	//This method just transfers the hoursperday from the old requests to the new request ;
	//this is done to avoid unnecessary calls to the TOHoursPerDay.
	public void setTOHoursPerDayForRequest(RequestAggregate reqAggOld, RequestAggregate reqAggNew) {
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if (reqAggOld.isTimeOffRequest()) {</span>
<span class="nc" id="L681">			HashMap toChoiceIDHourPerDayMap = ValueObjectUtil.getIDObjectMap(((TORequest) reqAggOld).getRequestChoiceList());</span>
<span class="nc" id="L682">			Collection tochoiceList = ((TORequest) reqAggNew).getRequestChoiceList();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">			for (Iterator iterator = tochoiceList.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L684">				TOChoice toChoice = (TOChoice) iterator.next();</span>
<span class="nc" id="L685">				toChoice.setHoursPerDay(((TOChoice) toChoiceIDHourPerDayMap.get(toChoice.getID())).getHoursPerDay());</span>
<span class="nc" id="L686">			}</span>
		}
<span class="nc" id="L688">	}</span>
    /**
     * Method is declared Public as it is part of the SSReqManager's remote interface (for declaration of
     * method's transaction attribute).  For SSReqManager, this method is declared with a transaction attribute
     * of Required
     *
     * See below method javadoc for the reason for 2 similar methods: changeRequesStateByID() and
     * _changeRequestStateByID().
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(com.bluepumpkin.common.datatypes.ID, java.lang.String, java.lang.String, java.lang.String)
     *
     * @param reqID
     * @param newState
     * @param objVerNum
     * @param comment
     * @throws
     * @throws RmHardValidationException
     */
    public void _changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment)
        throws  RmHardValidationException, RmException {
<span class="nc" id="L708">    	_changeRequestStateByID(reqID,newState,objectVersionNumber,comment,false);</span>
<span class="nc" id="L709">    }</span>
    /**
     *
     * See below method javadoc for the reason for 2 similar methods: changeRequesStateByID() and
     * _changeRequestStateByID().
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(com.bluepumpkin.common.datatypes.ID, java.lang.String, java.lang.String, java.lang.String)
     *
     * @param reqID
     * @param newState
     * @param objVerNum
     * @param comment
     * @param boolean skipSomeHardRulesWhenUpdate : for Time Off Requests only to serve new Group approval action for Time off bid requests
     * @throws
     * @throws RmHardValidationException
     */
    public void _changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment, boolean skipSomeHardRulesWhenUpdate)
            throws  RmHardValidationException, RmException
        {
<span class="nc" id="L728">            String _method_ = &quot;changeRequestStateByID&quot;;</span>
<span class="nc" id="L729">            methodStart(_method_, reqID, newState, objectVersionNumber, comment);</span>

<span class="nc" id="L731">            String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L732">            boolean cacheEnabled = false;</span>
            try {
<span class="nc" id="L734">                cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L736">                RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>
<span class="nc" id="L737">                String oldState = reqAgg.getRequestStatus();</span>

                // if a tentatively approved request is being withdrawn, then undo the schedule changes done for
                // tentative approval.  Note that this must be done before the request update below (as the update
                // changes the request's status and possibly other fields).
<span class="nc bnc" id="L742" title="All 2 branches missed.">                if (RequestAuditTrail.STATUS_TENTATIVE.equals(oldState) &amp;&amp;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">                    RequestAuditTrail.STATUS_WITHDRAWN.equals(newState)) {</span>
<span class="nc" id="L744">                    _undoSchedule(reqAgg, null, null);</span>
                }

<span class="nc" id="L747">                reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
                // The old code without skipSomeHardRulesWhenUpdate  _updateRequest(reqAgg, newState, comment, null, false, true);
<span class="nc" id="L749">               _updateRequest(reqAgg, newState, comment, null, false, false, true, skipSomeHardRulesWhenUpdate);</span>

                // refresh 'newState' since _updateRequest could have marked the status 'invalid'.
<span class="nc" id="L752">                newState = reqAgg.getRequestStatus();</span>

                // fire notifications only if there is a state change.
<span class="nc bnc" id="L755" title="All 2 branches missed.">                if (!oldState.equals(newState)) {</span>
<span class="nc" id="L756">                    fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_PENDING, reqAgg);</span>

<span class="nc" id="L758">                    fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_ESCALATED, reqAgg);</span>
                }
<span class="nc" id="L760">    		} catch (RmHardValidationException e) {</span>
    			//RM exceptions are always logged at the point where they are thrown.

                // Logged with priority 'debug' since this exception is generated by RM during validations or
                // workflow processing and happens often during normal operation.  If logged with a different
                // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L766">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L767">    			throw e;</span>
<span class="nc" id="L768">    		} catch (RmException e) {</span>
<span class="nc" id="L769">    			m_cat.error(e, e);</span>
<span class="nc" id="L770">    			handleException(e);</span>
<span class="nc" id="L771">    			throw e;</span>
<span class="nc" id="L772">            } catch (Exception e) {</span>
<span class="nc" id="L773">                handleException(e);</span>
<span class="nc" id="L774">                throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
            } finally {
<span class="nc bnc" id="L776" title="All 4 branches missed.">                if (cacheEnabled) {</span>
<span class="nc" id="L777">    				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
    			}
<span class="nc" id="L779">                methodFinish();</span>
<span class="nc" id="L780">            }</span>
<span class="nc" id="L781">        }</span>

    /**
	 * Note:
	 * This method is overridden by SSReqMgr. sSReqMgr does not call this
	 * overridden method. This is unlike the usual implementation where the overriding method
	 * calls the overridden method.
	 * Since 15.1.0_120, this method is also overriden by TORequestManager
	 * See below method javadoc for the reason for 2 similar methods: changeRequesStateByID() and
	 * _changeRequestStateByID().
	 *
	 * @throws Exception
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(com.bluepumpkin.common.datatypes.ID,
	 *      java.lang.String, java.lang.String, java.lang.String)
	 */
	@Override
	public void changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment)
			throws Exception {
		// SSReqMgr.changeRequestByID() also needs to be modified if additional code is added to this method body.
<span class="nc" id="L801">		checkChangeRequestStatePrivilege(reqID, newState);</span>
<span class="nc" id="L802">		_changeRequestStateByID(reqID, newState, objectVersionNumber, comment);</span>
<span class="nc" id="L803">	}</span>

    /**
     * Preprocess request before request is updated.  Return value is the updated request (***** could be the same as request passed ******) with the updated fields
     * validated or assigned defaults.
     *
     * @param reqAgg
     */
    protected abstract RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg,
        RequestAggregateDAO reqAggDAO, boolean loadedFromDB) throws Exception;

    /**
     * Postprocess request after request is updated.
     * should be implementd to preform any tasks that need to be done after updating the request.
     * @param reqAgg
     */
    protected void updateRequestPostProcess(RequestAggregate reqAgg,
                                            RequestAggregateDAO reqAggDAO, boolean loadedFromDB, String origState) throws Exception {
<span class="nc" id="L821">    }</span>

	protected void createRequestPostProcess(RequestAggregate reqAgg,
	                                        RequestAggregateDAO reqAggDAO) throws Exception {

<span class="nc" id="L826">	}</span>
    /**
     * Note: request will not be marked invalid if hardValidation fails.  See
     * {@link #doHardValidations(RequestAggregate, int, String, boolean) doHardValidations} for further
     * information.
     *
     * @param reqAgg
     * @param newState
     * @param comment
     * @param methodSubType see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _updateRequest(RequestAggregate reqAgg, String newState, String comment,
        String methodSubType, boolean suppressHardValidation, boolean suppressPrivilegeChecking,
        boolean loadedFromDB) throws Exception {
<span class="nc" id="L844">    	_updateRequest(reqAgg,newState,comment,methodSubType,suppressHardValidation,suppressPrivilegeChecking,loadedFromDB,false);</span>
<span class="nc" id="L845">    }</span>
    /**
     * Note: request will not be marked invalid if hardValidation fails.  See
     * {@link #doHardValidations(RequestAggregate, int, String, boolean) doHardValidations} for further
     * information.
     *
     * @param reqAgg
     * @param newState
     * @param comment
     * @param methodSubType see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @param skipSomeHardRulesWhenUpdate - To support for approve any choice of TO request. 1 TO Request can have multi-choices.
     * If one of them is invalid , it should not marked as invalid=&gt; the hard validation rule should not run in this case
     * Instead of that, some rules will be replaced by similar soft validation rules
     * @throws Exception
     */
    protected void _updateRequest(RequestAggregate reqAgg, String newState, String comment,
            String methodSubType, boolean suppressHardValidation, boolean suppressPrivilegeChecking,
            boolean loadedFromDB,boolean skipSomeHardRulesWhenUpdate) throws Exception {

<span class="nc" id="L867">            String methodName = &quot;_updateRequest&quot;;</span>
<span class="nc" id="L868">            m_cat.debug(RmUtil.dumpEnterMethod(methodName, new Object[] { reqAgg, newState, comment,</span>
                new Boolean(suppressHardValidation), new Boolean(suppressPrivilegeChecking)} ));
<span class="nc" id="L870">            RequestAggregateDAO reqAggDAO = null;</span>
            try  {
<span class="nc" id="L872">    	        String origState= reqAgg.getRequestStatus();</span>
<span class="nc" id="L873">                reqAggDAO = getDAO(getDetailLevelForValidation());</span>
<span class="nc" id="L874">                reqAgg = updateRequestPreProcess(reqAgg, reqAggDAO, loadedFromDB);</span>

                //webtier calls updateRequest() passing a shiftBidRequest with only the updateable
                //fields set to the proper value.  In this case, the parameter 'newState' will be &quot;&quot;.
<span class="nc bnc" id="L878" title="All 2 branches missed.">    	        if (StringUtil.isEmpty(newState)) {</span>
<span class="nc" id="L879">    				newState = reqAgg.getRequestStatus();</span>
    			}

<span class="nc" id="L882">                checkStateTransitionAndUpdatePrivilege(reqAgg, newState, suppressPrivilegeChecking);</span>

                // do hard validations
<span class="nc bnc" id="L885" title="All 2 branches missed.">                if (!suppressHardValidation) {</span>
<span class="nc" id="L886">                    doHardValidationsRaiseException(reqAgg, RequestUtil.METHODTYPE_MODIFIER, methodSubType, false, skipSomeHardRulesWhenUpdate, newState);</span>
                }

<span class="nc" id="L889">                reqAgg.setRequestStatus(newState);</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                reqAggDAO.updateRequest(reqAgg, (comment == null)?&quot;&quot;:comment,</span>
<span class="nc" id="L891">                	RequestUtil.getLoginUserBasic(m_sessionContext));</span>
<span class="nc" id="L892">                updateRequestPostProcess(reqAgg, reqAggDAO, loadedFromDB,origState);</span>
<span class="nc" id="L893">                m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
            } finally   {
<span class="nc bnc" id="L895" title="All 4 branches missed.">                if (reqAggDAO != null) {</span>
<span class="nc" id="L896">    				reqAggDAO.cleanUp();</span>
    			}
            }
<span class="nc" id="L899">    }</span>
    protected void _updateRequest(RequestAggregate reqAgg, String newState, String comment,
        String methodSubType, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="nc" id="L903">        _updateRequest(reqAgg, newState, comment, methodSubType,</span>
            false, suppressPrivilegeChecking, loadedFromDB);
<span class="nc" id="L905">    }</span>

	@Override
	public      void updateRequest(RequestAggregate reqAgg, String comment)
        throws BbmUpdateException, MultiUserException, RmHardValidationException {
<span class="nc" id="L910">          updateRequest( reqAgg,  comment,false);</span>
<span class="nc" id="L911">	}</span>
    /**
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#updateRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
     */
    @Override
	public void updateRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeCheck)
        throws BbmUpdateException, MultiUserException, RmHardValidationException {

        //RmUtil.dumpCollection(tor.getRequestChoiceList())
        //RmUtil.dumpCollection(ssr.getShiftSwapItems())
<span class="nc" id="L921">    	String _method_ = &quot;updateRequest&quot;;</span>
<span class="nc" id="L922">        methodStart(_method_, reqAgg, comment);</span>

<span class="nc" id="L924">        long detailLevelForVal = getDetailLevelForValidation();</span>
<span class="nc" id="L925">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L926">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L927">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L929">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L930">            IRequestType reqMgr = getRequestManager();</span>

            //fetch request from DB to obtain old status
<span class="nc bnc" id="L933" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(detailLevelForVal):reqAggDAO;</span>
<span class="nc" id="L934">            RequestAggregate oldReqAgg = reqAggDAO.getRequestByID(reqAgg.getID(), RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L935">            String oldStatus = oldReqAgg.getRequestStatus();</span>

            // tentatively approved requests cannot be edited.
<span class="nc" id="L938">            String newStatus = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L939" title="All 4 branches missed.">            if (oldStatus.equals(newStatus) &amp;&amp; RequestAuditTrail.STATUS_TENTATIVE.equals(oldStatus)) {</span>
<span class="nc" id="L940">                throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.REQ_CANNOT_EDIT_TENTATIVE_REQ , m_cat);</span>
            }

            // if a tentatively approved request is being withdrawn, then undo the schedule changes done for
            // tentative approval.  Note that this must be done before the request update below (as the update
            // changes the request's status and possibly other fields).
<span class="nc bnc" id="L946" title="All 2 branches missed.">            if (RequestAuditTrail.STATUS_TENTATIVE.equals(oldStatus) &amp;&amp;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                RequestAuditTrail.STATUS_WITHDRAWN.equals(newStatus)) {</span>
<span class="nc" id="L948">                _undoSchedule(reqAgg, null, null);</span>
            }

            // cannot pass 'oldReqAgg' and set the 'loadedFromDB' parameter to 'true'
            // in the following call since 'oldReqAgg' does not have the updates done to 'reqAgg'.
<span class="nc" id="L953">            _updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, suppressPrivilegeCheck, false);</span>

            // fire notifications only if request status has changed.
<span class="nc bnc" id="L956" title="All 2 branches missed.">            if (!oldStatus.equals(newStatus)) {</span>
<span class="nc" id="L957">                fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_PENDING, reqAgg);</span>

<span class="nc" id="L959">                fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_ESCALATED, reqAgg);</span>
            }

            // do autoprocessing if necessary.
<span class="nc bnc" id="L963" title="All 4 branches missed.">            if (reqAgg.isPending()||reqAgg.isWaitlisted()) {</span>
                // reload object to refresh objectVersionNumber (or column 'changeCounter' in DB used
                // for optimistic locking to prevent multi-user updates).
<span class="nc" id="L966">	            RequestAggregate reqAggOld =reqAgg;</span>

<span class="nc bnc" id="L968" title="All 2 branches missed.">	            reqAggDAO = (reqAggDAO == null) ? getDAO(detailLevelForVal) : reqAggDAO;</span>
<span class="nc" id="L969">	            reqAgg = reqAggDAO.getRequestByID(reqAgg.getID(), detailLevelForVal);</span>
<span class="nc" id="L970">	             setTOHoursPerDayForRequest( reqAggOld,  reqAgg);</span>
                //TODO: autoprocessing bracketed by its own transaction.
<span class="nc" id="L972">	             reqMgr._autoProcess(reqAgg, comment, true);</span>
            }
<span class="nc" id="L974">		} catch (BbmObjectNotFoundException e) {</span>
			// Show more specific error message if exception happens because the request has just become expired
<span class="nc" id="L976">			RequestAggregate req = getRequest(reqAgg.getID());</span>
<span class="nc" id="L977">			handleException(e);</span>
<span class="nc bnc" id="L978" title="All 4 branches missed.">			if (req != null &amp;&amp; req.hasExpired()) {</span>
<span class="nc" id="L979">				throw new BbmUpdateException(e, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.FLEX_REQ_ALREADY_EXPIRED, null);</span>
			} else {
<span class="nc" id="L981">				throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
			}
<span class="nc" id="L983">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L990">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L991">			throw e;</span>
<span class="nc" id="L992">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L993">			m_cat.error(e, e);</span>
<span class="nc" id="L994">			handleException(e);</span>
<span class="nc" id="L995">			throw e;</span>
<span class="nc" id="L996">		} catch (MultiUserException e) {</span>
<span class="nc" id="L997">			handleException(e);</span>
<span class="nc" id="L998">			throw e;</span>
<span class="nc" id="L999">    	} catch (Exception e) {</span>
<span class="nc" id="L1000">    		handleException(e);</span>
<span class="nc" id="L1001">    		throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
    	} finally {
<span class="nc bnc" id="L1003" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1004">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1006" title="All 4 branches missed.">            if (reqAggDAO != null) {</span>
<span class="nc" id="L1007">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1009">            methodFinish();</span>
<span class="nc" id="L1010">    	}</span>
<span class="nc" id="L1011">    }</span>


	private RequestAggregate getRequest(ID id) {
		try {
<span class="nc" id="L1016">			return _getRequestByID(id, true, false, false, getDetailLevelForValidation());</span>
<span class="nc" id="L1017">		} catch (Exception e) {</span>
			// ignore it
		}
<span class="nc" id="L1020">		return null;</span>
	}

	public static final RmHardValidationException createAndLogHardValForUnathToPurge(String userName, ID privFailedOrgID, Category cat) {
<span class="nc" id="L1024">		return RequestUtil.createAndLogRmHardValidationException(</span>
				RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_TO_PURGE,
				RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_TO_PURGE,
				new Object[]{userName, privFailedOrgID},
				cat);
	}

    // deletes a Request
    @Override
	public void deleteRequest(ID requestId, String comment) throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1034">        String _method_ = &quot;deleteRequest&quot;;</span>
<span class="nc" id="L1035">        methodStart(_method_, requestId, comment);</span>

        // Validate that requestor has purge privilege
<span class="nc" id="L1038">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1039">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1040">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1042">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>


<span class="nc" id="L1045">			reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L1046">			Collection orgIDs = getCurrentOrgIDsForReqID(requestId, reqAggDAO);</span>


<span class="nc bnc" id="L1049" title="All 2 branches missed.">			if (!canDeleteRequest(orgIDs)) {</span>
<span class="nc" id="L1050">				return;</span>
			}

<span class="nc" id="L1053">            reqAggDAO.deleteRequest(requestId);</span>
<span class="nc" id="L1054">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			// Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1059">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1060">			throw e;</span>
<span class="nc" id="L1061">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1062">			m_cat.error(e, e);</span>
<span class="nc" id="L1063">			handleException(e);</span>
<span class="nc" id="L1064">			throw e;</span>
<span class="nc" id="L1065">        } catch (Exception e) {</span>
<span class="nc" id="L1066">            handleException(e);</span>
<span class="nc" id="L1067">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1069" title="All 6 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1070">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1072" title="All 6 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1073">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1075">            methodFinish();</span>
<span class="nc" id="L1076">        }</span>
<span class="nc" id="L1077">    }</span>

	protected boolean canDeleteRequest(ID organizationId) throws Exception {
<span class="nc" id="L1080">		return canDeleteRequest(Collections.singletonList(organizationId));</span>
    }

	private boolean canDeleteRequest(Collection&lt;ID&gt; organizationIDs) throws Exception {
<span class="nc" id="L1084">		ID privilegeId = getPrivIDPurge();</span>
<span class="nc bnc" id="L1085" title="All 4 branches missed.">		if (PrivilegeKeys.FT_PURGEREQUESTS_ID.equals(privilegeId) &amp;&amp; !LicenseUtil.isAdvancedRMLicense()) {</span>
			//ideally FlexTimeRequestManagerEJB should not even be available if  advanced RM license is off,
			//but existing code assume it is there in all cases. The second best option would be to have a do nothing interface,
			//but it is too late in the cycle to get these fixed correctly.
<span class="nc" id="L1089">			return false;</span>
		}
<span class="nc" id="L1091">		String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L1093">		ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, organizationIDs, privilegeId);</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">		if (privFailedOrgID != null) {</span>
<span class="nc" id="L1095">			throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
		}

<span class="nc" id="L1098">		return true;</span>
	}

    // deletes a Collection of Requests
	@SuppressWarnings(&quot;unchecked&quot;)
	@Override
	public void deleteRequests(Collection reqIDs, String comment) throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1105">        String _method_ = &quot;deleteRequests&quot;;</span>
<span class="nc" id="L1106">        methodStart(_method_, reqIDs, comment);</span>

<span class="nc" id="L1108">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1109">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1110">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1112">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1114">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>

            // Get the set of organizations involved in the delete
<span class="nc" id="L1117">			Set&lt;ID&gt; orgIDSet = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">			for (ID reqId : (Collection&lt;ID&gt;) reqIDs) {</span>
<span class="nc" id="L1119">				orgIDSet.addAll(getCurrentOrgIDsForReqID(reqId, reqAggDAO));</span>
<span class="nc" id="L1120">            }</span>

<span class="nc bnc" id="L1122" title="All 2 branches missed.">			if (!canDeleteRequest(orgIDSet)) {</span>
<span class="nc" id="L1123">				return;</span>
			}

<span class="nc" id="L1126">            reqAggDAO.deleteRequests(reqIDs);</span>
<span class="nc" id="L1127">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1134">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1135">			throw e;</span>
<span class="nc" id="L1136">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1137">			m_cat.error(e, e);</span>
<span class="nc" id="L1138">			handleException(e);</span>
<span class="nc" id="L1139">			throw e;</span>
<span class="nc" id="L1140">        } catch (Exception e) {</span>
<span class="nc" id="L1141">            handleException(e);</span>
<span class="nc" id="L1142">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1144" title="All 6 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1145">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1147" title="All 6 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1148">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1150">            methodFinish();</span>
<span class="nc" id="L1151">        }</span>
<span class="nc" id="L1152">    }</span>

    /**
     * see {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManagerEJB#deleteRequestsByType(ID, boolean, String, ID) deleteRequestsByType}
     *
     * Delete all the requests of the given subtype.
     *
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public void deleteRequests(ID organizationId, boolean isForBranch, ID subType) throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1175">        String _method_ = &quot;deleteRequests&quot;;</span>
<span class="nc" id="L1176">        methodStart(_method_, organizationId, new Boolean(isForBranch), subType);</span>

        // Validate that requestor has purge privilege
<span class="nc" id="L1179">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1180">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1181">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1183">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1185" title="All 2 branches missed.">			if (!canDeleteRequest(organizationId)) {</span>
<span class="nc" id="L1186">				return;</span>
			}

<span class="nc" id="L1189">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L1190">            reqAggDAO.deleteRequests(organizationId, isForBranch, getRequestType(), subType);</span>
<span class="nc" id="L1191">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1198">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1199">			throw e;</span>
<span class="nc" id="L1200">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1201">			m_cat.error(e, e);</span>
<span class="nc" id="L1202">			handleException(e);</span>
<span class="nc" id="L1203">			throw e;</span>
<span class="nc" id="L1204">        } catch (Exception e) {</span>
<span class="nc" id="L1205">            handleException(e);</span>
<span class="nc" id="L1206">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1208" title="All 6 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1209">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1211" title="All 6 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1212">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1214">            methodFinish();</span>
<span class="nc" id="L1215">        }</span>
<span class="nc" id="L1216">    }</span>

    /**
     * see {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManagerEJB#deleteRequestsByDate(ID, boolean, Date, String, ID) deleteRequestsByDate}
     *
     * Delete all the requests of the given subtype that concern dates that
     * are older than the given date.
     *
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param date purge the requests that concern dates older than this date
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public void deleteRequestsByDate(ID organizationId, boolean isForBranch, Date date, ID subType)
        throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1243">        String _method_ = &quot;deleteRequestsByDate&quot;;</span>
<span class="nc" id="L1244">        methodStart(_method_, organizationId, new Boolean(isForBranch), date, subType);</span>

<span class="nc" id="L1246">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1247">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1248">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1250">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1252" title="All 2 branches missed.">			if (!canDeleteRequest(organizationId)) {</span>
<span class="nc" id="L1253">				return;</span>
			}

<span class="nc" id="L1256">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L1257">            reqAggDAO.deleteRequestsByDate(organizationId, isForBranch, date, getRequestType(), subType);</span>
<span class="nc" id="L1258">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1265">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1266">			throw e;</span>
<span class="nc" id="L1267">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1268">			m_cat.error(e, e);</span>
<span class="nc" id="L1269">			handleException(e);</span>
<span class="nc" id="L1270">			throw e;</span>
<span class="nc" id="L1271">        } catch (Exception e) {</span>
<span class="nc" id="L1272">            handleException(e);</span>
<span class="nc" id="L1273">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1275" title="All 6 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1276">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1278" title="All 6 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1279">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1281">            methodFinish();</span>
<span class="nc" id="L1282">        }</span>
<span class="nc" id="L1283">    }</span>

    /**
     * see {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManagerEJB#deleteRequestsByDateRange(ID, boolean, TimeRange, String, ID) deleteRequestsByDateRange}
     *
     * Delete all the requests of the given subtype that were created in the
     * given date range.
     *
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param range the range to use when purging requests.  All subject requests that were
     * created within this time range will be purged.
     *
     * @param requestType the type of request to purge.  This can be all or a specific
     * type like time off or shift swap.  The constants to use for this parameter are defined
     * in the {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public void deleteRequestsByDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
            throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1315">        String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L1316">        methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L1318">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1319">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1320">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1322">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1324" title="All 2 branches missed.">			if (!canDeleteRequest(organizationId)) {</span>
<span class="nc" id="L1325">				return;</span>
			}

<span class="nc" id="L1328">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L1329">            reqAggDAO.deleteRequestsByDateRange(organizationId, isForBranch, range, getRequestType(), subType);</span>
<span class="nc" id="L1330">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1336">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1337">			throw e;</span>
<span class="nc" id="L1338">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1339">			m_cat.error(e, e);</span>
<span class="nc" id="L1340">			handleException(e);</span>
<span class="nc" id="L1341">			throw e;</span>
<span class="nc" id="L1342">        } catch (Exception e) {</span>
<span class="nc" id="L1343">            handleException(e);</span>
<span class="nc" id="L1344">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1346" title="All 6 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1347">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1349" title="All 6 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1350">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1352">            methodFinish();</span>
<span class="nc" id="L1353">        }</span>
<span class="nc" id="L1354">    }</span>

    /**
     * Delete all the requests of the given subtype that were start within the
     * given date range.
     * to be implemented by respective request managers
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param range the range to use when purging requests.  All subject requests that were
     * created within this time range will be purged.
     *
     * @param requestType the type of request to purge.  This can be all or a specific
     * type like time off or shift swap.  The constants to use for this parameter are defined
     * in the {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public abstract void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
            throws BbmRemoveException, RmHardValidationException;

    /**
     * @param reqAgg
     * @param toChoiceID
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected boolean  _waitlistRequest(RequestAggregate reqAgg, ID toChoiceID, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L1394">        return false;</span>
	}

    /**
     * @param reqAgg
     * @param apprChoiceID only applies for TORequest.  If 'null', then the first TOChoice is approved.
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
	protected abstract void _approveRequest(RequestAggregate reqAgg, Collection&lt;ID&gt; apprChoiceID,
        String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception;
	/**
     * Overridden by TORequestManagerEJB.
     * @param reqAgg
     * @param apprChoiceID only applies for TORequest. It serves for new Group Action: Approve Time Off Choice without violations
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
	protected void _approveRequestChoice(RequestAggregate reqAgg, Collection&lt;ID&gt; apprChoiceID,
        String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="nc" id="L1419">    }</span>

	@Override
	public void approveRequestByID(ID reqID, ID choiceID, String objectVersionNumber, String comment)
			throws RmHardValidationException, RmException, MultiUserException {

<span class="nc" id="L1425">		approveRequestByIDWithChoiceIDs(reqID, Collections.singleton(choiceID), objectVersionNumber, comment);</span>

<span class="nc" id="L1427">	}</span>

    /**
     * approves the request specified by its ID.  For Shiftswap request, approves
     * the shift swap and swaps the shifts.  For TORequest the first TOChoice is approved
     * and the schedule is updated.  If any hard validations fail, then request not approved
     * and is marked invalid.
     *
     * @param reqID ID of the request to be approved
     * @param reqItemIndex the TOChoice to be approved (only for TORequests)
     * @throws
     */
    @Override
	public void approveRequestByIDWithChoiceIDs(ID reqID, Collection&lt;ID&gt; choiceIDs, String objectVersionNumber, String comment)
            throws RmHardValidationException, RmException, MultiUserException {
<span class="nc" id="L1442">	    String _method_ = &quot;approveRequestByID&quot;;</span>
<span class="nc" id="L1443">		methodStart(_method_, reqID, choiceIDs, objectVersionNumber, comment);</span>

<span class="nc" id="L1445">	    String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1446">	    boolean cacheEnabled = false;</span>
	    try {
<span class="nc" id="L1448">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
		    // get the timeoff request for the given ID

<span class="nc" id="L1451">		    RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation(),true);</span>

		    // set the object version number if necessary
<span class="nc bnc" id="L1454" title="All 2 branches missed.">		    if (objectVersionNumber != null) {</span>
<span class="nc" id="L1455">				reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
			}

<span class="nc" id="L1458">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L1459">			secMgr.assertAllowedAction(getUser(), reqAgg, RequestAction.APPROVE, RequestAuditTrail.STATUS_APPROVED);</span>

<span class="nc" id="L1461">			_approveRequestWorkFlow(reqAgg, choiceIDs, comment, false, true);</span>
<span class="nc" id="L1462">	    } catch (MultiUserException exM) {</span>
<span class="nc" id="L1463">			handleException(Level.DEBUG, exM);</span>
<span class="nc" id="L1464">		    throw exM;</span>
<span class="nc" id="L1465">	    } catch (RmHardValidationException e) {</span>
		    //RM exceptions are always logged at the point where they are thrown.

		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1471">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1472">		    throw e;</span>
<span class="nc" id="L1473">	    } catch (RmException e) {</span>
<span class="nc" id="L1474">		    m_cat.error(e, e);</span>
<span class="nc" id="L1475">		    handleException(e);</span>
<span class="nc" id="L1476">		    throw e;</span>
<span class="nc" id="L1477">	    } catch (BbmCreateException e) {</span>
<span class="nc" id="L1478">		    handleException(e);</span>
		    //QC 194895: Show the meaningful message instead of DEFAULT if an exception of InvalidObjectException thrown
		    //when creating a shift assignment
		    //TODO: do similar for other cases of InvalidObjectException
<span class="nc bnc" id="L1482" title="All 2 branches missed.">		    if(e.getCause() instanceof java.io.InvalidObjectException</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">		    		&amp;&amp; e.getCause().getLocalizedMessage().equals(ShiftEventAssignment.SHIFTEVENT_MUST_FALL_WITHIN_PARENT_SHIFT_ASSIGNMENT)){</span>
<span class="nc" id="L1484">		        throw new RmHardValidationException(</span>
						RmEjbBundleKey.BUNDLE_NAME,
						RmEjbBundleKey.CANNOT_APPROVE_CS_SHIFT_EVENT_NOT_FALL_WITHIN_SHIFT_ASSIGNMENT,
						null);
		    } else {
<span class="nc" id="L1489">		    	 throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		    }
	    }

<span class="nc" id="L1493">	    catch (Exception e) {</span>
<span class="nc" id="L1494">		    handleException(e);</span>
<span class="nc" id="L1495">		    throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="nc bnc" id="L1497" title="All 4 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L1498">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1500">		    methodFinish();</span>
<span class="nc" id="L1501">	    }</span>
<span class="nc" id="L1502">    }</span>

    /**
     * approves the given request.  For Shiftswap request, approves
     * the shift swap and swaps the shifts.  For TORequest the first TOChoice is approved
     * and the schedule is updated.  If any hard validations fail, then the request
     * is not approved and is marked invalid.
     *
     * TODO: verify that this method is not called by code in the bean class.  must call _approveRequest instead.
     *
     * @param reqAgg the request to be approved
     * @param reqItemIndex the TOChoice to be approved (only for TORequests)
     * @return To check if any hard vaidations failed, check validation results in the request.
     * @throws
     */
    @Override
	public void approveRequest(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment)
        throws    RmHardValidationException, RmException {
<span class="nc" id="L1520">        String _method_ = &quot;approveRequest&quot;;</span>
<span class="nc" id="L1521">		methodStart(_method_, reqAgg, choiceIDs, comment);</span>

<span class="nc" id="L1523">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1524">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1526">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1528">			_approveRequestWorkFlow(reqAgg, choiceIDs, comment, false, false);</span>
<span class="nc" id="L1529">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1536">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1537">			throw e;</span>
<span class="nc" id="L1538">		} catch (RmException e) {</span>
<span class="nc" id="L1539">			m_cat.error(e, e);</span>
<span class="nc" id="L1540">			handleException(e);</span>
<span class="nc" id="L1541">			throw e;</span>
<span class="nc" id="L1542">        } catch (Exception e) {</span>
<span class="nc" id="L1543">            handleException(e);</span>
<span class="nc" id="L1544">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1546" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1547">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1549">            methodFinish();</span>
<span class="nc" id="L1550">        }</span>
<span class="nc" id="L1551">    }</span>

    /**
     * Overridden by TORequestManagerEJB.
     *
     * @param reqAgg
     * @param choiceID Applies only to TOReqs.  See {@link com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManagerEJB#_approveRequest(RequestAggregate, ID, String, boolean, boolean) _approveRequest()}
     * for further information.
     *
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
	protected void _approveRequestWorkFlow(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="nc" id="L1568">		_approveRequest(reqAgg, choiceIDs, comment, suppressPrivilegeChecking, loadedFromDB);</span>

<span class="nc" id="L1570">        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_APPROVED, reqAgg);</span>

<span class="nc" id="L1572">		_approveRequestPostProcess(reqAgg, choiceIDs, comment);</span>
<span class="nc" id="L1573">    }</span>


	/**
	 *
	 * @param reqAgg
	 * for further information.
	 *
	 * @param toChoiceID
     * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	protected boolean _waitlistRequestWorkFlow(RequestAggregate reqAgg, ID toChoiceID, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L1588">		boolean result = _waitlistRequest(reqAgg, toChoiceID, comment, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">		if (result) {</span>
<span class="nc" id="L1590">			fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_WAITLIST, reqAgg);</span>
<span class="nc" id="L1591">			_waitlistRequestPostProcess(reqAgg, comment);</span>
		}
<span class="nc" id="L1593">		return result;</span>
	}

	/**
	 * overridden by TORequestManagerEJB only, returns false for all other types of Requests
	 *
	 * @param reqAgg  for further information.
	 */
	public boolean areWaitlistPreferencesSetForRequest(RequestAggregate reqAgg) throws BbmException{
<span class="nc" id="L1602">		return false;</span>
	}
	/**
	 * overridden by TORequestManagerEJB only, returns false for all other types of Requests
	 *
	 */
    public  boolean canRequestBeWaitlistedBasedOnValidations(int[] apprDenyResult1, Collection[] apprDenyValResults1)throws BbmException{
<span class="nc" id="L1609">        return false;</span>
    }
	/**
	 * overridden by TORequestManagerEJB only, returns false for all other types of Requests
	 *
	 * @param reqAgg  for further information.
	 */
	public boolean ignoreAmbiguousAutoProcessResults(RequestAggregate reqAgg) {
<span class="nc" id="L1617">		return false;</span>
	}
	/**
	 * overridden by TORequestManagerEJB only.
	 *
	 * @param reqAgg
	 * for further information.
	 * @param comment
	 */
	protected  void _waitlistRequestPostProcess(RequestAggregate reqAgg, String comment){

<span class="nc" id="L1628">	}</span>

	protected abstract void _approveRequestPostProcess(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment);

    /**
     * @param reqAgg
     * @param choiceID only applies for TORequests.  If 'null', then the first TOChoice is approved.
     * @param comment
     */
	protected abstract void _approveRequestTentatively(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceID, String comment,
        boolean loadedFromDB) throws Exception;


	@Override
	public void approveRequestTentativelyByID(ID reqID, ID choiceID, String objectVersionNumber, String comment)
			throws RmException, RmHardValidationException, RmException, MultiUserException {

<span class="nc" id="L1645">		approveRequestTentativelyByIDWithChoiceIDs(reqID, Collections.singleton(choiceID), objectVersionNumber, comment);</span>

<span class="nc" id="L1647">	}</span>

    /**
     * @see IRequestType#approveRequestTentativelyByID
     *
     * @param reqID - ID of the time off request.
     * @param choiceID - Choice id for teh time off request.
     * @param objectVersionNumber - object version number of request on which status change is based.
     * @param pComments - comments for time off request.
     * @throws - BbmUpdateException.
     */
    @Override
	public void approveRequestTentativelyByIDWithChoiceIDs(ID reqID, Collection&lt;ID&gt; choiceID, String objectVersionNumber, String comment)
            throws RmHardValidationException, RmException, MultiUserException {
<span class="nc" id="L1661">	    String _method_ = &quot;approveRequestTentativelyByID&quot;;</span>
<span class="nc" id="L1662">	    methodStart(_method_, reqID, choiceID, objectVersionNumber, comment);</span>

<span class="nc" id="L1664">	    String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1665">	    boolean cacheEnabled = false;</span>
	    try {
<span class="nc" id="L1667">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
		    //obtain the Request object
<span class="nc" id="L1669">		    RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation(),true);</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">		    if (objectVersionNumber != null) {</span>
<span class="nc" id="L1671">				reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
			}

<span class="nc" id="L1674">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L1675">			secMgr.assertAllowedAction(getUser(), reqAgg, RequestAction.TENTATIVELYAPPROVE, RequestAuditTrail.STATUS_TENTATIVE);</span>

<span class="nc" id="L1677">		    _approveRequestTentatively(reqAgg, choiceID, comment, true);</span>
		    // Notifications not supported for tentative approval
<span class="nc" id="L1679">	    } catch (MultiUserException exM) {</span>
<span class="nc" id="L1680">			handleException(Level.DEBUG, exM);</span>
<span class="nc" id="L1681">		    throw exM;</span>
<span class="nc" id="L1682">	    } catch (RmHardValidationException e) {</span>
		    //RM exceptions are always logged at the point where they are thrown.
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1687">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1688">		    throw e;</span>
<span class="nc" id="L1689">	    } catch (RmException e) {</span>
<span class="nc" id="L1690">		    m_cat.error(e, e);</span>
<span class="nc" id="L1691">		    handleException(e);</span>
<span class="nc" id="L1692">		    throw e;</span>
<span class="nc" id="L1693">	    } catch (Exception e) {</span>
<span class="nc" id="L1694">		    handleException(e);</span>
<span class="nc" id="L1695">		    throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="nc bnc" id="L1697" title="All 4 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L1698">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1700">		    methodFinish();</span>
<span class="nc" id="L1701">	    }</span>
<span class="nc" id="L1702">    }</span>

     protected abstract void _denyRequest(RequestAggregate reqAgg, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception;


    /**
     * @see IRequestType#denyRequestByID denyRequestByID
     *
     * @param reqID
     * @param objectVersionNumber
     * @param comment
     * @throws
     * @throws RmHardValidationException
     */
    @Override
	public void denyRequestByID(ID reqID, String objectVersionNumber, String comment)
			throws RmHardValidationException, RmException {
<span class="nc" id="L1720">        String _method_ = &quot;denyRequestByID&quot;;</span>
<span class="nc" id="L1721">        methodStart(_method_, reqID, objectVersionNumber, comment);</span>

<span class="nc" id="L1723">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1724">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1726">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            // get the timeoff request for the given ID
<span class="nc" id="L1729">            RequestAggregate toReq = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>

            // set the object version number if necessary
<span class="nc bnc" id="L1732" title="All 2 branches missed.">            if ( objectVersionNumber != null ) {</span>
<span class="nc" id="L1733">				toReq.setObjectVersionNumber(objectVersionNumber);</span>
			}

<span class="nc" id="L1736">			RmSecurityManager secMgr = RmSecurityManager.create(toReq);</span>
<span class="nc" id="L1737">			secMgr.assertAllowedAction(getUser(), toReq, RequestAction.DENY, RequestAuditTrail.STATUS_DENIED);</span>

<span class="nc" id="L1739">            _denyRequestWorkflow(toReq, comment, false, true);</span>
<span class="nc" id="L1740">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1745">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1746">			throw e;</span>
<span class="nc" id="L1747">		} catch (RmException e) {</span>
<span class="nc" id="L1748">			m_cat.error(e, e);</span>
<span class="nc" id="L1749">			handleException(e);</span>
<span class="nc" id="L1750">			throw e;</span>
<span class="nc" id="L1751">        } catch (Exception e) {</span>
<span class="nc" id="L1752">            handleException(e);</span>
<span class="nc" id="L1753">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1755" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1756">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1758">            methodFinish();</span>
<span class="nc" id="L1759">        }</span>
<span class="nc" id="L1760">    }</span>

    /**
     * Denies the given request.  If any hard validations fail, then
     * request is marked invalid.
     *
     * @param reqAgg the request to be approved
     * @return To check if any hard vaidations failed, check validation results in the request.
     * @throws
     */
    @Override
	public void denyRequest(RequestAggregate reqAgg, String comment)
        throws  RmHardValidationException, RmException
    {
<span class="nc" id="L1774">        String _method_ = &quot;denyRequest&quot;;</span>
<span class="nc" id="L1775">        methodStart(_method_, reqAgg, comment);</span>

<span class="nc" id="L1777">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1778">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1780">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1782">            _denyRequestWorkflow(reqAgg, comment, false, false);</span>
<span class="nc" id="L1783">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1788">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1789">			throw e;</span>
<span class="nc" id="L1790">		} catch (RmException e) {</span>
<span class="nc" id="L1791">			m_cat.error(e, e);</span>
<span class="nc" id="L1792">			handleException(e);</span>
<span class="nc" id="L1793">			throw e;</span>
<span class="nc" id="L1794">        } catch (Exception e) {</span>
<span class="nc" id="L1795">            handleException(e);</span>
<span class="nc" id="L1796">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1798" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1799">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1801">            methodFinish();</span>
<span class="nc" id="L1802">        }</span>
<span class="nc" id="L1803">    }</span>


    protected void _denyRequestWorkflow(RequestAggregate reqAgg, String comment, boolean suppressPrivChecking,
        boolean loadedFromDB) throws Exception {
<span class="nc" id="L1808">        _denyRequest(reqAgg, comment, suppressPrivChecking, loadedFromDB);</span>

<span class="nc" id="L1810">        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_DENIED, reqAgg);</span>

<span class="nc" id="L1812">        _denyRequestPostProcess(reqAgg, comment);</span>
<span class="nc" id="L1813">    }</span>

    /**
     * @param reqAgg
     * @param comment
     */
    protected abstract void _denyRequestPostProcess(RequestAggregate reqAgg, String comment);

    /**
     * Determine if a request is a shift swap withdrawl request.
     * To be overriden if necessary in extending classes.
     */
    public boolean isShiftSwapWithdrawRequest(RequestAggregate reqAgg) {
<span class="nc" id="L1826">    	return false;</span>
    }

    protected RequestAggregate _autoProcessPreValidation(RequestAggregate reqAgg) throws BbmUpdateException{
<span class="nc" id="L1830">    	return reqAgg;</span>
    }

    /**
     * Do the auto processing for a request.
     *
     * &lt;pre&gt;
     *   Rules:
     *       1. Find all autoProc rules that apply to the request.
     *       2. If any rule specifies &quot;APPRCLAUSE_DONOT_APPROVE&quot;, then the request must not be approved irrespective
     *       of what the other rules evalaute to.
     *       3. If a rule evaluates to &quot;APPRCLAUSE_NO_VIOLATIONS&quot;, then can ignore &quot;APPRCLAUSE_VIOLATIONS_FOUND&quot;
     *       from rules after it.  But must still consider APPRCLAUSE_DONOT_APPROVE from these rules.
     *       4. If any rule specifies &quot;DENYCLAUSE_DONOT_DENY&quot;, then the request must not be denied irrespective of
     *       what the other rules evaluate to.
     *       5. If any rule evaluates to &quot;DENYCLAUSE_VIOLATIONS_FOUND&quot;, then can ignore &quot;DENYCLAUSE_NO_VIOLATIONS&quot;
     *       from rules after it. But still should consider &quot;DENYCLAUSE_DONOT_DENY&quot; from these rules.
     *       6. if rule evaluates to both &quot;APPRCLAUSE_APPR_NO_VIOLATIONS&quot; and &quot;DENYCLAUSE_DENY_VIOLATIONS_FOUND&quot;
     *       then request must not be autoprocessed.
     *
     *       7. For SSReqs, both ssItems need to be considered before deciding to approve or deny
     *       the request.
     *           7a. Only if both SSItems evaluate to &quot;APPRCLAUSE_APPR_NO_VIOLATIONS&quot; request is approved.
     *           7b. if one or both ssItems evaluate to &quot;DENYCLAUSE_DENY_NO_VIOLATIONS&quot; and the other does
     *           not evaluate to DENYCLAUSE_DO_NOT_DENY, then the request is denied.
     *
     *
     *   Short circuits:
     *       1. Stop if approval == APPRCLAUSE_DONOT_APPROVE and denial == DENYCLAUSE_DONOT_DENY
     *       2. First scan autoProc rules to see if APPRCLAUSE_DONOT_APPROVE and DENYCLAUSE_DONOT_DENY can be detected.
     *      If so, then the other autoprocessing rules need not be evaluated.
     *
     * &lt;/pre&gt;
     *
     * TODO: change transaction attribute to RequiresNew
     *
     * @param ssr The ShiftSwapRequest for which to do auto processing.
     * @param comment The original comment for the operation (update or create)
     *
     * @return True if request was approved or denied by autoprocessing.
     *         False otherwise.
     *
     */
    @Override
	public Pair _autoProcess(RequestAggregate reqAgg, String comment, boolean loadedFromDB)
            throws BbmUpdateException, RmHardValidationException,MultiUserException {
<span class="nc" id="L1876">	    Pair retPair = new Pair(&quot;false&quot;, null);</span>
<span class="nc" id="L1877">	    String _method_ = &quot;_autoProcess&quot;;</span>
<span class="nc" id="L1878">	    methodStart(_method_, reqAgg, comment);</span>
	    // if not in pending request, auto processing not done.
<span class="nc bnc" id="L1880" title="All 2 branches missed.">		if (!canAutoProcessRequest(reqAgg)) {</span>
<span class="nc" id="L1881">		    return retPair;</span>
	    }
<span class="nc bnc" id="L1883" title="All 2 branches missed.">	    comment = (comment == null) ? &quot;&quot; : comment;</span>
<span class="nc" id="L1884">		StringBuilder denyCommentBuff = new StringBuilder(comment);</span>
<span class="nc" id="L1885">	    String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1886">	    boolean cacheEnabled = false;</span>
	    try {
<span class="nc" id="L1888">		    RequestAggregate preAutoReqAgg = _autoProcessPreValidation(reqAgg);</span>
<span class="nc" id="L1889">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L1890">		    ValidationCache vc = preAutoReqAgg.getValidationCache();</span>
			//Lock the employee's time off pool if this is a time off request
<span class="nc" id="L1892">			TimeOffPoolDBLock.getTimeOffPoolLock(preAutoReqAgg);</span>
<span class="nc" id="L1893">		    boolean processAllTimeRangePairs = isProcessAllTimeRangePairs(preAutoReqAgg);</span>
			// auto process each item in the request separately.
			//Pair&lt;Collection&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt; pair = getEmpIDTimeRangePairsForAutoProcess(reqAgg);
<span class="nc" id="L1896">		    Pair&lt;Collection&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt; pair = getEmpIDTimeRangePairsForAutoProcess(preAutoReqAgg);</span>
<span class="nc" id="L1897">			Collection&lt;Pair&lt;ID, TimeRange&gt;&gt; empIDTimeRangePairs = pair.getFirst();</span>
<span class="nc" id="L1898">			List&lt;TOChoice&gt; toChoiceList = pair.getSecond();</span>

<span class="nc" id="L1900">		    Iterator&lt;Pair&lt;ID, TimeRange&gt;&gt; iter = empIDTimeRangePairs.iterator();</span>
<span class="nc" id="L1901">		    boolean denyFirstTimeRangePair = false;</span>
<span class="nc" id="L1902">		    TOChoice toChoice = null;</span>


			//Iterate through each employee id - time range pair. For time off this iterates through the time off choices
<span class="nc bnc" id="L1906" title="All 2 branches missed.">			for (int counter = 0; iter.hasNext(); counter++) { // NOSONAR</span>
<span class="nc" id="L1907">				Pair&lt;ID, TimeRange&gt; empIDTimeRangePair =  iter.next();</span>

			    // this map stores the status of executed validators so they don't need
			    // to be run more than once.  a map of validator name to a collection of validation results.
<span class="nc" id="L1911">			    Map ruleNameToValResultsMap = new HashMap(19);</span>

<span class="nc bnc" id="L1913" title="All 6 branches missed.">			    if (reqAgg.isTimeOffRequest() &amp;&amp; toChoiceList != null &amp;&amp; toChoiceList.size() &gt; counter) {</span>
<span class="nc" id="L1914">				    toChoice = toChoiceList.get(counter);</span>
<span class="nc" id="L1915">				    ((TORequest) reqAgg).setTOChoiceForValidation(toChoice);</span>
			    }

<span class="nc" id="L1918">			    ID empID = empIDTimeRangePair.getFirst();</span>
<span class="nc" id="L1919">			    TimeRange timeRange = empIDTimeRangePair.getSecond();</span>
<span class="nc" id="L1920">			    Collection[] apprDenyValResults1 = new Collection[3];</span>

<span class="nc" id="L1922">			    int[] apprDenyResult1 = runAutoProcessForTimeRange(empID, timeRange,</span>
			            true, true, apprDenyValResults1, preAutoReqAgg, ruleNameToValResultsMap);

<span class="nc bnc" id="L1925" title="All 2 branches missed.">			    if (preAutoReqAgg.isShiftSwapRequest()) {</span>
					//NOSONAR Pair&lt;ID, TimeRange&gt; empIDTimeRangePair2 = iter.next();
					// empID2 and timeRange2 is using empIDTimeRangePair instead of empIDTimeRangePair2. Is this a bug?
<span class="nc" id="L1928">					ID empID2 = empIDTimeRangePair.getFirst();</span>
<span class="nc" id="L1929">					TimeRange timeRange2 = empIDTimeRangePair.getSecond();</span>

<span class="nc" id="L1931">				    Collection[] apprDenyValResults2 = new Collection[3];</span>
				    // run approval validators only if the earlier decision is not &quot;DO_NOT_APPROVE&quot;
				    // run denial validators only if the earlier decision is not &quot;DO_NOT_DENY&quot;
<span class="nc bnc" id="L1934" title="All 4 branches missed.">				    int[] apprDenyResult2 = runAutoProcessForTimeRange(empID2, timeRange2,</span>
				            apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] != AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_DONOT_APPROVE,
				            apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] != AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY,
				            apprDenyValResults2, preAutoReqAgg, ruleNameToValResultsMap);

<span class="nc" id="L1939">				    resolveAutoProcResults(apprDenyResult1, apprDenyResult2, apprDenyValResults1,</span>
				            apprDenyValResults2);
			    }
			    // will not check for Waitlist criteria if the Waitlist preferences are not set.
<span class="nc bnc" id="L1943" title="All 2 branches missed.">			    boolean checkForWaitlist = preAutoReqAgg.isWaitlisted() ||</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">			    		areWaitlistPreferencesSetForRequest(preAutoReqAgg);</span>

<span class="nc" id="L1946">			    String requestStatus = getDecisionBasedOnAutProcessRuleEngineResult(preAutoReqAgg, apprDenyResult1, apprDenyValResults1, checkForWaitlist);</span>

<span class="nc" id="L1948">				StringBuilder commentBuf = new StringBuilder(comment);</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">			    if (preAutoReqAgg.isTimeOffRequest()) {</span>
<span class="nc" id="L1950">				    ((TORequest) preAutoReqAgg).clearTOChoiceForValidation();</span>
				    //((TORequest) reqAgg).clearTOChoiceForValidation();

			    }

			    // approve the request
<span class="nc bnc" id="L1956" title="All 2 branches missed.">			    if (requestStatus.equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
				    // Setting status to 'approved' will trigger an exception (during status transition validation)
				    // with the message &quot;cannot change status from 'approved' to 'approved'&quot;,
				    // when  _approveRequest() is called below.
<span class="nc bnc" id="L1960" title="All 4 branches missed.">				    if (commentBuf != null &amp;&amp; commentBuf.length() &gt; 1) {</span>
<span class="nc" id="L1961">					    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GEN_END_OF_SENTENCE_DELIM));</span>
				    }
<span class="nc" id="L1963">				    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_APPROVED));</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">					Collection&lt;ID&gt; choiceIDs = toChoice == null ? Collections.emptyList() : Collections.singleton(toChoice.getID());</span>

<span class="nc" id="L1966">					_approveRequestWorkFlow(reqAgg, choiceIDs, commentBuf.toString(), true, loadedFromDB);</span>
<span class="nc" id="L1967">				    retPair.setPair(&quot;true&quot;, RequestAuditTrail.STATUS_APPROVED);</span>
<span class="nc" id="L1968">				    return retPair;</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">			    } else if (requestStatus.equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc bnc" id="L1970" title="All 4 branches missed.">				    if (commentBuf != null &amp;&amp; commentBuf.length() &gt; 1) {</span>
<span class="nc" id="L1971">					    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GEN_END_OF_SENTENCE_DELIM));</span>
				    }
<span class="nc" id="L1973">				    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_WAITLISTED));</span>
<span class="nc bnc" id="L1974" title="All 4 branches missed.">				    if (_waitlistRequestWorkFlow(reqAgg, (toChoice != null ? toChoice.getID() : null), commentBuf.toString(), true, loadedFromDB)) {</span>
<span class="nc" id="L1975">					    retPair.setPair(&quot;true&quot;, RequestAuditTrail.STATUS_WAITLIST);</span>
<span class="nc" id="L1976">					    return retPair;</span>
				    }
<span class="nc bnc" id="L1978" title="All 2 branches missed.">			    } else if (requestStatus.equals(RequestAuditTrail.STATUS_DENIED)) {</span>
				    // Setting status to 'denied' will trigger an exception (during status transition validation)
				    // with the message &quot;cannot change status from 'denied' to 'denied'&quot;,
				    // when  _denyRequest() is called below.
<span class="nc bnc" id="L1982" title="All 4 branches missed.">				    if (reqAgg.isTimeOffRequest() &amp;&amp; reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L1983">					    TOWaitlist waitlistInfo = ((TORequest) reqAgg).getWaitlistInfo();</span>
<span class="nc bnc" id="L1984" title="All 4 branches missed.">					    if (waitlistInfo != null &amp;&amp; waitlistInfo.isManuallyAdded()) {</span>
<span class="nc" id="L1985">						    m_cat.debug(&quot;Ignoring auto-deny decision because request is manually waitlisted; REQ=&quot; + reqAgg);</span>
<span class="nc" id="L1986">						    return retPair;</span>
					    }
				    }
<span class="nc bnc" id="L1989" title="All 2 branches missed.">				    if (counter == 0) {   //Check the Deny work flow for the First req</span>
<span class="nc" id="L1990">					    denyCommentBuff.append(&quot;\n &quot; + RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_DENIED));</span>
<span class="nc bnc" id="L1991" title="All 2 branches missed.">					    for (Iterator iterator = apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1992">						    ValidationResult validationResult = (ValidationResult) iterator.next();</span>
<span class="nc" id="L1993">						    denyCommentBuff.append(&quot;&lt;BR&gt; &quot; + validationResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), vc.getTimeZoneForOrg()));</span>
<span class="nc" id="L1994">					    }</span>
<span class="nc" id="L1995">					    denyFirstTimeRangePair = true;</span>
				    }
<span class="nc bnc" id="L1997" title="All 2 branches missed.">				    if (processAllTimeRangePairs) {</span>
<span class="nc" id="L1998">					    continue;       // Proceed to the next TO Choice only if this one is eligible for denial .</span>
				    }
			    } else {
<span class="nc" id="L2001">				    return retPair; //keep status pending if no decision can be made and exit the loop</span>
			    }
		    }
<span class="nc bnc" id="L2004" title="All 2 branches missed.">		    if (denyFirstTimeRangePair) {</span>
<span class="nc" id="L2005">			    _denyRequestWorkflow(reqAgg, denyCommentBuff.toString(), true, loadedFromDB);</span>
<span class="nc" id="L2006">			    retPair.setPair(&quot;true&quot;, RequestAuditTrail.STATUS_DENIED);</span>
<span class="nc" id="L2007">			    return retPair;</span>
		    }
<span class="nc" id="L2009">		    return retPair;  //returning false, since No Decision Made neither Approve, Waitlist nor Deny.</span>

<span class="nc" id="L2011">	    } catch (RmHardValidationException e) {</span>
		    //RM exceptions are always logged at the point where they are thrown.

		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2017">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L2018">		    throw e;</span>
<span class="nc" id="L2019">	    } catch (BbmUpdateException e) {</span>
<span class="nc" id="L2020">		    m_cat.error(e, e);</span>
<span class="nc" id="L2021">		    handleException(e);</span>
<span class="nc" id="L2022">		    throw e;</span>
<span class="nc" id="L2023">	    } catch (MultiUserException e) {</span>
<span class="nc" id="L2024">		    m_cat.error(e, e);</span>
<span class="nc" id="L2025">		    handleException(e);</span>
<span class="nc" id="L2026">		    throw e;</span>
<span class="nc" id="L2027">	    }catch (Exception e) {</span>
<span class="nc" id="L2028">		    handleException(e);</span>
<span class="nc" id="L2029">		    throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="nc bnc" id="L2031" title="All 14 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L2032">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2034">			methodFinish();</span>
	    }
    }

	private boolean canAutoProcessRequest(RequestAggregate reqAgg) {
<span class="nc bnc" id="L2039" title="All 2 branches missed.">		if (isAdvancedVtoRequest(reqAgg)) {</span>
<span class="nc" id="L2040">			return false;</span>
		}
<span class="nc" id="L2042">		String reqStatus = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L2043" title="All 4 branches missed.">		return RequestAuditTrail.STATUS_PENDING.equals(reqStatus) || RequestAuditTrail.STATUS_WAITLIST.equals(reqStatus)</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">				|| isShiftSwapWithdrawRequest(reqAgg);</span>

	}

	private static boolean isAdvancedVtoRequest(RequestAggregate reqAgg) {
<span class="nc bnc" id="L2049" title="All 2 branches missed.">		if (reqAgg.isTimeOffRequest()) {</span>
<span class="nc" id="L2050">			TORequest toRequest = (TORequest) reqAgg;</span>
<span class="nc" id="L2051">			return toRequest.isAdvancedVTORequest();</span>
		}
<span class="nc" id="L2053">		return false;</span>
	}

	protected Pair&lt;Collection&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt; getEmpIDTimeRangePairsForAutoProcess(RequestAggregate reqAgg) {
<span class="nc" id="L2057">		Pair&lt;Collection&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt; pair = new Pair&lt;Collection&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt;();</span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">        if (reqAgg.isTimeOffRequest()) {</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">            if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="nc" id="L2060">                pair = ((TORequest) reqAgg).getAllEmpIDTimeRangePairs();</span>
            } else {
<span class="nc" id="L2062">                pair = ((TORequest) reqAgg).getFirstEmpIDTimeRangePair();</span>
            }
        } else{
<span class="nc" id="L2065">           pair.setFirst(reqAgg.getEmpIDTimeRangePairs());</span>
        }
<span class="nc" id="L2067">        return pair;</span>
    }

    /**
     * resolves the first approvalDenialResults with the second and assigns the results
     * to the first.  Also does the corresponding updates to the first approvalDenialValidationResults.
     *
     * &lt;p&gt; Rules:
     * &lt;li&gt; if specified result1 and result2 == approve, then returned result == approve.
     * &lt;li&gt; if either result1 or result2 == deny and the other result is != DO_NOT_DENY, then deny.
     *
     * See javadoc for {@link #_autoProcess(RequestAggregate, String, boolean) _autoProcess()} for
     * a complete description of the logic used for autoprocessing.
     *
     * @param effecApprDenyResults1
     * @param effecApprDenyResults2
     * @param apprDenyValResults1
     * @param apprDenyValResults2
     */
    protected void resolveAutoProcResults(int[] apprDenyResult1, int[] apprDenyResult2,
        Collection[] apprDenyValResults1, Collection[] apprDenyValResults2) {

        //                     NO_VIOL      VIOL_FOUND    DO_NOT_APPR
        // NO_VIOL             appr         donot appr      dont appr
        // VIOL_FOUND          dont appr    donot appr      dont appr
        // DO_NOT_APPR         dont appr     dont appr      dont appr

        // if result1 == APPROVE
<span class="nc bnc" id="L2095" title="All 2 branches missed.">        if ( apprDenyResult1[0] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS ) {</span>
            // if result2 != APPROVE
<span class="nc bnc" id="L2097" title="All 2 branches missed.">            if ( apprDenyResult2[0] != AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS) {</span>
                // effective result == do not approve.

                // Move result from result2 to result1.
<span class="nc" id="L2101">                apprDenyResult1[0] = apprDenyResult2[0];</span>
<span class="nc" id="L2102">                apprDenyValResults1[0] = apprDenyValResults2[0];</span>
            }
        } else { //result1 == APPRCLAUSE_DO_NOT_APPROVE or APPRCLAUSE_VIOLATIONS_FOUND
            // leave as is.
        }

        //                     NO_VIOL      VIOL_FOUND    DO_NOT_DENY
        // NO_VIOL             dont deny       deny          dont deny
        // VIOL_FOUND            deny          deny          dont deny
        // DO_NOT_DENY         dont deny     dont deny       dont deny

        // if result1 == DENY and result2 != DO_NOT_DENY
<span class="nc bnc" id="L2114" title="All 4 branches missed.">        if ( apprDenyResult1[1] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND &amp;&amp;</span>
             apprDenyResult2[1] != AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY ) {

             // leave as is.

        // if result2 == DENY and result1 != DO_NOT_DENY
<span class="nc bnc" id="L2120" title="All 4 branches missed.">        } else if ( apprDenyResult2[1] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND &amp;&amp;</span>
            apprDenyResult1[1] != AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY ) {
            // move results from result2 to result1.
<span class="nc" id="L2123">            apprDenyResult1[1] = apprDenyResult2[1];</span>
<span class="nc" id="L2124">            apprDenyValResults1[1] = apprDenyValResults2[1];</span>
        } else {
            // this handles the case where result1 == VIOL_FOUND and result2 == DONOT_DENY.
<span class="nc bnc" id="L2127" title="All 2 branches missed.">            if (apprDenyResult2[1] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY) {</span>
                // move results from result2 to result1.
<span class="nc" id="L2129">                apprDenyResult1[1] = apprDenyResult2[1];</span>
<span class="nc" id="L2130">                apprDenyValResults1[1] = apprDenyValResults2[1];</span>
            } else {
                // leave  as is (do not deny)
            }
        }

<span class="nc" id="L2136">        m_cat.debug(&quot;final autoproc approval result considering result1 and result2 = &quot; + apprDenyResult1[0]);</span>
<span class="nc" id="L2137">        m_cat.debug(&quot;final autoproc deny result considering result1 and result2 = &quot; + apprDenyResult1[1]);</span>
<span class="nc" id="L2138">    }</span>

    /**
     * See javadoc for {@link #_autoProcess(RequestAggregate, String, boolean) _autoProcess()} for
     * a complete description of the logic used for autoprocessing.
     *
     * @param empID
     * @param timeRange
     * @param runApproval
     * @param runDenial
     * @param apprDenyValResults
     * @param reqAgg
     * @param ruleNameToValResultsMap
     * @return
     * @throws Exception
     */
    protected int[] runAutoProcessForTimeRange(ID empID, TimeRange timeRange, boolean runApproval, boolean runDenial,
        Collection[] apprDenyValResults, RequestAggregate reqAgg, Map ruleNameToValResultsMap) throws Exception {

<span class="nc" id="L2157">        ValidationCache vc = reqAgg.getValidationCache();</span>

        // get orgID for employee during timeRange.
<span class="nc" id="L2160">        ID orgId = vc.getOrgIDForEmployeeDuringPeriod(empID, timeRange.getStartDate(), timeRange.getEndDate());</span>
<span class="nc" id="L2161">        String requestType = reqAgg.getRequestType();</span>
<span class="nc bnc" id="L2162" title="All 2 branches missed.">        ID activityID = reqAgg.isTimeOffRequest()?reqAgg.getRequestSubType():null;</span>


<span class="nc" id="L2165">        requestType = adjustRequestTypeForAutoProcess(reqAgg, requestType);</span>

<span class="nc bnc" id="L2167" title="All 2 branches missed.">        if (requestType.equals(Request.REQUESTTYPE_TIMEOFF_WITHDRAW)) {</span>
<span class="nc" id="L2168">        	activityID=null;</span>
        }

<span class="nc" id="L2171">		Collection&lt;String&gt; enabledValidatorsForOrg =</span>
<span class="nc bnc" id="L2172" title="All 2 branches missed.">				Request.REQUESTTYPE_FLEXTIME.equals(requestType) ? vc.getValidators() : vc.getValidators(orgId, requestType,</span>
						activityID);

<span class="nc" id="L2175">        AutoProcessingRuleChecker ckr = AutoProcessingRuleCheckerHelper.getChecker(</span>
            orgId, reqAgg,activityID , timeRange, enabledValidatorsForOrg,requestType);

<span class="nc" id="L2178">        int[] apprDenyResults = ckr.autoProcess(timeRange, ruleNameToValResultsMap,</span>
            runApproval, runDenial, apprDenyValResults,requestType );
<span class="nc bnc" id="L2180" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2181">            m_cat.debug(&quot;autoproc approval result from set of autoProc rules evaluated for empID &quot; + empID + &quot; = &quot; + apprDenyResults[0]);</span>
<span class="nc" id="L2182">            m_cat.debug(&quot;autoproc deny result from set of autoProc rules evaluated for empID &quot; + empID + &quot; = &quot; + apprDenyResults[1]);</span>
        }
<span class="nc" id="L2184">        return apprDenyResults;</span>

    }

	protected String adjustRequestTypeForAutoProcess(RequestAggregate reqAgg, String requestType) {
<span class="nc" id="L2189">		String result = requestType;</span>
<span class="nc bnc" id="L2190" title="All 4 branches missed.">		if (reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForAcceptAndRejectWithdrawAction()) {</span>
<span class="nc" id="L2191">			result = Request.REQUESTTYPE_TIMEOFF_WITHDRAW;</span>
<span class="nc bnc" id="L2192" title="All 4 branches missed.">		} else if (reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).getFlexType() == TORequest.FLEXTYPE_FLEXWITHMAKEUP) {</span>
<span class="nc" id="L2193">			result = Request.REQUESTTYPE_FLEXTIME;</span>
<span class="nc bnc" id="L2194" title="All 2 branches missed.">		} else if (isShiftSwapWithdrawRequest(reqAgg)) {</span>
<span class="nc" id="L2195">			result = Request.REQUESTTYPE_SHIFTSWAP_WITHDRAW;</span>
		}
<span class="nc" id="L2197">		return result;</span>
	}

    protected abstract RequestAggregate _undoTentativeApprovalByID(ID reqID,
        String objectVersionNumber, String comment) throws Exception;

    /**
     * Switches the request status to Pending from Tentatively approved, after running
     * the hard validations.  If any hard validation fails, request is marked invalid.
     *
     * @throws if any validations fail.
     */
    //TESTME undoTentativeapprovalByID
    @Override
	public void undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment)
        throws  RmHardValidationException, RmException
    {
<span class="nc" id="L2214">        String _method_ = &quot;undoTentativeApprovalByID&quot;;</span>
<span class="nc" id="L2215">        methodStart(_method_, reqID, objectVersionNumber, comment);</span>

<span class="nc" id="L2217">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2218">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2220">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2222">            _undoTentativeApprovalByID(reqID, objectVersionNumber, comment);</span>
<span class="nc" id="L2223">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2230">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L2231">			throw e;</span>
<span class="nc" id="L2232">		} catch (RmException e) {</span>
<span class="nc" id="L2233">			m_cat.error(e, e);</span>
<span class="nc" id="L2234">			handleException(e);</span>
<span class="nc" id="L2235">			throw e;</span>
<span class="nc" id="L2236">        } catch (Exception e) {</span>
<span class="nc" id="L2237">            handleException(e);</span>
<span class="nc" id="L2238">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2240" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2241">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2243">            methodFinish();</span>
<span class="nc" id="L2244">        }</span>
<span class="nc" id="L2245">    }</span>

    protected abstract void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        Object[] optionalUndoData) throws Exception;

    /**
     * @param reqAgg
     * @param reqAggDAO
     */
    protected void _undoRequestAndSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        Object[] optionalUndoData) throws Exception {

<span class="nc bnc" id="L2257" title="All 2 branches missed.">        boolean daoAllocNeeded = (reqAggDAO == null);</span>
        try {
<span class="nc bnc" id="L2259" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(ShiftBidRequest.DL_BASIC):reqAggDAO;</span>

<span class="nc" id="L2261">            _undoSchedule(reqAgg, reqAggDAO, optionalUndoData);</span>

            //delete request.
<span class="nc bnc" id="L2264" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(ShiftBidRequest.DL_BASIC):reqAggDAO;</span>
<span class="nc" id="L2265">            reqAggDAO.deleteRequest(reqAgg.getID());</span>
        } finally {
<span class="nc bnc" id="L2267" title="All 8 branches missed.">            if (daoAllocNeeded &amp;&amp; reqAggDAO != null) {</span>
<span class="nc" id="L2268">				reqAggDAO.cleanUp();</span>
			}
        }
<span class="nc" id="L2271">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#undoRequestAndSchedule(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate)
     */
    @Override
	public void undoRequestAndSchedule(RequestAggregate reqAgg, Object[] optionalUndoData) throws RmException, RmHardValidationException
    {
<span class="nc" id="L2279">        String _method_ = &quot;undoRequestAndSchedule&quot;;</span>
<span class="nc" id="L2280">        methodStart(_method_, reqAgg);</span>
<span class="nc" id="L2281">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2282">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2284">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2286">            _undoRequestAndSchedule(reqAgg, null, optionalUndoData);</span>
<span class="nc" id="L2287">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2294">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L2295">			throw e;</span>
<span class="nc" id="L2296">		} catch (RmException e) {</span>
<span class="nc" id="L2297">			m_cat.error(e, e);</span>
<span class="nc" id="L2298">			handleException(e);</span>
<span class="nc" id="L2299">			throw e;</span>
<span class="nc" id="L2300">        } catch (Exception e) {</span>
<span class="nc" id="L2301">            handleException(e);</span>
<span class="nc" id="L2302">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2304" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2305">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2307">            methodFinish();</span>
<span class="nc" id="L2308">        }</span>
<span class="nc" id="L2309">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#undoRequestAndScheduleByID(com.bluepumpkin.common.datatypes.ID)
     */
    @Override
	public void undoRequestAndScheduleByID(ID reqID) throws RmException, RmHardValidationException
    {
<span class="nc" id="L2317">        String _method_ = &quot;undoRequestAndScheduleByID&quot;;</span>
<span class="nc" id="L2318">        methodStart(_method_, reqID);</span>

<span class="nc" id="L2320">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L2321">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2322">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2324">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            // get the request. bypass validations by using the DAO.
<span class="nc" id="L2327">            RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>

<span class="nc" id="L2329">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L2330">            _undoRequestAndSchedule(reqAgg, reqAggDAO, null);</span>
<span class="nc" id="L2331">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2336">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L2337">			throw e;</span>
<span class="nc" id="L2338">		} catch (RmException e) {</span>
<span class="nc" id="L2339">			m_cat.error(e, e);</span>
<span class="nc" id="L2340">			handleException(e);</span>
<span class="nc" id="L2341">			throw e;</span>
<span class="nc" id="L2342">        } catch (Exception e) {</span>
<span class="nc" id="L2343">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2345" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2346">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L2348" title="All 4 branches missed.">            if (reqAggDAO != null) {</span>
<span class="nc" id="L2349">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L2351">            methodFinish();</span>
<span class="nc" id="L2352">        }</span>
<span class="nc" id="L2353">    }</span>

    /**
     * Validate the given request using hard validations and optionally with soft validations.
     * If hard validation fails, then request marked as invalid.
     *
     * @param reqAgg Request to be validated.
     * @param runSoftValids Set to true to run soft validations.  False otherwise.
     * @param handleForAnytimeTORequests. Set to true to do special for Anytime TO Requests
     * such as only run when do approval processing
     * @return returns the argument after running
     * validations.  If invoked from the EJB container, argument
     * and returned request refer to the same object.  If invoked from the web container,
     * due to marshalling, argument and returned request are different.
     */
    @Override
	public RequestAggregate _validateRequest(RequestAggregate reqAgg, boolean runSoftValids, boolean runNetStaffingSoftVal, boolean handleForAnytimeTORequests) {
        // do hard validations.  return if hard validation errors found.  hard validations
        // will be run only for **certain** states.
        //For TO Requests that are waitlisted only validate the Waitlisted Choice
<span class="nc bnc" id="L2373" title="All 4 branches missed.">        if(reqAgg.isTimeOffRequest()&amp;&amp;reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)){</span>
<span class="nc" id="L2374">           ((TORequest)reqAgg).setTOChoiceForValidation(((TORequest)reqAgg).getWaitlistTOChoice());</span>
        }

<span class="nc" id="L2377">        ValidationResult result = doHardValidations(reqAgg, RequestUtil.METHODTYPE_FINDER, null, true);</span>
        //Clear the Validation choice since all the choices should be soft validated
<span class="nc bnc" id="L2379" title="All 2 branches missed.">        if (reqAgg.isTimeOffRequest()) {</span>
<span class="nc" id="L2380">			((TORequest) reqAgg).clearTOChoiceForValidation();</span>
        }
<span class="nc bnc" id="L2382" title="All 2 branches missed.">        if ( result != null ) {</span>
<span class="nc" id="L2383">			return reqAgg;</span>
		}

        // if hard validations were not run or were successful, try soft validations.  Again soft
        // validations will **only** be run if necessary.  As part of the softValidation preprocess,
        // the TO lengths are filled.

<span class="nc bnc" id="L2390" title="All 2 branches missed.">        if (runSoftValids) {</span>
<span class="nc" id="L2391">			doSoftValidations(reqAgg, RequestUtil.METHODTYPE_FINDER, null, runNetStaffingSoftVal);</span>
		}

<span class="nc" id="L2394">        return reqAgg;</span>
    }
    @Override
   	public RequestAggregate _validateRequest(RequestAggregate reqAgg, boolean runSoftValids, boolean runNetStaffingSoftVal) {
<span class="nc" id="L2398">         return  _validateRequest(reqAgg,runSoftValids,runNetStaffingSoftVal,false);</span>
       }

   	/**
   	 * Only applicable for Time Off Requests in Advanced license so this method will be overridden in TORequestManagerEJB.It  is because in hard validation rules,
   	 * we skip some hard special rules while validating request if the requests have invalid choice due to these rules viola and valid choices.
   	 * We replaced them by similar soft validation rules for multi-choices TOB.
   	 *  However, to have consistence, only normal request(not TOB request) will marked as invalid to have consistence.
   	 * */
    protected void markRequestViolateSpecialRulesAsInValidIfNeeded(RequestAggregate reqAgg,
        	RequestAggregateDAO reqAggDAO) throws Exception {

<span class="nc" id="L2410">    }</span>

    /**
     * isTransitionValid for ProcessSingleRequest and Log.
     *
     * @param reqAgg
     * @param newState
     * @return
     * @throws
     */
    protected boolean isTransitionValidForPSRAndLog(RequestAggregate reqAgg, String newState)   {
        // transition from same state --&gt; same state is not necessary when processing a single request
        // as part of group processing.  same state --&gt; same state transition only happens when a request is edited
<span class="nc" id="L2423">        String oldState = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">        if (oldState.equals(newState)) {</span>
<span class="nc" id="L2425">            m_cat.debug(&quot;Process Single Request: Not processing transition from &quot; + oldState + &quot; to &quot; + newState + &quot; not necessary&quot;);</span>
<span class="nc" id="L2426">            return false;</span>
        }

<span class="nc" id="L2429">        StateTransValResult stateTransValResult = validStateTransition(reqAgg, newState);</span>
<span class="nc bnc" id="L2430" title="All 2 branches missed.">        if (!stateTransValResult.isTransitionValid()) {</span>
            //Note: prior to this message in the log, a stack trace for an RMChangeStateException with this
            // same message will be be found.  This stack trace is logged by validStateTransition() during
            // the creation of the RMChangeStateException embedded in 'stateTransResult' and is not a cause for concern.
<span class="nc" id="L2434">            m_cat.debug(&quot;Process Single Request: Not processing request: &quot; + stateTransValResult.m_RmHardValidationException.getLocalizedMessage());</span>
<span class="nc" id="L2435">            return false;</span>
        }

<span class="nc" id="L2438">        return true;</span>
    }

    /**
     * GetRequestByID And Check For HardValidationErrors
     *
     * @param reqID
     * @param runSoftValids
     * @return null if hard validation fails.  the request otherwise.
     * @throws Exception
     */
    private RequestAggregate getRequestByIDAndCheckHVE(ID reqID, boolean runSoftValids) throws Exception {
        //ValidationMethodResult result = _validateRequest(reqMgr, req);
<span class="nc" id="L2451">        RequestAggregate reqAgg =</span>
<span class="nc" id="L2452">            _getRequestByID(reqID, false, true, runSoftValids, getDetailLevelForValidation());</span>

        // if hard validation errros, return null.
<span class="nc bnc" id="L2455" title="All 2 branches missed.">        return ( reqAgg.hardValidationFailed() == null )?reqAgg:null;</span>
    }

    /**
     * Called by CommonReqMgr.ProcessRequests() to process a single request during group processing.
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#processSingleRequest(com.bluepumpkin.ejb.rm.requests.common.model.Request, java.lang.String)
     *
     */
    @Override
	public RequestAggregate processSingleRequest(Request req, String reqAction)
        throws RmException, RmHardValidationException {

<span class="nc" id="L2468">        String _method_ = &quot;processSingleRequest&quot;;</span>
<span class="nc" id="L2469">        methodStart(_method_, req, reqAction);</span>

<span class="nc" id="L2471">        ID reqID = req.getID();</span>
<span class="nc" id="L2472">        String objVersionNum = req.getObjectVersionNumber();</span>
<span class="nc" id="L2473">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2474">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2476">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2478">			RequestAggregate reqAgg = null;</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">			if (reqAction.equals(CommonRequestManager.GA_APPROVE_ALL_WITHOUT_VIOL)) {</span>
<span class="nc" id="L2480">				reqAgg = groupApproveAllWithoutViolations(reqID);</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">			} else if (reqAction.equals(CommonRequestManager.GA_TENT_APPROVE_ALL_WITHOUT_VIOL)) {</span>
<span class="nc" id="L2482">				reqAgg = groupTentativeApproveAllWithoutViolations(reqID);</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">			} else if (reqAction.equals(CommonRequestManager.GA_DENY_ALL_WITH_VIOLATIONS)) {</span>
<span class="nc bnc" id="L2484" title="All 2 branches missed.">				if ((reqAgg = getRequestByIDAndCheckHVE(reqID, false)) == null) {</span>
<span class="nc" id="L2485">					return null;</span>
				}
				//Skip the VTO requests since they are processed in a seperate button
<span class="nc bnc" id="L2488" title="All 2 branches missed.">				if (reqAgg.isAdvancedVTORequest()) {</span>
<span class="nc" id="L2489">					return null;</span>
				}
				// check if transition is valid.
<span class="nc bnc" id="L2492" title="All 2 branches missed.">				if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_DENIED)) {</span>
<span class="nc" id="L2493">					return reqAgg;</span>
				}

				//Do soft validation rule
<span class="nc" id="L2497">				doSoftValidations(reqAgg, RequestUtil.METHODTYPE_FINDER,</span>
				//null for methodSubType
						null,
						//run netstaffing if it is enabled
						true, null, true);

<span class="nc bnc" id="L2503" title="All 2 branches missed.">				if (!reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L2504">					reqAgg.setObjectVersionNumber(objVersionNum);</span>
<span class="nc" id="L2505">					_denyRequestWorkflow(reqAgg, RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), false, false);</span>
				}
<span class="nc bnc" id="L2507" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_CONFIRM_ALL_TENT_APPROVALS)) {</span>
                // only applies to tentative requests.
<span class="nc bnc" id="L2509" title="All 2 branches missed.">                if (req.isTentative()) {</span>
<span class="nc bnc" id="L2510" title="All 2 branches missed.">                    if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, false)) == null ) {</span>
<span class="nc" id="L2511">						return null;</span>
					}
                    //Skip the VTO requests since they are processed in a seperate button
<span class="nc bnc" id="L2514" title="All 2 branches missed.">	           	    if(reqAgg.isAdvancedVTORequest()){</span>
<span class="nc" id="L2515">	           	    	 return null;</span>
	           	    }
                    // check if transition is valid.
<span class="nc bnc" id="L2518" title="All 2 branches missed.">                    if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L2519">						return reqAgg;</span>
					}

<span class="nc" id="L2522">                    reqAgg.setObjectVersionNumber(objVersionNum);</span>
<span class="nc" id="L2523">                    _approveRequestWorkFlow(reqAgg, null,</span>
<span class="nc" id="L2524">						RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), false, true);</span>
                }
<span class="nc bnc" id="L2526" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_REMOVE_ALL_TENT_APPROVALS)) {</span>
                // only applies to tentative requests.
<span class="nc bnc" id="L2528" title="All 2 branches missed.">                if (req.isTentative()) {</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">                    if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, false)) == null ) {</span>
<span class="nc" id="L2530">						return null;</span>
					}
                    //Skip the VTO requests since they are processed in a seperate button
<span class="nc bnc" id="L2533" title="All 2 branches missed.">	           	    if(reqAgg.isAdvancedVTORequest()){</span>
<span class="nc" id="L2534">	           	    	 return null;</span>
	           	    }
                    // check if transition is valid.
<span class="nc bnc" id="L2537" title="All 2 branches missed.">                    if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="nc" id="L2538">						return reqAgg;</span>
					}

<span class="nc" id="L2541">                    reqAgg = _undoTentativeApprovalByID(reqID, objVersionNum,</span>
<span class="nc" id="L2542">						RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION));</span>
                }
<span class="nc bnc" id="L2544" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_APPROVE_TO_CHOICE_WITHOUT_VIOL)) {</span>
				//Approve Time Off Choices without Violations
<span class="nc" id="L2546">            	reqAgg = groupApproveTOChoiceWithoutViolations(reqID);</span>
<span class="nc bnc" id="L2547" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_PROCESS_VTO_OPTIONS_REQUESTS_WITHOUT_VIOL)) {</span>
<span class="nc" id="L2548">				reqAgg = groupApproveVTORequest(reqID);</span>
            } else {
                //invalid value for reqAction.
<span class="nc" id="L2551">                throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
            }

<span class="nc" id="L2554">            return reqAgg;</span>
<span class="nc" id="L2555">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2561">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L2562">			throw e;</span>
<span class="nc" id="L2563">		} catch (RmException e) {</span>
<span class="nc" id="L2564">			m_cat.error(e, e);</span>
<span class="nc" id="L2565">			handleException(e);</span>
<span class="nc" id="L2566">			throw e;</span>
<span class="nc" id="L2567">        } catch (Exception e) {</span>
<span class="nc" id="L2568">            handleException(e);</span>
<span class="nc" id="L2569">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2571" title="All 22 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2572">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2574">            methodFinish();</span>
        }
    }
    public RequestAggregate groupApproveAllWithoutViolations(ID reqID) throws Exception{
<span class="nc" id="L2578">    	  RequestAggregate reqAgg = null;</span>

<span class="nc bnc" id="L2580" title="All 2 branches missed.">    	  if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, false)) == null ) {</span>
<span class="nc" id="L2581">				return null;</span>
		  }
    	  //Skip the VTO requests since they are processed in a seperate button in different way
<span class="nc bnc" id="L2584" title="All 2 branches missed.">    	     if(reqAgg.isAdvancedVTORequest()){</span>
<span class="nc" id="L2585">    	    	 return null;</span>
    	     }

	         // check if transition is valid.
<span class="nc bnc" id="L2589" title="All 2 branches missed.">	         if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L2590">					return null;</span>
			 }

<span class="nc" id="L2593">	         doSoftValidations(reqAgg, RequestUtil.METHODTYPE_FINDER,</span>
	 				//null for methodSubType
	 				null,
	 				//run netstaffing if it is enabled
	 				true, null,true);

<span class="nc bnc" id="L2599" title="All 2 branches missed.">	         if (reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L2600">	        	 reqAgg.setObjectVersionNumber(reqAgg.getObjectVersionNumber());</span>
<span class="nc" id="L2601">	             _approveRequestWorkFlow(reqAgg, null,</span>
<span class="nc" id="L2602">	             	RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), false, true);</span>
	         }
<span class="nc" id="L2604">	         return reqAgg;</span>
    }
    public RequestAggregate groupTentativeApproveAllWithoutViolations(ID reqID) throws Exception{
<span class="nc" id="L2607">    	RequestAggregate reqAgg = null;</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">	  	 if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, false)) == null ) {</span>
<span class="nc" id="L2609">				return null;</span>
			}
	  	  //Skip the VTO requests since they are processed in a seperate button
<span class="nc bnc" id="L2612" title="All 2 branches missed.">	     if(reqAgg.isAdvancedVTORequest()){</span>
<span class="nc" id="L2613">	    	 return null;</span>
	     }
	     // check if transition is valid.
<span class="nc bnc" id="L2616" title="All 2 branches missed.">	     if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_TENTATIVE)) {</span>
<span class="nc" id="L2617">				return null;</span>
			}


<span class="nc" id="L2621">	     doSoftValidations(reqAgg, RequestUtil.METHODTYPE_FINDER,</span>
					//null for methodSubType
					null,
					//run netstaffing if it is enabled
					true, null,true);

<span class="nc bnc" id="L2627" title="All 2 branches missed.">	     if (reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L2628">	    	 reqAgg.setObjectVersionNumber(reqAgg.getObjectVersionNumber());</span>
<span class="nc" id="L2629">	         _approveRequestTentatively(reqAgg, null,</span>
<span class="nc" id="L2630">	         	RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), true);</span>
	     }
<span class="nc" id="L2632">	     return reqAgg;</span>
  }
    /*
     *  Approve valid multi-choices of TOB requests. See details inside TORequestManagerEJB.__approveRequestChoice
     * */
	public RequestAggregate groupApproveTOChoiceWithoutViolations(ID reqID) throws Exception {

<span class="nc" id="L2639">		long detailLevel = TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH;</span>

<span class="nc" id="L2641">		RequestAggregate reqAgg = _getRequestByID(reqID,</span>
				//incExpired
				false,
				//runHardValids
				true,
				//runSoftValids
				false, detailLevel);

<span class="nc bnc" id="L2649" title="All 4 branches missed.">		if (reqAgg == null || reqAgg.hardValidationFailed() != null) {</span>
<span class="nc" id="L2650">			return null;</span>
		}

		//Only applies to TORequest
<span class="nc bnc" id="L2654" title="All 4 branches missed.">		if (!(reqAgg.isTimeOffRequest() || reqAgg.isFlexTimeRequest())) {</span>
<span class="nc" id="L2655">			return null;</span>
		}
		// check if transition is valid.
<span class="nc bnc" id="L2658" title="All 2 branches missed.">		if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L2659">			return null;</span>
		}

		//These validators are handled in TORequestManagerEJB.doValidationsForMultiChoiceTOB
		//It might be a good idea to move TORequestManagerEJB.softValidatorsForMultiChoice here
		//and ignore all of those validator in the following doSoftValidations
		//As of now the validators in softValidatorsForMultiChoice will be called twice
		//once in the following doSoftValidations and again in doValidationsForMultiChoiceTOB
<span class="nc" id="L2667">		Set&lt;String&gt; softValidatorsToIgnore = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</span>
<span class="nc" id="L2668">		softValidatorsToIgnore.add(AvaliableHoursValidationRule.class.getName());</span>
<span class="nc" id="L2669">		softValidatorsToIgnore.add(EmployeeHoursValidationRule.class.getName());</span>
<span class="nc" id="L2670">		softValidatorsToIgnore.add(TimeOffBidMaxWeeksValidationRule.class.getName());</span>
<span class="nc" id="L2671">		TORequest toReq=(TORequest)reqAgg;</span>
		//Turn on the flag if 1 choice violates the first rule,
		//then this choice should be skipped in next rules.
<span class="nc" id="L2674">		toReq.setRunForGroupTOBApproval(true);</span>
<span class="nc" id="L2675">		doSoftValidations(toReq, RequestUtil.METHODTYPE_FINDER,</span>
				//null for methodSubType
				null,
				//run netstaffing if it is enabled
				true, softValidatorsToIgnore,false);
<span class="nc" id="L2680">		toReq.setRunForGroupTOBApproval(false);</span>

		// Approve requests which has any choice without violations
<span class="nc" id="L2683">        String comment = RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION);</span>
<span class="nc" id="L2684">		boolean loadedFromDB = true;</span>
<span class="nc" id="L2685">		boolean suppressPrivilegeChecking = false;</span>

<span class="nc" id="L2687">		_approveRequestChoice(toReq, null, comment, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L2688">        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_APPROVED, toReq);</span>
<span class="nc" id="L2689">		_approveRequestPostProcess(toReq, null, comment);</span>
<span class="nc" id="L2690">		return reqAgg;</span>
	}
	 /*Process VTO request which has Multiple VTO Options checked. See details inside TORequestManagerEJB._processVTORequest
     */
	public RequestAggregate groupApproveVTORequest(ID reqID) throws Exception {
<span class="nc" id="L2695">		long detailLevel = TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH;</span>
<span class="nc" id="L2696">		RequestAggregate reqAgg = _getRequestByID(reqID,</span>
				//incExpired
				false,
				//runHardValids
				true,
				//runSoftValids
				false, detailLevel);

<span class="nc bnc" id="L2704" title="All 4 branches missed.">		if (reqAgg == null || reqAgg.hardValidationFailed() != null) {</span>
<span class="nc" id="L2705">			return null;</span>
		}
		//Only applies to TORequest
<span class="nc bnc" id="L2708" title="All 2 branches missed.">		if (!reqAgg.isAdvancedVTORequest()) {</span>
<span class="nc" id="L2709">			return null;</span>
		}
		// check if transition is valid.
<span class="nc bnc" id="L2712" title="All 2 branches missed.">		if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L2713">			return null;</span>
		}

		//Ignore these validators, they are handled in the advanced vto calculator or are not applicable for advance VTO
<span class="nc" id="L2717">		Set&lt;String&gt; softValidatorsToIgnore = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</span>
<span class="nc" id="L2718">		softValidatorsToIgnore.add(AvaliableHoursValidationRule.class.getName());</span>
<span class="nc" id="L2719">		softValidatorsToIgnore.add(EmployeeHoursValidationRule.class.getName());</span>
<span class="nc" id="L2720">		softValidatorsToIgnore.add(AvoidCalendarEventsValidationRule.class.getName());</span>
<span class="nc" id="L2721">		softValidatorsToIgnore.add(ComplyMinRequiredPayPeriodHoursRuleTimeOff.class.getName());</span>

<span class="nc" id="L2723">		doSoftValidations(reqAgg, RequestUtil.METHODTYPE_FINDER,</span>
				//null for methodSubType
				null,
				//for vto, don't run netstaffing even if they have it somehow enabled in the UI
				false, softValidatorsToIgnore,true);

		//approve valid VTO request and deny invalid VTO request during processing
<span class="nc bnc" id="L2730" title="All 2 branches missed.">		if (reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L2731">			String objVersionNum = reqAgg.getObjectVersionNumber();</span>
<span class="nc" id="L2732">			reqAgg.setObjectVersionNumber(objVersionNum);</span>
<span class="nc" id="L2733">			boolean isApproved=_processVTORequest(reqAgg,RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION));</span>
<span class="nc bnc" id="L2734" title="All 2 branches missed.">	    	String statusChanged = isApproved?RequestAuditTrail.STATUS_APPROVED:RequestAuditTrail.STATUS_DENIED;</span>
<span class="nc" id="L2735">	        fireReqStatusChangeNotificationIfNecessary(statusChanged, reqAgg);</span>
		}
<span class="nc" id="L2737">		return reqAgg;</span>
	}



    /**Just a pass through; Inheriting classes need to implement this method
     * Overridden in ShiftBidReqMgr &amp; TORequestManager.
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#applyFilterAndSortCriteriaForRequests(java.util.List, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter, int, int)
     */
    @Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDs, RequestFilter reqFilter,
    		int sortColumn, int sortDirection, boolean inclExpired, long detailLevel,
            boolean runSoftValids, boolean runNetStaffingSoftVal) throws RmException, RmHardValidationException {

<span class="nc" id="L2752">        String _method_ = &quot;applyFilterAndSortCriteriaForReqIDs&quot;;</span>
<span class="nc" id="L2753">		methodStart(_method_, new Object[] { mgrEmpID, reqIDs, reqFilter, Integer.valueOf(sortColumn), Integer.valueOf(sortDirection),</span>
<span class="nc" id="L2754">				Boolean.valueOf(inclExpired) });</span>

<span class="nc" id="L2756">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2757">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2759">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

	        // this method must not be called when the request type in the filter is 'all'
<span class="nc" id="L2762">            String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">            if (Request.REQUESTTYPE_ALL.equals(filterReqType)) {</span>
<span class="nc" id="L2764">	            throw new IllegalArgumentException();</span>
	        }
<span class="nc" id="L2766">	        Set reqEmpIDSet =null; //this set holds the actual Requests for the given request ids</span>
            //Actual implementations return this as non null
<span class="nc" id="L2768">            return new Pair(reqIDs, reqEmpIDSet) ;</span>
		} finally {
<span class="nc bnc" id="L2770" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2771">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2773">            methodFinish();</span>
		}
    }

	/**
	 * Overridden by SSReqMgr.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addEmployeeIDsToSet(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.util.Set)
	 */
	@Override
	public Set addEmployeeIDsToSet(RequestAggregate request, Set reqEmpIds)  {
<span class="nc" id="L2784">		reqEmpIds.add(request.getEmployeeID());</span>

<span class="nc" id="L2786">		return reqEmpIds;</span>
	}

	/**
	 * Overridden in SSReqMgr.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#restrictEmployeesByFilter(java.util.Collection, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
	 */
	@Override
	public Collection restrictEmployeesByFilter(Collection empIds, RequestFilter requestFilter)  {
		// ShiftBid requests do not need to further restrict employee ids
<span class="nc" id="L2797">		return empIds;</span>
	}

    /**
     * @return
     */
    protected abstract IRequestType getRequestManager() throws Exception;

    protected abstract ValidatorDescriptor[] getHardValidatorDescriptors();

    /**
     * Returns an array of soft validators which are mandatory.  Contrast this with optional
     * softvalidators (can be turned on or off from the UI).  For example see
     * {@link com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLength TimeOffChoiceHasZeroLength}
     * validation rule.
     *
     * @return
     */
    protected abstract ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory();

    /**
     * Performs hard validations for the given request based on the request type &lt;br&gt;
     *
     * Hard validations are always run unlike softvalidations (which can be suppressed by setting
     * runSoftValids=false parameter to the getXXXX() methods).&lt;br&gt;
     *
     * Hard validations will be done in the following scenarios:
     * &lt;li&gt; Request create: All hard validations done as all associated data is loaded, by the createRequest() method.
     * &lt;li&gt; Request update: All hard validations done as all associated data is loaded using RequestType.getDetailLevelForValidation()
     * This prevents Null pointer exceptions due to lack of data when hard validations are run.
     * &lt;li&gt; Request fetch: Hard validations are done selectively based on data avaialbility.  The data
     * loaded with the requestr is defined by the detailLevel flag passed to the getXXXX() method.
     * Only the validations for which data exists will be run.  For instnace,
     * if the shiftbid request detailLevel lacks DL_SHIFTBID_AUCTION, then the auction related hardvalidation
     * {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.AuctionIsValidHV AuctionIsValidHV}
     * will not be run.
     *
     * @param reqAgg
     * @param methodType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants
     * @param methodSubType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants.
     * see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param markInvalidIfHardValFails if true, then request will be marked invalid on hard validation error.
     * If false, then request not marked invalid due to  hardval error.
     * see {@link com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceApprovedNotZeroLengthHV TimeOffChoiceApprovedNotZeroLengthHV}
     * for an example of this scenario.
     * @return To check if any hard validations failed, use reqAgg.getHardValidationResults()
     */
    protected ValidationResult doHardValidations(RequestAggregate reqAgg, int methodType,
        String methodSubType, boolean markInvalidIfHardValFails) {
<span class="nc" id="L2847">    	return doHardValidations(reqAgg,methodType,methodSubType,markInvalidIfHardValFails, false, null);</span>
    }

    protected ValidationResult doHardValidations(RequestAggregate reqAgg, int methodType,
            String methodSubType, boolean markInvalidIfHardValFails, boolean skipSomeHardValidationRules) {
<span class="nc" id="L2852">        	return doHardValidations(reqAgg,methodType,methodSubType,markInvalidIfHardValFails, skipSomeHardValidationRules, null);</span>
    }

    /**Similar to doHardValidations as below but have one more param skipSomeHardValidationRules
     * @param skipSomeHardRulesWhenUpdate - To support for approve any choice of TO request. 1 TO Request can have multi-choices.
     * If one of them is invalid , it should not marked as invalid=&gt; the hard validation rule should not run in this case
     * Instead of that, some rules will be replaced by similar soft validation rules
     * */
    protected ValidationResult doHardValidations(RequestAggregate reqAgg, int methodType,
            String methodSubType, boolean markInvalidIfHardValFails, boolean skipSomeHardValidationRules, String newState) {

            // commented: invalid requests are validated to provide the reason for being invalid).
<span class="nc bnc" id="L2864" title="All 2 branches missed.">            if (!reqAgg.isHardValidationNeeded(methodType, newState) ) {</span>
<span class="nc" id="L2865">    			return null;</span>
    		}
<span class="nc" id="L2867">            RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L2868">            String validatorName = &quot;No hard validators run yet&quot;;</span>
            try {
<span class="nc" id="L2870">                reqAgg.clearValidationResults(true); // clear any residual validation results</span>
                // if request hasn't expired, validate
<span class="nc" id="L2872">    			ValidationResult hardValResult = null;</span>
<span class="nc" id="L2873">                ValidatorDescriptor[] hardValDescArr = getHardValidatorDescriptors();</span>
<span class="nc bnc" id="L2874" title="All 6 branches missed.">                boolean isSkipForTimeOffRequestOnly = skipSomeHardValidationRules &amp;&amp; reqAgg.isTimeOffRequest() &amp;&amp; !reqAgg.isFlexTimeRequest() ;</span>
<span class="nc bnc" id="L2875" title="All 4 branches missed.">                for (int i = 0; i &lt; hardValDescArr.length &amp;&amp; hardValResult == null; i++) {</span>
                    // if hard validator does not apply, continue.
<span class="nc" id="L2877">                    ValidatorDescriptor hardValDesc = hardValDescArr[i];</span>
<span class="nc" id="L2878">                    boolean  checkIfVAlidatorapplies= checkIfValidatorApplies(reqAgg, hardValDesc, methodType, methodSubType);</span>
<span class="nc" id="L2879">                    validatorName = hardValDesc.getName();</span>
<span class="nc bnc" id="L2880" title="All 4 branches missed.">                    boolean isSkipRunOnThisRule = isSkipForTimeOffRequestOnly &amp;&amp; isSpecialHardRulesForTimeOff(validatorName);</span>
                    // check if the validator applies in the current context
<span class="nc bnc" id="L2882" title="All 4 branches missed.">                    if (!checkIfVAlidatorapplies||isSkipRunOnThisRule) {</span>
<span class="nc" id="L2883">    					continue;</span>
    				}

<span class="nc" id="L2886">                    hardValResult= ValidationUtil.doValidation(validatorName, reqAgg, validatorMap);</span>

                    // if validation succeeded
<span class="nc bnc" id="L2889" title="All 2 branches missed.">                    if(hardValResult==null){</span>
<span class="nc" id="L2890">                        hardValResult = reqAgg.hardValidationFailed();</span>
                    }

<span class="nc bnc" id="L2893" title="All 4 branches missed.">                    if (  hardValResult != null &amp;&amp; markInvalidIfHardValFails ) {</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">                    	if (hardValResult.getApprove()){</span>
                    		//mark the request as approved
<span class="nc" id="L2896">                    		reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L2897">                    		reqAgg.setRequestStatus(RequestAuditTrail.STATUS_APPROVED);</span>
<span class="nc" id="L2898">    			            String comment = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), reqAgg.getValidationCache().getTimeZoneForOrg())</span>
<span class="nc" id="L2899">    			                    + RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_APPROVED);</span>
<span class="nc" id="L2900">    			            reqAggDAO.updateRequest(reqAgg, comment, RequestUtil.getBPSuperUser());</span>
<span class="nc" id="L2901">    			            JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, reqAgg.getRequestStatus()));</span>
<span class="nc" id="L2902">                            break;//no need to do more validations</span>
                    	} else {
<span class="nc" id="L2904">                    		markRequestAsInvalid(reqAgg, hardValResult, reqAggDAO);</span>
    					}
                    }
                }

<span class="nc" id="L2909">                return hardValResult; //will be null.</span>
<span class="nc" id="L2910">            } catch ( Exception e ) {</span>
                // log the fact that exception is caught but not propogated.
                //
                // Note: This mode of ignoring exceptions is usually done only during bulk fetching of requests
                // (ie. usually callers of this method do bulk fetching).
                //
                // we log this with priority 'error' since only unexpected exceptions are thrown by the validation
                // rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
<span class="nc" id="L2918">                m_cat.warn(&quot;*** Following exception was caught but not propogated ***: &quot; + e);</span>
<span class="nc" id="L2919">                return ValidationUtil.setHardValidationResult(reqAgg, e, validatorName);</span>
    			//return ValidationUtil.setHardValidationResult(reqAgg, RmEjbBundleKey.REQ_UNEXPECTED_ERROR, validatorName);
            } finally {
<span class="nc bnc" id="L2922" title="All 6 branches missed.">                if (reqAggDAO != null) {</span>
<span class="nc" id="L2923">    				reqAggDAO.cleanUp();</span>
    			}
            }
        }
    /** It is applicable for Time Off requests only
     *  It will mark all requests except Time Off Request as invalid.
     *  It should be override in TORequestManagerEJB.java to handle Time Off requests
     *  since a Time Off Requests can have many choices
	 * */
    protected boolean isSpecialHardRulesForTimeOff(String validatorName) throws Exception{
<span class="nc" id="L2933">    	boolean isWorkableTimeWithinScheduleTimeOff = validatorName.equals(WorkableTimeWithinScheduleTimeOffHV.CLASS_NAME);</span>
<span class="nc" id="L2934">		boolean isAgentGoodStanding = validatorName.equals(AgentGoodStandingValidationRuleHV.CLASS_NAME);</span>
<span class="nc" id="L2935">		boolean isBidChoicePeriod = validatorName.equals(TimeOffBidPeriodPerChoiceHV.CLASS_NAME);</span>
<span class="nc bnc" id="L2936" title="All 6 branches missed.">		return isWorkableTimeWithinScheduleTimeOff || isAgentGoodStanding || isBidChoicePeriod;</span>
    }

    private boolean checkIfValidatorApplies(RequestAggregate reqAgg, ValidatorDescriptor valDesc,
        int methodType, String methodSubType) {

        // check if hard validator's methodType matches specified methodType.
<span class="nc bnc" id="L2943" title="All 2 branches missed.">        if (!valDesc.isEnabledForMethodType(methodType, methodSubType)) {</span>
<span class="nc bnc" id="L2944" title="All 2 branches missed.">            if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2945">                m_cat.debug(&quot;Skipping validation: methodType and methodSubType do not match: &quot; +  methodType + ',' +</span>
<span class="nc" id="L2946">                    methodSubType + ',' + valDesc.getName() + ',' + valDesc.getMethodType());</span>
            }

<span class="nc" id="L2949">            return false;</span>
        }

        // All requests must have DL_BASIC set.
        // If not set, specifying HardValidatorDescriptor.m_requiredDetailLevel = DL_BASIC with the
        // intention to run the hardValidator for all detailLevels will not work and the hard validator
        // will not be run for any request.
<span class="nc" id="L2956">        reqAgg.setDetailLevel(reqAgg.getDetailLevel() | RequestDetailLevel.DL_BASIC);</span>

        // for request fetches, run validator only if validator's required detail level is
        // supported by the fetched request.  This means, some hard validators may be skipped
        // if the request's detailLevel is not adequate enough.  Done for performance reasons.
<span class="nc bnc" id="L2961" title="All 2 branches missed.">        if (valDesc.isEnabledForDetailLevel(reqAgg.getDetailLevel())) {</span>
<span class="nc" id="L2962">            m_cat.debug(&quot;Skipping validation: detailLevel does not match: &quot; + valDesc.getName() +</span>
<span class="nc" id="L2963">                ',' + valDesc.getRequiredDetailLevel() + ',' + reqAgg.getDetailLevel());</span>

<span class="nc" id="L2965">            return false;</span>
        }


<span class="nc" id="L2969">        return true;</span>
    }

    protected void markRequestAsInvalid(RequestAggregate reqAgg, ValidationResult hardValResult,
    	RequestAggregateDAO reqAggDAO) throws Exception {

		// hard validation failed. Log reason for failure
<span class="nc" id="L2976">		String hardValLocalizedMsg = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L2977">		    		reqAgg.getValidationCache().getTimeZoneForOrg());</span>
<span class="nc" id="L2978">		m_cat.l7dDebug(RmEjbLogBundleKey.UNLOCALIZED_MESSAGE, new Object[] { hardValLocalizedMsg} );</span>
<span class="nc" id="L2979">		m_cat.debug(&quot;Marking request (ID = &quot; + reqAgg.getID() + &quot;) as invalid due to hard validation failure&quot;);</span>

		// Mark request as invalid in **db**, except for requests being created (ID == null) or invalid to begin with.
<span class="nc bnc" id="L2982" title="All 2 branches missed.">		boolean newRequest = (reqAgg.getID() == null);</span>
<span class="nc bnc" id="L2983" title="All 4 branches missed.">		if ( newRequest || reqAgg.isInvalid() ) {</span>
<span class="nc" id="L2984">			reqAgg.setRequestStatus(RequestAuditTrail.STATUS_INVALID);</span>
		} else {
			try {
<span class="nc" id="L2987">				reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>

				// don't need to worry about msg too long for audit trail anymore because
				// RequestAuditTrail has been enhanced to use LargeString table for long messages.

<span class="nc" id="L2992">				invalidateRequestAndFireNotification(reqAgg, hardValLocalizedMsg, reqAggDAO);</span>
<span class="nc" id="L2993">			} catch (Exception e) {</span>
				// log the fact that exception is caught but not propogated.
				//
				// Note: This mode of ignoring exceptions is usually done only during bulk fetching of requests
				// (ie. usually callers of this method do bulk fetching).
				//
				// we log this with priority 'error' since only unexpected exceptions are thrown by the validation
				// rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
<span class="nc" id="L3001">				m_cat.warn(&quot;*** Following exception was caught but not propogated ***: &quot; + e);</span>
<span class="nc" id="L3002">				String validatorName = &quot;No hard validtors run yet&quot;;</span>
<span class="nc" id="L3003">				ValidationUtil.setHardValidationResult(reqAgg, e, validatorName);</span>
				//return ValidationUtil.setHardValidationResult(reqAgg, RmEjbBundleKey.REQ_UNEXPECTED_ERROR, validatorName);
			} finally {
<span class="nc bnc" id="L3006" title="All 6 branches missed.">				if (reqAggDAO != null) {</span>
<span class="nc" id="L3007">					reqAggDAO.cleanUp();</span>
				}
			}
		}
<span class="nc" id="L3011">	}</span>

	/**
     * Wrapper around the hardValidation logic.  Throws an exception if hard validation fails
     *
     * @param reqAgg
     * @param methodType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants
     * @param methodSubType see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @throws RmHardValidationException
     * @throws Exception
     */
    protected void doHardValidationsRaiseException(RequestAggregate reqAgg, int methodType,
        String methodSubType, boolean markInvalidOnHardValFail) throws RmHardValidationException {
<span class="nc" id="L3025">        ValidationResult result = doHardValidations(reqAgg, methodType, methodSubType, markInvalidOnHardValFail);</span>
<span class="nc bnc" id="L3026" title="All 2 branches missed.">        if ( result != null ) {</span>
<span class="nc" id="L3027">            throw RequestUtil.createRmHardValidationException(result, m_cat);</span>
        }
<span class="nc" id="L3029">    }</span>

    protected void doHardValidationsRaiseException(RequestAggregate reqAgg, int methodType,
            String methodSubType, boolean markInvalidOnHardValFail,boolean skipSomeHardValidationRules) throws RmHardValidationException {
<span class="nc" id="L3033">            ValidationResult result = doHardValidations(reqAgg, methodType, methodSubType, markInvalidOnHardValFail,skipSomeHardValidationRules);</span>
<span class="nc bnc" id="L3034" title="All 2 branches missed.">            if ( result != null ) {</span>
<span class="nc" id="L3035">                throw RequestUtil.createRmHardValidationException(result, m_cat);</span>
            }
<span class="nc" id="L3037">    }</span>

    protected void doHardValidationsRaiseException(RequestAggregate reqAgg, int methodType,
            String methodSubType, boolean markInvalidOnHardValFail, boolean skipSomeHardValidationRules, String newState) throws RmHardValidationException {
<span class="nc" id="L3041">            ValidationResult result = doHardValidations(reqAgg, methodType, methodSubType, markInvalidOnHardValFail, skipSomeHardValidationRules, newState);</span>
<span class="nc bnc" id="L3042" title="All 2 branches missed.">            if ( result != null ) {</span>
<span class="nc" id="L3043">                throw RequestUtil.createRmHardValidationException(result, m_cat);</span>
            }
<span class="nc" id="L3045">    }</span>
    /**
     * @param reqAgg
     * @param methodType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants
     * see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param methodSubType one of the constants similar to {@link RequestAuditTrail#STATUS_APPROVED STATUS_APPROVED}
     */

	private final void doSoftValidations(RequestAggregate reqAgg, int methodType, String methodSubType, boolean runNetStaffingSoftVal) {
<span class="nc" id="L3055">		doSoftValidations(reqAgg, methodType, methodSubType, runNetStaffingSoftVal, null,false);</span>
<span class="nc" id="L3056">	}</span>

	private final void doSoftValidations(RequestAggregate reqAgg, int methodType, String methodSubType, boolean runNetStaffingSoftVal,
			Set&lt;String&gt; validatorsToIgnore,boolean isForGroupAction) {

        /* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
         * If the validation alert for a request shows &quot;No soft validators run yet&quot;, it means
         * that an exception was thrown even before the first validator was run.  Check the log
         * for exception stack trace.
         * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
         */

<span class="nc" id="L3068">    	String validatorName = &quot;&quot;;</span>
<span class="nc bnc" id="L3069" title="All 4 branches missed.">		boolean handleForAnytimeTORequests = reqAgg.isAdvancedVTORequest() &amp;&amp; LicenseUtil.isAdvancedRMLicense();</span>
<span class="nc" id="L3070">		RequestAggregateDAO reqAggDAO = null;</span>
        try {
            // if no soft validations are necessary, simply return.
<span class="nc bnc" id="L3073" title="All 2 branches missed.">            if ( !reqAgg.isSoftValidationNeeded()) {</span>
<span class="nc" id="L3074">                return;</span>
            }

            // get the mandatory soft validators to be run.
<span class="nc" id="L3078">            ValidatorDescriptor[] softValDescMandArr = getSoftValidatorDescriptorsMandatory();</span>
<span class="nc bnc" id="L3079" title="All 2 branches missed.">            for (int i = 0; i &lt; softValDescMandArr.length; i++) {</span>
<span class="nc" id="L3080">                ValidatorDescriptor softValDescMand = softValDescMandArr[i];</span>

<span class="nc" id="L3082">                boolean validatorApplied = checkIfValidatorApplies(reqAgg, softValDescMand, methodType, methodSubType);</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">                if (!validatorApplied) {</span>
<span class="nc" id="L3084">                    continue;</span>
                }

<span class="nc" id="L3087">                validatorName = softValDescMand.getName();</span>
<span class="nc" id="L3088">                ValidationUtil.doValidation(validatorName, reqAgg, validatorMap);</span>

<span class="nc bnc" id="L3090" title="All 2 branches missed.">                if (isValidatorRemoveFromCache(validatorName)) {</span>
<span class="nc" id="L3091">					validatorMap.remove(validatorName);</span>
				}
            }

            // get the configured validators (in the suite using the UI)

<span class="nc" id="L3097">			Collection&lt;String&gt; validators = reqAgg.getValidationCache().getValidators();</span>
<span class="nc bnc" id="L3098" title="All 2 branches missed.">			for (Iterator&lt;String&gt; it = validators.iterator(); it.hasNext();) {</span>
            	// Run the validations
<span class="nc" id="L3100">				validatorName = it.next();</span>

<span class="nc bnc" id="L3102" title="All 4 branches missed.">				if (validatorsToIgnore != null &amp;&amp; validatorsToIgnore.contains(validatorName)) {</span>
<span class="nc" id="L3103">					continue;</span>
				}

<span class="nc bnc" id="L3106" title="All 2 branches missed.">				if (shouldRunValidator(validatorName, runNetStaffingSoftVal, handleForAnytimeTORequests)) {</span>
<span class="nc" id="L3107">					ValidationUtil.doValidation(validatorName, reqAgg, validatorMap);</span>
				}
				// No need to run remaining soft rules if one of them is failed
<span class="nc bnc" id="L3110" title="All 4 branches missed.">				if(isForGroupAction&amp;&amp;!reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L3111">					break;</span>
				}
				//clear the cached validators if needed
<span class="nc bnc" id="L3114" title="All 2 branches missed.">				if (isValidatorRemoveFromCache(validatorName)) {</span>
<span class="nc" id="L3115">					validatorMap.remove(validatorName);</span>
				}
            }

<span class="nc bnc" id="L3119" title="All 4 branches missed.">			if (reqAgg.isTimeOffRequest() &amp;&amp; !reqAgg.isFlexTimeRequest()) {</span>
<span class="nc" id="L3120">            	reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L3121">            	markRequestViolateSpecialRulesAsInValidIfNeeded(reqAgg,reqAggDAO);</span>
            }



<span class="nc" id="L3126">        } catch ( Exception e ) {</span>
            // we log this with priority 'error' since only unexpected exceptions are thrown by the validation
            // rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
//        	change it to info since it was cluttering the log file
<span class="nc" id="L3130">			m_cat.info(&quot;Translating Exception to Validation result: &quot; + e.getLocalizedMessage());</span>

			//exception maybe thrown even before the first soft validator is run
<span class="nc bnc" id="L3133" title="All 2 branches missed.">            ValidationUtil.setSoftValidationResult(reqAgg, e,</span>
            	(validatorName != null)?validatorName:&quot;ExceptionCaughtBeforeSoftValStart&quot;);
        } finally {
<span class="nc bnc" id="L3136" title="All 8 branches missed.">        	if(reqAggDAO != null){</span>
<span class="nc" id="L3137">        		reqAggDAO.cleanUp();</span>
        	}
        }
<span class="nc" id="L3140">    }</span>

	private boolean shouldRunValidator(String validatorName, boolean runNetStaffingSoftVal, boolean handleForAnytimeTORequests) {
<span class="nc bnc" id="L3143" title="All 2 branches missed.">		if (validatorName.contains(&quot;NetStaffingValidationRule&quot;)) {</span>
<span class="nc" id="L3144">			return runNetStaffingSoftVal;</span>
		}
		//For anytime TO Requests, the soft process should skip 3 special validation rules and only run other applicable rules
<span class="nc bnc" id="L3147" title="All 4 branches missed.">		return !handleForAnytimeTORequests || !specialRulesForAnytimeTimeOffRequest(validatorName);</span>
	}



   /**
    * If a validator needs to be removed from the caches map
    * Add validator name here
    * */
    private boolean isValidatorRemoveFromCache(String validatorName){
<span class="nc" id="L3157">		return doNotCacheValidatorNames.containsKey(validatorName);</span>
    }

	private static ConcurrentMap&lt;String, Boolean&gt; getDoNotCacheValidatorNames() {
<span class="nc" id="L3161">		ConcurrentMap&lt;String, Boolean&gt; map = new ConcurrentHashMap&lt;String, Boolean&gt;();</span>
<span class="nc" id="L3162">		map.put(ComplyMinRequiredPayPeriodHoursRuleTimeOff.class.getName(), true);</span>
<span class="nc" id="L3163">		map.put(AvaliableHoursValidationRule.class.getName(), true);</span>
<span class="nc" id="L3164">		map.put(TimeOffRequestsPerQuarterValidationRule.class.getName(), true);</span>
<span class="nc" id="L3165">		return map;</span>
	}

	/**
	 * For advance VTO requests: Late Start, Early Off or anytime Off
	 * 3 rules : &quot;Time Off Pool has available time off hours&quot;, &quot;Requested time off is not being swapped&quot;
	 * and &quot;Scheduled calendar event activities that the requests avoids&quot;
	 * should be skipped upon save but should be executed during approval process
	 */
    private boolean specialRulesForAnytimeTimeOffRequest(String validatorName){
<span class="nc bnc" id="L3175" title="All 4 branches missed.">    	return validatorName.contains(&quot;AvaliableHoursValidationRule&quot;)||validatorName.contains(&quot;AvoidCalendarEventsValidationRule&quot;)</span>
<span class="nc bnc" id="L3176" title="All 2 branches missed.">    			||validatorName.contains(&quot;ComplyMinRequiredPayPeriodHoursRuleTimeOff&quot;);</span>
    }

	/**
	 * This method checks whether the user has privilege to perform this operation.
	 *
	 * @param request
	 *            The request that is being acted on.
	 * @param user
	 *            The currently logged on user.
	 * @param newState
	 *            The new state of the request.
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the user has the required privileges.
	 */
	protected void checkUpdatePrivilege(User userBasic, RequestAggregate reqAgg, String newState)
			throws Exception {
<span class="nc bnc" id="L3192" title="All 2 branches missed.">		if (!RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L3193">			return; // if running outside container, no privilege check done.</span>
		}

<span class="nc" id="L3196">		ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(reqAgg.getEmployeeID());</span>
<span class="nc" id="L3197">		String oldState = reqAgg.getRequestStatus();</span>

<span class="nc bnc" id="L3199" title="All 2 branches missed.">		boolean stateTrans = !oldState.equals(newState);</span>

		// the special checks use different privileges that can be granted without modify privilege so return immediately
<span class="nc bnc" id="L3202" title="All 4 branches missed.">		if (stateTrans &amp;&amp; RequestAuditTrail.APPROVE_DENY_STATES.contains(newState)) {</span>
<span class="nc" id="L3203">			checkApproveDenyTransPriv(userBasic, reqAgg, oldState, newState, orgID);</span>
<span class="nc" id="L3204">			return;</span>
		}

<span class="nc bnc" id="L3207" title="All 4 branches missed.">		if (stateTrans &amp;&amp; newState.equals(RequestAuditTrail.STATUS_ESCALATED)) {</span>
<span class="nc" id="L3208">			checkEscalateTransPriv(userBasic, reqAgg, oldState, newState, orgID);</span>
<span class="nc" id="L3209">			return;</span>
		}

<span class="nc" id="L3212">		checkModifyPrivilege(userBasic, reqAgg, oldState, newState, orgID);</span>
<span class="nc" id="L3213">	}</span>

	/**
	 * //////////////////////////////////////////////////////////////////////
	 * SSReqMgr overrides this method with its own version
	 * //////////////////////////////////////////////////////////////////////
	 *
	 * @param userBasic
	 * @param reqAgg
	 * @param oldState
	 * @param newState
	 * @param orgID
	 * @throws Exception
	 */
	protected void checkModifyPrivilege(User userBasic, RequestAggregate reqAgg, String oldState,
			String newState, ID orgID) throws Exception {

<span class="nc" id="L3230">		RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L3231">		secMgr.assertCanModifyRequest(userBasic, reqAgg, newState);</span>
<span class="nc" id="L3232">	}</span>

	/**
	 * Checks to make sure the current user can modify the request. This does not check if the action can be performed
	 * or if new state is valid.
	 */
	protected void checkChangeRequestStatePrivilege(ID reqID, String newState) throws Exception {
<span class="nc" id="L3239">		RequestAggregate request = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>
<span class="nc" id="L3240">		User user = getUser();</span>

<span class="nc" id="L3242">		RmSecurityManager secMgr = RmSecurityManager.create(request);</span>
<span class="nc" id="L3243">		secMgr.assertChangeRequestState(user, request, newState);</span>
<span class="nc" id="L3244">	}</span>

	/**
	 * @param userBasic
	 * @param reqAgg
	 * @param oldState
	 * @param newState
	 * @param orgID
	 * @throws Exception
	 */
	protected void checkEscalateTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
			String newState, ID orgID) throws Exception {

<span class="nc" id="L3257">		RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L3258">		secMgr.assertCanEscalateRequest(userBasic, reqAgg, newState);</span>
<span class="nc" id="L3259">	}</span>

	/**
	 * //////////////////////////////////////////////////////////////////////////
	 * SSReqMgr overrides this method with its own version.
	 * //////////////////////////////////////////////////////////////////////////
	 *
	 * @param userBasic
	 * @param reqAgg
	 * @param oldState
	 * @param newState
	 * @param orgID
	 * @throws Exception
	 */
	protected void checkApproveDenyTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
			String newState, ID orgID) throws Exception {

<span class="nc" id="L3276">		RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L3277">		secMgr.assertCanApproveDenyRequest(userBasic, reqAgg, newState);</span>
<span class="nc" id="L3278">	}</span>

	protected abstract ID getPrivIDPurge();

    /**
     * Represents a state transition validation result.
     *
     * Title:        Blue Pumpkin Software Request Management Module
     * Copyright:    Copyright (c) 2001-2004
     * Company:      Blue Pumpkin Software, inc
     * @author       Raja Rajendran
     */
    public static class StateTransValResult {
        // invalid transistion.
        protected static final int TRANSITION_RESULT_INVALID = 1;
        // valid transistion.
        protected static final int TRANSITION_RESULT_VALID = 2;
        // no transition necessary: 'from' status and to 'status' are the same.  For instance
        // 'approved' to 'approved'.  In some cases, this is an error. In some it is not.
        protected static final int TRANSITION_RESULT_NOTRANSITIONNECESSARY = 3;

        // one of the above constants.
        int m_transitionResult;
        // if transition is invalid, an exception with a localized message describing why.
        public RmHardValidationException m_RmHardValidationException;

<span class="nc" id="L3304">        StateTransValResult(int transitionResult, RmHardValidationException e) {</span>
<span class="nc" id="L3305">            m_transitionResult = transitionResult;</span>
<span class="nc" id="L3306">            m_RmHardValidationException = e;</span>
<span class="nc" id="L3307">        }</span>

        public boolean isTransitionValid() {
<span class="nc bnc" id="L3310" title="All 2 branches missed.">            return m_transitionResult == TRANSITION_RESULT_VALID;</span>
        }

        public boolean isTransitionInValid() {
<span class="nc bnc" id="L3314" title="All 2 branches missed.">            return m_transitionResult == TRANSITION_RESULT_INVALID;</span>
        }

        public boolean isTransitionNotNecessary() {
<span class="nc bnc" id="L3318" title="All 2 branches missed.">            return m_transitionResult == TRANSITION_RESULT_NOTRANSITIONNECESSARY;</span>
        }
    }

    /**
     * Determines whether the transition from oldState to newState is a
     * valid state transition. The class variable &lt;tt&gt;RequestAuditTrail.VALID_TRANSITION_MAP&lt;/tt&gt;
     * is a Map: oldState -&gt; array of new states. If the newState is in the
     * array, the transition is valid.
     *
     * @param oldState the existing requeststatus
     * @param newState the new requeststatus
     * @return returns a {@link StateTransValResult StateTransValResult} object.
     */
    protected StateTransValResult validStateTransition(RequestAggregate reqAgg, String newState) {
<span class="nc" id="L3333">        ID reqID = reqAgg.getID();</span>
<span class="nc" id="L3334">		String oldState = reqAgg.getRequestStatus();</span>

        // if oldstate == newstate is handled my the state transistion change map.  For some states
        // (the non terminal states), change to the same state is not allowed. For others it is.
//        if (oldState.equals(newState)) {
//            return new StateTransValResult(
//                StateTransValResult.TRANSITION_RESULT_NOTRANSITIONNECESSARY,
//                RequestUtil.createRmHardValidationException( RmEjbBundleKey.CANNOT_TRANSITION_STATUS,
//                    new Object[] { reqID, oldState, newState}, m_cat));
//        }

		// if oldstate is a final state, can't transition
<span class="nc bnc" id="L3346" title="All 2 branches missed.">		if (RequestAuditTrail.VALID_FINAL_STATES.contains(oldState)) {</span>
			// m_cat == null to prevent exception logging. The caller will log the exception if necessary.
<span class="nc" id="L3348">			return new StateTransValResult(</span>
					StateTransValResult.TRANSITION_RESULT_INVALID,
<span class="nc" id="L3350">					RequestUtil.createAndLogRmHardValidationException(</span>
							RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,
							RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS,
							new Object[] { oldState, newState, reqID },
							m_cat));
		}

<span class="nc bnc" id="L3357" title="All 2 branches missed.">        if ( reqAgg.hasExpired() ) {</span>
            //m_cat == null to prevent exception logging.  The caller will log the exception if necessary.
<span class="nc" id="L3359">            return new StateTransValResult(</span>
                StateTransValResult.TRANSITION_RESULT_INVALID,
<span class="nc" id="L3361">                RequestUtil.createAndLogRmHardValidationException(</span>
										RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,
										RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS,
                    new Object[] {&quot;expired&quot;, newState, reqID},
										m_cat));
        }

        // if no new states are defined.
<span class="nc" id="L3369">        String[] validNextStatesArr = (String[]) RequestAuditTrail.VALID_TRANSITION_MAP.get(oldState);</span>
//        if (validNextStatesArr == null) {
        //m_cat == null to prevent exception logging.  The caller will log the exception if necessary.
//            return new StateTransitionValidationResult(
//                StateTransitionValidationResult.TRANSITION_RESULT_INVALID,
//                RequestUtil.createRmHardValidationException( RmEjbBundleKey.CANNOT_TRANSITION_STATUS,
//                    new Object[] { reqID, oldState, newState}, null));
//        }

        //If Flex Time request, remove invalid states for flex time
<span class="nc bnc" id="L3379" title="All 2 branches missed.">        if(reqAgg.isFlexTimeRequest()) {</span>
<span class="nc" id="L3380">        	Collection&lt;String&gt; flexTimeNewStates = new ArrayList&lt;String&gt;(Arrays.asList(validNextStatesArr));</span>
        	//Keep only possible flex time states
<span class="nc" id="L3382">        	flexTimeNewStates.retainAll(RequestAuditTrail.FT_POSSIBLE_STATES);</span>
<span class="nc" id="L3383">        	validNextStatesArr = flexTimeNewStates.toArray(new String[flexTimeNewStates.size()]);</span>
        }

        //todo: use hash for efficiency
        // search if newState is in the list of possible transitions from old state
<span class="nc" id="L3388">        int i = 0;</span>
<span class="nc bnc" id="L3389" title="All 4 branches missed.">        for (i = 0; validNextStatesArr != null &amp;&amp; i &lt; validNextStatesArr.length; i++) {</span>
<span class="nc bnc" id="L3390" title="All 2 branches missed.">            if (validNextStatesArr[i].equals(newState)) {</span>
<span class="nc" id="L3391">				break;</span>
			}
        }
        // if transition is not valid.
<span class="nc bnc" id="L3395" title="All 4 branches missed.">		if (validNextStatesArr == null || i == validNextStatesArr.length) {</span>
			// m_cat == null to prevent exception logging. The caller will log the exception if necessary.
<span class="nc" id="L3397">			return new StateTransValResult(</span>
					StateTransValResult.TRANSITION_RESULT_INVALID,
<span class="nc" id="L3399">					RequestUtil.createAndLogRmHardValidationException(</span>
							RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,
							RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS,
							new Object[] { oldState, newState, reqID },
							m_cat));
		}

<span class="nc" id="L3406">        return new StateTransValResult(StateTransValResult.TRANSITION_RESULT_VALID, null);</span>
    }

	protected void checkStateTransitionAndUpdatePrivilege(RequestAggregate reqAgg, String newState, boolean suppressPrivilegeChecking)
			throws Exception {
		// validatate state transition.
<span class="nc" id="L3412">		StateTransValResult stateTransValResult = validStateTransition(reqAgg, newState);</span>
<span class="nc bnc" id="L3413" title="All 2 branches missed.">		if (!stateTransValResult.isTransitionValid()) {</span>
<span class="nc" id="L3414">			throw stateTransValResult.m_RmHardValidationException;</span>
		}

		// check if user has privilege.
<span class="nc bnc" id="L3418" title="All 2 branches missed.">		if (!suppressPrivilegeChecking) {</span>
<span class="nc" id="L3419">			checkUpdatePrivilege(RequestUtil.getLoginUserBasic(m_sessionContext), reqAgg, newState);</span>
		}
<span class="nc" id="L3421">	}</span>

    protected abstract RequestAggregateDAO getDAO(long detailLevel);

    /**
     * The type of Request this manager handles.  Returns one of
     * {@link Request#REQUESTTYPE_SHIFTBID REQUESTTYPE_SHIFTBID},
     * {@link Request#REQUESTTYPE_SHIFTSWAP REQUESTTYPE_SHIFTSWAP},
     * {@link Request#REQUESTTYPE_TIMEOFF REQUESTTYPE_TIMEOFF}
     *
     * @return
     */
    protected abstract String getRequestType();

    /**
     * @param reqAgg
     */
    protected void assignDefaultsForReqAgg(RequestAggregate reqAgg) {
<span class="nc bnc" id="L3439" title="All 2 branches missed.">        if ( StringUtil.isEmpty(reqAgg.getRequestStatus()) ) {</span>
<span class="nc" id="L3440">			reqAgg.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>
		}
<span class="nc" id="L3442">    }</span>

    /**
     * @return
     */
    protected long getDetailLevelForValidation()  {
<span class="nc" id="L3448">        return RequestAggregate.getDetailLevelForValidation(getRequestType());</span>
    }

    /**
     * This method should not throw any exceptions to ensure that the current transaction
     * is not aborted because notification failed.
     *
     * @param reqStatusToCheck
     * @param reqAgg
     * @param statusChangeType
     */
    protected void fireReqStatusChangeNotificationIfNecessary(String reqStatusToCheck, RequestAggregate reqAgg) {
        try {
<span class="nc bnc" id="L3461" title="All 2 branches missed.">            if (reqAgg.getRequestStatus().equals(reqStatusToCheck)) {</span>
<span class="nc" id="L3462">                m_cat.debug(&quot;Firing request change notification: reqAgg.ID, reqType, newStatus == &quot; +</span>
<span class="nc" id="L3463">                    reqAgg.getID() + ',' + reqAgg.getRequestType() + ',' + reqStatusToCheck);</span>

<span class="nc" id="L3465">                JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, reqStatusToCheck));</span>
            }
<span class="nc" id="L3467">        } catch (Exception e) {</span>
<span class="nc" id="L3468">            m_cat.l7dError(RmEjbLogBundleKey.EXCEPTION_CAUGHT_NOT_PROPOGATED, e);</span>
<span class="nc" id="L3469">        }</span>
<span class="nc" id="L3470">    }</span>

    /**
     * Default implementation if the request is associated with a single employee.
     * Exception is a SS Request which is associated with two employees.
     *
     * @param requestId
     * @param reqAggDAO
     * @return
     * @throws BbmFinderException
     * @throws BbmObjectNotFoundException
     */
	protected List&lt;ID&gt; getCurrentOrgIDsForReqID(ID requestId, RequestAggregateDAO reqAggDAO)
			throws
        BbmFinderException, BbmObjectNotFoundException {

<span class="nc" id="L3486">        RequestAggregateDAO localReqAggDAO = null;</span>
        try  {
<span class="nc" id="L3488">            long detailLevel = RequestAggregate.DL_BASIC;</span>
<span class="nc bnc" id="L3489" title="All 2 branches missed.">            localReqAggDAO = (reqAggDAO == null)?getDAO(detailLevel):reqAggDAO;</span>
<span class="nc" id="L3490">            Request req = localReqAggDAO.getRequestByID(requestId, detailLevel).getAggregatedRequest();</span>
<span class="nc" id="L3491">            ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(req.getEmployeeID());</span>
<span class="nc" id="L3492">            return Collections.singletonList(orgID);</span>
        } finally  {
<span class="nc bnc" id="L3494" title="All 4 branches missed.">            if (localReqAggDAO != null) {</span>
<span class="nc" id="L3495">				localReqAggDAO.cleanUp();</span>
			}
        }
    }

    /**
     * @param reqAgg
     * @param comment
     * @param reqAggDAO
     * @throws Exception
     */
    protected void invalidateRequestAndFireNotification(RequestAggregate reqAgg, String comment,
                                                        RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L3508">	    reqAgg.setRequestStatus(RequestAuditTrail.STATUS_INVALID);</span>
<span class="nc" id="L3509">	    reqAggDAO.updateRequest(reqAgg, comment, RequestUtil.getBPSuperUser());</span>
<span class="nc" id="L3510">	    invalidateRequestPostProcess(reqAggDAO.getDMO(), reqAgg, comment);</span>
<span class="nc" id="L3511">    }</span>

	protected  void invalidateRequestPostProcess(Jdmo jdmo, RequestAggregate reqAgg, String comment)throws BbmUpdateException{
<span class="nc" id="L3514">		fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_INVALID, reqAgg);</span>
<span class="nc" id="L3515">	}</span>

    /**
     * @param sortDir
     * @return
     */
    public String invertSortDir(String sortDir) {
<span class="nc bnc" id="L3522" title="All 6 branches missed.">        assert RequestUtil.SORTDIR_ASC.equalsIgnoreCase(sortDir) || RequestUtil.SORTDIR_DESC.equalsIgnoreCase(sortDir):</span>
            &quot;sortDir != ASC or DESC&quot;;

<span class="nc bnc" id="L3525" title="All 2 branches missed.">        return sortDir.equalsIgnoreCase(RequestUtil.SORTDIR_ASC)?RequestUtil.SORTDIR_DESC:RequestUtil.SORTDIR_ASC;</span>
    }

	@Override
	public boolean isRequestEligibleForWaitlist(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3530">		return false;</span>
	}
    //All the Request Choices are auto processed only for Time Off Requests
    public boolean isProcessAllTimeRangePairs(RequestAggregate reqAgg){
<span class="nc" id="L3534">        boolean returnVal=false;</span>
<span class="nc bnc" id="L3535" title="All 2 branches missed.">        if(reqAgg.isTimeOffRequest()){</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">            if(reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_PENDING)){</span>
<span class="nc" id="L3537">                returnVal= true;</span>
            }
        }
<span class="nc" id="L3540">         return returnVal;</span>
    }


    @Override
	public boolean _autoProcessWithdraw(RequestAggregate reqAgg, String comment, boolean loadedFromDB)
            throws BbmUpdateException, RmHardValidationException {
<span class="nc" id="L3547">        String _method_ = &quot;_autoProcessWithdraw&quot;;</span>
<span class="nc" id="L3548">        methodStart(_method_, reqAgg, comment);</span>
        // AutoProcessing of Withdraw is currently done for Approved TO requests only.
<span class="nc" id="L3550">        TORequest toRequest = null;</span>
<span class="nc bnc" id="L3551" title="All 2 branches missed.">        if (reqAgg.isTimeOffRequest()) {</span>
<span class="nc" id="L3552">            toRequest = (TORequest) reqAgg;</span>
        }
        //Only TO Requests that can be Auto Rejected and Accepted will be processed.
<span class="nc bnc" id="L3555" title="All 4 branches missed.">        if (toRequest == null || !toRequest.isEligibleForAcceptAndRejectWithdrawAction()) {</span>
<span class="nc" id="L3556">            return false;</span>
        }
<span class="nc bnc" id="L3558" title="All 2 branches missed.">        comment = (comment == null) ? &quot;&quot; : comment;</span>
<span class="nc" id="L3559">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3560">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L3562">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>


<span class="nc" id="L3565">            Map ruleNameToValResultsMap = new HashMap(19);</span>
<span class="nc" id="L3566">			boolean result = false;</span>

<span class="nc bnc" id="L3568" title="All 2 branches missed.">			for (TOChoice choice : toRequest.getApprovedChoices()) {</span>

<span class="nc" id="L3570">				Collection[] apprDenyValResults1 = new Collection[3];</span>
<span class="nc" id="L3571">				TimeRange timeRange = new TimeRange(choice.getStartDate(), choice.getEndDate());</span>
<span class="nc" id="L3572">				int[] apprDenyResult1 = runAutoProcessForTimeRange(toRequest.getEmployeeID(), timeRange,</span>
						true, true, apprDenyValResults1, reqAgg, ruleNameToValResultsMap);
				// If both approve and deny are set to true, the results are ambiguous,
				// and no auto approval or auto denial should be done in this case.
<span class="nc" id="L3576">				return processAutoProcessResult(reqAgg, comment, loadedFromDB, apprDenyValResults1, apprDenyResult1);</span>

			}

<span class="nc" id="L3580">			return result;</span>

<span class="nc" id="L3582">        } catch (RmHardValidationException e) {</span>
<span class="nc" id="L3583">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L3584">            throw e;</span>
<span class="nc" id="L3585">        } catch (BbmUpdateException e) {</span>
<span class="nc" id="L3586">            m_cat.error(e, e);</span>
<span class="nc" id="L3587">            handleException(e);</span>
<span class="nc" id="L3588">            throw e;</span>
<span class="nc" id="L3589">        } catch (Exception e) {</span>
<span class="nc" id="L3590">            handleException(e);</span>
<span class="nc" id="L3591">            throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L3593" title="All 6 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L3594">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L3596">            methodFinish();</span>
        }
    }

	private boolean processAutoProcessResult(RequestAggregate reqAgg, String comment, boolean loadedFromDB,
			Collection[] apprDenyValResults1, int[] apprDenyResult1) throws Exception {

<span class="nc" id="L3603">		ValidationCache vc = reqAgg.getValidationCache();</span>

<span class="nc bnc" id="L3605" title="All 4 branches missed.">		if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS &amp;&amp;</span>
		        apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {
			//Conflict. No violations found for the auto approve (so should approve), but found violations for auto deny (so should deny)
<span class="nc" id="L3608">		    m_cat.l7dInfo(RmEjbLogBundleKey.APPROVE_DENY_AMBIGUOUS, new Object[]{reqAgg.getID()});</span>
<span class="nc" id="L3609">		    return false;</span>
		}
<span class="nc" id="L3611">		StringBuilder commentBuf = new StringBuilder(comment);</span>

<span class="nc bnc" id="L3613" title="All 2 branches missed.">		if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS) {</span>
			// approve the request (did not find any violations that would prevent auto approval)

		    // Setting status to 'approved' will trigger an exception (during status transition validation)
		    // with the message &quot;cannot change status from 'approved' to 'approved'&quot;,
		    // when  _approveRequest() is called below.
<span class="nc" id="L3619">		    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GEN_END_OF_SENTENCE_DELIM) +</span>
<span class="nc" id="L3620">		            RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_ACCEPTED));</span>
<span class="nc" id="L3621">		    _acceptWithdrawOfApprovedRequestWorkFlow(reqAgg, null, commentBuf.toString(), true, loadedFromDB);</span>
<span class="nc" id="L3622">		    return true;</span>
<span class="nc bnc" id="L3623" title="All 2 branches missed.">		} else if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {</span>
			//deny the request (found violations that trigger auto deny)

		    // Setting status to 'denied' will trigger an exception (during status transition validation)
		    // with the message &quot;cannot change status from 'denied' to 'denied'&quot;,
		    // when  _denyRequest() is called below.
<span class="nc" id="L3629">		    commentBuf.append(&quot;\n &quot; + RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_REJECTED));</span>
<span class="nc" id="L3630">		    ValidationResult valResult = (ValidationResult) apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].iterator().next();</span>
<span class="nc" id="L3631">		    commentBuf.append(&quot;\n &quot; + valResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), vc.getTimeZoneForOrg()));</span>
<span class="nc" id="L3632">		    _rejectWithdrawOfApprovedRequestWorkFlow(reqAgg, commentBuf.toString(), true, loadedFromDB);</span>
<span class="nc" id="L3633">		    return true;</span>
		} else {
			//keep status pending if no decision can be made and exit the loop
<span class="nc" id="L3636">			return false;</span>
		}
	}

    /** applies to Withdrawal of approved Requests
     *
     * @param reqAgg
     *
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _acceptWithdrawOfApprovedRequestWorkFlow(RequestAggregate reqAgg, ID choiceID, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc bnc" id="L3651" title="All 2 branches missed.">        if(_acceptWithdrawOfApprovedRequest(reqAgg, comment, suppressPrivilegeChecking, loadedFromDB)){</span>
            //fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_WITHDRAWN, reqAgg);
        }
<span class="nc" id="L3654">    }</span>

    /**applies to Withdrawal of approved Requests
     * @param reqAgg
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected  boolean _acceptWithdrawOfApprovedRequest(RequestAggregate reqAgg,String comment,
                                             boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception{
<span class="nc" id="L3665">        return false;</span>
    }
    protected void _rejectWithdrawOfApprovedRequestWorkFlow(RequestAggregate reqAgg, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc bnc" id="L3669" title="All 2 branches missed.">        if(_rejectWithdrawOfApprovedRequest(reqAgg, comment, suppressPrivilegeChecking, loadedFromDB)){</span>
            //fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_WITHDRAW_REJECT, reqAgg);
        }
<span class="nc" id="L3672">    }</span>

    /**applies to rejecting Withdrawal of approved Requests
     * @param reqAgg
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected  boolean _rejectWithdrawOfApprovedRequest(RequestAggregate reqAgg,String comment,
                                             boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception{
<span class="nc" id="L3683">        return false;</span>
    }

    @Override
	public boolean acceptWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment) throws RmHardValidationException, RmException {
<span class="nc" id="L3688">		String _method_ = &quot;acceptWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L3689">		methodStart(_method_, reqAgg, comment);</span>
<span class="nc" id="L3690">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3691">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3693">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3695">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L3696">			secMgr.assertAllowedAction(getUser(), reqAgg, RequestAction.ACCEPT_WITHDRAWAL, RequestAuditTrail.STATUS_WITHDRAW_ACCEPT);</span>

<span class="nc bnc" id="L3698" title="All 2 branches missed.">			if (isEligibleForAcceptWithdrawOfApprovedRequest(reqAgg)) {</span>
<span class="nc" id="L3699">				return _acceptWithdrawOfApprovedRequest(reqAgg, comment, false, false);</span>
			}
<span class="nc" id="L3701">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L3702">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L3703">			throw e;</span>
<span class="nc" id="L3704">		} catch (RmException e) {</span>
<span class="nc" id="L3705">			m_cat.error(e, e);</span>
<span class="nc" id="L3706">			handleException(e);</span>
<span class="nc" id="L3707">			throw e;</span>
<span class="nc" id="L3708">		} catch (Exception e) {</span>
<span class="nc" id="L3709">			handleException(e);</span>
<span class="nc" id="L3710">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3712" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3713">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L3715">			methodFinish();</span>
<span class="nc" id="L3716">		}</span>
<span class="nc" id="L3717">		return false;</span>
	}
    //Check if request is eligible for accepting the withdraw  overridden in TORequestManagerEJB
    protected boolean isEligibleForAcceptWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3721">        return false;</span>
    }

    //Check if request is eligible for rejecting the withdraw, overridden in TORequestManagerEJB
    protected boolean isEligibleForRejectWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3726">        return false;</span>
    }
    @Override
	public boolean rejectWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment) throws RmHardValidationException, RmException {
<span class="nc" id="L3730">		String _method_ = &quot;rejectWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L3731">		methodStart(_method_, reqAgg, comment);</span>
<span class="nc" id="L3732">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3733">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3735">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3737">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L3738">			secMgr.assertAllowedAction(getUser(), reqAgg, RequestAction.REJECT_WITHDRAWAL, RequestAuditTrail.STATUS_WITHDRAW_REJECT);</span>

<span class="nc bnc" id="L3740" title="All 2 branches missed.">			if (isEligibleForRejectWithdrawOfApprovedRequest(reqAgg)) {</span>
<span class="nc" id="L3741">				return _rejectWithdrawOfApprovedRequest(reqAgg, comment, false, false);</span>
			}
<span class="nc" id="L3743">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L3744">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L3745">			throw e;</span>
<span class="nc" id="L3746">		} catch (RmException e) {</span>
<span class="nc" id="L3747">			m_cat.error(e, e);</span>
<span class="nc" id="L3748">			handleException(e);</span>
<span class="nc" id="L3749">			throw e;</span>
<span class="nc" id="L3750">		} catch (Exception e) {</span>
<span class="nc" id="L3751">			handleException(e);</span>
<span class="nc" id="L3752">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3754" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3755">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L3757">			methodFinish();</span>
<span class="nc" id="L3758">		}</span>
<span class="nc" id="L3759">		return false;</span>
	}

	@Override
	public boolean requestWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment)
			throws BbmUpdateException, RmHardValidationException {
<span class="nc" id="L3765">		String methodName = &quot;requestWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L3766">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
			// enforce security so callers do not reveal any data to unauthorized users
<span class="nc" id="L3769">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L3770">			secMgr.assertAllowedAction(getUser(), reqAgg, RequestAction.REQUEST_WITHDRAW, RequestAuditTrail.STATUS_WITHDRAW_REQUEST);</span>
<span class="nc" id="L3771">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L3772">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L3773">			throw e;</span>
<span class="nc" id="L3774">		} catch (Exception e) {</span>
<span class="nc" id="L3775">			handleException(e);</span>
<span class="nc" id="L3776">			throw new BbmUpdateException(e.getMessage());</span>
		} finally {
<span class="nc" id="L3778">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L3779">		}</span>
<span class="nc" id="L3780">		return false;</span>
	}

    //Check if request is eligible for Cancelling the withdraw, overridden in TORequestManagerEJB
    protected boolean isEligibleForCancelWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3785">        return false;</span>
    }

	@Override
	public boolean cancelWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment)
			throws RmHardValidationException, RmException {
<span class="nc" id="L3791">		String _method_ = &quot;cancelWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L3792">		methodStart(_method_, reqAgg, comment);</span>
<span class="nc" id="L3793">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3794">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3796">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3798">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L3799">			secMgr.assertAllowedAction(getUser(), reqAgg, RequestAction.CANCEL_WITHDRAWAL, RequestAuditTrail.STATUS_WITHDRAW_CANCEL);</span>

<span class="nc bnc" id="L3801" title="All 2 branches missed.">			if (isEligibleForCancelWithdrawOfApprovedRequest(reqAgg)) {</span>
<span class="nc" id="L3802">				return _cancelWithdrawOfApprovedRequest(reqAgg, comment, false, false);</span>
			}
<span class="nc" id="L3804">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L3805">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L3806">			throw e;</span>
<span class="nc" id="L3807">		} catch (RmException e) {</span>
<span class="nc" id="L3808">			m_cat.error(e, e);</span>
<span class="nc" id="L3809">			handleException(e);</span>
<span class="nc" id="L3810">			throw e;</span>
<span class="nc" id="L3811">		} catch (Exception e) {</span>
<span class="nc" id="L3812">			handleException(e);</span>
<span class="nc" id="L3813">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3815" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3816">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L3818">			methodFinish();</span>
<span class="nc" id="L3819">		}</span>
<span class="nc" id="L3820">		return false;</span>
	}

    /**applies to Cancelling Withdrawal of approved Requests
     * @param reqAgg
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected  boolean _cancelWithdrawOfApprovedRequest(RequestAggregate reqAgg,String comment,
                                             boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception{
<span class="nc" id="L3832">        return false;</span>
    }

    /*
    returns
    0= Pending
    1= Pending
    */
    public String getDecisionBasedOnAutProcessRuleEngineResult(RequestAggregate reqAgg, int[] apprDenyResult1, Collection[] apprDenyValResults1, boolean checkForWaitlist) throws BbmException {
<span class="nc" id="L3841">        String requestStatus = RequestAuditTrail.STATUS_PENDING;</span>
        //ambiguous results Check
        // for time off requests ignore the ambiguous results (done for the Waitlist feature)
<span class="nc bnc" id="L3844" title="All 2 branches missed.">        if (!ignoreAmbiguousAutoProcessResults(reqAgg)) {</span>
            // If both approve and deny are set to true, the results are ambiguous,
            // and no auto approval or auto denial should be done in this case.
<span class="nc bnc" id="L3847" title="All 4 branches missed.">            if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS &amp;&amp;</span>
                    apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {
<span class="nc" id="L3849">                m_cat.l7dInfo(RmEjbLogBundleKey.APPROVE_DENY_AMBIGUOUS, new Object[]{reqAgg.getID()});</span>
<span class="nc" id="L3850">                return requestStatus;</span>
            }
        }
<span class="nc bnc" id="L3853" title="All 2 branches missed.">        if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS) {</span>
            // Setting status to 'approved' will trigger an exception (during status transition validation)
            // with the message &quot;cannot change status from 'approved' to 'approved'&quot;,
            // when  _approveRequest() is called below.
            //reqAgg.setRequestStatus(RequestAuditTrail.STATUS_APPROVED);
<span class="nc" id="L3858">            return RequestAuditTrail.STATUS_APPROVED;</span>
          // will not check for Waitlist criteria if the Waitlist preferences are not set.
<span class="nc bnc" id="L3860" title="All 4 branches missed.">        } else if (checkForWaitlist&amp;&amp;canRequestBeWaitlistedBasedOnValidations(apprDenyResult1, apprDenyValResults1)) {</span>
<span class="nc" id="L3861">            return RequestAuditTrail.STATUS_WAITLIST; //this returns only if request can be waitlisted ; does not check for user preferences.</span>
<span class="nc bnc" id="L3862" title="All 2 branches missed.">        } else if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {</span>
<span class="nc" id="L3863">            return RequestAuditTrail.STATUS_DENIED;</span>
        } else {
<span class="nc" id="L3865">            return requestStatus;</span>
        }
    }

    protected boolean _processVTORequest(RequestAggregate reqAgg,String comment) throws Exception{
<span class="nc" id="L3870">    	return false;</span>
    }
   	public TOHoursPerDayManager getTOHoursPerDayManager() throws BbmCreateException {
<span class="nc" id="L3873">        return RmManagerFactory.getInstance(true).getTOHoursPerDayManager(null, null);</span>
    }

	public TimeOffIntervalAllocationManager getTimeOffIntervalAllocationManager() throws BbmCreateException {
<span class="nc" id="L3877">        return RmManagerFactory.getInstance(true).getTimeOffIntervalAllocationManager(null, null);</span>
    }

	public TimeOffBiddingManager getTimeOffBiddingManager() throws BbmCreateException {
<span class="nc" id="L3881">        return RmManagerFactory.getInstance(true).getTimeOffBiddingManager();</span>
    }

	@Override
	public boolean isUserAuthorizedToViewPersonalRequests(User user) {
<span class="nc" id="L3886">		return true;</span>
	}

	private User getUser() throws Exception {
<span class="nc" id="L3890">		return RequestUtil.getLoginUserBasic(m_sessionContext);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>