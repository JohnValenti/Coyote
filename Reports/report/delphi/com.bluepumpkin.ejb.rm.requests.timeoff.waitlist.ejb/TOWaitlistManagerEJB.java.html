<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOWaitlistManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb</a> &gt; <span class="el_source">TOWaitlistManagerEJB.java</span></div><h1>TOWaitlistManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityProperties;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestDAO;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TOValidationCache;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.model.TOWaitlist;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignment;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;


<span class="nc" id="L67">public class TOWaitlistManagerEJB extends SessionEJBBase {     //OUTSIDE_CONTAINER</span>
<span class="nc" id="L68">	private static final String m_className = TOWaitlistManagerEJB.class.getName();</span>
<span class="nc" id="L69">	private static Category m_cat = Log.initCategory(TOWaitlistManagerEJB.m_className);</span>
	private static final long oneDayInMilliSecs = 24 * 60 * 60 * 1000;
	private static final int INVALID_MSG_NOTIFY_TYPE = -999;

	{
<span class="nc" id="L74">		super.init(TOWaitlistManagerEJB.class.getName());</span>
<span class="nc" id="L75">	}</span>

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="nc" id="L82">		return m_cat;</span>
	}

	public void deleteTOWaitlistRequestSetting(ID pTOWaitlistID) throws BbmRemoveException {
<span class="nc" id="L86">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L88">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L89">			toWaitlistDAO.deleteObject(pTOWaitlistID);</span>
		} finally {

<span class="nc bnc" id="L92" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L93">				toWaitlistDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L96">	}</span>

	public ID createTOWaitlistRequest(TOWaitlist pTOWaitlist) throws RmException, BbmCreateException {
<span class="nc" id="L99">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L101">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L102">			return toWaitlistDAO.createTOWaitlistRequest(pTOWaitlist);</span>
		} finally {
<span class="nc bnc" id="L104" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L105">				toWaitlistDAO.cleanUp();</span>
			}
		}
	}

	public TOWaitlist getTOWaitlistByTimeOffRequestId(ID toRequestId) throws BbmFinderException {
<span class="nc" id="L111">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L113">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L114">			return toWaitlistDAO.getWaitlistByTimeOffRequestId(toRequestId);</span>
		} finally {
<span class="nc bnc" id="L116" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L117">				toWaitlistDAO.cleanUp();</span>
			}
		}
	}


	public void updateStatusForExpiredTOWaitlistRequests() throws BbmUpdateException {
<span class="nc" id="L124">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L126">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L127">			Collection toReqIDCol = toWaitlistDAO.getWaitlistedTORequestIdsThatArePastExpiryDate();</span>
<span class="nc" id="L128">			TORequestManager toReqMgr = getTORequestManager();</span>
<span class="nc" id="L129">			long detailLevel = TORequest.DL_BASIC;</span>
<span class="nc" id="L130">			Collection toRequests = toReqMgr.getRequestsById(toReqIDCol, false, false, false, detailLevel);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">			for (Iterator iterator = toRequests.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L132">				TORequest toRequest = (TORequest) iterator.next();</span>
<span class="nc" id="L133">				toRequest.setRequestStatus(RequestAuditTrail.STATUS_DENIED);</span>
<span class="nc" id="L134">				toReqMgr.updateRequest(toRequest, RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_DENIED_WAITLIST_EXPIRYDATE), true);</span>
<span class="nc" id="L135">			}</span>
<span class="nc" id="L136">		} catch (Exception e) {</span>
<span class="nc" id="L137">			throw  new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L139" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L140">				toWaitlistDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L143">	}</span>

	public void scanAllTOWaitlistRequests() throws BbmUpdateException {
<span class="nc" id="L146">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L148">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L149">			Collection toReqIDCol = toWaitlistDAO.getAllWaitlistedTORequestIds();</span>
<span class="nc" id="L150">			TORequestManager toReqMgr = getTORequestManager();</span>
<span class="nc" id="L151">			final long detailLevel = TORequest.DL_AUDIT_TRAIL |</span>
			        TORequest.DL_TIMEOFF_CHOICES |
			        TORequest.DL_TIMEOFF_CHOICES_LENGTH |
			        TORequest.DL_TIMEOFF_WAITLIST;
<span class="nc bnc" id="L155" title="All 2 branches missed.">			for (Iterator iterator = toReqIDCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L156">				ID reqID = (ID) iterator.next();</span>
<span class="nc" id="L157">				TORequest toRequest = (TORequest) toReqMgr.getRequestByID(reqID, false, false, detailLevel);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">				if (toRequest.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L159">					toReqMgr._autoProcess(toRequest, &quot;waitlist scan @ &quot; + new Date(), true);</span>
				}
<span class="nc" id="L161">			}</span>
<span class="nc" id="L162">		} catch (Exception e) {</span>
<span class="nc" id="L163">			throw  new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L165" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L166">				toWaitlistDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L169">	}</span>

	public Pair sortAndSetPriortyOrderForWaitlists(List reqIDsSorted, ID pTOPoolID, int sortColumn, String sortDirStr, long detailLevel, boolean runSoftValids) throws BbmException {
<span class="nc" id="L172">		TORequestDAO toDAO = null;</span>
<span class="nc" id="L173">		List sbReqsList = null;</span>
		try {
<span class="nc" id="L175">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L176">			TOPool toPool = toCalFacade.getTOPool(pTOPoolID);</span>
<span class="nc" id="L177">			Pair[] sortSeqPairArray = toPool.getTOWaitlistPriortyOrderSettings();</span>
			//if the Array is null then the Priority order need not be computed.
<span class="nc bnc" id="L179" title="All 2 branches missed.">			if (sortSeqPairArray != null) {</span>
<span class="nc" id="L180">				detailLevel |= TORequest.DL_AUDIT_TRAIL |</span>
				        TORequest.DL_TIMEOFF_CHOICES |
				        TORequest.DL_TIMEOFF_CHOICES_LENGTH |
				        TORequest.DL_TIMEOFF_WAITLIST | Request.DL_EMPLOYEE;
<span class="nc" id="L184">				toDAO = new TORequestDAO(detailLevel);</span>
<span class="nc" id="L185">				Collection sbReqs = getTORequestManager().getRequestsById(reqIDsSorted, false, runSoftValids, true, detailLevel);</span>
<span class="nc" id="L186">				sbReqsList = RequestUtil.getListFromCollection(sbReqs);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">				if (sbReqsList.size() &gt; 1) {//throws UnsupportedOperationException if the size is one</span>
<span class="nc" id="L188">					Collections.sort(sbReqsList, new TORequestUtil.TOWailistComparator(sortSeqPairArray));</span>
				}
<span class="nc bnc" id="L190" title="All 2 branches missed.">				for (int i = 0; i &lt; sbReqsList.size(); i++) {</span>
<span class="nc" id="L191">					TORequest toRequest = (TORequest) sbReqsList.get(i);</span>
<span class="nc" id="L192">					toRequest.setTOWaitlistPriorityOrder(i + 1);</span>
				}
				//Request Ids are already sorted in the database query but that is useless if requests need to be
				//sorted by Priority order, in that case we need to re-sort the reqIDsSorted collection
<span class="nc bnc" id="L196" title="All 2 branches missed.">				if (sortColumn == Request.SORT_TO_WAITLIST_PRIORITY_ORDER) {</span>
					//Reverse the list if the request need to be sorted in reverse order
<span class="nc bnc" id="L198" title="All 2 branches missed.">					if (RequestUtil.SORTDIR_DESC.equalsIgnoreCase(sortDirStr)) {</span>
<span class="nc" id="L199">						RequestUtil.getListReversed(sbReqsList);</span>
					}
<span class="nc" id="L201">					reqIDsSorted = new ArrayList();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">					for (int i = 0; i &lt; sbReqsList.size(); i++) {</span>
<span class="nc" id="L203">						TORequest toRequest = (TORequest) sbReqsList.get(i);</span>
<span class="nc" id="L204">						reqIDsSorted.add(toRequest.getID());</span>
					}
				}
			}
<span class="nc" id="L208">		} catch (Exception e) {</span>
<span class="nc" id="L209">			handleException(e);</span>
<span class="nc" id="L210">			throw  new BbmException();</span>
		} finally {
<span class="nc bnc" id="L212" title="All 4 branches missed.">			if (toDAO != null) toDAO.cleanUp();</span>
<span class="nc" id="L213">			methodFinish();</span>
<span class="nc" id="L214">		}</span>
		//Please note that reqIDsSorted are sorted correctly but sbReqsList is not.
		//We expect the caller to use hashmap to get request for a given REQ ID.
<span class="nc" id="L217">		return new Pair(reqIDsSorted, sbReqsList);</span>
	}

	protected static CommonRequestManager getCommonRequestManager() throws BbmCreateException {
<span class="nc" id="L221">		return RmManagerFactory.getInstance(true).getCommonRequestManager();</span>
	}

	protected static TORequestManager getTORequestManager() throws BbmCreateException {
<span class="nc" id="L225">		return RmManagerFactory.getInstance(true).getTimeOffRequestManager();</span>
	}

	/**
	 * This method will return Ordered Time-Off Waitlist Requests falling in the given Date Range.
	 * The List will be ordered by the Priority Settings for the TOPool.
	 *
	 * @param pTOPool          ID for which order waitlists are required.
	 * @param startDate
	 * @param endDate
	 * @param checkForAutoScan
	 * @return Pair
	 * @throws BbmFinderException This method will return Ordered Time-Off Waitlist Requests falling in the given Date Range.
	 *                            The Returned Waitlists will depend upon the shared allocation hour Settings.
	 *                            If hours are shared then list will be returned for all Organizations sharing the hours.
	 *                            The List will be ordered by the Priority Settings of the Parent Org.
	 */
	public Pair&lt;List&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt;, Collection&lt;ID&gt;&gt; getOrderedTOWaitlistsForTOPool(TOPool pTOPool, Date stDate, Date enDate,
			boolean checkForAutoScan)
			throws BbmFinderException {



		try {
<span class="nc bnc" id="L249" title="All 6 branches missed.">			if (!pTOPool.isWaitlistEnabled() || (checkForAutoScan &amp;&amp; !pTOPool.isIsWaitlistscan())) {</span>
				//Return  empty list because waitlist is not enabled or checkForAutoScan is true and waitlist scan is not enabled
<span class="nc" id="L251">				return getEmptyReturn();</span>
			}
<span class="nc" id="L253">			Collection&lt;ID&gt; empIDsFiltered = RmManagerFactory.getInstance(true).getTimeOffDayFacade()</span>
<span class="nc" id="L254">					.getEmployeeIDsForTOPool(pTOPool.getID(), stDate, enDate);</span>
<span class="nc bnc" id="L255" title="All 4 branches missed.">			if (empIDsFiltered == null || empIDsFiltered.isEmpty()) {</span>
<span class="nc" id="L256">				return getEmptyReturn();</span>
			}
<span class="nc" id="L258">			TOHoursPerDayManager hrsPerDayMgr = RmManagerFactory.getInstance(true).getTOHoursPerDayManager();</span>
<span class="nc" id="L259">			return new Pair&lt;List&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt;, Collection&lt;ID&gt;&gt;(</span>
<span class="nc" id="L260">					hrsPerDayMgr.getOrderedTOWaitlists(pTOPool, empIDsFiltered, stDate, enDate), empIDsFiltered);</span>
<span class="nc" id="L261">		} catch (Exception e) {</span>
<span class="nc" id="L262">			handleException(e, false);</span>
<span class="nc" id="L263">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		}
	}

	private Pair&lt;List&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt;, Collection&lt;ID&gt;&gt; getEmptyReturn() {
<span class="nc" id="L268">		return new Pair&lt;List&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt;, Collection&lt;ID&gt;&gt;(Collections.emptyList(), null);</span>
	}

<span class="nc" id="L271">	private static final ID genericlock = new ID(-3001);</span>

	public void processWaitlistsForDecision(int msgNotifyType, ID pTOPoolID, Date startDate, Date endDate, boolean fullCheck) throws BbmException {
		try {
<span class="nc" id="L275">			CalendarTimeOffDayFacade ctodf = getCalendarTimeOffDayFacade();</span>
<span class="nc" id="L276">			TOPool pTOPool = ctodf.getTOPool(pTOPoolID);</span>
<span class="nc" id="L277">			RequestUtil.getTOWaitlistManager().processWaitlistsForDecision(msgNotifyType, pTOPool, startDate, endDate, fullCheck);</span>
<span class="nc" id="L278">		} catch (Exception e) {</span>
<span class="nc" id="L279">			e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span>
<span class="nc" id="L280">		}</span>
<span class="nc" id="L281">	}</span>

	private CalendarTimeOffDayFacade getCalendarTimeOffDayFacade() throws BbmCreateException {
<span class="nc" id="L284">		return RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
	}
	
	public void processWaitlistsForDecision(int msgNotifyType, TOPool toPool, Date startDate, Date endDate, boolean fullCheck) throws BbmException {
		try {
<span class="nc" id="L289">			ID toPoolID = toPool.getID();</span>
<span class="nc" id="L290">			m_cat.debug(&quot;processWaitlistsForDecision toPoolID=&quot; + toPoolID + &quot; :startDate=&quot; + startDate + &quot; :endDate=&quot; + endDate);</span>
			/* bug fixfor timezone issue bug# 94621; sameet 2007;
			/* advance the end date by one day and rollback the start date by one day to account for all time zones of the user requests)*/
<span class="nc" id="L293">			long timeStart = Calendar.getInstance().getTimeInMillis();</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L295">				m_cat.info(&quot; PERF, BEFORE synchronized(orgLock),toPoolID=&quot; + toPoolID + &quot; :&quot;</span>
<span class="nc" id="L296">						+ (Calendar.getInstance().getTimeInMillis() - timeStart) + &quot; Msecs :startDate=&quot; + startDate + &quot; :endDate=&quot;</span>
						+ endDate);
			}
<span class="nc" id="L299">			timeStart = Calendar.getInstance().getTimeInMillis();</span>

<span class="nc" id="L301">			synchronized (genericlock) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">				if (startDate != null) {</span>
<span class="nc" id="L303">					startDate = new Date(startDate.getTime() - oneDayInMilliSecs);</span>
				} else {
<span class="nc" id="L305">					startDate = new Date();</span>
				}
<span class="nc bnc" id="L307" title="All 2 branches missed.">				if (endDate != null) {</span>
<span class="nc" id="L308">					endDate = new Date(endDate.getTime() + oneDayInMilliSecs);</span>
					
				} else {
<span class="nc" id="L311">					endDate = new Date(RequestUtil.MAX_DATE.getTime());</span>
				}
				
				// get time-off waitlist requests for pool in the waitlist scan date range. 				
<span class="nc" id="L315">				Pair&lt;List&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt;, Collection&lt;ID&gt;&gt; pair = RequestUtil.getTOWaitlistManager()</span>
<span class="nc" id="L316">						.getOrderedTOWaitlistsForTOPool(toPool, startDate, endDate, true);</span>
				

<span class="nc" id="L319">				Collection&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt; wlCol = pair.getFirst();</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">				if (wlCol == null || wlCol.isEmpty()) {</span>
<span class="nc" id="L321">					m_cat.info(&quot; PERF, No Waitlisted Requests to scan ,toPoolID=&quot; + toPoolID + &quot; :&quot; + ((Calendar.getInstance().getTimeInMillis() - timeStart)) + &quot; Msecs :startDate=&quot; + startDate + &quot; :endDate=&quot; + endDate);</span>
<span class="nc" id="L322">					return;</span>
				}
<span class="nc bnc" id="L324" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">					m_cat.info(&quot; PERF, after _getOrderedTOWaitlistsForOrg,&quot; + ((Calendar.getInstance().getTimeInMillis() - timeStart)) + &quot; Msecs size=&quot; + (wlCol != null ? wlCol.size() : 0));</span>
				}
<span class="nc" id="L327">				Collection&lt;ID&gt; orgEmpIDs = pair.getSecond();</span>
				
				
				// get max start/end time range by looking at all wait-listed time off requests start/end date.
<span class="nc" id="L331">				TimeRange maxDateRange = null;</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">				for (Pair&lt;ID, TOHoursPerDay&gt; reqIDHrsPerDayPair : wlCol) {</span>
<span class="nc" id="L333">					TOHoursPerDay item = reqIDHrsPerDayPair.getSecond();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">					if (maxDateRange == null) {</span>
<span class="nc" id="L335">						maxDateRange = new TimeRange(item.getStartTime(), item.getEndTime());</span>
					}
<span class="nc bnc" id="L337" title="All 2 branches missed.">					if (maxDateRange.getStartDate().after(item.getStartTime())) {</span>
<span class="nc" id="L338">						maxDateRange.setStartDate(item.getStartTime());</span>
					}
<span class="nc bnc" id="L340" title="All 2 branches missed.">					if (maxDateRange.getEndDate().before(item.getEndTime())) {</span>
<span class="nc" id="L341">						maxDateRange.setEndDate(item.getEndTime());</span>
					}
<span class="nc" id="L343">				}</span>
				
				// get org associated with the pool
<span class="nc" id="L346">				Organization org = CacheUtilBBM.getOrganizationByID(toPool.getOrganizationId());</span>
				
				// Use the max start/date time range encompassing all wait-listed time off requests to audit.
				
				// get scheduled TO hours for pool for this max date range to use in audit before processing wait-listed TOs 			
				//JT adding null activity
<span class="nc" id="L352">				DailyHoursBuckets beforeScanScheduledTOHours = TOCalendarUtil.getTOScheduledData(toPoolID, org, maxDateRange, null, null);</span>
				
				// get allocated TO hours for pool for this max date range
<span class="nc" id="L355">				DailyHoursBuckets allocatedTOHours = TOCalendarUtil.getTOAllocatedData(toPoolID, org, maxDateRange);</span>
				
		        // get TO pools for all emps (again look back over a year from start of waitlist scan date)
<span class="nc" id="L358">				Date minStDate = TOCalendarUtil.getBackAyearforDate(maxDateRange.getStartDate());</span>
<span class="nc" id="L359">				HashMap wras = RequestUtil.getTOWaitlistManager().getWorkResourceAssignments(org, orgEmpIDs, minStDate, maxDateRange.getEndDate());</span>
				//JT: REVIEW THIS
<span class="nc" id="L361">				HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; empTOPoolAssnMap =  </span>
<span class="nc" id="L362">						getCalendarTimeOffDayFacade().getTOPoolsForWorkResources(orgEmpIDs, minStDate, maxDateRange.getEndDate());</span>
				

<span class="nc" id="L365">				timeStart = Calendar.getInstance().getTimeInMillis();</span>
<span class="nc" id="L366">				TORequestManager toReqMgr = getTORequestManager();</span>
<span class="nc" id="L367">				Date today = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;)).getTime();</span>
<span class="nc" id="L368">				long level = RequestAggregate.getDetailLevelForValidation(Request.REQUESTTYPE_TIMEOFF);</span>
<span class="nc" id="L369">				int count = 0;</span>
<span class="nc" id="L370">				DailyHoursBuckets availTOHours = null;</span>
				

				// iterate over the wait-list TO requests and if there are available hours approve time off request, else deny
<span class="nc bnc" id="L374" title="All 2 branches missed.">				for (Pair&lt;ID, TOHoursPerDay&gt; reqIDHrsPerDayPair : wlCol) {</span>
					try {

<span class="nc bnc" id="L377" title="All 4 branches missed.">						if (!fullCheck &amp;&amp; availTOHours == null) {</span>
<span class="nc" id="L378">							availTOHours = getAvailableHoursForDailyTOPool(toPool, org, maxDateRange, allocatedTOHours);</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">							if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L380">								m_cat.info(&quot;getAvailableHoursForTOPool;loaded=&quot; + count++);</span>
							}
						}
<span class="nc bnc" id="L383" title="All 2 branches missed.">						if (fullCheck</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">								|| checkAvailableHrsForDailyPool(toPoolID, org, availTOHours,</span>
<span class="nc" id="L385">										reqIDHrsPerDayPair.getSecond(), wras, empTOPoolAssnMap)) {</span>

<span class="nc" id="L387">							TORequest req = (TORequest) toReqMgr.getRequestByID(reqIDHrsPerDayPair.getFirst(), false, false, level);</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">							if (isWaitListedAndNotExpired(today, req)) {</span>
<span class="nc" id="L390">								logFullCheck(fullCheck, reqIDHrsPerDayPair, req);</span>
<span class="nc" id="L391">								availTOHours = runAutoProcessing(toReqMgr, today, availTOHours, req);</span>
							} else {
<span class="nc" id="L393">								toReqMgr.denyRequest(req, RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_DENIED_WAITLIST_EXPIRYDATE));</span>
							}
						}

<span class="nc" id="L397">					} catch (Exception e) {</span>
<span class="nc" id="L398">						m_cat.info(&quot;Exception thrown for Request=&quot; + reqIDHrsPerDayPair.getFirst());</span>
<span class="nc" id="L399">						handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L400">						continue;</span>
<span class="nc" id="L401">					}</span>
<span class="nc" id="L402">				}</span>

				// get scheduled TO hours for pool for this max date range to use in audit after processing wait-listed TOs, 
				// only if the scheduled TO hours changed during processing of the wait-listed TO requests.
				
				//JT adding null activity
<span class="nc" id="L408">				DailyHoursBuckets afterScanScheduledTOHours = TOCalendarUtil.getTOScheduledData(toPoolID, org, maxDateRange, null, null);</span>
				
				// audit calendar state after processing wait-listed TO requests.
<span class="nc" id="L411">				auditWaitlistScan(msgNotifyType, toPool, maxDateRange.getStartDate(), maxDateRange.getEndDate(), </span>
<span class="nc" id="L412">							TOCalendarUtil.getTOCalendar(allocatedTOHours, beforeScanScheduledTOHours, afterScanScheduledTOHours));</span>
							
<span class="nc bnc" id="L414" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">					m_cat.info(&quot; PERF, after synch&amp;autoprocess complete toPoolID=&quot; + toPoolID + &quot;;fullCheck=&quot; + fullCheck +</span>
<span class="nc" id="L416">					        &quot;:No of Rows=&quot; + (wlCol != null ? wlCol.size() : 0) + &quot;:,&quot; + ((Calendar.getInstance().getTimeInMillis() - timeStart)) +</span>
					        &quot;:Msecs :startDate=&quot; + startDate + &quot; :endDate=&quot; + endDate);
				}
<span class="nc" id="L419">			}</span>
<span class="nc" id="L420">		} catch (Exception e) {</span>
<span class="nc" id="L421">			handleException(e);</span>
<span class="nc" id="L422">			throw new BbmException(e);</span>
<span class="nc" id="L423">		}</span>
<span class="nc" id="L424">	}</span>

	private DailyHoursBuckets runAutoProcessing(TORequestManager toReqMgr, Date today, DailyHoursBuckets availTOHours, TORequest req)
			throws BbmUpdateException, RmHardValidationException, MultiUserException, RemoteException {

<span class="nc" id="L429">		Pair result = toReqMgr._autoProcess(req, &quot;waitlist scan @ &quot; + today, true);</span>

<span class="nc bnc" id="L431" title="All 6 branches missed.">		if (result != null &amp;&amp; Boolean.getBoolean(result.getFirst().toString()) &amp;&amp; result.getSecond() != null) {</span>
			//reload from db to check if request is approved
<span class="nc bnc" id="L433" title="All 2 branches missed.">			m_cat.info(&quot;OLDSTATUS=&quot; + (req != null ? req.getID() + &quot; &quot; + req.getRequestStatus() : &quot;NULL&quot;) + &quot;:NEWSTATUS=&quot;</span>
<span class="nc" id="L434">					+ result.getSecond());</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">			if (result.getSecond().equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L436">				m_cat.info(&quot;Approved Request in Waitlist scan; REQ=&quot; + req);</span>
<span class="nc" id="L437">				return null;</span>
			}
		}
<span class="nc" id="L440">		return availTOHours;</span>
	}

	private void logFullCheck(boolean fullCheck, Pair&lt;ID, TOHoursPerDay&gt; reqIDHrsPerDayPair, TORequest req) {
<span class="nc bnc" id="L444" title="All 2 branches missed.">		if (!fullCheck) {</span>
<span class="nc" id="L445">			m_cat.info(&quot;fullCheck=&quot; + fullCheck + &quot;: Req has avail hours TOChoice=&quot; + req.getWaitlistTOChoice().getID()</span>
<span class="nc" id="L446">					+ &quot;:EMPID=&quot; + req.getEmployeeID() + &quot;: ACCT MINS=&quot; + reqIDHrsPerDayPair.getSecond().getTotalMinutes()</span>
<span class="nc" id="L447">					+ &quot;: ST=&quot; + req.getWaitlistTOChoice().getStartDate() + &quot;:END=&quot; + req.getWaitlistTOChoice().getEndDate());</span>
		}
<span class="nc" id="L449">	}</span>

	private boolean isWaitListedAndNotExpired(Date today, TORequest req) {
<span class="nc bnc" id="L452" title="All 4 branches missed.">		return req.isWaitlisted() &amp;&amp; today.before(req.getWaitlistInfo().getTOWaitlistExpiryDate());</span>
	}

	public HashMap getWorkResourceAssignments(Organization org, Collection orgEmpIDs, Date startDate, Date endDate) throws BbmException {
		try {
<span class="nc" id="L457">			return RequestUtil.getWorkResourceManager().getValidWorkResourceAssignments(orgEmpIDs,</span>
<span class="nc" id="L458">			        new LocalDate(startDate, org.getTimeZone()),</span>
<span class="nc" id="L459">			        new LocalDate(endDate, org.getTimeZone()), false);</span>
<span class="nc" id="L460">		} catch (Exception e) {</span>
<span class="nc" id="L461">			throw new BbmException(e);</span>
		}
	}

	/**
	 * Audit time off pool's calendar after processing wait-listed TO requests.
	 * @param msgNotifyType
	 * @param toPool
	 * @param auditStDate
	 * @param auditEndDate
	 * @param toCalendar
	 */
	private void auditWaitlistScan(int msgNotifyType, TOPool toPool, Date auditStDate, Date auditEndDate, String toCalendar) {
<span class="nc" id="L474">		AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT,</span>
													AuditTrailEntry.ACTION_TIME_OFF_POOL_WAITLISTSCAN,
<span class="nc" id="L476">													toPool.getId(), toPool.getName(), auditStDate, auditEndDate);</span>
		try {
<span class="nc" id="L478">			String notifyType = TONotifyMessage.getNotifyString(msgNotifyType);</span>
			
<span class="nc" id="L480">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TIMEOFF_POOL, toCalendar, notifyType, false);</span>
			
<span class="nc" id="L482">			EventAuditTrailManager auditManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L483">			auditManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L484">		} catch (Exception e) {</span>
<span class="nc" id="L485">			m_cat.debug(&quot;unable to audit waitlist scan process for time off pool with id: &quot; + toPool.getId() + </span>
<span class="nc" id="L486">					&quot; because of exception : &quot; + e.getMessage());</span>
<span class="nc" id="L487">		} </span>
<span class="nc" id="L488">	}</span>
	
	private boolean checkAvailableHrsForDailyPool(ID pTOPoolID, Organization pTOPoolOrg, DailyHoursBuckets availBkts,
			TOHoursPerDay hrsPerDay, HashMap empWrs, Map&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; empTOPoolAssnMap) throws Exception {

<span class="nc" id="L493">		boolean result = false;</span>
<span class="nc bnc" id="L494" title="All 4 branches missed.">		if (hrsPerDay == null || hrsPerDay.getTotalMinutes() &lt;= 0) {</span>
<span class="nc" id="L495">			m_cat.info(&quot;total minutes are zero or hrsperday is null=&quot; + hrsPerDay);</span>
<span class="nc" id="L496">			return result;</span>
		}

<span class="nc" id="L499">		Organization currOrg = TOCalendarUtil.getOrgforDate(hrsPerDay.getStartTime(), (Collection) empWrs.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">		if (currOrg == null) {</span>
<span class="nc" id="L501">			m_cat.info(&quot;employee has been terminated EMP=&quot; + hrsPerDay.getEmployeeID());</span>
<span class="nc" id="L502">			return result; //employee has been terminated or has been changed org and does not belong to the current requested list</span>
		}

<span class="nc" id="L505">		List&lt;EmpTOPoolAssignment&gt; toPoolAssignmentsForEmployee = empTOPoolAssnMap.get(hrsPerDay.getEmployeeID());</span>
		
		//toPoolAssignmentsForEmployee contains all pools for the employee, including pools for specific activities.
		//If the advanced license is enabled, then get the pool for the employee, for the time off type on the day of the time off event 
		//If the advanced license is disabled then get the pool for the employee on the day of the time off event
<span class="nc" id="L510">		ID activityID = TOCalendarUtil.adjustForPoolByActivity(hrsPerDay.getActivityID());</span>
<span class="nc" id="L511">		ID empTOPoolID = TOCalendarUtil.getTOPoolIDforDate(hrsPerDay.getStartTime(), toPoolAssignmentsForEmployee, activityID);</span>
<span class="nc bnc" id="L512" title="All 4 branches missed.">		if (empTOPoolID == null || !empTOPoolID.equals(pTOPoolID)) {</span>
<span class="nc" id="L513">			m_cat.debug(&quot;ignoring TOHoursPerday because employee does not belong to this TOPOOLId=&quot; + empTOPoolID</span>
			        + &quot;: on start date of this:&quot; + hrsPerDay);
			//employee has  changed TOPool and does not belong to the current TOPOOL
<span class="nc" id="L516">			return result; </span>
		}

<span class="nc bnc" id="L519" title="All 2 branches missed.">		if (requestActivityUsesIntervalPool(hrsPerDay)) {</span>
			//if the request uses the interval pool go ahead and run the approval process 
<span class="nc" id="L521">			return true;</span>
		}

<span class="nc" id="L524">		DailyHoursBuckets bkt = TOHoursPerDayUtil.getDailyHoursBuckets(pTOPoolOrg, hrsPerDay);</span>
		// Check that each &quot;day&quot; during request period has enough available hours for the pending request.
<span class="nc" id="L526">		Date firstShortDay = availBkts.checkAllocation(bkt);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">		result = (firstShortDay == null);</span>
<span class="nc" id="L528">		return result;</span>
	}

	private boolean requestActivityUsesIntervalPool(TOHoursPerDay requestHrsPerDay) throws Exception { // NOSONAR

<span class="nc bnc" id="L533" title="All 2 branches missed.">		if (!LicenseUtil.isAdvancedRMLicense()) {</span>
<span class="nc" id="L534">			return false;</span>
		}

<span class="nc" id="L537">		ID activityID = requestHrsPerDay.getActivityID();</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">		if (activityID == null) {</span>
<span class="nc" id="L539">			return false;</span>
		}
<span class="nc" id="L541">		ActivityProperties property = TORequestUtil.getActivityProperties(activityID);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">		if (property == null) {</span>
<span class="nc" id="L543">			return false;</span>
		}

<span class="nc" id="L546">		return property.isUseIntervalTOPool();</span>
	}

	private DailyHoursBuckets getAvailableHoursForDailyTOPool(TOPool pTOPool, Organization org, TimeRange toRange,
			DailyHoursBuckets allocHrs) throws Exception {
<span class="nc" id="L551">		long currentime = new Date().getTime();</span>
		
<span class="nc" id="L553">		DailyHoursBuckets availHrs = new DailyHoursBuckets(allocHrs);</span>
		// the buckets end date expanded to org day start and end
<span class="nc" id="L555">		Date stDate = availHrs.getDHBRangeStartAsOrgDayStart();</span>
<span class="nc" id="L556">		Date enDate = availHrs.getDHBRangeEndAsOrgDayEnd();</span>
	
<span class="nc" id="L558">		TimeRange availTOHoursBktsForOrgTimeRange = new TimeRange(stDate, enDate);</span>
		//JT adding null activity
<span class="nc" id="L560">		Collection&lt;ID&gt; dailyPoolActivities = TOCalendarUtil.getListOfDailyPoolAllotmentActivities(null);</span>
<span class="nc" id="L561">		DailyHoursBuckets orgSched = TOCalendarUtil.getTOScheduledData(pTOPool.getID(), org, availTOHoursBktsForOrgTimeRange,</span>
				dailyPoolActivities, null);
<span class="nc" id="L563">		availHrs.subFromBucket(orgSched, stDate, enDate);</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L565">			m_cat.info(&quot;TOTAL TIME for getAvailableHoursForDailyTOPool=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L567">		return availHrs;</span>
	}

	public void triggerWaitlistScanForEmployeeIDs(Collection empIDs, int msgNotifyType, Date minStartDate, Date maxEndDate, boolean scanForOneEmpOnly) throws BbmException {
		try {
<span class="nc" id="L572">			Collection pTOPoolCol = getCalendarTimeOffDayFacade().getTOPoolsForEmployees(empIDs, minStartDate, maxEndDate);</span>
<span class="nc" id="L573">			processWaitlistsForDecision(msgNotifyType, pTOPoolCol, minStartDate, maxEndDate);</span>
<span class="nc" id="L574">		} catch (Exception e) {</span>
<span class="nc" id="L575">			handleException(e);</span>
<span class="nc" id="L576">			throw new BbmException(e);</span>
<span class="nc" id="L577">		}</span>
<span class="nc" id="L578">	}</span>

	/*DONE FOR TOPOOL*/
	public void processOrgWaitlistsForDecision(Collection orgIDs, int msgNotifyType, Date startDate, Date endDate) throws BbmException {
		try {
<span class="nc" id="L583">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L584">			Collection pTOPoolCol = toCalFacade.getTOPoolsForOrgIDs(orgIDs);</span>
<span class="nc" id="L585">			processWaitlistsForDecision(msgNotifyType, pTOPoolCol, startDate, endDate);</span>
<span class="nc" id="L586">		} catch (Exception e) {</span>
<span class="nc" id="L587">			handleException(e);</span>
<span class="nc" id="L588">			throw new BbmException(e);</span>
<span class="nc" id="L589">		}</span>
<span class="nc" id="L590">	}</span>

	private void processWaitlistsForDecision(int msgNotifyType, Collection toPoolSet, Date startDate, Date endDate) {
<span class="nc bnc" id="L593" title="All 2 branches missed.">		for (Iterator iterator = toPoolSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L594">			TOPool toPool = (TOPool) iterator.next();</span>
<span class="nc bnc" id="L595" title="All 6 branches missed.">			if (toPool != null &amp;&amp; toPool.isWaitlistEnabled() &amp;&amp; toPool.isIsWaitlistscan()) {</span>
				//This is needed for transaction level isolation, since this method requires new transaction.
				try {
<span class="nc" id="L598">					RequestUtil.getTOWaitlistManager().processWaitlistsForDecision(msgNotifyType, toPool, startDate, endDate, false);</span>
<span class="nc" id="L599">				} catch (Exception e) {</span>
<span class="nc" id="L600">					handleException(e);</span>
<span class="nc" id="L601">				}</span>
			}
<span class="nc" id="L603">		}</span>
<span class="nc" id="L604">	}</span>

	static final long detailLevel = TORequest.DL_AUDIT_TRAIL | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH | TORequest.DL_TIMEOFF_WAITLIST;

	public void processWaitlistScan(TONotifyMessage msgObj) throws BbmException {
<span class="nc bnc" id="L609" title="All 2 branches missed.">		if (!TORequestUtil.isTOWaitlistFeatureEnabled()) {</span>
<span class="nc" id="L610">			return;</span>
		}

<span class="nc" id="L613">		boolean cacheEnabled = false; </span>

		try {
<span class="nc" id="L616">			cacheEnabled = ThreadLocalCache.enable();</span>

<span class="nc" id="L618">			m_cat.debug(&quot;MDB TONotifyMessage: &quot; + msgObj);</span>
<span class="nc bnc" id="L619" title="All 9 branches missed.">			switch (msgObj.getNotificationType()) {</span>
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_COMPLETE:
<span class="nc" id="L621">				triggerWaitlistScanForEmployeeIDs(msgObj.getEmployeeIDs(), msgObj.getNotificationType(), msgObj.getStartDate(),</span>
<span class="nc" id="L622">						msgObj.getEndDate(), false);</span>
<span class="nc" id="L623">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_ORG_CHANGE:
<span class="nc" id="L625">				triggerWaitlistScanForEmployeeIDs(msgObj.getEmployeeIDs(), msgObj.getNotificationType(), new Date(0), null, false);</span>
<span class="nc" id="L626">				break;</span>
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH:
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_TO_ONLY: {
<span class="nc" id="L629">				ScheduleChangeDetails changeDetails = (ScheduleChangeDetails) msgObj.getObject();</span>
<span class="nc" id="L630">				triggerWaitlistScanForEmployeeIDs(changeDetails.getWorkResourceIDs(), msgObj.getNotificationType(),</span>
<span class="nc" id="L631">						changeDetails.getStartDate(), changeDetails.getEndDate(), false);</span>
<span class="nc" id="L632">				break;</span>
			}
			case TONotifyMessage.TO_NOTIFY_VALIDATION_RULE_CHANGE:
			case TONotifyMessage.TO_NOTIFY_FILING_RULE_CHANGE:
			case TONotifyMessage.TO_NOTIFY_AUTO_PROCESS_RULE_CHANGE:
			case TONotifyMessage.TO_NOTIFY_WAITLIST_SETTING_CHANGE:
<span class="nc" id="L638">				processOrgWaitlistsForDecision((HashSet) msgObj.getObject(), msgObj.getNotificationType(), null, null);</span>
<span class="nc" id="L639">				break;</span>
			case TONotifyMessage.TO_NOTIFY_ORG_BLACKOUTDAY_CHANGE:
<span class="nc" id="L641">				processOrgWaitlistsForDecision(Collections.singletonList(msgObj.getOrgId()), msgObj.getNotificationType(),</span>
<span class="nc" id="L642">						msgObj.getStartDate(), msgObj.getEndDate());</span>
<span class="nc" id="L643">				break;</span>
			case TONotifyMessage.TO_NOTIFY_TOPOOL_ALLOCATED_HRS_CHANGE:
			case TONotifyMessage.TO_NOTIFY_APPROVED_TOREQUEST_WITHDRAW:
			case TONotifyMessage.TO_NOTIFY_GENERIC_WAITLIST_MSG:
<span class="nc" id="L647">				processWaitlistsForDecision(msgObj.getNotificationType(), msgObj.getTOPoolId(), msgObj.getStartDate(), msgObj.getEndDate(),</span>
						false);
<span class="nc" id="L649">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_TOPOOL_CHANGE:
<span class="nc" id="L651">				processWaitlistsForDecision(msgObj.getNotificationType(), (Collection) msgObj.getObject(), msgObj.getStartDate(),</span>
<span class="nc" id="L652">						msgObj.getEndDate());</span>
<span class="nc" id="L653">				break;</span>
			case TONotifyMessage.TO_NOTIFY_TOPOOL_FULL_SCAN:
<span class="nc" id="L655">				processWaitlistsForDecision(msgObj.getNotificationType(), msgObj.getTOPoolId(), null, null, true);</span>
				break;

			}
		} finally {
<span class="nc" id="L660">			ThreadLocalCache.clear(cacheEnabled);</span>
<span class="nc" id="L661">		}</span>
<span class="nc" id="L662">	}</span>

	/**
	 * returns an int array containing rank of the request as 1st element and total waitlisted requests as 2n element
	 * for the range of the waitlisted request Id passed to this API.
	 *
	 * @param toReqID
	 * @return
	 */
	public int[] getWaitlistRank(ID toReqID) {
<span class="nc" id="L672">		int[] returnVal = new int[2];</span>
		try {
<span class="nc" id="L674">			TORequest tor = (TORequest) getTORequestManager().getRequestByID(toReqID, false, false, detailLevel);</span>
<span class="nc bnc" id="L675" title="All 4 branches missed.">			if (tor != null &amp;&amp; tor.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L676">				TOValidationCache cache = tor.getTOValidationCache();</span>
<span class="nc" id="L677">				Pair pair = getOrderedTOWaitlistsForTOPool(cache.getTOPool(),</span>
<span class="nc" id="L678">				        tor.getWaitlistTOChoice().getStartDate(), tor.getWaitlistTOChoice().getEndDate(), false);</span>
<span class="nc" id="L679">				Collection col = (Collection) pair.getFirst();</span>
<span class="nc" id="L680">				int count = 0;</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">				for (Iterator iterator = col.iterator(); iterator.hasNext(); count++) {</span>
<span class="nc" id="L682">					Pair reqIDHrsPerDayPair = (Pair) iterator.next();</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">					if (reqIDHrsPerDayPair.getFirst().equals(toReqID)) {</span>
<span class="nc" id="L684">						returnVal[0] = count + 1;</span>
<span class="nc" id="L685">						returnVal[1] = col.size();</span>
					}
				}
			}
<span class="nc" id="L689">		} catch (Exception e) {</span>
<span class="nc" id="L690">			handleException(e);</span>
<span class="nc" id="L691">		}</span>
<span class="nc" id="L692">		return returnVal;</span>
	}

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>