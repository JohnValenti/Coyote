<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CommonRequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb</a> &gt; <span class="el_source">CommonRequestManagerEJB.java</span></div><h1>CommonRequestManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * CommonRequestManagerEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.IDStringPair;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.core.filterconfig.ejb.FilterConfigManager;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.cache.CacheUtilRM;
import com.bluepumpkin.ejb.rm.config.RequestManagementConfigKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAuditTrailDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestCollection;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.custshift.ejb.CustShiftReqMgr;
import com.bluepumpkin.ejb.rm.requests.flextime.ejb.FlexTimeRequestManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestManager;
import com.bluepumpkin.ejb.rm.requests.swap.request.ejb.ShiftSwapRequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.ejb.TimeOffBidDAO;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.model.TimeOffBid;
import com.bluepumpkin.ejb.rm.util.DAOUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;
import com.witness.ejb.core.security.model.SuperUserFacade;
import com.witness.ejb.core.security.model.User;

/**
 * EJB implementation for CommonRequestManager. This ejb provides common methods for managaging collections of requests.
 */
<span class="nc bnc" id="L85" title="All 2 branches missed.">public class CommonRequestManagerEJB extends SessionEJBBase implements ICommonRequestManager { // OUTSIDE_CONTAINER</span>
// public class CommonRequestManagerEJB extends SessionEjbBaseForTest implements CommonRequestManager { //OUTSIDE_CONTAINER
<span class="nc" id="L87">	private static Category m_cat = Log.initCategory(CommonRequestManagerEJB.class.getName());</span>

<span class="nc" id="L89">	private static String m_className = CommonRequestManagerEJB.class.getName();</span>

	public static final String TABLE_EMPLOYEEAM_ALIAS = RequestUtil.TABLE_EMPLOYEEAM_ALIAS;

	/*
	 * This array and m_requestEJBManagersArr are linked. ie corresponding elements of both the list have the same request type.
	 */
<span class="nc" id="L96">	private final static String[] m_requestTypesArr = { Request.REQUESTTYPE_SHIFTSWAP, Request.REQUESTTYPE_TIMEOFF,</span>
			Request.REQUESTTYPE_FLEXTIME, Request.REQUESTTYPE_SHIFTBID, Request.REQUESTTYPE_CUSTSHIFT };

	// ====================================================================
	/**
	 * Each of the request type remote interfaces implement IRequestType. This
	 */
<span class="nc" id="L103">	private IRequestType[] m_requestEJBManagersArr = null;</span>

<span class="nc" id="L105">	private HashMap m_requestEJBManagersMap = null;</span>

<span class="nc" id="L107">	private final RmManagerFactory m_managerFactory = RmManagerFactory.getInstance(true);</span>

<span class="nc" id="L109">	private static Integer maxPages = null;</span>

<span class="nc" id="L111">	public CommonRequestManagerEJB() throws Exception {</span>
<span class="nc" id="L112">		super.init(m_className);</span>

<span class="nc" id="L114">		m_requestEJBManagersArr = new IRequestType[m_requestTypesArr.length];</span>

<span class="nc" id="L116">		m_requestEJBManagersMap = new HashMap(m_requestTypesArr.length);</span>

<span class="nc bnc" id="L118" title="All 2 branches missed.">		for (int i = 0; i &lt; m_requestTypesArr.length; i++) {</span>
<span class="nc" id="L119">			m_requestEJBManagersArr[i] = m_managerFactory.getRequestManagerByType(m_requestTypesArr[i], null, null);</span>

<span class="nc" id="L121">			m_requestEJBManagersMap.put(m_requestTypesArr[i], m_requestEJBManagersArr[i]);</span>
		}
<span class="nc" id="L123">	}</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="nc" id="L128">		return m_cat;</span>
	}

	// General methods:
	// returns a Request
	@Override
	public RequestAggregate getRequestByID(ID requestId, String requestType, boolean incExpired, boolean runSoftValids,
			long detailLevel) throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L136">		String _method_ = &quot;getRequestByID&quot;; // necessary for logging</span>
<span class="nc" id="L137">		methodStart(_method_, requestId, requestType);</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">		if (requestId == null) {</span>
<span class="nc" id="L140">			throw new IllegalArgumentException(&quot;requestId&quot;);</span>
		}

<span class="nc bnc" id="L143" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L144">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L147">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L148">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L150">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L151">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L154">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L157">			return manager.getRequestByID(requestId, incExpired, runSoftValids, detailLevel);</span>
<span class="nc" id="L158">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L159">			m_cat.error(e, e);</span>
<span class="nc" id="L160">			handleException(e);</span>
<span class="nc" id="L161">			throw e;</span>
<span class="nc" id="L162">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L169">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L170">			throw e;</span>
<span class="nc" id="L171">		} catch (Exception e) {</span>
<span class="nc" id="L172">			this.handleException(e);</span>
<span class="nc" id="L173">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L175" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L176">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L178">			methodFinish();</span>
		}
	}

	// returns a Collection of non-validated common portion of Requests given a Collection of requestIds

	/*
	 * public Collection getRequestsByID (Collection requestIds ) throws BbmFinderException, RemoteException { String _method_ =
	 * &quot;getRequestsByID/1&quot;; methodStart(_method_, requestIds); if (requestIds == null) { throw RequestUtil.createBbmFinderException(
	 * RmEjbBundleKey.BUNDLE, RmEjbBundleKey.INVALID_VALUE, new Object[] {_method_, m_className, &quot;requestIds&quot;, requestIds}); }
	 *
	 * RequestManager manager = m_managerFactory.getRequestManager(); try { return manager.findRequestsByIds(requestIds); } catch
	 * (BbmFinderException e) { this.handleException(_method_, e, false); throw e; } finally { methodFinish(); } }
	 */

	// returns a Collection of validated specific Requests (e.g. TO, SS, SB)
	@Override
	public Collection getRequestsByID(Collection requestIds, String reqType, boolean incExpired, boolean runSoftValids,
			long detailLevel) throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L197">		String _method_ = &quot;getRequestsByID&quot;; // necessary for logging.</span>
<span class="nc" id="L198">		methodStart(_method_, requestIds, reqType, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">		if (requestIds == null) {</span>
<span class="nc" id="L201">			throw new IllegalArgumentException(&quot;requestIds&quot;);</span>
		}

<span class="nc bnc" id="L204" title="All 2 branches missed.">		if (reqType == null) {</span>
<span class="nc" id="L205">			throw new IllegalArgumentException(&quot;reqType&quot;);</span>
		}

<span class="nc" id="L208">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L209">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L211">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L212">			IRequestType manager = m_managerFactory.getRequestManagerByType(reqType);</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L215">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L218">			return manager.getRequestsById(requestIds, incExpired, runSoftValids, true, detailLevel);</span>
<span class="nc" id="L219">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L220">			m_cat.error(e, e);</span>
<span class="nc" id="L221">			handleException(e);</span>
<span class="nc" id="L222">			throw e;</span>
<span class="nc" id="L223">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L230">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L231">			throw e;</span>
<span class="nc" id="L232">		} catch (Exception e) {</span>
<span class="nc" id="L233">			handleException(e);</span>
<span class="nc" id="L234">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L236" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L237">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L239">			methodFinish();</span>
		}
	}

	// returns a count of the Requests of type requestType for an employee
	@Override
	public int getRequestsCountForEmployee(ID employeeId, String requestType) throws BbmFinderException, RmException,
			RmHardValidationException {
<span class="nc" id="L247">		String _method_ = &quot;getRequestsCountForEmployee&quot;; // necessary for logging</span>
<span class="nc" id="L248">		methodStart(_method_, employeeId, requestType);</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">		if (employeeId == null) {</span>
<span class="nc" id="L251">			throw new IllegalArgumentException(&quot;employeeId&quot;);</span>
		}

<span class="nc bnc" id="L254" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L255">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

		IRequestType manager;
<span class="nc" id="L259">		Collection requests = new ArrayList(21);</span>

<span class="nc" id="L261">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L262">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L264">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L266" title="All 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(requestType)) {</span>
<span class="nc" id="L267">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L270">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L273">				requests = manager.getRequestIdsByEmployee(employeeId, false);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">				if (requests == null) {</span>
<span class="nc" id="L275">					throw RequestUtil.createRmException(RmEjbLogBundleKey.NO_OBJECTS, null, m_cat);</span>
				}

<span class="nc" id="L278">				return requests.size();</span>
			} else {
<span class="nc bnc" id="L280" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L281">					manager = m_requestEJBManagersArr[i];</span>
<span class="nc" id="L282">					requests.addAll(manager.getRequestIdsByEmployee(employeeId, false));</span>
				}

<span class="nc" id="L285">				return requests.size();</span>
			}
<span class="nc" id="L287">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L288">			m_cat.error(e, e);</span>
<span class="nc" id="L289">			handleException(e);</span>
<span class="nc" id="L290">			throw e;</span>
<span class="nc" id="L291">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L298">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L299">			throw e;</span>
<span class="nc" id="L300">		} catch (RmException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L303">			handleException(e);</span>
<span class="nc" id="L304">			throw e;</span>
<span class="nc" id="L305">		} catch (Exception e) {</span>
<span class="nc" id="L306">			handleException(e);</span>
<span class="nc" id="L307">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L309" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L310">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L312">			methodFinish();</span>
		}
	}

	/**
	 * returns a Collection of Requests (agent view).
	 *
	 * Note: transaaction attribute == NotSupported. Primary motivations for this are &lt;li&gt;Each 'request manager' (which handles a
	 * specific type of request) delegated to by this method manages its own transaction. Thus any error, when fetching requests
	 * within a request manager, only rolls back the transaction it started. If transaction support == 'requires' for this method
	 * instead of 'NotSupported, then the transaction started by this method will be rolledback.
	 *
	 * @param employeeId
	 * @param reqType 'all', 'shift-swap','time-off', 'flex-time', 'shift-bid'
	 * @param incExpired
	 * @param runSoftValids
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	@Override
	public Collection getRequestsByEmployee(ID empID, String reqType, boolean incExpired, boolean runSoftValids, long detailLevel)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L335">		String _method_ = &quot;getRequestsByEmployee&quot;; // necessary for logging.</span>
<span class="nc" id="L336">		methodStart(_method_, empID, reqType, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">		if (empID == null) {</span>
<span class="nc" id="L339">			throw new IllegalArgumentException(&quot;empID&quot;);</span>
		}

<span class="nc bnc" id="L342" title="All 2 branches missed.">		if (reqType == null) {</span>
<span class="nc" id="L343">			throw new IllegalArgumentException(&quot;reqType&quot;);</span>
		}

<span class="nc" id="L346">		ArrayList requests = new ArrayList(10);</span>

<span class="nc" id="L348">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L349">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L351">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// if a specific request type is requested.
<span class="nc bnc" id="L354" title="All 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(reqType)) {</span>
				// 'activate agent TO workflow' setting is enforced by webtier
				// when requestType != all (eg: if reqType == 'timeoff', then webtier does not fetch
				// requests if this setting is off).
<span class="nc" id="L358">				IRequestType reqMgr = m_managerFactory.getRequestManagerByType(reqType);</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">				if (reqMgr == null) {</span>
<span class="nc" id="L361">					throw new IllegalArgumentException(&quot;reqMgr&quot;);</span>
				}

<span class="nc" id="L364">				return reqMgr.getRequestsByEmployee(empID, incExpired, runSoftValids, detailLevel);</span>
			} else { // if reqType == 'all'
				// get 'activate agent TO workflow' setting for employee's organization. This
				// setting is processed only for reqType == 'all'. For specific request types, this
				// processing is done by webtier (if reqType == 'timeoff', then webtier does not fetch
				// requests if this setting is off).
<span class="nc" id="L370">				ID empOrgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(empID);</span>
<span class="nc" id="L371">				OrganizationSetting empOrgSetting = CacheUtilRM.getOrgSetting(empOrgID);</span>
<span class="nc" id="L372">				boolean AGTOWFlowActive = empOrgSetting.getAgentTimeOffWorkflowActive();</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L375">					IRequestType reqMgr = m_requestEJBManagersArr[i];</span>

					// get type of request manager.
<span class="nc" id="L378">					String reqTypeForReqMgr = m_requestTypesArr[i];</span>

					// if type == 'timeoff' and 'activate agent TO workflow' == false, skip fetching TO requets.
<span class="nc bnc" id="L381" title="All 4 branches missed.">					if (reqTypeForReqMgr.equals(Request.REQUESTTYPE_TIMEOFF) &amp;&amp; !AGTOWFlowActive) {</span>
<span class="nc" id="L382">						continue;</span>
					}

					// if an exception is thrown when fetching a request type, continue with the other
					// request types.
					try {
<span class="nc bnc" id="L388" title="All 2 branches missed.">						if (reqMgr.isUserAuthorizedToViewPersonalRequests(RequestUtil.getLoginUserBasic(m_sessionContext))) {</span>
<span class="nc" id="L389">							Collection reqsForEmp = reqMgr.getRequestsByEmployee(empID, incExpired, runSoftValids, detailLevel);</span>

<span class="nc" id="L391">							requests.addAll(reqsForEmp);</span>
						}
<span class="nc" id="L393">					} catch (Exception e) {</span>
<span class="nc" id="L394">						m_cat.error(&quot;Not propogating caught exception: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L395">						continue;</span>
<span class="nc" id="L396">					}</span>
					// if code added below, note 'continue' within 'try' block above.
				}

<span class="nc" id="L400">				return requests;</span>
			}
<span class="nc" id="L402">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L403">			m_cat.error(e, e);</span>
<span class="nc" id="L404">			handleException(e);</span>
<span class="nc" id="L405">			throw e;</span>
<span class="nc" id="L406">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L413">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L414">			throw e;</span>
<span class="nc" id="L415">		} catch (Exception e) {</span>
<span class="nc" id="L416">			handleException(e);</span>
<span class="nc" id="L417">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L419" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L420">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L422">			methodFinish();</span>
		}
	}

	/**
	 * Find all the requests in manager's view.
	 *
	 * Note: transaaction attribute == NotSupported. Primary motivations for this are &lt;li&gt;If all requests are retrieved without
	 * pagination, then a transaction timeout will occur since it may take a few minutes to retrieve all transactions. &lt;li&gt;Each
	 * 'request manager' (which handles a specific type of request) delegated to by this method manages its own transaction. Thus
	 * any error, when fetching requests within a request manager, only rolls back the transaction it started. If transaction
	 * support == 'requires' for this method instead of 'NotSupported, then the transaction started by this method will be
	 * rolledback.
	 *
	 *
	 * @param empID the employee ID of the manager
	 * @param filterID the id of the request filter controlling the scope of requests returned. This input can be null. If null,
	 *            then all by all employees in organizations for which the manager is able to view requests are returned.
	 * @param findName an additional filter that is applied to the set of employees. Only employees whose names contain the the
	 *            findName as a substring will be returned. This input may be null. If not null, then findName is checked agains the
	 *            string FIRST_NAME||&quot; &quot;||LAST_NAME for the CONTAINS relation. The comparison is case sensitive.
	 * @param sortColumn identifies the column to use to sort the requests. The constants that define the expected values are in
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
	 * @param sortDirection this controls whether or not the sort is ascending or descending. The constants that define this input
	 *            are defined in {@link com.bluepumpkin.ejb.core.base.SupportNavigation SupportNavigation}
	 * @param chunkSize the maximum number of request value objects to return. The resulting RequestCollection will have at most
	 *            this many request objects in it. Webtier specifies Integer.MAX_VALUE to mean CHUNKSIZE_ALL. to return all the
	 *            requests objects matching the filter at once.
	 * @return a request collection that contains a list of requests as well as a map of employeeIds to EmployeeName objects
	 */
	@Override
	public RequestCollection getRequestsForManager(ID empID, ID filterID, String findName, int sortColumn, int sortDirection,
			int chunkSize, boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal, long detailLevel)
			throws BbmFinderException, RmHardValidationException {

<span class="nc" id="L457">		String methodName = &quot;getRequestsForManager&quot;;</span>
<span class="nc" id="L458">		methodStart(methodName, new Object[] { empID, filterID, findName, new Integer(sortColumn), new Integer(sortDirection),</span>
				new Integer(chunkSize), new Boolean(incExpired), new Boolean(runSoftValids) });

<span class="nc" id="L461">		String setterID = m_className + '.' + methodName + '_' + &quot;filterID&quot;;</span>
<span class="nc" id="L462">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L464">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// Get the request filter if specified
<span class="nc" id="L467">			RequestFilter requestFilter = null;</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">			if (filterID != null) {</span>
				try {
<span class="nc" id="L471">					requestFilter = getRequestFilterById(filterID);</span>
<span class="nc" id="L472">				} catch (Exception e) {</span>
<span class="nc" id="L473">					m_cat.error(&quot;Error getting request filter&quot;, e);</span>
<span class="nc" id="L474">				}</span>

				// If unable to read filter for id, then t_hrow a BbmFinderException
<span class="nc bnc" id="L477" title="All 2 branches missed.">				if (requestFilter == null) {</span>
<span class="nc" id="L478">					throw new NullPointerException(&quot;requestFilter&quot;);</span>
				}
			}

			// Invoke the adhoc version now that we have the filter object, if specified
<span class="nc" id="L483">			return getRequestsForManager(empID, requestFilter, findName, sortColumn, sortDirection, chunkSize, incExpired,</span>
					runSoftValids, runNetStaffingSoftVal, detailLevel);
<span class="nc" id="L485">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L486">			m_cat.error(e, e);</span>
<span class="nc" id="L487">			handleException(e, false);</span>
<span class="nc" id="L488">			throw e;</span>
<span class="nc" id="L489">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L496">			handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L497">			throw e;</span>
<span class="nc" id="L498">		} catch (Exception e) { // TODO: ensure that no exception leaves any remote interface method without rolling back the</span>
								// exception.
<span class="nc" id="L500">			handleException(e, false);</span>
<span class="nc" id="L501">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L503" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L504">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L506">			methodFinish();</span>
		}
	}

	/**
	 * Find all the requests a manager's view.
	 *
	 * &lt;p&gt;
	 * Note that:
	 * &lt;li&gt;if Filter.STATUS_KEY is not set, then all reqs with status 'invalid', 'withdrawn' or 'negotiation' is filtered.
	 *
	 * Note: transaaction attribute == NotSupported. Primary motivations for this are
	 * &lt;li&gt;If all requests are retrieved without pagination, then a transaction timeout will occur since it may take a few minutes
	 * to retrieve all transactions.
	 * &lt;li&gt;Each 'request manager' (which handles a specific type of request) delegated to by this method manages its own
	 * transaction. Thus any error, when fetching requests within a request manager, only rolls back the transaction it started. If
	 * transaction support == 'requires' for this method instead of 'NotSupported, then the transaction started by this method will
	 * be rolledback.
	 *
	 * @param empID the employee ID of the manager
	 * @param filterID the id of the request filter controlling the scope of requests returned. This input can be null. If null,
	 *            then all by all employees in organizations for which the manager is able to view requests are returned.
	 * @param findName an additional filter that is applied to the set of employees. Only employees whose names contain the the
	 *            findName as a substring will be returned. This input may be null. If not null, then findName is checked agains the
	 *            string FIRST_NAME||&quot; &quot;||LAST_NAME for the CONTAINS relation. The comparison is case sensitive.
	 * @param sortColumn identifies the column to use to sort the requests. The constants that define the expected values are in
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
	 * @param sortDirection this controls whether or not the sort is ascending or descending. The constants that define this input
	 *            are defined in {@link com.bluepumpkin.ejb.core.base.SupportNavigation SupportNavigation}
	 * @param chunkSize the maximum number of request value objects to return. The resulting RequestCollection will have at most
	 *            this many request objects in it. Webtier specified Integer.MAX_VALUE to mean CHUNKSIZE_ALL to return all the
	 *            requests objects matching the filter at once.
	 * @return a request collection that contains a list of requests as well as a map of employeeIds to EmployeeName objects
	 */
	@Override
	public RequestCollection getRequestsForManager(ID mgrEmpID, RequestFilter reqFilter, String findName, int sortColumn,
			int sortDirection, int chunkSize, boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal,
			long detailLevel) throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L544">		String _method_ = &quot;getRequestsForManager&quot;;</span>
<span class="nc" id="L545">		methodStart(_method_, new Object[] { mgrEmpID, reqFilter, findName, new Integer(sortColumn), new Integer(sortDirection),</span>
				new Integer(chunkSize), new Boolean(incExpired), new Boolean(runSoftValids) });

<span class="nc bnc" id="L548" title="All 2 branches missed.">		if (mgrEmpID == null) {</span>
<span class="nc" id="L549">			throw new IllegalArgumentException(&quot;mgrEmpID&quot;);</span>
		}
<span class="nc" id="L551">		String setterID = m_className + '.' + _method_ + '_' + &quot;filter&quot;;</span>
<span class="nc" id="L552">		boolean cacheEnabled = false;</span>
<span class="nc" id="L553">		boolean threadCacheEnabled = false;</span>
		try {
<span class="nc" id="L555">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L556">			threadCacheEnabled = ThreadLocalCache.enable();</span>

			// if reqFilter == null, then create a default filter.
<span class="nc bnc" id="L559" title="All 2 branches missed.">			if (reqFilter == null) {</span>
<span class="nc" id="L560">				reqFilter = new RequestFilter(mgrEmpID, &quot;default filter&quot;);</span>
<span class="nc" id="L561">				reqFilter.setKey(RequestFilter.REQUEST_TYPE_KEY, Request.REQUESTTYPE_ALL);</span>
			}

<span class="nc" id="L564">			String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>

			// This collection empIDsFiltered is used to filter requests by a given employee collection.
<span class="nc" id="L567">			Collection empIDsFiltered = null;</span>
			// EMPLOYEE_KEY is only used for the timeoff rest service
<span class="nc bnc" id="L569" title="All 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.EMPLOYEE_KEY)) {</span>
<span class="nc" id="L570">				ID empId = (ID) reqFilter.getValueForKey(RequestFilter.EMPLOYEE_KEY);</span>
<span class="nc" id="L571">				empIDsFiltered = new ArrayList();</span>
<span class="nc" id="L572">				empIDsFiltered.add(empId);</span>
<span class="nc" id="L573">			}</span>
			// if EMPLOYEE_KEY is set, SUPERVISOR_KEY will not be effective
<span class="nc bnc" id="L575" title="All 2 branches missed.">			else if (reqFilter.isKeySet(RequestFilter.SUPERVISOR_KEY)) {</span>
<span class="nc" id="L576">				empIDsFiltered = getEmpIDsForMgrUsingReqFilter(mgrEmpID, reqFilter);</span>
<span class="nc bnc" id="L577" title="All 4 branches missed.">				if (empIDsFiltered == null || empIDsFiltered.isEmpty()) {</span>
					// SUPERVISOR Key is set but no employees found for gievn SUPERVISOR; hence abort search and return
<span class="nc" id="L579">					return new RequestCollection(Collections.emptyList(), Collections.emptyList(), Collections.emptyMap());</span>
				}
			}

<span class="nc" id="L583">			Collection mgrViewPrivOrgs = getOrgIDsForMgrUsingReqFilter(mgrEmpID, reqFilter);</span>

<span class="nc" id="L585">			Object[] fourElemArr = getRequestIDsSortedUsingReqFilter(empIDsFiltered, mgrViewPrivOrgs, reqFilter, findName,</span>
					incExpired, sortColumn, sortDirection);
<span class="nc" id="L587">			List&lt;ID&gt; reqIDsAfterFilter = (List&lt;ID&gt;) fourElemArr[0];</span>
<span class="nc" id="L588">			Map reqIDToReqTypeMap = (Map) fourElemArr[4];</span>
			// Map reqIDToReqTypeMap = RequestUtil.getReqIDToReqTypeMap(reqIDsAfterFilter, (List) fourElemArr[1]);

<span class="nc" id="L591">			List reqEmpIDsForReqIDs = (List) fourElemArr[2];</span>
<span class="nc" id="L592">			List reqEmpOrgIDForReqIDs = (List) fourElemArr[3];</span>

			// process requestIDs for org level setting: 'TimeOff Management' &gt; 'Activiate manager workflow'
			// Note: this method modifies the lists passed as parameters.
<span class="nc" id="L596">			processActivateManagerTOWorkflowSetting(reqIDsAfterFilter, reqIDToReqTypeMap, reqEmpIDsForReqIDs, reqEmpOrgIDForReqIDs);</span>

			// process requestIDs for org level setting: 'Shift Swap' &gt; 'Enable Shift Swap'
			// Note: this method modifies the lists passed as parameters.
<span class="nc" id="L600">			processEnableShiftSwapSetting(reqIDsAfterFilter, reqIDToReqTypeMap, reqEmpIDsForReqIDs, reqEmpOrgIDForReqIDs);</span>

			// QC 42221: If an employee creates a future request, and that employee will change orgs
			// before the effective date of the request, AND if a manager has privileges to view requests
			// for both the employee's current and future org, then the request will be duplicated.
			// Note: this method may modify the lists passed as parameters.
<span class="nc" id="L606">			removeDuplicateRequests(reqIDsAfterFilter, reqIDToReqTypeMap, reqEmpIDsForReqIDs, reqEmpOrgIDForReqIDs);</span>

			// Now process 'sort' criteria and 'filter' conditions which cannot be done at the SQL level.
			// Note: this filtering cannot be done for 'REQUEST_TYPE == all'. It can only be done for a
			// single request type.
<span class="nc" id="L611">			Collection reqs = null;</span>
			// This will hold the requests that are already queried if REquestType != All . Specially for
			// ShiftBIDs &amp; TimeOFF
<span class="nc bnc" id="L614" title="All 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(filterReqType)) {</span>
				// returns a Pair of RequestIds &lt;-&gt; Requests. The Collection of Request may be null based on implementation
<span class="nc" id="L616">				Pair reqsEmpIDsPairAfterFilter = applyFilterAndSortCriteriaForReqIDs(mgrEmpID, reqIDsAfterFilter, reqFilter,</span>
						sortColumn, sortDirection, incExpired, detailLevel, runSoftValids, runNetStaffingSoftVal);
<span class="nc" id="L618">				reqIDsAfterFilter = (List) reqsEmpIDsPairAfterFilter.getFirst();</span>
<span class="nc" id="L619">				reqs = (Collection) reqsEmpIDsPairAfterFilter.getSecond();</span>
			}

			// if no reqIDs found after applying filter, return.
<span class="nc bnc" id="L623" title="All 4 branches missed.">			if (reqIDsAfterFilter == null || reqIDsAfterFilter.isEmpty()) {</span>
<span class="nc" id="L624">				return new RequestCollection(Collections.emptyList(), Collections.emptyList(), Collections.emptyMap());</span>
			}

			// use min of returned size and chunk size to get request objects
<span class="nc bnc" id="L628" title="All 2 branches missed.">			int adjChunkSize = (chunkSize == Integer.MAX_VALUE) ? reqIDsAfterFilter.size() : chunkSize;</span>
			// limit to 4096 requests. Earlier bug at this point caused (#23290) caused an OutOfMemoryException when
			// marshalling results back to the caller.
<span class="nc" id="L631">			adjChunkSize = Math.min(adjChunkSize, 4096);</span>

			// use the reqIDs and reqTypes to invoke the appropriate request manager to load the actual requests
<span class="nc" id="L634">			Pair reqsEmpIDsPair = getReqsFromEJBManagersOrdered(reqIDsAfterFilter, reqIDToReqTypeMap,</span>
<span class="nc" id="L635">					Request.REQUESTTYPE_ALL.equals(filterReqType), incExpired, runSoftValids, runNetStaffingSoftVal, 0,</span>
					adjChunkSize, detailLevel, reqs);

			// filter expired requests; we expect the returned req list to be of type linkedList
			// since 'invalid' requests may be removed from the middle of the list.
<span class="nc" id="L640">			LinkedList sortedReqs = (LinkedList) reqsEmpIDsPair.getFirst();</span>
			// filterInvalidRequests(sortedReqs);

			// Use set of employee ids to get name map
<span class="nc" id="L644">			Set reqEmpIDs = (Set) reqsEmpIDsPair.getSecond();</span>
<span class="nc" id="L645">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L646">			Map&lt;ID, EmployeeName&gt; nameMap = wrm.getEmployeeNamesByIDs(reqEmpIDs);</span>
			// build rquest collection and return to caller

			//limit the number of records returned if needed
<span class="nc" id="L650">			return limitToMaxPages(reqIDsAfterFilter, sortedReqs, nameMap, adjChunkSize);</span>
<span class="nc" id="L651">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L652">			m_cat.error(e, e);</span>
<span class="nc" id="L653">			handleException(e, false);</span>
<span class="nc" id="L654">			throw e;</span>
<span class="nc" id="L655">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L662">			handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L663">			throw e;</span>
<span class="nc" id="L664">		} catch (Exception e) {</span>
<span class="nc" id="L665">			handleException(e, false);</span>
<span class="nc" id="L666">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L668" title="All 8 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L669">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L671">			ThreadLocalCache.clear(threadCacheEnabled);</span>
<span class="nc" id="L672">			methodFinish();</span>
		}
	}

	private RequestCollection limitToMaxPages(List&lt;ID&gt; requestIds, List&lt;?&gt; requests, Map&lt;ID, EmployeeName&gt; nameMap, int pageSize) {

<span class="nc bnc" id="L678" title="All 2 branches missed.">		if (maxPages == null) {</span>
<span class="nc" id="L679">			maxPages = RequestManagementConfigKey.getMaxPages();</span>
		}

<span class="nc bnc" id="L682" title="All 2 branches missed.">		if (maxPages &lt;= 0) {</span>
<span class="nc" id="L683">			return new RequestCollection(requestIds, requests, nameMap);</span>
		}

		//limit to a max of maxPages pages
<span class="nc" id="L687">		int limitRequestIDCountTo = Math.min(pageSize * maxPages, requestIds.size());</span>
<span class="nc" id="L688">		List&lt;ID&gt; requestIDsLimited = requestIds.subList(0, limitRequestIDCountTo);</span>
<span class="nc" id="L689">		return new RequestCollection(requestIDsLimited, requests, nameMap);</span>
	}

	/**
	 * returns a Pair of RequestIds &lt;-&gt; Requests. The Collection of Request may be null based on implementation of each
	 * RequestManager
	 *
	 * @param reqIDsAfterFilter
	 * @param reqFilter
	 * @param sortColumn
	 * @param sortDirection
	 * @param inclExpired
	 * @param detailLevel
	 */
	@Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDsAfterFilter, RequestFilter reqFilter, int sortColumn,
			int sortDirection, boolean inclExpired, long detailLevel, boolean runSoftValids, boolean runNetStaffingSoftVal)
			throws BbmFinderException {

		// filtering at the 'java' level is presently supported only for a single request type and not
		// for request type == all.
<span class="nc" id="L710">		String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">		if (Request.REQUESTTYPE_ALL.equals(filterReqType)) {</span>
<span class="nc" id="L712">			throw new IllegalArgumentException(&quot;RequestFilter.requestType cannot be ALL&quot;);</span>
		}
<span class="nc" id="L714">		IRequestType reqMgr = (IRequestType) m_requestEJBManagersMap.get(filterReqType);</span>
		try {
<span class="nc" id="L716">			return reqMgr.applyFilterAndSortCriteriaForReqIDs(mgrEmpID, reqIDsAfterFilter, reqFilter, sortColumn, sortDirection,</span>
					inclExpired, detailLevel, runSoftValids, runNetStaffingSoftVal);
<span class="nc" id="L718">		} catch (Exception e) {</span>
<span class="nc" id="L719">			handleException(e);</span>
<span class="nc" id="L720">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Get the next chunk of requests for display in a manager view. This interface is designed to be called when paging through a
	 * set of results returned by {@link #getRequestsForManager getRequestsForManager}. The caller must preserve the complete lists
	 * of ids and their associated types from a previous call to {@link #getRequestsForManager getRequestsForManager}.
	 *
	 * @param empID the employee ID of the manager
	 * @param ids this is a sublist of the complete list of ids. The caller selects this list of ids to display.
	 * @param types this is the list of request types that correspond to the list or request ids being passed in
	 * @return a request collection that contains
	 *         &lt;ul&gt;
	 *         &lt;li&gt;the same list of request ids passed in. This list isn't terribly useful for the caller. The original list
	 *         returned by {@link #getRequestsForManager getRequestsForManager} must be preserved,&lt;/li&gt;
	 *         &lt;li&gt;the same list of types passed in,&lt;/li&gt;
	 *         &lt;li&gt;a list of the requested request objects,&lt;/li&gt;
	 *         &lt;li&gt;map of employeeId-&gt;EmployeeName objects. The set of employees is the complete set of employees referenced in the
	 *         returned set of request objects.&lt;/li&gt;
	 *         &lt;/ul&gt;
	 */
	@Override
	public RequestCollection getNextRequestsForManager(ID mgrEmpID, List givenIDs, RequestFilter reqFilter, boolean incExpired,
			boolean runSoftValids, boolean runNetStaffingSoftVal, long detailLevel) throws BbmFinderException,
			RmHardValidationException {
<span class="nc" id="L746">		String _method_ = &quot;getNextRequestsForManager&quot;;</span>
<span class="nc" id="L747">		methodStart(_method_, mgrEmpID, givenIDs, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="nc" id="L749">		RequestDAO reqDAO = null;</span>

<span class="nc" id="L751">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L752">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L754">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// Need to get a map of IDs to types
<span class="nc" id="L757">			reqDAO = new RequestDAO(Request.REQUESTTYPE_ALL, Request.DL_BASIC);</span>
<span class="nc" id="L758">			Map&lt;ID, String&gt; reqIDToType = reqDAO.getRequestTypesForIds(givenIDs);</span>

			// TODO: optimize: isReqTypeAll == true|false.
<span class="nc" id="L761">			Pair reqsEmpIDsPair = getReqsFromEJBManagersOrdered(givenIDs, reqIDToType, true, incExpired, runSoftValids,</span>
<span class="nc" id="L762">					runNetStaffingSoftVal, 0, givenIDs.size(), detailLevel, null);</span>

			// filter expired requests; we expect the returned req list to be of type linkedList
			// since 'invalid' requests may be removed from the middle of the list.
<span class="nc" id="L766">			LinkedList orderedReqs = (LinkedList) reqsEmpIDsPair.getFirst();</span>
			// filterInvalidRequests(orderedReqs);

			// get map of empID to empName
<span class="nc" id="L770">			Collection reqEmpIDs = (Collection) reqsEmpIDsPair.getSecond();</span>
<span class="nc" id="L771">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L772">			Map empIDToEmpNameMap = wrm.getEmployeeNamesByIDs(reqEmpIDs);</span>
			// build rquest collection and return to caller
<span class="nc" id="L774">			return new RequestCollection(givenIDs, orderedReqs, empIDToEmpNameMap);</span>
<span class="nc" id="L775">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L776">			m_cat.error(e, e);</span>
<span class="nc" id="L777">			handleException(e);</span>
<span class="nc" id="L778">			throw e;</span>
<span class="nc" id="L779">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L786">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L787">			throw e;</span>
<span class="nc" id="L788">		} catch (Exception e) {</span>
<span class="nc" id="L789">			handleException(e);</span>
<span class="nc" id="L790">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L792" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L793">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L795" title="All 4 branches missed.">			if (reqDAO != null) {</span>
<span class="nc" id="L796">				reqDAO.cleanUp();</span>
			}
<span class="nc" id="L798">			methodFinish();</span>
		}
	}

	private void filterInvalidRequests(LinkedList sortedReqs) {
<span class="nc bnc" id="L803" title="All 2 branches missed.">		for (Iterator iter = sortedReqs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L804">			RequestAggregate reqAgg = (RequestAggregate) iter.next();</span>
			// if request is invalid, remove from collection.
<span class="nc bnc" id="L806" title="All 2 branches missed.">			if (RequestAuditTrail.STATUS_INVALID.equals(reqAgg.getRequestStatus())) {</span>
<span class="nc" id="L807">				iter.remove();</span>
			}
<span class="nc" id="L809">		}</span>
<span class="nc" id="L810">	}</span>

	// creates a Request
	@Override
	public ID createRequest(RequestAggregate request, String comment) throws BbmCreateException, RmHardValidationException {
<span class="nc" id="L815">		String _method_ = &quot;createRequest&quot;; // used elsewhere as well</span>
<span class="nc" id="L816">		methodStart(&quot;createRequest&quot;, request, comment);</span>

<span class="nc bnc" id="L818" title="All 2 branches missed.">		if (request == null) {</span>
<span class="nc" id="L819">			throw new IllegalArgumentException(&quot;request&quot;);</span>
		}

<span class="nc" id="L822">		String requestType = request.getRequestType();</span>
<span class="nc" id="L823">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L824">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L826">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L828">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L830" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L831">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L834">			return manager.createRequest(request, comment);</span>
<span class="nc" id="L835">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L836">			m_cat.error(e, e);</span>
<span class="nc" id="L837">			handleException(e);</span>
<span class="nc" id="L838">			throw e;</span>
<span class="nc" id="L839">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L846">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L847">			throw e;</span>
<span class="nc" id="L848">		} catch (Exception e) {</span>
<span class="nc" id="L849">			handleException(e);</span>
<span class="nc" id="L850">			throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L852" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L853">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L855">			methodFinish();</span>
		}
	}

	// updates a Request
	@Override
	public void updateRequest(RequestAggregate request, String comment) throws BbmUpdateException, MultiUserException,
			RmHardValidationException {
<span class="nc" id="L863">		String _method_ = &quot;updateRequest&quot;; // used elsewhere as well.</span>
<span class="nc" id="L864">		methodStart(_method_, request, comment);</span>

<span class="nc bnc" id="L866" title="All 2 branches missed.">		if (request == null) {</span>
<span class="nc" id="L867">			throw new IllegalArgumentException(&quot;request&quot;);</span>
		}

<span class="nc" id="L870">		String requestType = request.getRequestType();</span>
<span class="nc" id="L871">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L872">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L874">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L876">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L878" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L879">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L882">			manager.updateRequest(request, comment);</span>
<span class="nc" id="L883">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L884">			m_cat.error(e, e);</span>
<span class="nc" id="L885">			handleException(e);</span>
<span class="nc" id="L886">			throw e;</span>
<span class="nc" id="L887">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L894">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L895">			throw e;</span>
<span class="nc" id="L896">		} catch (MultiUserException e) {</span>
<span class="nc" id="L897">			m_cat.error(e, e);</span>
<span class="nc" id="L898">			handleException(e);</span>
<span class="nc" id="L899">			throw e;</span>
<span class="nc" id="L900">		} catch (Exception e) {</span>
<span class="nc" id="L901">			handleException(e);</span>
<span class="nc" id="L902">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L904" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L905">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L907">			methodFinish();</span>
<span class="nc" id="L908">		}</span>
<span class="nc" id="L909">	}</span>

	// change the state of a Request (specific processing to be handled by back-end)
	@Override
	public void changeRequestState(ID requestId, String state, String objectVersionNumber, String comment, String requestType)
			throws RmException, RmHardValidationException {
<span class="nc" id="L915">		String _method_ = &quot;changeRequestState&quot;;</span>
<span class="nc" id="L916">		methodStart(_method_, requestId, state, comment, requestType);</span>

<span class="nc" id="L918">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L919">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L921">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L923">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L925">				throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_REQUEST_TYPE, new Object[] { requestType }, m_cat);</span>
			}

<span class="nc" id="L928">			manager.changeRequestStateByID(requestId, state, objectVersionNumber, comment);</span>
<span class="nc" id="L929">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L936">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L937">			throw e;</span>
<span class="nc" id="L938">		} catch (RmException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L941">			handleException(e);</span>
<span class="nc" id="L942">			throw e;</span>
<span class="nc" id="L943">		} catch (Exception e) {</span>
<span class="nc" id="L944">			handleException(e);</span>
<span class="nc" id="L945">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L947" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L948">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L950">			methodFinish();</span>
<span class="nc" id="L951">		}</span>
<span class="nc" id="L952">	}</span>

	/**
	 * Process a group of requests for one of the following actions: &lt;li&gt;@see CommonRequestManager#GA_APPROVE_ALL_WITHOUT_VIOL &lt;li&gt;@see
	 * CommonRequestManager#GA_TENT_APPROVE_ALL_WITHOUT_VIOL &lt;li&gt;@see CommonRequestManager#GA_DENY_ALL_WITH_VIOLATIONS &lt;li&gt;@see
	 * CommonRequestManager#GA_CONFIRM_ALL_TENT_APPROVALS &lt;li&gt;@see CommonRequestManager#GA_REMOVE_ALL_TENT_APPROVALS
	 *
	 * Note: transaction attribute == 'Not supported'.
	 *
	 * @see CommonRequestManager#processRequests(Collection, Collection, String)
	 *
	 */
	@Override
	public void processRequests(Collection reqIDs, Collection objVerNums, String reqAction) throws RmException,
			RmHardValidationException {
<span class="nc" id="L967">		String _method_ = &quot;processRequests&quot;;</span>
<span class="nc" id="L968">		methodStart(_method_, reqIDs, objVerNums, reqAction);</span>

<span class="nc" id="L970">		RequestDAO reqDAO = null;</span>
<span class="nc" id="L971">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L972">		boolean cacheEnabled = false;</span>
<span class="nc" id="L973">		boolean localCacheEnabled = ThreadLocalCache.enable();</span>
		try {
<span class="nc" id="L975">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>


			// load the request objects (without their children) to identify the request type.
<span class="nc" id="L979">			reqDAO = new RequestDAO(Request.REQUESTTYPE_ALL, Request.DL_BASIC);</span>
<span class="nc" id="L980">			Collection requests = reqDAO.getRequestsByIDs(reqIDs, Request.DL_BASIC);</span>
			// build a map or request ID to request.
<span class="nc" id="L982">			Map reqIDToReqMap = RequestUtil.getMapOfIDsForVOBases(requests);</span>

<span class="nc" id="L984">			ShiftSwapRequestManager ssMgr = (ShiftSwapRequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_SHIFTSWAP);</span>
<span class="nc" id="L985">			TORequestManager toMgr = (TORequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_TIMEOFF);</span>
<span class="nc" id="L986">			FlexTimeRequestManager ftMgr = (FlexTimeRequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_FLEXTIME);</span>
<span class="nc" id="L987">			ShiftBidRequestManager sbReqMgr = (ShiftBidRequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_SHIFTBID);</span>
<span class="nc" id="L988">			CustShiftReqMgr csReqMgr = (CustShiftReqMgr) m_requestEJBManagersMap.get(Request.REQUESTTYPE_CUSTSHIFT);</span>

<span class="nc" id="L990">			Map&lt;ID, RequestAggregate&gt; toRequestMap = ftMgr.getRequestMapByIDs(reqIDs, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP);</span>

			// identify the type of request (using the IDs)
<span class="nc" id="L993">			Iterator verNumItr = objVerNums.iterator();</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">			for (Iterator reqIDsItr = reqIDs.iterator(); reqIDsItr.hasNext();) {</span>
				// get the request's ID
<span class="nc" id="L996">				ID reqID = (ID) reqIDsItr.next();</span>
				// get the version number
<span class="nc bnc" id="L998" title="All 2 branches missed.">				if (!verNumItr.hasNext()) {</span>
<span class="nc" id="L999">					throw new RuntimeException(&quot;Error: Cannot find version number for request with ID: &quot; + reqID);</span>
				}
<span class="nc" id="L1001">				String reqVerNum = (String) verNumItr.next();</span>

				// look up the request in the map by its ID.
<span class="nc" id="L1004">				Request req = (Request) reqIDToReqMap.get(reqID);</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">				if (req == null) {</span>
<span class="nc" id="L1006">					throw new RuntimeException(&quot;Error: Cannot find request with ID in map: &quot; + reqID);</span>
				}

				// set the object version number passed from the UI.
<span class="nc" id="L1010">				req.setObjectVersionNumber(reqVerNum);</span>

				// in the next catch handler, exception will be eaten or propogated based on this flag.
<span class="nc" id="L1013">				boolean propogateException = false;</span>
				try {
					// process based on request's type.
<span class="nc bnc" id="L1016" title="All 2 branches missed.">					if (req.isTimeOffRequest()) {</span>
<span class="nc" id="L1017">						RequestAggregate reqAggr = toRequestMap.get(reqID);</span>
<span class="nc bnc" id="L1018" title="All 4 branches missed.">						if(reqAggr != null &amp;&amp; reqAggr.isFlexTimeRequest()) {</span>
							//process single Flex Time Request
<span class="nc" id="L1020">							ftMgr.processSingleRequest(req, reqAction);</span>
						}
						else {
							//process single TO Request
<span class="nc" id="L1024">							toMgr.processSingleRequest(req, reqAction);</span>
						}
<span class="nc bnc" id="L1026" title="All 2 branches missed.">					} else if (req.isShiftSwapRequest()) {</span>
<span class="nc" id="L1027">						ssMgr.processSingleRequest(req, reqAction);</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">					} else if (req.isShiftBidRequest()) {</span>
<span class="nc" id="L1029">						sbReqMgr.processSingleRequest(req, reqAction);</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">					} else if (req.isCustShiftRequest()) {</span>
<span class="nc" id="L1031">						csReqMgr.processSingleRequest(req, reqAction);</span>
					} else {
						// Normally, exceptions are not propogated to the caller by the catch handler. In this case, it should.
<span class="nc" id="L1034">						propogateException = true;</span>
<span class="nc" id="L1035">						throw new IllegalArgumentException(req.getRequestType());</span>
					}
<span class="nc" id="L1037">				} catch (Exception e) {</span>
<span class="nc" id="L1038">					m_cat.l7dError(RmEjbLogBundleKey.GROUP_ACTION_EXCEPTION, new Object[] { e.getLocalizedMessage() }, e);</span>

<span class="nc bnc" id="L1040" title="All 2 branches missed.">					if (propogateException) {</span>
<span class="nc" id="L1041">						throw e;</span>
					}
<span class="nc" id="L1043">				}</span>
<span class="nc" id="L1044">			}</span>
<span class="nc" id="L1045">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1052">			handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L1053">			throw e;</span>
<span class="nc" id="L1054">		} catch (RmException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L1057">			handleException(e, false);</span>
<span class="nc" id="L1058">			throw e;</span>
<span class="nc" id="L1059">		} catch (Exception e) {</span>
<span class="nc" id="L1060">			handleException(e, false);</span>
<span class="nc" id="L1061">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1063">			ThreadLocalCache.clear(localCacheEnabled);</span>

<span class="nc bnc" id="L1065" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1066">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1068" title="All 4 branches missed.">			if (reqDAO != null) {</span>
<span class="nc" id="L1069">				reqDAO.cleanUp();</span>
			}
<span class="nc" id="L1071">			methodFinish();</span>
<span class="nc" id="L1072">		}</span>
<span class="nc" id="L1073">	}</span>

	// deletes a Request
	@Override
	public void deleteRequest(ID requestId, String requestType, String comment) throws BbmRemoveException,
			RmHardValidationException {
<span class="nc" id="L1079">		String _method_ = &quot;deleteRequest&quot;;</span>
<span class="nc" id="L1080">		methodStart(_method_, requestId, requestType, comment);</span>

<span class="nc bnc" id="L1082" title="All 2 branches missed.">		if (requestId == null) {</span>
<span class="nc" id="L1083">			throw new IllegalArgumentException(&quot;requestId&quot;);</span>
		}

<span class="nc bnc" id="L1086" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1087">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1090">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1091">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1093">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1095">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1097" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L1098">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L1101">			manager.deleteRequest(requestId, comment);</span>
<span class="nc" id="L1102">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1109">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1110">			throw e;</span>
<span class="nc" id="L1111">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1112">			m_cat.error(e, e);</span>
<span class="nc" id="L1113">			handleException(e);</span>
<span class="nc" id="L1114">			throw e;</span>
<span class="nc" id="L1115">		} catch (Exception e) {</span>
<span class="nc" id="L1116">			handleException(e);</span>
<span class="nc" id="L1117">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1119" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1120">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1122">			methodFinish();</span>
<span class="nc" id="L1123">		}</span>
<span class="nc" id="L1124">	}</span>

	// deletes a Collection of Requests
	@Override
	public void deleteRequests(Collection ids, String requestType, String comment) throws BbmRemoveException,
			RmHardValidationException {
<span class="nc" id="L1130">		String _method_ = &quot;deleteRequests&quot;;</span>
<span class="nc" id="L1131">		methodStart(_method_, ids, comment);</span>

<span class="nc bnc" id="L1133" title="All 2 branches missed.">		if (ids == null) {</span>
<span class="nc" id="L1134">			throw new IllegalArgumentException(&quot;ids&quot;);</span>
		}

<span class="nc bnc" id="L1137" title="All 2 branches missed.">		if (requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1138">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1141">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1142">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1144">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1146">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1148" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L1149">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L1152">			manager.deleteRequests(ids, comment);</span>
<span class="nc" id="L1153">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1154">			m_cat.error(e, e);</span>
<span class="nc" id="L1155">			handleException(e);</span>
<span class="nc" id="L1156">			throw e;</span>
<span class="nc" id="L1157">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1164">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1165">			throw e;</span>
<span class="nc" id="L1166">		} catch (Exception e) {</span>
<span class="nc" id="L1167">			handleException(e);</span>
<span class="nc" id="L1168">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1170" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1171">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1173">			methodFinish();</span>
<span class="nc" id="L1174">		}</span>
<span class="nc" id="L1175">	}</span>

	/**
	 * Delete all the requests of the given type and subtype.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: All requests of this type
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByType(ID organizationId, boolean isForBranch, String requestType, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1196">		String _method_ = &quot;deleteRequestsByType&quot;;</span>
<span class="nc" id="L1197">		methodStart(_method_, organizationId, new Boolean(isForBranch), requestType, subType);</span>

<span class="nc bnc" id="L1199" title="All 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1200">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="nc bnc" id="L1203" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1204">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1207">		IRequestType manager = null;</span>

<span class="nc" id="L1209">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1210">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1212">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1214" title="All 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1215">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1217" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1218">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1221">				manager.deleteRequests(organizationId, isForBranch, subType);</span>
			} else {
<span class="nc bnc" id="L1223" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1224">					manager = m_requestEJBManagersArr[i];</span>

					// Subtype does not make sense for ALL requests, ignore anything passed
					// and call the manager
<span class="nc" id="L1228">					manager.deleteRequests(organizationId, isForBranch, null);</span>
				}
			}
<span class="nc" id="L1231">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1232">			m_cat.error(e, e);</span>
<span class="nc" id="L1233">			handleException(e);</span>
<span class="nc" id="L1234">			throw e;</span>
<span class="nc" id="L1235">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1242">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1243">			throw e;</span>
<span class="nc" id="L1244">		} catch (Exception e) {</span>
<span class="nc" id="L1245">			handleException(e);</span>
<span class="nc" id="L1246">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1248" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1249">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1251">			methodFinish();</span>
<span class="nc" id="L1252">		}</span>
<span class="nc" id="L1253">	}</span>

	/**
	 * Delete all the requests of the given type and subtype that concern dates that are older than the given date.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: For the dates more than 'n' days
	 * in the past
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param date purge the requests that concern dates older than this date
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByDate(ID organizationId, boolean isForBranch, Date date, String requestType, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1276">		String _method_ = &quot;deleteRequestsByDate&quot;;</span>
<span class="nc" id="L1277">		methodStart(_method_, organizationId, new Boolean(isForBranch), date, subType);</span>

<span class="nc bnc" id="L1279" title="All 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1280">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="nc bnc" id="L1283" title="All 2 branches missed.">		if (date == null) {</span>
<span class="nc" id="L1284">			throw new IllegalArgumentException(&quot;date&quot;);</span>
		}

<span class="nc bnc" id="L1287" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1288">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1291">		IRequestType manager = null;</span>

<span class="nc" id="L1293">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1294">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1296">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1298" title="All 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1299">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1301" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1302">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1305">				manager.deleteRequestsByDate(organizationId, isForBranch, date, subType);</span>
			} else {
<span class="nc bnc" id="L1307" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1308">					manager = m_requestEJBManagersArr[i];</span>

					// Subtype does not make sense for ALL requests, ignore anything passed
					// and call the manager
<span class="nc" id="L1312">					manager.deleteRequestsByDate(organizationId, isForBranch, date, null);</span>
				}
			}
<span class="nc" id="L1315">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1316">			m_cat.error(e, e);</span>
<span class="nc" id="L1317">			handleException(e);</span>
<span class="nc" id="L1318">			throw e;</span>
<span class="nc" id="L1319">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1326">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1327">			throw e;</span>
<span class="nc" id="L1328">		} catch (Exception e) {</span>
<span class="nc" id="L1329">			handleException(e);</span>
<span class="nc" id="L1330">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1332" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1333">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1335">			methodFinish();</span>
<span class="nc" id="L1336">		}</span>
<span class="nc" id="L1337">	}</span>

	/**
	 * Delete all the requests of the given type and subtype that were created in the given date range.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: For requests created 'fromdate'
	 * to 'todate'
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param range the range to use when purging requests. All subject requests that were created within this time range will be
	 *            purged.
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByDateRange(ID organizationId, boolean isForBranch, TimeRange range, String requestType, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1361">		String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L1362">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, requestType);</span>

<span class="nc bnc" id="L1364" title="All 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1365">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="nc bnc" id="L1368" title="All 2 branches missed.">		if (range == null) {</span>
<span class="nc" id="L1369">			throw new IllegalArgumentException(&quot;range&quot;);</span>
		}

<span class="nc bnc" id="L1372" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1373">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1376">		IRequestType manager = null;</span>

<span class="nc" id="L1378">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1379">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1381">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1383" title="All 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1384">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1386" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1387">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1390">				manager.deleteRequestsByDateRange(organizationId, isForBranch, range, subType);</span>
			} else {
<span class="nc bnc" id="L1392" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1393">					manager = m_requestEJBManagersArr[i];</span>

					// Ignore subtype parameter for type=ALL request
<span class="nc" id="L1396">					manager.deleteRequestsByDateRange(organizationId, isForBranch, range, null);</span>
				}
			}
<span class="nc" id="L1399">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1400">			m_cat.error(e, e);</span>
<span class="nc" id="L1401">			handleException(e);</span>
<span class="nc" id="L1402">			throw e;</span>
<span class="nc" id="L1403">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1410">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1411">			throw e;</span>
<span class="nc" id="L1412">		} catch (Exception e) {</span>
<span class="nc" id="L1413">			handleException(e);</span>
<span class="nc" id="L1414">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1416" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1417">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1419">			methodFinish();</span>
<span class="nc" id="L1420">		}</span>
<span class="nc" id="L1421">	}</span>

	/**
	 * Delete all the requests of the given type and subtype that start in the given date range.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: For requests starting during
	 * 'fromdate' to 'todate'
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param range the range to use when purging requests. All subject requests that were created within this time range will be
	 *            purged.
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, String requestType,
			ID subType) throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1445">		String _method_ = &quot;deleteRequestsByStartDateRange&quot;;</span>
<span class="nc" id="L1446">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, requestType);</span>

<span class="nc bnc" id="L1448" title="All 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1449">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="nc bnc" id="L1452" title="All 2 branches missed.">		if (range == null) {</span>
<span class="nc" id="L1453">			throw new IllegalArgumentException(&quot;range&quot;);</span>
		}

<span class="nc bnc" id="L1456" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1457">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1460">		IRequestType manager = null;</span>

<span class="nc" id="L1462">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1463">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1465">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1467" title="All 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1468">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1470" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1471">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1474">				manager.deleteRequestsByStartDateRange(organizationId, isForBranch, range, subType);</span>
			} else {
<span class="nc bnc" id="L1476" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1477">					manager = m_requestEJBManagersArr[i];</span>

					// Ignore subtype parameter for type=ALL request
<span class="nc" id="L1480">					manager.deleteRequestsByStartDateRange(organizationId, isForBranch, range, null);</span>
				}
			}
<span class="nc" id="L1483">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1484">			m_cat.error(e, e);</span>
<span class="nc" id="L1485">			handleException(e);</span>
<span class="nc" id="L1486">			throw e;</span>
<span class="nc" id="L1487">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1494">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1495">			throw e;</span>
<span class="nc" id="L1496">		} catch (Exception e) {</span>
<span class="nc" id="L1497">			handleException(e);</span>
<span class="nc" id="L1498">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1500" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1501">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1503">			methodFinish();</span>
<span class="nc" id="L1504">		}</span>
<span class="nc" id="L1505">	}</span>

	/**
	 * Get list of possible states for a given request type
	 *
	 * @param reqType one of the strings defined in {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}, the type
	 *            may be ALL in which case the states that are common to all request types are returned
	 * @return a List of possible states for the specified type or the list of the common states if ALL is specified.
	 */
	@Override
	public List getPossibleStatesForRequestType(String reqType) throws BbmFinderException {
<span class="nc" id="L1516">		String _method_ = &quot;getPossibleStatesForRequestType&quot;;</span>
<span class="nc" id="L1517">		methodStart(_method_);</span>

<span class="nc" id="L1519">		List result = null;</span>

<span class="nc bnc" id="L1521" title="All 2 branches missed.">		if (reqType == null) {</span>
<span class="nc" id="L1522">			throw new IllegalArgumentException(&quot;reqType&quot;);</span>
		}

		try {
<span class="nc bnc" id="L1526" title="All 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(reqType)) {</span>
<span class="nc" id="L1527">				IRequestType manager = m_managerFactory.getRequestManagerByType(reqType);</span>

<span class="nc bnc" id="L1529" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1530">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1533">				result = manager.getPossibleStates();</span>
<span class="nc" id="L1534">			} else {</span>
				// Want all common states
<span class="nc" id="L1536">				result = RequestAuditTrail.COMMON_STATES;</span>
			}

			// Add expired to the list we have so far
<span class="nc" id="L1540">			List returnValue = new ArrayList();</span>

<span class="nc bnc" id="L1542" title="All 2 branches missed.">			if (result != null) {</span>
<span class="nc" id="L1543">				returnValue.addAll(result);</span>
			}

<span class="nc" id="L1546">			returnValue.add(RequestFilter.EXPIRED_STATUS);</span>

<span class="nc" id="L1548">			return returnValue;</span>
			// } catch (BbmFinderException e) {
			// m_cat.error(e, e);
			// handleException(e);
			// throw e;
<span class="nc" id="L1553">		} catch (Exception e) {</span>
<span class="nc" id="L1554">			this.handleException(e, false);</span>
<span class="nc" id="L1555">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1557">			methodFinish();</span>
		}
	}

	/**
	 * Gets orgs for which given manager has VIEWREQUEST privilege
	 *
	 * @param mgrEmpID
	 * @param requestFilter
	 * @return A Set of Organizations
	 * @throws Exception
	 */
	protected Collection getOrgIDsForMgrUsingReqFilter(ID mgrEmpID, RequestFilter requestFilter) throws Exception {
<span class="nc" id="L1570">		Set orgsWithViewPrivForMgr = RequestUtil.getOrgIDsWithViewReqPrivilegesForEmpID(mgrEmpID);</span>

		// Check, if the user does not have the request viewing privilege
		// in any organization, then log that and return a null result
<span class="nc bnc" id="L1574" title="All 2 branches missed.">		if (orgsWithViewPrivForMgr.size() == 0) {</span>
<span class="nc" id="L1575">			m_cat.debug(&quot;mgrEmpID &quot; + mgrEmpID + &quot; does not have the privilege to view reqeusts in any organization.&quot;);</span>
<span class="nc" id="L1576">			return Collections.emptyList();</span>
		}
<span class="nc" id="L1578">		m_cat.debug(&quot;&gt;&gt;&gt; checking for requests in: &quot; + orgsWithViewPrivForMgr);</span>

		// Process the organizations in the filter
<span class="nc bnc" id="L1581" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L1582">			TimeOffBidDAO dao = new TimeOffBidDAO();</span>
			try {
<span class="nc" id="L1584">				WorkResourceManager wkrManager = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1585">				Collection&lt;ID&gt; bidOrgIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1586">				ID bidID = new ID(requestFilter.getValueForKey(RequestFilter.TOBID_KEY).toString());</span>
<span class="nc" id="L1587">				TimeOffBid bid = dao.getObjectByID(bidID);</span>

<span class="nc" id="L1589">				bidOrgIDs.add(bid.getOrganizationId());</span>
<span class="nc" id="L1590">				bidOrgIDs = wkrManager.getOrganizationsChildrenByIDs(bidOrgIDs);</span>
<span class="nc" id="L1591">				bidOrgIDs.add(bid.getOrganizationId());</span>
<span class="nc" id="L1592">				orgsWithViewPrivForMgr.retainAll(bidOrgIDs);</span>
<span class="nc" id="L1593">			} catch (Exception e) {</span>
				// restrict the set of organizations by the tree in the filter.
				// Fall Back if there is an exception
<span class="nc" id="L1596">				orgsWithViewPrivForMgr.retainAll(requestFilter.getSelectedOrganizationIDs());</span>
			} finally {
<span class="nc bnc" id="L1598" title="All 6 branches missed.">				if (dao != null) {</span>
<span class="nc" id="L1599">					dao.cleanUp();</span>
				}
			}
<span class="nc bnc" id="L1602" title="All 2 branches missed.">		} else if (requestFilter.isKeySet(RequestFilter.ORGANIZATION_KEY)) {</span>
			// restrict the set of organizations by the tree in the filter.
<span class="nc" id="L1604">			orgsWithViewPrivForMgr.retainAll((Collection) requestFilter.getValueForKey(RequestFilter.ORGANIZATION_KEY)); // performs</span>
																															// intersection
		}

<span class="nc" id="L1608">		return orgsWithViewPrivForMgr;</span>
	}

	/**
	 * &lt;li&gt;get orgs with 'VIEWREQSFOREMP' privilege for the given mgr &lt;li&gt;get empIDs for these orgs. Restrict empIDs further based
	 * on reqFilter criteria (seniority, supervisor etc).
	 *
	 * @param mgrEmpID
	 * @param requestFilter
	 * @return
	 * @throws Exception
	 */
	protected Collection getEmpIDsForMgrUsingReqFilter(ID mgrEmpID, RequestFilter requestFilter) throws Exception {
		// Get the User object for manager
<span class="nc" id="L1622">		Set orgsWithViewPrivForMgr = RequestUtil.getOrgIDsWithViewReqPrivilegesForEmpID(mgrEmpID);</span>

		// Check, if the user does not have the request viewing privilege
		// in any organization, then log that and return a null result
<span class="nc bnc" id="L1626" title="All 2 branches missed.">		if (orgsWithViewPrivForMgr.size() == 0) {</span>
<span class="nc" id="L1627">			m_cat.debug(&quot;mgrEmpID &quot; + mgrEmpID + &quot; does not have the privilege to view reqeusts in any organization.&quot;);</span>
<span class="nc" id="L1628">			return Collections.emptyList();</span>
		}
<span class="nc" id="L1630">		m_cat.debug(&quot;&gt;&gt;&gt; checking for requests in: &quot; + orgsWithViewPrivForMgr);</span>

		// Process the organizations in the filter
<span class="nc bnc" id="L1633" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.ORGANIZATION_KEY)) {</span>
			// restrict the set of organizations by the tree in the filter.
<span class="nc" id="L1635">			orgsWithViewPrivForMgr.retainAll((Collection) requestFilter.getValueForKey(RequestFilter.ORGANIZATION_KEY)); // performs</span>
																															// intersection
		}

		// Build an employee filter using what we know to get a collection
		// of employee ids. The filter is made of compounding sub filter
		// objects. I'm using the fully qualified class names to avoid
		// confusion since there are a few different kinds of filters.
<span class="nc" id="L1643">		ArrayList empFilters = new ArrayList();</span>
<span class="nc" id="L1644">		List requestTimeRange = null;</span>
<span class="nc" id="L1645">		List dateRange = (List) requestFilter.getValueForKey(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L1646">		Date start = null;</span>
<span class="nc" id="L1647">		Date end = null;</span>
<span class="nc bnc" id="L1648" title="All 2 branches missed.">		if (dateRange != null) {</span>
<span class="nc" id="L1649">			start = (Date) dateRange.get(0);</span>
<span class="nc" id="L1650">			end = (Date) dateRange.get(1);</span>
		}
<span class="nc bnc" id="L1652" title="All 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1653">			requestTimeRange = new ArrayList();</span>
<span class="nc" id="L1654">			requestTimeRange.add(start);</span>
<span class="nc" id="L1655">			requestTimeRange.add(end);</span>
		}
<span class="nc" id="L1657">		addOrganizationToEmpFilter(empFilters, orgsWithViewPrivForMgr, requestTimeRange);</span>
<span class="nc" id="L1658">		addSupervisorToEmpFilter(empFilters, requestFilter, requestTimeRange);</span>
<span class="nc" id="L1659">		addCampaignToEmpFilter(empFilters, requestFilter, requestTimeRange);</span>
<span class="nc" id="L1660">		Collection empIds = getEmpIDsUsingEmpFilter(new SuperUserFacade(), empFilters);</span>
		// The employee ids cannot be an empty set, or else we'll find nothing.
<span class="nc bnc" id="L1662" title="All 4 branches missed.">		if ((empIds == null) || (empIds.isEmpty())) {</span>
<span class="nc" id="L1663">			m_cat.debug(&quot;&gt;&gt;&gt;No users in organizations!.&quot;);</span>
		}
<span class="nc" id="L1665">		return empIds;</span>
	}

	protected Object getFilterKey(RequestFilter reqFilter, String keyName) {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">		if (reqFilter.isKeySet(keyName)) {</span>
<span class="nc" id="L1670">			return reqFilter.getValueForKey(keyName);</span>
		}

<span class="nc" id="L1673">		return null;</span>
	}

	static class Quad {

		private Object m_first;
		private Object m_second;
		private Object m_third;
		private Object m_fourth;

<span class="nc" id="L1683">		Quad() {</span>
<span class="nc" id="L1684">		}</span>

<span class="nc" id="L1686">		Quad(Object first, Object second, Object third, Object fourth) {</span>
<span class="nc" id="L1687">			m_first = first;</span>
<span class="nc" id="L1688">			m_second = second;</span>
<span class="nc" id="L1689">			m_third = third;</span>
<span class="nc" id="L1690">			m_fourth = fourth;</span>
<span class="nc" id="L1691">		}</span>

		/**
		 * @return Object
		 */
		public Object getFirst() {
<span class="nc" id="L1697">			return m_first;</span>
		}

		/**
		 * @return Object
		 */
		public Object getSecond() {
<span class="nc" id="L1704">			return m_second;</span>
		}

		/**
		 * @return Object
		 */
		public Object getThird() {
<span class="nc" id="L1711">			return m_third;</span>
		}

		/**
		 * @return Object
		 */
		public Object getFourth() {
<span class="nc" id="L1718">			return m_fourth;</span>
		}

	}

	/**
	 * get a sorted list of request IDs by transforming the given request filter and sort criteria into SQL and executing it.
	 *
	 * &lt;li&gt;get the SQL statement clauses (select, from, where and order by) from the specific request manager if requestType !=
	 * REQUESTTYPE_ALL &lt;li&gt;get the SQL statement clauses (select, from, where and order by) common to all request types. &lt;li&gt;Use dmo
	 * to execute the query built using the clauses retrieved above.
	 *
	 * @param mgrViewPrivOrgs a Set of organizations for which the querying mgr has view privileges
	 * @param reqFilter
	 * @param findName
	 * @param sortColumn
	 * @param sortDirection
	 * @return an array of arrays: reqIDs, reqTypes, reqEmpIDs, reqEmpOrgIDs.
	 * @throws Exception
	 */
	// QA 95168: refactor query to use list of orgs rather than list of employees
	// public Object[] getRequestIDsSortedUsingReqFilter(Collection empIDsFiltered, RequestFilter reqFilter,
	@Override
	public Object[] getRequestIDsSortedUsingReqFilter(Collection empIDsFiltered, Collection mgrViewPrivOrgs,
			RequestFilter reqFilter, String findName, boolean includeExpired, int sortColumn, int sortDirection) throws Exception {
		// validate 'sortColumn' parameter
<span class="nc bnc" id="L1744" title="All 4 branches missed.">		sortColumn = (sortColumn &lt; Request.SORT_MINVALUE || sortColumn &gt; Request.SORT_MAXVALUE) ? Request.SORT_LAST_NAME_FIRST</span>
				: sortColumn;

		// get request type from filter
<span class="nc" id="L1748">		String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>

		// The query generation process has call outs to places for
		// a specific request type to customize the query. These callouts
		// are triggered with the reqeust filter specifies a specific
		// request type. We record that choice by setting the reqMgr here.
		// Later, if this is null, we know no callouts are necessary.
<span class="nc" id="L1755">		IRequestType reqMgr = null;</span>
<span class="nc" id="L1756">		Quad reqTypeSpecificSQLComps = new Quad();</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">		if (!filterReqType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1758">			reqMgr = (IRequestType) m_requestEJBManagersMap.get(filterReqType);</span>

			// Now that we have the employee ids, we need to see if the set of employeeIds
			// needs to be further restricted.
			// call the request manager for the specific request type and
			// let them further restrict the set of employees based on
			// other data in the filter.
			/*
			 * QA 95168: refactor query to remove IN (employeeList) clause empIDsFiltered =
			 * reqMgr.restrictEmployeesByFilter(empIDsFiltered, reqFilter);
			 *
			 * if ((empIDsFiltered == null) || (empIDsFiltered.size() == 0)) {
			 * m_cat.error(&quot;&gt;&gt;&gt;No users found after applying requestFilter!.&quot;); return new Object[] { Collections.emptyList(),
			 * Collections.emptyList(), Collections.emptyList(), Collections.emptyList() }; } END QA 95168
			 */

			// obtain request type specific SQL query components
<span class="nc" id="L1775">			reqTypeSpecificSQLComps = getSelectFromWhereOrderClausesForReqType(reqMgr, reqFilter, sortColumn, sortDirection);</span>
		}

		// Using linked lists instead of ArrayLists since caller may remove elements
		// from the middle of the list (for manager workflow setting).
<span class="nc" id="L1780">		List reqIDs = new LinkedList();</span>
<span class="nc" id="L1781">		List reqTypes = new LinkedList();</span>
<span class="nc" id="L1782">		List reqEmpIDs = new LinkedList();</span>
<span class="nc" id="L1783">		List reqEmpOrgIDs = new LinkedList();</span>

		// Get DMO object to work with database
<span class="nc" id="L1786">		Jdmo dmo = new Jdmo(false);</span>
<span class="nc" id="L1787">		JdmoRowset rs = null;</span>
<span class="nc" id="L1788">		Map reqIDToReqTypeMap = new HashMap();</span>
		try {
			// obtain SQL query components common across all query types.
			// QA 95168: refactor query to remove IN (employeeList) clause
			// Quad allReqTypesSQLComps = getSelectFromWhereOrderByClausesForAllReqs(reqFilter, empIDsFiltered, findName,
<span class="nc" id="L1793">			Quad allReqTypesSQLComps = getSelectFromWhereOrderByClausesForAllReqs(reqFilter, empIDsFiltered, mgrViewPrivOrgs,</span>
					findName, includeExpired, sortColumn, sortDirection, reqMgr, dmo);

			// build SQL query using 2 sets of query components: one set common to all request type and the second
			// specific to ther requestType
<span class="nc" id="L1798">			StringBuffer emptyStrBuf = new StringBuffer(&quot;&quot;);</span>
<span class="nc" id="L1799">			StringBuilder query = new StringBuilder();</span>
<span class="nc" id="L1800">			query.append((StringBuffer) allReqTypesSQLComps.getFirst())</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">					.append((reqTypeSpecificSQLComps.getFirst() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getFirst()</span>
							: emptyStrBuf)
<span class="nc" id="L1803">					.append((StringBuffer) allReqTypesSQLComps.getSecond())</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">					.append((reqTypeSpecificSQLComps.getSecond() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getSecond()</span>
							: emptyStrBuf)
<span class="nc" id="L1806">					.append((StringBuffer) allReqTypesSQLComps.getThird())</span>
<span class="nc bnc" id="L1807" title="All 2 branches missed.">					.append((reqTypeSpecificSQLComps.getThird() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getThird()</span>
							: emptyStrBuf)
<span class="nc" id="L1809">					.append((StringBuffer) allReqTypesSQLComps.getFourth())</span>
<span class="nc bnc" id="L1810" title="All 2 branches missed.">					.append((reqTypeSpecificSQLComps.getFourth() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getFourth()</span>
							: emptyStrBuf);

			// Generate row set for request ids, types and empIDs.

<span class="nc" id="L1815">			String queryStr = query.toString();</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1817">				m_cat.debug(&quot;&gt;&gt;&gt; getRequestsForManager query string: &quot; + queryStr);</span>
			}
<span class="nc" id="L1819">			rs = dmo.createRowset(queryStr);</span>
<span class="nc" id="L1820">			boolean isFlexTypeCol = queryStr.contains(&quot;FLEXTYPE&quot;);</span>

			// Get the id and type lists from the query
<span class="nc bnc" id="L1823" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1824">				reqIDs.add(rs.getID(1)); // first column: request ID</span>

<span class="nc bnc" id="L1826" title="All 4 branches missed.">				if (isFlexTypeCol &amp;&amp; rs.getInt(&quot;FLEXTYPE&quot;)==1){</span>
					// some of 'time-off' requests are actually 'flex-time' requests, we need to 'fix' them by checking which IDs are
					// 'flex-time' requests and update
<span class="nc" id="L1829">					reqTypes.add(Request.REQUESTTYPE_FLEXTIME);</span>
<span class="nc" id="L1830">					reqIDToReqTypeMap.put(rs.getID(1), Request.REQUESTTYPE_FLEXTIME);</span>
				} else {
<span class="nc" id="L1832">					reqTypes.add(rs.getString(2)); // 2nd column: request type</span>
<span class="nc" id="L1833">					reqIDToReqTypeMap.put(rs.getID(1), rs.getString(2));</span>
				}

<span class="nc" id="L1836">				reqEmpIDs.add(rs.getID(3)); // 3rd column: request's employee id.</span>

<span class="nc" id="L1838">				reqEmpOrgIDs.add(rs.getID(4)); // 4th column: request employee's organization ID.</span>
			}
		} finally {
<span class="nc bnc" id="L1841" title="All 4 branches missed.">			if (rs != null) {</span>
<span class="nc" id="L1842">				rs.close();</span>
			}
<span class="nc bnc" id="L1844" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1845">				dmo.cleanUp();</span>
			}
		}

<span class="nc" id="L1849">		m_cat.debug(&quot;&gt;&gt;&gt; getRequestsForManager returned  &quot; + reqIDs.size() + &quot; rows.&quot;);</span>
<span class="nc" id="L1850">		return new Object[] { reqIDs, reqTypes, reqEmpIDs, reqEmpOrgIDs, reqIDToReqTypeMap };</span>
	}

	/**
	 * Process 'Activate Manager TimeOff Workflow' Setting.
	 *
	 * Processes each reqID to check if it is a 'timeoff' request and if 'Activate Manager time off workflow' setting applies to it
	 * or not. If setting is disabled for the organization that the request is associated with, then the request ID is filtered out
	 * (removed). Organization associated with a request is found as follows: request --&gt; request's employee --&gt; request's
	 * employee's organization.
	 *
	 *
	 * @param reqIDsAfterFilter
	 * @param reqIDToReqTypeMap
	 * @param reqEmpIDsForReqIDs
	 * @param reqEmpOrgIDForReqIDs
	 */
	@Override
	public void processActivateManagerTOWorkflowSetting(List reqIDsAfterFilter, Map reqIDToReqTypeMap, List reqEmpIDsForReqIDs,
			List reqEmpOrgIDForReqIDs) throws BbmFinderException {
		// if (reqType == timeoff) {
		// if ( !empIDToAMWFlowMap.keyExists(empID) ) {
		// identify org association for employee
		// retrieve org setting for org (use cache if necessary).
		// empIDToAMWFlowMap.put(empID, AMWFlowSetting);
		// }
		//
		// if (empIDToAMWFlowMap.get(empID) == false) {
		// remove reqID from list.
		// }
		// }

		// caches to improve performance.
<span class="nc" id="L1883">		Map empIDToAMWFlowMap = new HashMap(); // empIDToActivateAgentWorkflowMap</span>

<span class="nc" id="L1885">		Iterator reqEmpIDsForReqIDsIter = reqEmpIDsForReqIDs.iterator();</span>
<span class="nc" id="L1886">		Iterator reqEmpOrgIDForReqIDsIter = reqEmpOrgIDForReqIDs.iterator();</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">		for (Iterator reqIDsAfterFilterIter = reqIDsAfterFilter.iterator(); reqIDsAfterFilterIter.hasNext();) {</span>
			// get request ID
<span class="nc" id="L1889">			ID reqID = (ID) reqIDsAfterFilterIter.next();</span>

			// get reqType
<span class="nc" id="L1892">			String reqType = (String) reqIDToReqTypeMap.get(reqID);</span>
			// get reqEmpID
<span class="nc" id="L1894">			ID reqEmpID = (ID) reqEmpIDsForReqIDsIter.next();</span>
			// get request employee's org ID
<span class="nc" id="L1896">			ID reqEmpOrgID = (ID) reqEmpOrgIDForReqIDsIter.next();</span>

			// if not a time off request, simply continue
<span class="nc bnc" id="L1899" title="All 4 branches missed.">			if (reqType == null || !reqType.equals(Request.REQUESTTYPE_TIMEOFF)) {</span>
<span class="nc" id="L1900">				continue;</span>
			}

			// retrieve org setting.
<span class="nc" id="L1904">			OrganizationSetting reqEmpOrgSetting = null;</span>
			try {
<span class="nc" id="L1906">				reqEmpOrgSetting = CacheUtilRM.getOrgSetting(reqEmpOrgID);</span>
<span class="nc" id="L1907">			} catch (Exception e) {</span>
<span class="nc" id="L1908">				handleException(e);</span>
<span class="nc" id="L1909">				throw new BbmFinderException(e);</span>
<span class="nc" id="L1910">			}</span>

<span class="nc bnc" id="L1912" title="All 2 branches missed.">			Boolean AMWFlowSetting = reqEmpOrgSetting.getManagerTimeOffWorkflowActive() ? Boolean.TRUE : Boolean.FALSE;</span>

			// if AMWFlowSetting is false, then remove reqID
<span class="nc bnc" id="L1915" title="All 2 branches missed.">			if (AMWFlowSetting.equals(Boolean.FALSE)) {</span>
<span class="nc" id="L1916">				reqIDsAfterFilterIter.remove();</span>
<span class="nc" id="L1917">				reqIDToReqTypeMap.remove(reqID);</span>
<span class="nc" id="L1918">				reqEmpIDsForReqIDsIter.remove();</span>
<span class="nc" id="L1919">				reqEmpOrgIDForReqIDsIter.remove();</span>
			}
<span class="nc" id="L1921">		}</span>
<span class="nc" id="L1922">	}</span>

	/**
	 * Process 'Enable Shift Swap' Setting.
	 *
	 * Processes each reqID to check if it is a 'shiftswap' request and if 'Enable Shift Swap' setting applies to it or not. If
	 * setting is disabled for the organization that the request is associated with, then the request ID is filtered out (removed).
	 * Organization associated with a request is found as follows: request --&gt; request's employee --&gt; request's employee's
	 * organization.
	 *
	 *
	 * @param reqIDsAfterFilter
	 * @param reqIDToReqTypeMap
	 * @param reqEmpIDsForReqIDs
	 * @param reqEmpOrgIDForReqIDs
	 */
	private void processEnableShiftSwapSetting(List reqIDsAfterFilter, Map reqIDToReqTypeMap, List reqEmpIDsForReqIDs,
			List reqEmpOrgIDForReqIDs) throws Exception {

<span class="nc" id="L1941">		Iterator reqEmpIDsForReqIDsIter = reqEmpIDsForReqIDs.iterator();</span>
<span class="nc" id="L1942">		Iterator reqEmpOrgIDForReqIDsIter = reqEmpOrgIDForReqIDs.iterator();</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">		for (Iterator reqIDsAfterFilterIter = reqIDsAfterFilter.iterator(); reqIDsAfterFilterIter.hasNext();) {</span>
			// get request ID
<span class="nc" id="L1945">			ID reqID = (ID) reqIDsAfterFilterIter.next();</span>

			// get reqType
<span class="nc" id="L1948">			String reqType = (String) reqIDToReqTypeMap.get(reqID);</span>
			// get reqEmpID
<span class="nc" id="L1950">			ID reqEmpID = (ID) reqEmpIDsForReqIDsIter.next();</span>
			// get request employee's org ID
<span class="nc" id="L1952">			ID reqEmpOrgID = (ID) reqEmpOrgIDForReqIDsIter.next();</span>

			// if not a shift swap request, simply continue
<span class="nc bnc" id="L1955" title="All 4 branches missed.">			if (reqType == null || !reqType.equals(Request.REQUESTTYPE_SHIFTSWAP)) {</span>
<span class="nc" id="L1956">				continue;</span>
			}

			// retrieve org setting.
<span class="nc" id="L1960">			OrganizationSetting reqEmpOrgSetting = CacheUtilRM.getOrgSetting(reqEmpOrgID);</span>

<span class="nc bnc" id="L1962" title="All 2 branches missed.">			Boolean enableShiftSwapSetting = reqEmpOrgSetting.getEnableShiftSwap() ? Boolean.TRUE : Boolean.FALSE;</span>

			// if AMWFlowSetting is false, then remove reqID
<span class="nc bnc" id="L1965" title="All 2 branches missed.">			if (enableShiftSwapSetting.equals(Boolean.FALSE)) {</span>
<span class="nc" id="L1966">				reqIDsAfterFilterIter.remove();</span>
<span class="nc" id="L1967">				reqIDToReqTypeMap.remove(reqID);</span>
<span class="nc" id="L1968">				reqEmpIDsForReqIDsIter.remove();</span>
<span class="nc" id="L1969">				reqEmpOrgIDForReqIDsIter.remove();</span>
			}
<span class="nc" id="L1971">		}</span>
<span class="nc" id="L1972">	}</span>

	/**
	 * Remove duplicate requests. Requests can be duplicated in this situation: An employee creates a request for some future time
	 * (the request effective date). The employee is configured to move to another organization between now and the request
	 * effective date. The employee's current manager has view request privileges for both the current and future organization.
	 *
	 * @param reqIDsAfterFilter
	 * @param reqIDToReqTypeMap
	 * @param reqEmpIDsForReqIDs
	 * @param reqEmpOrgIDForReqIDs
	 * @throws BbmFinderException
	 */
	private void removeDuplicateRequests(List reqIDsAfterFilter, Map reqIDToReqTypeMap, List reqEmpIDsForReqIDs,
			List reqEmpOrgIDForReqIDs) throws BbmFinderException {
<span class="nc" id="L1987">		Set requestIDs = new HashSet(reqIDsAfterFilter.size()); // empIDToActivateAgentWorkflowMap</span>

<span class="nc" id="L1989">		Iterator reqEmpIDsForReqIDsIter = reqEmpIDsForReqIDs.iterator();</span>
<span class="nc" id="L1990">		Iterator reqEmpOrgIDForReqIDsIter = reqEmpOrgIDForReqIDs.iterator();</span>
<span class="nc bnc" id="L1991" title="All 2 branches missed.">		for (Iterator reqIDsAfterFilterIter = reqIDsAfterFilter.iterator(); reqIDsAfterFilterIter.hasNext();) {</span>
			// get request ID
<span class="nc" id="L1993">			ID reqID = (ID) reqIDsAfterFilterIter.next();</span>
<span class="nc" id="L1994">			reqEmpIDsForReqIDsIter.next();</span>
<span class="nc" id="L1995">			reqEmpOrgIDForReqIDsIter.next();</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">			if (requestIDs.contains(reqID)) {</span>
<span class="nc" id="L1997">				reqIDsAfterFilterIter.remove();</span>
				// reqIDToReqTypeMap.remove(reqID); // don't remove entry from map
<span class="nc" id="L1999">				reqEmpIDsForReqIDsIter.remove();</span>
<span class="nc" id="L2000">				reqEmpOrgIDForReqIDsIter.remove();</span>
			} else {
<span class="nc" id="L2002">				requestIDs.add(reqID);</span>
			}
<span class="nc" id="L2004">		}</span>
<span class="nc" id="L2005">	}</span>

	protected StringBuffer getSQLDateBetweenClause(String givenDate, String rangeStart, String rangeEnd) {
		// return new StringBuffer( '(' + givenDate + &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;')&quot;);
<span class="nc" id="L2009">		return new StringBuffer(givenDate + &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;'&quot;);</span>
	}

	protected StringBuffer getSQLDateRangeBetweenClause(String givenDateStart, String givenDateEnd, String rangeStart,
			String rangeEnd) {
<span class="nc" id="L2014">		return new StringBuffer('(' + givenDateStart + &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;' AND &quot; + givenDateEnd</span>
				+ &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;')&quot;);
	}

	/*
	 * given, say columName = &quot;A.FIRSTNAME&quot; and personName = &quot;FIRST LAST&quot;, returns &quot;A.FIRSTNAME LIKE '%FIRST%' OR A.FIRSTNAME LIKE
	 * '%LAST%'
	 */
	protected String getSQLLikeClause(String columName, String personName, Jdmo dmo) {
		// replace ','s in personName
<span class="nc" id="L2024">		personName = personName.replace(',', ' ');</span>

		// format the 'LIKE' clause.
<span class="nc" id="L2027">		StringBuffer likeClause = new StringBuffer(40);</span>

<span class="nc" id="L2029">		boolean firstItr = true;</span>

<span class="nc bnc" id="L2031" title="All 2 branches missed.">		for (StringTokenizer tokenizer = new StringTokenizer(personName); tokenizer.hasMoreTokens();) {</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">			if (!firstItr) {</span>
<span class="nc" id="L2033">				likeClause.append(&quot; OR &quot;);</span>
			}

<span class="nc" id="L2036">			likeClause.append(columName).append(&quot; LIKE '%&quot;).append(JdmoUtil.formatDBString(tokenizer.nextToken())).append(&quot;%' &quot;);</span>

<span class="nc" id="L2038">			firstItr = false;</span>
		}

<span class="nc" id="L2041">		return likeClause.toString();</span>
	}

	/**
	 * Get SQL query components, for request filtering, which apply to all request types.
	 *
	 * If request type == 'all', and a date range is specified, a query based on the following is used. &lt;code&gt;
	 * -- If the inner joins are done first before the left joins, it will result
	 *  -- in a large result set.  Better optimization, if this is the case, is to
	 *  -- split this into 2 queries or force the inner joins to use the restrictive
	 *  -- predicates applied to the Request table.
	 *
	 *  select
	 *     req.id, req.employeeid, req.requesttype, req.requeststatus, req.expirationdate,
	 *     ssr.swaptype,
	 *     tor.debittype
	 *     ,ssri.*
	 *     , toc.*
	 *  from
	 *     request req left join (shiftswaprequest ssr inner join shiftswaprequestitem ssri on ssr.id = ssri.shiftswaprequestid and ssri.itemorder=0 inner join shiftswapitem ssi on ssri.shiftswapitemid=ssi.id) on req.id=ssr.id
	 *     left join (timeoffrequest tor inner join timeoffrequestchoice toc on tor.id=toc.timeoffrequestid) on req.id=tor.id
	 *  where
	 *     ( &lt;given daterange&gt; falls within first tochoice daterange ) or
	 *     ( &lt;given daterange&gt; falls within first shiftswap daterange )
	 * &lt;/code&gt;
	 *
	 * &lt;p&gt;
	 * If request type == 'all'|SS|TO, and a date range is not specified, then a query based on the follwoing is used. &lt;code&gt;
	 *    SELECT REQ.ID, REQ.REQUESTTYPE, REQ.REQUESTSTATUS, REQ.SUBMITTEDON, REQ.LASTMODIFIEDAT, PER.FIRSTNAME,
	 *       PER.MIDDLEINITIAL, PER.LASTNAME, PER.PFIRSTNAME, PER.PLASTNAME
	 *    FROM REQUEST A, EMPLOYEE B, PERSON C
	 *    WHERE REQ.EMPLOYEEID IN  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29) AND
	 *       REQ.EMPLOYEEID=EMP.ID AND
	 *       EMP.PERSONID=PER.ID  AND
	 *       REQ.REQUESTSTATUS NOT IN ('invalid','negotiation','withdrawn')  AND
	 *       (REQ.EXPIRATIONDATE&gt;'2003-02-17 11:25:51'  OR REQ.REQUESTSTATUS IN ( 'approved','denied','invalid','withdrawn'))  AND
	 *       PER.FIRSTNAME+' '+PER.LASTNAME LIKE '%west%'
	 *    ORDER BY PER.LASTNAME ASC , PER.FIRSTNAME ASC , PER.MIDDLEINITIAL ASC '
	 * &lt;/code&gt;
	 *
	 * @param reqFilter
	 * @param empIDs
	 * @param findName
	 * @param sortColumn
	 * @param sortDirection
	 * @param reqMgr
	 * @param dmo
	 * @return
	 * @throws RemoteException
	 * @throws JdmoException
	 */
	protected Quad getSelectFromWhereOrderByClausesForAllReqs(RequestFilter reqFilter, Collection empIDsFiltered,
			Collection mgrViewPrivOrgs, String findName, boolean incExpired, int sortColumn, int sortDirection,
			IRequestType reqMgr, Jdmo dmo) throws RemoteException, JdmoException {
<span class="nc" id="L2095">		String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>

<span class="nc bnc" id="L2097" title="All 2 branches missed.">		boolean isAllAndDateRangeSpecified = reqFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">				&amp;&amp; filterReqType.equals(Request.REQUESTTYPE_ALL);</span>

		// Now we're ready to start building the query
<span class="nc" id="L2101">		StringBuffer selectClause = new StringBuffer();</span>
<span class="nc" id="L2102">		StringBuffer fromClause = new StringBuffer();</span>
<span class="nc" id="L2103">		StringBuffer orderByClause = new StringBuffer();</span>
<span class="nc" id="L2104">		StringBuffer whereClause = new StringBuffer();</span>

		// Note: The 'DISTINCT' qualifier forces all columns that may appear in 'ORDER BY' clause to be specified in
		// the SELECT clause, though only REQ.ID, REQ.REQUESTTYPE, REQ.EMPLOYEEID and WRO.ORGANIZATIONID
		// are actually used by the application logic.
<span class="nc" id="L2109">		boolean addSortColsToSelectClause = false;</span>

		// Note: fields REQ.EMPLOYEEID and WRO.ORGANIZATIONID are fetched to identify the org
		// association of time off requests for processing 'Activate manager time off work flow' setting.
<span class="nc" id="L2113">		String SELECT_COLS_MANDATORY = &quot; &quot;;</span>
		// Makeup start date should always consider the min start date of all makeup's for each request and vice-versa for makeup end date
		// So modifying query to append an aggregate function for all select fields to include a group by on the request id
		// added in the addOrderByClause() method of FlexTimeRequestManagerEJB
<span class="nc bnc" id="L2117" title="All 6 branches missed.">		if(filterReqType.equals(Request.REQUESTTYPE_FLEXTIME) &amp;&amp;</span>
				(Request.SORT_CS_STARTTIME == sortColumn || Request.SORT_CS_ENDTIME == sortColumn)) {
<span class="nc" id="L2119">			SELECT_COLS_MANDATORY+= &quot;max(REQ.ID), max(REQ.REQUESTTYPE), max(REQ.EMPLOYEEID), max(WRO.ORGANIZATIONID) &quot;;</span>
		}else{
<span class="nc" id="L2121">			SELECT_COLS_MANDATORY+= &quot;REQ.ID, REQ.REQUESTTYPE, REQ.EMPLOYEEID, WRO.ORGANIZATIONID &quot;;</span>
		}

<span class="nc bnc" id="L2124" title="All 4 branches missed.">		if (reqMgr == null &amp;&amp; !isAllAndDateRangeSpecified) {</span>
			// We can optimize the query if we know that we wont be joining with child tables. The generic query will be unique.
<span class="nc" id="L2126">			selectClause.append(&quot;SELECT &quot;).append(SELECT_COLS_MANDATORY);</span>
		} else {
			// Since we might be joining with child tables, we need to add the DISTINCT modifier.
			// This increases the overhead of the query, but it can't be avoided.
<span class="nc" id="L2130">			selectClause.append(&quot;SELECT DISTINCT &quot;).append(SELECT_COLS_MANDATORY);</span>
			// this adds any column that may appear in the ORDER BY clause to be added to the select clause.
<span class="nc" id="L2132">			addSortColsToSelectClause = true;</span>
		}
<span class="nc" id="L2134">		fromClause.append(&quot; FROM REQUEST REQ &quot;);</span>
<span class="nc bnc" id="L2135" title="All 4 branches missed.">		if (sortColumn == Request.SORT_EMP_RANK || reqFilter.isKeySet(RequestFilter.EMP_RANK_OPERATOR_KEY)) {</span>
<span class="nc" id="L2136">			fromClause.append(&quot; LEFT JOIN (SELECT EMPLOYEEID, RANK FROM EMPLOYEERANK &quot;);</span>
<span class="nc" id="L2137">			fromClause.append(&quot; WHERE STARTTIME&lt;='&quot;).append(JdmoUtil.formatDBString(new Date())).append(&quot;'&quot;);</span>
<span class="nc" id="L2138">			fromClause.append(&quot; AND (ENDTIME&gt;'&quot;).append(JdmoUtil.formatDBString(new Date())).append(&quot;'&quot;)</span>
<span class="nc" id="L2139">					.append(&quot; OR ENDTIME IS NULL)) EMPRANK&quot;);</span>
<span class="nc" id="L2140">			fromClause.append(&quot; ON EMPRANK.EMPLOYEEID=REQ.EMPLOYEEID&quot;);</span>
		}
		// Now we add the FROM clause
<span class="nc bnc" id="L2143" title="All 2 branches missed.">		if (isAllAndDateRangeSpecified) {</span>
<span class="nc" id="L2144">			fromClause</span>
<span class="nc" id="L2145">					.append(&quot; LEFT JOIN (ShiftSwapRequest ssr INNER JOIN ShiftSwapRequestItem ssri ON ssr.ID = ssri.ShiftSwapRequestID &quot;</span>
							+ &quot;INNER JOIN ShiftSwapItem ssi ON ssri.ShiftSwapItemID=ssi.ID) &quot;
							+ &quot;on req.ID=ssr.ID &quot;);
<span class="nc" id="L2148">			fromClause</span>
<span class="nc" id="L2149">					.append(&quot; LEFT JOIN (TimeOffRequest tor INNER JOIN TimeOffRequestChoice toc on tor.ID=toc.TimeOffRequestID) on req.ID=tor.ID &quot;);</span>
<span class="nc" id="L2150">			selectClause.append(&quot;,tor.FLEXTYPE &quot;);</span>
			// Shift bid requests will always be queried based on the shift bid auction start-end dates. having more granualrity is
			// not efficient or required for now
			// Sameet Apr 2007 SILK # 92886
<span class="nc" id="L2154">			fromClause</span>
<span class="nc" id="L2155">					.append(&quot; LEFT JOIN (SHIFTBIDREQUEST  SBR INNER JOIN SHIFTBIDAUCTION SBA ON SBR.SHIFTBIDAUCTIONID=SBA.ID)  ON REQ.ID=SBR.ID &quot;);</span>
<span class="nc" id="L2156">			fromClause.append(&quot; LEFT JOIN CUSTSHIFTREQ CSR ON REQ.ID = CSR.ID &quot;);</span>
		}
		// use the WORKRESOURCEORGANIZATION association for today to prevent duplicate requests
<span class="nc" id="L2159">		fromClause.append(&quot;, EMPLOYEEAM &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;, PERSON PER, WORKRESOURCEORGANIZATION WRO &quot;);</span>

<span class="nc" id="L2161">		StringsPair datesPair = RmFilterUtil.getStartAndEndDates(reqFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L2162">		String rangeStart = datesPair.getKey();</span>
<span class="nc" id="L2163">		String rangeEnd = datesPair.getValue();</span>
<span class="nc" id="L2164">		Date dtNow = new Date();</span>
<span class="nc" id="L2165">		String strDtNow = JdmoUtil.formatDBString(dtNow);</span>

<span class="nc" id="L2167">		whereClause.append(&quot; WHERE WRO.ORGANIZATIONID IN &quot;).append(dmo.createInClause(mgrViewPrivOrgs));</span>
<span class="nc bnc" id="L2168" title="All 4 branches missed.">		if (empIDsFiltered != null &amp;&amp; !empIDsFiltered.isEmpty()) {</span>
<span class="nc" id="L2169">			whereClause.append(&quot; AND REQ.EMPLOYEEID IN &quot;).append(dmo.createInClause(empIDsFiltered));</span>
		}
<span class="nc" id="L2171">		whereClause.append(&quot; AND REQ.EMPLOYEEID=&quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.ID&quot;);</span>
<span class="nc" id="L2172">		whereClause.append(&quot; AND &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.PERSONID=PER.ID &quot;);</span>
<span class="nc" id="L2173">		whereClause.append(&quot; AND REQ.EMPLOYEEID = WRO.WORKRESOURCEID &quot;);</span>

		// check for expiration
		// Special case: if request type == all and the date range is specified.
<span class="nc bnc" id="L2177" title="All 2 branches missed.">		if (isAllAndDateRangeSpecified) {</span>
<span class="nc" id="L2178">			whereClause.append(&quot;AND (&quot;);</span>
<span class="nc" id="L2179">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot;( &quot;, &quot;toc&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L2180">			whereClause.append(&quot;)&quot;);</span>
<span class="nc" id="L2181">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot; OR (&quot;, &quot;ssi&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L2182">			whereClause.append(&quot;)&quot;);</span>
<span class="nc" id="L2183">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot; OR (&quot;, &quot;SBA&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L2184">			whereClause.append(&quot;)&quot;);</span>
<span class="nc" id="L2185">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot; OR (&quot;, &quot;CSR&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L2186">			whereClause.append(&quot;))&quot;);</span>
		}

		// Process the generic portions of the WHERE clause that come from the filter.
		// Some of the selections have defaults, so process each separately

		/*
		 * QC 39692 (QA 94619): Rewrite the status section. Create WHERE restrictions for STATUS conditions. There are various types
		 * of conditions: 1) The name of the filter. The built-in 'All active' filter is treated specially. 2) Explicitly set
		 * conditions corresponding to persistent Request object fields. For instance, status set to 'pending' translates directly
		 * to &quot;AND REQ.REQUESTSTATUS='pending'&quot; 3) Implicit conditions. For instance, the built-in filter whose name is 'All active'
		 * implicitly excludes Requests whose Status are 'invalid' or 'withdrawn'.
		 */

<span class="nc" id="L2200">		String filterName = reqFilter.getName();</span>
<span class="nc" id="L2201">		boolean isAllActiveFilter = filterName.equals(RequestUtil.DEFAULT_FILTER);</span>
<span class="nc" id="L2202">		StringBuffer statusNotInRestriction = new StringBuffer();</span>
<span class="nc" id="L2203">		statusNotInRestriction.append(&quot; AND REQ.REQUESTSTATUS NOT IN ('&quot;).append(RequestAuditTrail.STATUS_NEGOTIATION).append(&quot;'&quot;);</span>
<span class="nc" id="L2204">		StringBuffer expDateRestriction = new StringBuffer();</span>
<span class="nc" id="L2205">		expDateRestriction.append(&quot; AND REQ.EXPIRATIONDATE&quot;);</span>

		// All Active filter is a special case
<span class="nc bnc" id="L2208" title="All 2 branches missed.">		if (isAllActiveFilter) {</span>
<span class="nc" id="L2209">			expDateRestriction.append(&quot;&gt;'&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="nc" id="L2210">			statusNotInRestriction.append(&quot;,&quot;).append(RequestAuditTrail.inClauseForFinalStates()).append(&quot;)&quot;);</span>
<span class="nc" id="L2211">			whereClause.append(expDateRestriction).append(statusNotInRestriction);</span>
		} else {
			// No Filter
<span class="nc bnc" id="L2214" title="All 2 branches missed.">			if (!reqFilter.isKeySet(RequestFilter.STATUS_KEY)) {</span>
<span class="nc" id="L2215">				statusNotInRestriction.append(&quot;)&quot;);</span>
<span class="nc" id="L2216">				whereClause.append(statusNotInRestriction);</span>
			} else {
				// Include request status only if it is not for withdrawal states of TO Request
				// these withdrawal states are in seperate table so cannot include it in the REQUEST Clause
				// QC 45878 ;Filter for TO Withdraw Request and TO Withdraw Reject do not work.
				// Sameet Sept 2009
<span class="nc" id="L2222">				String reqStatus = (String) reqFilter.getValueForKey(RequestFilter.STATUS_KEY);</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">				if (!RequestAuditTrail.isRequestForWithdrawalStates(reqStatus)) {</span>
<span class="nc" id="L2224">					StringBuffer statusInRestriction = new StringBuffer();</span>
<span class="nc" id="L2225">					statusInRestriction.append(&quot; AND REQ.REQUESTSTATUS&quot;);</span>
<span class="nc bnc" id="L2226" title="All 2 branches missed.">					if (reqStatus.equals(RequestFilter.EXPIRED_STATUS)) {</span>
<span class="nc" id="L2227">						expDateRestriction.append(&quot;&lt;='&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="nc" id="L2228">						statusInRestriction.append(&quot; IN &quot;).append(RequestAuditTrail.inClauseForExpiredStates()).append(&quot; &quot;);</span>
<span class="nc" id="L2229">						statusNotInRestriction.append(&quot;) &quot;);</span>
<span class="nc" id="L2230">						whereClause.append(expDateRestriction).append(statusNotInRestriction).append(statusInRestriction);</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">					} else if (reqStatus.equals(RequestAuditTrail.STATUS_ALL_PENDING_STATES)) {</span>
<span class="nc" id="L2232">						statusInRestriction.append(&quot; IN &quot;).append(RequestAuditTrail.inClauseForExpiredStates()).append(&quot; &quot;);</span>
<span class="nc" id="L2233">						expDateRestriction.append(&quot;&gt;'&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="nc" id="L2234">						whereClause.append(expDateRestriction);</span>
<span class="nc" id="L2235">						whereClause.append(statusInRestriction);</span>
					} else { // a specific Status selected that's separate from Expired
<span class="nc" id="L2237">						statusInRestriction.append(&quot;='&quot;).append(reqStatus).append(&quot;'&quot;);</span>
						// if status is waitlist or pending, expiration date &gt; dtNow
<span class="nc bnc" id="L2239" title="All 2 branches missed.">						if (reqStatus.equals(RequestAuditTrail.STATUS_WAITLIST)</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">								|| reqStatus.equals(RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="nc" id="L2241">							expDateRestriction.append(&quot;&gt;'&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="nc" id="L2242">							whereClause.append(expDateRestriction);</span>
						}

<span class="nc" id="L2245">						whereClause.append(statusInRestriction);</span>
					}
				}
			}

		}

		// Status:
		// if Filter.STATUS_KEY is not set, then show all reqs except 'invalid', 'negotiation' and 'withdrawn'
		// if Filter.STATUS_KEY is set and Filter.STATUS_KEY != 'EXPIRED', show only requests of that type.
		// if Filter.STATUS_KEY is set and Filter.STATUS_KEY == 'EXPIRED', show all requests except 'invalid' and 'withdrawn'.
		// submitted
<span class="nc bnc" id="L2257" title="All 4 branches missed.">		if (reqFilter.isKeySet(RequestFilter.SUBMITTED_KEY) &amp;&amp; !reqFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L2258">			List dates = (List) reqFilter.getValueForKey(RequestFilter.SUBMITTED_KEY);</span>
<span class="nc" id="L2259">			String begDate = JdmoUtil.formatDBString((Date) dates.get(0));</span>
<span class="nc" id="L2260">			String endDate = JdmoUtil.formatDBString((Date) dates.get(1));</span>

			// add status condition from filter to query
<span class="nc" id="L2263">			whereClause.append(&quot; AND REQ.SUBMITTEDON &gt;='&quot;).append(begDate).append(&quot;' AND REQ.SUBMITTEDON &lt;='&quot;).append(endDate)</span>
<span class="nc" id="L2264">					.append(&quot;' &quot;);</span>
		}
<span class="nc bnc" id="L2266" title="All 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.SENIORITY_KEY)) {</span>
			// add seniority subfilter to filters
<span class="nc" id="L2268">			List dates = (List) reqFilter.getValueForKey(RequestFilter.SENIORITY_KEY);</span>
<span class="nc" id="L2269">			String begDate = JdmoUtil.formatDBString((Date) dates.get(0));</span>
<span class="nc" id="L2270">			String endDate = JdmoUtil.formatDBString((Date) dates.get(1));</span>

<span class="nc" id="L2272">			whereClause.append(&quot; AND &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.STARTTIME BETWEEN '&quot;).append(begDate)</span>
<span class="nc" id="L2273">					.append(&quot;' AND '&quot;).append(endDate).append(&quot;' &quot;);</span>
		}

		// Add find name filter
<span class="nc bnc" id="L2277" title="All 4 branches missed.">		if ((findName != null) &amp;&amp; (findName.trim().length() &gt; 0)) {</span>
<span class="nc" id="L2278">			whereClause.append(&quot; AND &quot;).append(&quot;( &quot;).append(getSQLLikeClause(&quot;PER.FIRSTNAME&quot;, findName, dmo)).append(&quot; OR &quot;)</span>
<span class="nc" id="L2279">					.append(getSQLLikeClause(&quot;PER.LASTNAME&quot;, findName, dmo)).append(&quot; ) &quot;);</span>
		}

		// Finally, we add the order by clause for the sort order.
<span class="nc" id="L2283">		String sqlSortDir = DAOUtil.getSortDirection(sortDirection);</span>

		// append the &quot;ORDER BY&quot; clause for the query. Based on the sort column, add the sort condition
<span class="nc" id="L2286">		appendToOrderByAndSelectClause(orderByClause, selectClause, addSortColsToSelectClause, sortColumn, sqlSortDir);</span>

<span class="nc" id="L2288">		return new Quad(selectClause, fromClause, whereClause, orderByClause);</span>
	}

	private void appendToOrderByAndSelectClause(StringBuffer orderByClause, StringBuffer selectClause,
			boolean addSortColsToSelectClause, int sortColumn, String sqlSortDir) {

		// append the &quot;ORDER BY&quot; clause for the query.
		// Based on the sort column, add the sort condition
<span class="nc bnc" id="L2296" title="All 11 branches missed.">		switch (sortColumn) {</span>
			case Request.SORT_LAST_NAME_FIRST:
<span class="nc" id="L2298">				orderByClause.append(&quot; ORDER BY PER.LASTNAME&quot;).append(sqlSortDir).append(&quot;, PER.FIRSTNAME&quot;).append(sqlSortDir)</span>
<span class="nc" id="L2299">						.append(&quot;, PER.MIDDLEINITIAL&quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2301" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2302">					selectClause.append(&quot;, PER.LASTNAME, PER.FIRSTNAME, PER.MIDDLEINITIAL &quot;);</span>
				}
				break;

			case Request.SORT_FIRST_NAME_FIRST:
<span class="nc" id="L2307">				orderByClause.append(&quot; ORDER BY PER.FIRSTNAME&quot;).append(sqlSortDir).append(&quot;, PER.MIDDLEINITIAL&quot;).append(sqlSortDir)</span>
<span class="nc" id="L2308">						.append(&quot;, PER.LASTNAME&quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2310" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2311">					selectClause.append(&quot;, PER.LASTNAME, PER.FIRSTNAME, PER.MIDDLEINITIAL &quot;);</span>
				}
				break;

			case Request.SORT_PLAST_NAME_FIRST:
<span class="nc" id="L2316">				orderByClause.append(&quot; ORDER BY PER.PLASTNAME&quot;).append(sqlSortDir).append(&quot;, PER.PFIRSTNAME&quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2318" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2319">					selectClause.append(&quot;, PER.PFIRSTNAME, PER.PLASTNAME &quot;);</span>
				}
				break;

			case Request.SORT_PFIRST_NAME_FIRST:
<span class="nc" id="L2324">				orderByClause.append(&quot; ORDER BY PER.PFIRSTNAME&quot;).append(sqlSortDir).append(&quot;, PER.PLASTNAME&quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2326" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2327">					selectClause.append(&quot;, PER.PFIRSTNAME, PER.PLASTNAME &quot;);</span>
				}
				break;

			case Request.SORT_STATUS:
<span class="nc" id="L2332">				orderByClause.append(&quot; ORDER BY REQ.REQUESTSTATUS &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2334" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2335">					selectClause.append(&quot;, REQ.REQUESTSTATUS &quot;);</span>
				}
				break;

			case Request.SORT_TYPE:
<span class="nc" id="L2340">				orderByClause.append(&quot; ORDER BY REQ.REQUESTTYPE &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2342" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2343">					selectClause.append(&quot;, REQ.REQUESTTYPE &quot;);</span>
				}
				break;

			case Request.SORT_MODIFIED:
<span class="nc" id="L2348">				orderByClause.append(&quot; ORDER BY REQ.LASTMODIFIEDAT &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2350" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2351">					selectClause.append(&quot;, REQ.LASTMODIFIEDAT &quot;);</span>
				}
				break;

			case Request.SORT_CREATED:
<span class="nc" id="L2356">				orderByClause.append(&quot; ORDER BY REQ.SUBMITTEDON &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2358" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2359">					selectClause.append(&quot;, REQ.SUBMITTEDON &quot;);</span>
				}
				break;
			case Request.SORT_EMP_RANK:
<span class="nc" id="L2363">				orderByClause.append(&quot; ORDER BY EMPRANK.RANK &quot;).append(sqlSortDir);</span>
<span class="nc" id="L2364">				selectClause.append(&quot;, EMPRANK.RANK &quot;);</span>
<span class="nc" id="L2365">				break;</span>
			case Request.SORT_TO_SENIORITY:
<span class="nc" id="L2367">				orderByClause.append(&quot; ORDER BY &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.STARTTIME &quot;).append(sqlSortDir);</span>
<span class="nc" id="L2368">				selectClause.append(&quot;,&quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.STARTTIME &quot;);</span>
<span class="nc" id="L2369">				break;</span>
			default:
				break;
		}
<span class="nc" id="L2373">	}</span>

	protected Quad getSelectFromWhereOrderClausesForReqType(IRequestType reqMgr, RequestFilter reqFilter, int sortColumn,
			int sortDirection) throws Exception {
<span class="nc" id="L2377">		String sortDirStr = RequestUtil.SORTDIR_ASC;</span>
<span class="nc bnc" id="L2378" title="All 2 branches missed.">		if (sortDirection == SupportNavigation.SORT_DESCENDING) {</span>
<span class="nc" id="L2379">			sortDirStr = RequestUtil.SORTDIR_DESC;</span>
		}

		// Because the sort by clause may be added by a call back
		// it may need to add additional columns here
		// call the request manager for the specific request type to
		// add any addition columns. The only ones that need be
		// added are ones that might show up in a ORDER BY clause
<span class="nc" id="L2387">		StringBuffer selectClause = new StringBuffer();</span>
<span class="nc" id="L2388">		reqMgr.addToSelectColumns(selectClause, reqFilter, sortColumn);</span>

		// Call the type-specific request manager to add additional
		// tables as necessary
		// call the request manager for the specific request type to
		// add any addition tables.
<span class="nc" id="L2394">		StringBuffer fromClause = new StringBuffer();</span>
<span class="nc" id="L2395">		reqMgr.addToFromClause(fromClause, reqFilter, sortColumn);</span>

		// We have to let the reqMgr add their join and filter conditions
		// call the request manager for the specific request type to
		// add any addition conditions
<span class="nc" id="L2400">		StringBuffer whereClause = new StringBuffer();</span>
<span class="nc" id="L2401">		reqMgr.addToWhereClause(whereClause, reqFilter, sortColumn);</span>

		// Assume that the sort order is one understood by the
		// type specific request mgr, if any
		// call the request mgr call back to add the sort
		// condition
<span class="nc" id="L2407">		StringBuffer orderByClause = new StringBuffer();</span>
<span class="nc" id="L2408">		reqMgr.addOrderByClause(orderByClause, reqFilter, sortColumn, sortDirStr);</span>

<span class="nc" id="L2410">		return new Quad(selectClause, fromClause, whereClause, orderByClause);</span>
	}

	/**
	 * Note: returned requests may be fewer than the requested number of reqs. This will be the case if one or more of the given
	 * request IDs cannot be loaded. As result, the returned list of requests will not correspond to the elements in the reqID list
	 * or reqTypes list (the elements in the reqID list and reqTypes list correspond to each other for reqType == 'all').
	 *
	 * @param isReqTypeAll
	 * @param incExpired
	 * @param runSoftValids
	 * @param reqs
	 * @return
	 * @throws RemoteException
	 */
	protected Pair getReqsFromEJBManagersOrdered(List givenReqIDs, Map reqIDToReqTypeMap, boolean isReqTypeAll, boolean incExpired,
			boolean runSoftValids, boolean runNetStaffingSoftVal, int fromIndex, int chunkSize, long detailLevel, Collection reqs)
			throws Exception {

		// get the subset of requestIDs to be loaded using the given chunkSize and fromIndex.
<span class="nc" id="L2430">		int toIndexExcl = Math.min(fromIndex + chunkSize, givenReqIDs.size());</span>
<span class="nc bnc" id="L2431" title="All 2 branches missed.">		List reqIDsToBeLoaded = (toIndexExcl == givenReqIDs.size()) ? givenReqIDs : givenReqIDs.subList(fromIndex, toIndexExcl);</span>

<span class="nc bnc" id="L2433" title="All 2 branches missed.">		if (reqIDsToBeLoaded.isEmpty()) {</span>
<span class="nc" id="L2434">			return new Pair(Collections.emptyList(), Collections.emptySet());</span>
		}

<span class="nc" id="L2437">		Set reqEmpIDSet = new HashSet(3 * chunkSize);</span>
<span class="nc" id="L2438">		Collection unsortedReqs = new ArrayList(chunkSize);</span>
<span class="nc bnc" id="L2439" title="All 2 branches missed.">		if (isReqTypeAll) { // reqType == all.</span>
			// if requestType == 'all', group the IDs in the reqIDsToBeLoaded collection by requestType for bulk loading.
<span class="nc" id="L2441">			Map reqTypeToReqIDsMap = groupReqIDsByReqType(reqIDsToBeLoaded, reqIDToReqTypeMap);</span>

<span class="nc bnc" id="L2443" title="All 2 branches missed.">			for (int i = 0; i &lt; m_requestTypesArr.length; i++) {</span>
				// get request IDs for a specific request type.
<span class="nc" id="L2445">				String reqType = m_requestTypesArr[i];</span>
<span class="nc" id="L2446">				Collection reqIDsCollForSingleReqType = (Collection) reqTypeToReqIDsMap.get(reqType);</span>
				// if ID collection is empty, continue.
<span class="nc bnc" id="L2448" title="All 2 branches missed.">				if (reqIDsCollForSingleReqType == null) {</span>
<span class="nc" id="L2449">					continue;</span>
				}

<span class="nc" id="L2452">				IRequestType reqMgr = m_requestEJBManagersArr[i];</span>

				// load the requests
<span class="nc" id="L2455">				reqs = getRequestsByIDsEatExceptions(reqIDsCollForSingleReqType, reqMgr, incExpired, runSoftValids,</span>
						runNetStaffingSoftVal, detailLevel);
<span class="nc" id="L2457">				unsortedReqs.addAll(reqs);</span>

				// build set of employeeIDs from the reqs
<span class="nc" id="L2460">				addReqEmpIDsToSet(reqEmpIDSet, reqs, reqMgr);</span>
			}
<span class="nc" id="L2462">		} else { // all requests are of a single type</span>
<span class="nc" id="L2463">			String reqType = (String) reqIDToReqTypeMap.get(reqIDsToBeLoaded.get(0));</span>
<span class="nc" id="L2464">			IRequestType reqMgr = (IRequestType) m_requestEJBManagersMap.get(reqType);</span>
			// load the requests
<span class="nc bnc" id="L2466" title="All 2 branches missed.">			if (reqs == null) {</span>
<span class="nc" id="L2467">				reqs = getRequestsByIDsEatExceptions(reqIDsToBeLoaded, reqMgr, incExpired, runSoftValids, runNetStaffingSoftVal,</span>
						detailLevel);
			}
<span class="nc" id="L2470">			unsortedReqs.addAll(reqs);</span>

			// build set of employeeIDs from the reqs
<span class="nc" id="L2473">			addReqEmpIDsToSet(reqEmpIDSet, reqs, reqMgr);</span>
		}

		// Map for fast lookup of requests by their IDs.
<span class="nc" id="L2477">		Map reqIDToReqMap = RequestUtil.getMapOfIDsForVOBases(unsortedReqs);</span>

		// Sort loaded requests in the same order as the given reqIDs
<span class="nc" id="L2480">		List sortedReqs = new LinkedList();</span>
<span class="nc bnc" id="L2481" title="All 2 branches missed.">		for (Iterator iter = reqIDsToBeLoaded.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2482">			Object req = reqIDToReqMap.get(iter.next());</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">			if (req != null) {</span>
<span class="nc" id="L2484">				sortedReqs.add(req);</span>
			}
<span class="nc" id="L2486">		}</span>

<span class="nc" id="L2488">		return new Pair(sortedReqs, reqEmpIDSet);</span>
	}

	/**
	 * Attempts bulk loading of requests first. If that fails, falls back to loading requests one by one.
	 *
	 * @param reqIDsCollForSingleReqType
	 * @param reqMgr
	 * @param incExpired
	 * @param runSoftValids
	 * @param detLevelForReqType
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private Collection getRequestsByIDsEatExceptions(Collection reqIDsCollForSingleReqType, IRequestType reqMgr,
			boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal, long detLevelForReqType) {

<span class="nc" id="L2506">		Collection reqs = null;</span>
		try {
<span class="nc" id="L2508">			reqs = reqMgr.getRequestsById(reqIDsCollForSingleReqType, incExpired, runSoftValids, runNetStaffingSoftVal,</span>
					detLevelForReqType);
<span class="nc" id="L2510">		} catch (Exception e) {</span>
<span class="nc" id="L2511">			m_cat.error(</span>
					&quot;Bulk loading of requests failed.  Trying loading reqs one by one: &quot;
<span class="nc" id="L2513">							+ RmUtil.dumpCollection(reqIDsCollForSingleReqType), e);</span>
<span class="nc" id="L2514">		}</span>

		// bulk load succeeded, so return.
<span class="nc bnc" id="L2517" title="All 2 branches missed.">		if (reqs != null) {</span>
<span class="nc" id="L2518">			return reqs;</span>
		}

		// bulk load failed. try loading reqs one by one.
<span class="nc" id="L2522">		reqs = new ArrayList(reqIDsCollForSingleReqType.size());</span>
<span class="nc bnc" id="L2523" title="All 2 branches missed.">		for (Iterator reqIDIter = reqIDsCollForSingleReqType.iterator(); reqIDIter.hasNext();) {</span>
<span class="nc" id="L2524">			ID reqID = (ID) reqIDIter.next();</span>

			try {
				// fetch the request
<span class="nc" id="L2528">				RequestAggregate reqAgg = reqMgr.getRequestByID(reqID, incExpired, runSoftValids, detLevelForReqType);</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">				if (reqAgg != null) { // will return 'null' if request does not exist.</span>
<span class="nc" id="L2530">					reqs.add(reqAgg);</span>
				}
<span class="nc" id="L2532">			} catch (Exception e) {</span>
<span class="nc" id="L2533">				m_cat.error(&quot;Could not get request id: &quot; + reqID + &quot;. Ignoring exception and resuming with next. &quot;, e);</span>
<span class="nc" id="L2534">			}</span>
<span class="nc" id="L2535">		}</span>

<span class="nc" id="L2537">		return reqs;</span>
	}

	/**
	 * Splits the given reqID collection into three collections, one each for each request type. Returns a map of reqType to reqIDs
	 * collection.
	 *
	 * @param reqIDs
	 * @param reqTypesList list of request types. Can be 'null' if parameter reqIDToReqTypeMap is non-null.
	 * @param reqIDToReqTypeMap. Can be 'null' if parameter reqTypesList is non-null.
	 * @param reqsNeeded
	 * @return
	 */
	private Map groupReqIDsByReqType(List reqIDs, Map reqIDToReqTypeMap) {

<span class="nc" id="L2552">		Map reqTypeToreqIDsCollMap = new HashMap(m_requestTypesArr.length);</span>
		// for each request ID
<span class="nc bnc" id="L2554" title="All 2 branches missed.">		for (int i = 0; i &lt; reqIDs.size(); i++) {</span>
<span class="nc" id="L2555">			ID reqID = (ID) reqIDs.get(i);</span>

			// fetch the reqType from reqTypesList or reqIDToReqTypeMap parameter.
<span class="nc" id="L2558">			String reqType = (String) reqIDToReqTypeMap.get(reqID);</span>
<span class="nc bnc" id="L2559" title="All 4 branches missed.">			assert reqType != null : &quot;reqType != null&quot;;</span>

			// get reqID collection for request type.
<span class="nc" id="L2562">			Collection reqIDsForReqType = (Collection) reqTypeToreqIDsCollMap.get(reqType);</span>
			// if collection not found in map
<span class="nc bnc" id="L2564" title="All 2 branches missed.">			if (reqIDsForReqType == null) {</span>
				// create collection
<span class="nc" id="L2566">				reqIDsForReqType = new ArrayList(reqIDs.size());</span>
				// store in map.
<span class="nc" id="L2568">				reqTypeToreqIDsCollMap.put(reqType, reqIDsForReqType);</span>
			}

<span class="nc" id="L2571">			reqIDsForReqType.add(reqID);</span>
		}

<span class="nc" id="L2574">		return reqTypeToreqIDsCollMap;</span>
	}

	private void addReqEmpIDsToSet(Set reqEmpIDs, Collection reqs, IRequestType reqMgr) throws RemoteException {
<span class="nc bnc" id="L2578" title="All 2 branches missed.">		for (Iterator reqsIter = reqs.iterator(); reqsIter.hasNext();) {</span>
<span class="nc" id="L2579">			RequestAggregate reqAgg = (RequestAggregate) reqsIter.next();</span>
<span class="nc" id="L2580">			reqMgr.addEmployeeIDsToSet(reqAgg, reqEmpIDs);</span>
<span class="nc" id="L2581">		}</span>
<span class="nc" id="L2582">	}</span>

	// /**
	// * Obtain the detailLevels from the requesFilter and store it in map. If no detail maps
	// * are specified, map retured will be null.
	// *
	// * @param reqFilter
	// * @return
	// */
	// private Map getReqTypeToDetLevelMap(RequestFilter reqFilter) {
	//
	// Map reqTypeToDetLevelMap = null; // Map of requestType to detailLevel.
	//
	// boolean isSetBidReqDetLevel = ( (reqFilter != null) &amp;&amp;
	// reqFilter.isKeySet(RequestFilter.BIDREQ_DETAILLEVEL_KEY) );
	// if (isSetBidReqDetLevel) {
	// reqTypeToDetLevelMap = (reqTypeToDetLevelMap == null)?new HashMap():reqTypeToDetLevelMap;
	// // obtain the detail level.
	// Long bidReqDetLevel = (Long) reqFilter.getValueForKey(RequestFilter.BIDREQ_DETAILLEVEL_KEY);
	// // store it in the map.
	// reqTypeToDetLevelMap.put(Request.REQUESTTYPE_SHIFTBID, bidReqDetLevel);
	// }
	// return reqTypeToDetLevelMap;
	// }
	//
	/**
	 * @param i
	 */
	private void removeFromListsAndMap(int i, List reqIDs, List reqTypesList, Map IDToReqTypesMap) {
<span class="nc" id="L2611">		ID idToBeRemoved = (ID) reqIDs.get(i);</span>

<span class="nc" id="L2613">		reqIDs.remove(i);</span>
<span class="nc bnc" id="L2614" title="All 2 branches missed.">		if (reqTypesList != null) {</span>
<span class="nc" id="L2615">			reqTypesList.remove(i);</span>
		}

<span class="nc bnc" id="L2618" title="All 2 branches missed.">		if (IDToReqTypesMap != null) {</span>
<span class="nc" id="L2619">			IDToReqTypesMap.remove(idToBeRemoved);</span>
		}
<span class="nc" id="L2621">	}</span>

	protected Collection getEmpIDsUsingEmpFilter(User mgr, ArrayList empFilters) // , List seniorityTimeRange)
			throws BbmEJBCreateException, RemoteException, BbmFinderException {
		// Now make the compound filter we'll use to get the list of
		// employee ids
<span class="nc" id="L2627">		Filter cmpFltr = new Filter(0, // not used for AND filters</span>
				Filter.OPERATOR_AND, empFilters);

		// if (seniorityTimeRange != null) {
		// cmpFltr.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);
		// cmpFltr.setStartTime((Date) seniorityTimeRange.get(0));
		// cmpFltr.setEndTime((Date) seniorityTimeRange.get(1));
		// }

<span class="nc" id="L2636">		com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter empFltr = BbmManagerFactory.getEmployeeFilter();</span>
<span class="nc" id="L2637">		Collection empIds = empFltr.getEmployeeIDs(cmpFltr,</span>
				// User
				mgr,
				// sort fields
<span class="nc" id="L2641">				Collections.emptyList(),</span>
				// is ascending, don't care about order
				false,
				// offset
				0,
				// max number of ids
				Integer.MAX_VALUE);

<span class="nc" id="L2649">		return empIds;</span>
	}

	/**
	 * get filter for Campaign ID
	 */
	private void addCampaignToEmpFilter(ArrayList empFilters, RequestFilter requestFilter, List requestTimeRange) {
<span class="nc bnc" id="L2656" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.CS_CAMPAIGNID_KEY)) {</span>
<span class="nc" id="L2657">			ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L2658">			list.add(requestFilter.getValueForKey(RequestFilter.SUPERVISOR_KEY));</span>
<span class="nc" id="L2659">			Filter f = new Filter(Filter.CAMPAIGNID, Filter.OPERATOR_EQUALS, list);</span>
<span class="nc bnc" id="L2660" title="All 2 branches missed.">			if (requestTimeRange != null) {</span>
<span class="nc" id="L2661">				f.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2662">				f.setStartTime((Date) requestTimeRange.get(0));</span>
<span class="nc" id="L2663">				f.setEndTime((Date) requestTimeRange.get(1));</span>
			}
<span class="nc" id="L2665">			empFilters.add(f);</span>
		}
<span class="nc" id="L2667">	}// getFilterForCampaign</span>

	protected void addSupervisorToEmpFilter(ArrayList empFilters, RequestFilter requestFilter, List requestTimeRange) {
		// Was supervisor filter condition set?
<span class="nc bnc" id="L2671" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.SUPERVISOR_KEY)) {</span>
<span class="nc" id="L2672">			ArrayList sups = new ArrayList(1);</span>
<span class="nc" id="L2673">			sups.add(requestFilter.getValueForKey(RequestFilter.SUPERVISOR_KEY));</span>
			// add supervisor subfilter to filters
<span class="nc" id="L2675">			Filter fsup = new Filter(Filter.MANAGERID, Filter.OPERATOR_IN, sups);</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">			if (requestTimeRange != null) {</span>
<span class="nc" id="L2677">				fsup.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2678">				fsup.setStartTime((Date) requestTimeRange.get(0));</span>
<span class="nc" id="L2679">				fsup.setEndTime((Date) requestTimeRange.get(1));</span>
			}

<span class="nc" id="L2682">			empFilters.add(fsup);</span>
		}
<span class="nc" id="L2684">	}</span>

	protected void addOrganizationToEmpFilter(ArrayList empFilters, Set orgs) {
<span class="nc" id="L2687">		addOrganizationToEmpFilter(empFilters, orgs, null);</span>
<span class="nc" id="L2688">	}</span>

	protected void addOrganizationToEmpFilter(ArrayList empFilters, Set orgs, List requestTimeRange) {
		// Build the organization subfilter
<span class="nc" id="L2692">		ArrayList parms = new ArrayList(1);</span>
<span class="nc" id="L2693">		parms.add(orgs);</span>
<span class="nc" id="L2694">		Filter f = new Filter(Filter.ORGANIZATIONID, Filter.OPERATOR_IN, parms);</span>

		// QA 93028 - Time Off Request does not show if agent starts in future
		// Should get all employees during the requested time range instead of current time
<span class="nc bnc" id="L2698" title="All 2 branches missed.">		if (requestTimeRange != null) {</span>
<span class="nc" id="L2699">			f.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2700">			f.setStartTime((Date) requestTimeRange.get(0));</span>
<span class="nc" id="L2701">			f.setEndTime((Date) requestTimeRange.get(1));</span>
		}
		// End 93028

<span class="nc" id="L2705">		empFilters.add(f);</span>
<span class="nc" id="L2706">	}</span>

	@Override
	public RequestFilter getRequestFilterById(ID id) throws BbmFinderException {
<span class="nc" id="L2710">		String _method_ = &quot;getRequestFilterById&quot;;</span>
<span class="nc" id="L2711">		methodStart(_method_, id);</span>

<span class="nc" id="L2713">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2716">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="nc" id="L2718">			return new RequestFilter(fcm.findFilter(id));</span>
<span class="nc" id="L2719">		} catch (Exception e) {</span>
<span class="nc" id="L2720">			handleException(e, false);</span>
<span class="nc" id="L2721">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2723">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2724">			methodFinish();</span>
		}
	}

	@Override
	public RequestFilter getRequestFilterByName(ID idUser, String name) throws BbmFinderException {
<span class="nc" id="L2730">		String _method_ = &quot;getRequestFilterByName&quot;;</span>
<span class="nc" id="L2731">		methodStart(_method_, idUser, name);</span>

<span class="nc" id="L2733">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2736">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="nc" id="L2738">			return new RequestFilter(fcm.findFilter(idUser, RequestFilter.REQUEST_FILTER_COMPONENT_CLASS, name));</span>
<span class="nc" id="L2739">		} catch (Exception e) {</span>
<span class="nc" id="L2740">			handleException(e, false);</span>
<span class="nc" id="L2741">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2743">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2744">			methodFinish();</span>
		}
	}

	@Override
	public IDStringPair[] getRequestFilterNamesByUserID(ID idUser) throws BbmFinderException {
<span class="nc" id="L2750">		String _method_ = &quot;getRequestFilterNamesByUserID&quot;;</span>
<span class="nc" id="L2751">		methodStart(_method_, idUser);</span>

<span class="nc" id="L2753">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2756">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="nc" id="L2758">			return fcm.getFilterNames(idUser, RequestFilter.REQUEST_FILTER_COMPONENT_CLASS);</span>
<span class="nc" id="L2759">		} catch (Exception e) {</span>
<span class="nc" id="L2760">			handleException(e, false);</span>
<span class="nc" id="L2761">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2763">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2764">			methodFinish();</span>
		}
	}

	// filters
	@Override
	public ID createRequestFilter(RequestFilter filter) throws BbmCreateException {
<span class="nc" id="L2771">		String _method_ = &quot;createRequestFilter&quot;;</span>
<span class="nc" id="L2772">		methodStart(_method_, filter);</span>

<span class="nc" id="L2774">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2777">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="nc" id="L2779">			return fcm.insertFilter(filter.asFilterConfigVO());</span>
<span class="nc" id="L2780">		} catch (Exception e) {</span>
<span class="nc" id="L2781">			handleException(e);</span>
<span class="nc" id="L2782">			throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2784">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2785">			methodFinish();</span>
		}
	}

	@Override
	public void deleteRequestFilterByID(ID id) throws BbmRemoveException {
<span class="nc" id="L2791">		String _method_ = &quot;deleteRequestFilterByID&quot;;</span>
<span class="nc" id="L2792">		methodStart(_method_, id);</span>

<span class="nc" id="L2794">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2797">			fcm = CoreManagerFactory.getFilterConfigManager();</span>
<span class="nc" id="L2798">			fcm.deleteFilter(id);</span>
<span class="nc" id="L2799">		} catch (Exception e) {</span>
<span class="nc" id="L2800">			handleException(e);</span>
<span class="nc" id="L2801">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2803">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2804">			methodFinish();</span>
<span class="nc" id="L2805">		}</span>
<span class="nc" id="L2806">	}</span>

	/*
	 * update the given request filter in the database
	 */
	@Override
	public void updateRequestFilter(RequestFilter filter) throws BbmUpdateException {
<span class="nc" id="L2813">		String _method_ = &quot;updateRequestFilter&quot;;</span>
<span class="nc" id="L2814">		methodStart(_method_, filter);</span>

<span class="nc" id="L2816">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2819">			fcm = CoreManagerFactory.getFilterConfigManager();</span>
<span class="nc" id="L2820">			fcm.updateFilter(filter.asFilterConfigVO());</span>
<span class="nc" id="L2821">		} catch (Exception e) {</span>
<span class="nc" id="L2822">			handleException(e);</span>
<span class="nc" id="L2823">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2825">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2826">			methodFinish();</span>
<span class="nc" id="L2827">		}</span>
<span class="nc" id="L2828">	}</span>

	/**
	 * Gets the list of requests ids for which the status has been updated since given date
	 *
	 * @param date
	 * @throws BbmFinderException
	 */
	@Override
	public Collection getRequestIDsByStatusChange(Date date) throws BbmFinderException {
<span class="nc" id="L2838">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L2840">			dmo = new Jdmo(false);</span>
			// load the request objects (without their children) to identify the request type.
<span class="nc" id="L2842">			RequestAuditTrailDAO reqDAO = new RequestAuditTrailDAO(dmo);</span>
<span class="nc" id="L2843">			return reqDAO.getRequestIDsByStatusChangeAndType(date);</span>
<span class="nc" id="L2844">		} catch (Exception e) {</span>
<span class="nc" id="L2845">			handleException(e, false);</span>
<span class="nc" id="L2846">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2848" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L2849">				dmo.cleanUp();</span>
			}
<span class="nc" id="L2851">			methodFinish();</span>
		}
	}

	private void removeFcmFinally(FilterConfigManager fcm) {
<span class="nc bnc" id="L2856" title="All 2 branches missed.">		if (fcm != null) {</span>
			try {
<span class="nc" id="L2858">				fcm.remove();</span>
<span class="nc" id="L2859">			} catch (Exception e) {</span>
<span class="nc" id="L2860">				m_cat.error(&quot;Exception in finally clause: &quot; + e, e);</span>
<span class="nc" id="L2861">			}</span>
		}

<span class="nc" id="L2864">	}</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>