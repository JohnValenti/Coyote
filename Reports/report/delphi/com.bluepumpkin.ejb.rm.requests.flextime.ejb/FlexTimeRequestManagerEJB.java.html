<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FlexTimeRequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.flextime.ejb</a> &gt; <span class="el_source">FlexTimeRequestManagerEJB.java</span></div><h1>FlexTimeRequestManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.flextime.ejb;

import java.util.Collection;
import java.util.Date;
import java.util.List;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.RequestNotExpiredOnCreateHV;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.custshift.ejb.CustShiftReqMgrEJB;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.AllowConsecFlexRequestsMustAdhereToOrgSettingsRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.FTValidationCache;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.FlexTimeMustBeAtBeginningShiftBlockRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.FlexTimeMustBeWithinShiftRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.FlexTimeMustNotOverlapUnpaidCalendarEventRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.FlexTimeUnpublishedAndPublishedMustInSyncRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupDatesOfFlexRequestCannotBeOnSameDayRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupExtensionsMustAdhereToOrgSettingsRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupGapBlocksNotChangedRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupHoursCannotOverlapCalendarEventsRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupHoursCannotOverlapFlexHoursRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupHoursMustMatchAccountedHoursRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupHoursMustNotOverlapShiftsRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupMainShiftNotChangedRule;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.MakeupOTBlocksNotChangedRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.FlexRequestMakeupDAO;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestDAO;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManagerEJB;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.FlexRequestMakeup;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AgentGoodStandingValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TentativeRequestHardValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceApprOrTentAppNotZeroLengthHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceContainsHoliday;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceContainsOrgChange;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLength;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLengthHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffRequestsPerQuarterValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationPublishedStatusRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationReferenceScheduleRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.ValidTimeOffChoicesValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeWithinScheduleTimeOffHV;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.witness.ejb.core.security.PrivilegeKeys;

<span class="nc" id="L60">public class FlexTimeRequestManagerEJB extends TORequestManagerEJB {</span>

	private static final long serialVersionUID = 1L;

	/**
	 * Array of Flex-specific hard validation classes
	 */
<span class="nc" id="L67">	private static final ValidatorDescriptor[] FLEX_HARD_VALIDATOR_DESCRIPTOR_ARR = {</span>

			// REUSE TIME-OFF'S RULES
<span class="nc" id="L70">			new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L72">			new ValidatorDescriptor(WorkableTimeValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L74">			new ValidatorDescriptor(WorkableTimeWithinScheduleTimeOffHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L76">			new ValidatorDescriptor(AgentGoodStandingValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L78">			new ValidatorDescriptor(ValidTimeOffChoicesValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L80">			new ValidatorDescriptor(TentativeRequestHardValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL,</span>
					null, TORequest.DL_BASIC),
<span class="nc" id="L82">			new ValidatorDescriptor(TimeOffChoiceApprOrTentAppNotZeroLengthHV.class.getName(),</span>
					RequestUtil.METHODTYPE_MODIFIER,
					new String[] { RequestAuditTrail.STATUS_APPROVED, RequestAuditTrail.STATUS_TENTATIVE },
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L86">			new ValidatorDescriptor(TimeoffIntervalAllocationPublishedStatusRule.class.getName(),</span>
					RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L88">			new ValidatorDescriptor(TimeoffIntervalAllocationReferenceScheduleRule.class.getName(),</span>
					RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC),
<span class="nc" id="L90">			new ValidatorDescriptor(TimeOffChoiceHasZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L92">			new ValidatorDescriptor(TimeOffRequestsPerQuarterValidationRule.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					TORequest.DL_BASIC),



			// END OF REUSE TIME-OFF'S RULES

			// FLEX TIME RULES
			// makeup dates cannot duplicate
<span class="nc" id="L101">			new ValidatorDescriptor(MakeupDatesOfFlexRequestCannotBeOnSameDayRule.class.getName(),</span>
					RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// Org settings
<span class="nc" id="L105">			new ValidatorDescriptor(MakeupExtensionsMustAdhereToOrgSettingsRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// Calendar: makeup shifts not changed
<span class="nc" id="L109">			new ValidatorDescriptor(MakeupMainShiftNotChangedRule.class.getName(),</span>
					RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// Calendar: makeup shift's OT blocks not changed
<span class="nc" id="L113">			new ValidatorDescriptor(MakeupOTBlocksNotChangedRule.class.getName(),</span>
					RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// Calendar: makeup shift's gap blocks not changed
<span class="nc" id="L117">			new ValidatorDescriptor(MakeupGapBlocksNotChangedRule.class.getName(),</span>
					RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// makeup time &amp; events
<span class="nc" id="L121">			new ValidatorDescriptor(MakeupHoursCannotOverlapCalendarEventsRule.class.getName(),</span>
					RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// makeup time &amp; shifts
<span class="nc" id="L125">			new ValidatorDescriptor(MakeupHoursMustNotOverlapShiftsRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// makeup time = TO time
<span class="nc" id="L129">			new ValidatorDescriptor(MakeupHoursMustMatchAccountedHoursRule.class.getName(), RequestUtil.METHODTYPE_ALL,</span>
					null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// makeup durations &amp; TO duration not overlapping
<span class="nc" id="L133">			new ValidatorDescriptor(MakeupHoursCannotOverlapFlexHoursRule.class.getName(), RequestUtil.METHODTYPE_ALL,</span>
					null, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// TO range must inside shift
<span class="nc" id="L137">			new ValidatorDescriptor(FlexTimeMustBeWithinShiftRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// TO time cannot overlap events
<span class="nc" id="L141">			new ValidatorDescriptor(FlexTimeMustNotOverlapUnpaidCalendarEventRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// TO time must be in sync between unpublished calendar and published calendar
<span class="nc" id="L145">			new ValidatorDescriptor(FlexTimeUnpublishedAndPublishedMustInSyncRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// TO time must be at beginning of shift blocks
<span class="nc" id="L149">			new ValidatorDescriptor(FlexTimeMustBeAtBeginningShiftBlockRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP),

			// TO time cannot have approved consecutive TO requests
<span class="nc" id="L153">			new ValidatorDescriptor(AllowConsecFlexRequestsMustAdhereToOrgSettingsRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP)

			// END OF FLEX TIME RULES
	};
	// REUSE TIME-OFF'S MANDATORY RULES

<span class="nc" id="L160">	private final static ValidatorDescriptor[] FLEX_MANDATORY_SOFT_VALIDATOR_DESCRIPTOR_ARR = {</span>
		// validator run only when fetching a request with the specified detail level.
<span class="nc" id="L162">		new ValidatorDescriptor(TimeOffChoiceHasZeroLength.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
				| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L164">		new ValidatorDescriptor(TimeOffChoiceContainsHoliday.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
				| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L166">		new ValidatorDescriptor(TimeOffChoiceContainsOrgChange.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
				| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH) };

	@Override
	protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc" id="L171">		return FLEX_HARD_VALIDATOR_DESCRIPTOR_ARR;</span>
	}
	@Override
	protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc" id="L175">		return FLEX_MANDATORY_SOFT_VALIDATOR_DESCRIPTOR_ARR;</span>
	}

    /**
     * Return the possible states for a request of this type.
     *
     * @return a List of the possible states for requests of this type.
     */
	@Override
    public List getPossibleStates() {
<span class="nc" id="L185">        return RequestAuditTrail.FT_POSSIBLE_STATES;</span>
    }

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestManager()
	 */
	@Override
	protected IRequestType getRequestManager() throws Exception {
<span class="nc" id="L193">		return RequestUtil.getFlexTimeRequestMgr(null, null);</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestType()
	 */
	@Override
	protected String getRequestType() {
<span class="nc" id="L201">		return Request.REQUESTTYPE_FLEXTIME;</span>
	}

	@Override
	protected ID getPrivIDPurge() {
<span class="nc" id="L206">		return PrivilegeKeys.FT_PURGEREQUESTS_ID;</span>
	}

	@Override
	public boolean isRequestEligibleForWaitlist(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L211">		return false;</span>
	}

	/**
	 * @param apprChoiceID if null, see {@link #getApprChoiceIDIfNull(RequestAggregate, ID) getApprChoiceIDIfNull()} method.
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#
	 *      _approveRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String, boolean)
	 */
	@Override
	protected void _approveRequest(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment,
								boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

		// 1. Approve Time Off section
<span class="nc" id="L224">		reqAgg.addDetailLevel(TORequest.DL_TIMEOFF_FLEXMAKEUP);</span>
<span class="nc" id="L225">		super._approveRequest(reqAgg, choiceIDs, comment, suppressPrivilegeChecking, loadedFromDB);</span>

		// 2. Approve Makeup section
<span class="nc" id="L228">		approveMakeup((TORequest) reqAgg);</span>
<span class="nc" id="L229">	}</span>

	private void approveMakeup(TORequest toReq) throws Exception {
<span class="nc" id="L232">		FlexRequestMakeupDAO makeupDao = new FlexRequestMakeupDAO();</span>
		try {
<span class="nc bnc" id="L234" title="All 2 branches missed.">			for (FlexRequestMakeup makeup : toReq.getFlexRequestMakeupList()) {</span>
<span class="nc" id="L235">				CustShiftReq custShiftReq = (new FTValidationCache(toReq)).createCustShiftReqFromMakeup(makeup, toReq);</span>
<span class="nc" id="L236">				ID shiftAssnID = CustShiftReqMgrEJB._doApproveRequest(custShiftReq, true);</span>
				// update the flex request to point to the new shift assignment
				// created during approving make up part within custom shift request approval process
				// this update is to later pull all the approved flex requests by applying a filter
<span class="nc" id="L240">				makeup.setShiftAssignmentID(shiftAssnID);</span>
<span class="nc" id="L241">				makeupDao.updateFlexRequestMakeup(makeup);</span>
<span class="nc" id="L242">			}</span>
		} finally {
<span class="nc" id="L244">			makeupDao.cleanUp();</span>
<span class="nc" id="L245">		}</span>
<span class="nc" id="L246">	}</span>



	/**
	 * Add columns necessary to process a query governed by the given filter.  The caller has already
	 * added columns from the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.  Columns from
	 * new tables should start with D as a column synonym.  See
	 * {@link #addToFromClause addToFromClause} for how the from clause is modified,
	 * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
	 * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
	 * a request manager to reflect type-specific filtered queries.
	 * Columns added by this
	 * method should insert a leading comma.
	 *
	 * @param selectClause  the string buffer being constructed, the generic columns have already been
	 *                      added, this method should append its columns.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToSelectColumns(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L267">		super.addToSelectColumns(query, requestFilter, sortColumn);</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">		if (sortColumn == Request.SORT_CS_SHIFTID) {</span>
<span class="nc" id="L270">			query.append(&quot;, SHIFT.NAME &quot;);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L272">			query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_CS_STARTTIME) {</span>
<span class="nc" id="L274">			query.append(&quot;, min(FRM.STARTTIME) &quot;);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_CS_ENDTIME) {</span>
<span class="nc" id="L276">			query.append(&quot;, max(FRM.ENDTIME) &quot;);</span>
		}
<span class="nc" id="L278">	}</span>

	/**
	 * Add tables necessary to process a query governed by the given filter.  The caller has already
	 * added the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.
	 * New tables should start with D as a column synonym.  See
	 * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
	 * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
	 * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
	 * a request manager to reflect type-specific filtered queries.
	 * Tables added by this
	 * method should insert a leading comma.
	 *
	 * @param fromClause    the string buffer being constructed, the generic tables have already been
	 *                      added, this method should append its tables with a leading comma and start with D as a synonym.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToFromClause(StringBuffer fromClause, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L297">		super.addToFromClause(fromClause, requestFilter, sortColumn);</span>

<span class="nc" id="L299">		fromClause.append(&quot;, FLEXREQUESTMAKEUP FRM LEFT JOIN FLEXREQMAKEUPGAP FRMG ON FRM.ID = FRMG.FLEXREQUESTMAKEUPID &quot;);</span>
		//including the activity table for sorting based on makeup activity on manager's list page
<span class="nc bnc" id="L301" title="All 2 branches missed.">		if(sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L302">			fromClause.append(&quot;, ACTIVITY ACTS &quot;);</span>
		}

		//joins for sorts &amp; filter
<span class="nc bnc" id="L306" title="All 4 branches missed.">		if (sortColumn == Request.SORT_CS_SHIFTID || requestFilter.isKeySet(RequestFilter.CS_SHIFTID_KEY)) {</span>
<span class="nc" id="L307">			fromClause.append(&quot; LEFT JOIN SHIFTASSIGNMENT SA on FRM.SHIFTASSIGNMENTID = SA.ID &quot;);</span>
<span class="nc" id="L308">			fromClause.append(&quot; LEFT JOIN SHIFT on SHIFT.SID = SA.SHIFTID &quot;);</span>
		}

		//Joins for Sorts only
<span class="nc bnc" id="L312" title="All 4 branches missed.">		if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID || sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L313">			fromClause.append(&quot; LEFT JOIN ACTIVITY ACTS on ACTS.ID = &quot;);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">			if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID) {</span>
<span class="nc" id="L315">				fromClause.append(&quot; EXTBEFOREACTIVITYID &quot;);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">			} else if (sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L317">				fromClause.append(&quot; EXTAFTERACTIVITYID &quot;);</span>
			}
		}

		//joins for Filters only
<span class="nc bnc" id="L322" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.CS_ACTIVITYID_KEY)) {</span>
<span class="nc" id="L323">			fromClause.append(&quot;, ACTIVITY ACT &quot;);</span>
		}
<span class="nc" id="L325">	}</span>

	/**
	 * Add the appropriate FLEXTYPE clause to the query (either FLEXTYPE_NONE or FLEXTYPE_FLEXWITHMAKEUP).
	 */
	@Override
	protected void appendFlexTypeWhereClause(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L332">		query.append(&quot; AND TOR.FLEXTYPE = &quot;).append(TORequest.FLEXTYPE_FLEXWITHMAKEUP).append(' ');</span>
<span class="nc" id="L333">		query.append(&quot; AND FRM.TIMEOFFREQUESTID=REQ.ID &quot;);</span>

<span class="nc bnc" id="L335" title="All 4 branches missed.">		if (sortColumn == Request.SORT_CS_SHIFTID || requestFilter.isKeySet(RequestFilter.CS_SHIFTID_KEY)) {</span>
<span class="nc" id="L336">			query.append(&quot; AND FRM.SHIFTASSIGNMENTID=SA.ID &quot;);</span>
		}

		//Filter by date range
<span class="nc bnc" id="L340" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.REQUEST_FLEX_MAKEUP_DATE_RANGE_KEY)) {</span>
<span class="nc" id="L341">			StringsPair dates = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_FLEX_MAKEUP_DATE_RANGE_KEY);</span>
<span class="nc" id="L342">			String rangeStart = dates.getKey();</span>
<span class="nc" id="L343">			String rangeEnd = dates.getValue();</span>
<span class="nc" id="L344">			Date dtNow = new Date();</span>
<span class="nc" id="L345">			String strDtNow = JdmoUtil.formatDBString(dtNow);</span>
<span class="nc" id="L346">			query.append(&quot;AND &quot;);</span>
<span class="nc" id="L347">			appendMakeupDateRangeClauses(query, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L348">			query.append(&quot; &quot;);</span>
		}

		//Filter by shift Name
<span class="nc bnc" id="L352" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.CS_SHIFTID_KEY)) {</span>
<span class="nc" id="L353">			query.append(&quot; AND SHIFT.SID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_SHIFTID_KEY));</span>
		}

		//FILTER BY ACTIVITY NAME
<span class="nc bnc" id="L357" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.CS_ACTIVITYID_KEY)) {</span>
<span class="nc" id="L358">			query.append(&quot; AND ACT.ID  IN (FRM.EXTBEFOREACTIVITYID, FRM.EXTAFTERACTIVITYID, FRMG.EXTGAPACTIVITYID) &quot;);</span>
<span class="nc" id="L359">			query.append(&quot; AND ACT.ID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_ACTIVITYID_KEY));</span>
		}
<span class="nc" id="L361">	}</span>

	private static void appendMakeupDateRangeClauses(StringBuffer whereClause, String rangeStart, String rangeEnd, String strDtNow) {

<span class="nc" id="L365">		whereClause.append(&quot; (&quot;);</span>

<span class="nc" id="L367">		whereClause.append(&quot; (DATEADD(minute, - FRM.EXTBEFOREGAP - FRM.EXTBEFOREDURATION, FRM.SHIFTSTARTTIME) &lt; '&quot; + rangeEnd + &quot;') AND (DATEADD(minute, - FRM.EXTBEFOREGAP, FRM.SHIFTSTARTTIME) &gt; '&quot; + rangeStart + &quot;') &quot;);</span>

<span class="nc" id="L369">		whereClause.append(&quot; OR&quot;);</span>

<span class="nc" id="L371">		whereClause.append(&quot; (DATEADD(minute, FRM.EXTAFTERGAP, FRM.SHIFTENDTIME) &lt; '&quot; + rangeEnd + &quot;') AND (DATEADD(minute, FRM.EXTAFTERGAP + FRM.EXTAFTERDURATION, FRM.SHIFTENDTIME) &gt; '&quot; + rangeStart + &quot;') &quot;);</span>

<span class="nc" id="L373">		whereClause.append(&quot; OR&quot;);</span>

<span class="nc" id="L375">		whereClause.append(&quot; (DATEADD(minute, FRMG.EXTGAPGAP, FRMG.EXTGAPSTARTTIME) &lt; '&quot; + rangeEnd + &quot;') AND (DATEADD(minute, FRMG.EXTGAPGAP + FRMG.EXTGAPDURATION, FRMG.EXTGAPSTARTTIME) &gt; '&quot; + rangeStart + &quot;') &quot;);</span>

<span class="nc" id="L377">		whereClause.append(&quot; ) &quot;);</span>

<span class="nc" id="L379">		RmUtil.appendCurrentMgrRestrictions(whereClause, &quot;FRM.STARTTIME&quot;, strDtNow);</span>

<span class="nc" id="L381">	}</span>


	/**
	 * Add conditions necessary to process a query governed by the given filter.  The caller has already
	 * added everthing but the order by clause.  See
	 * {@link #aaddToSelectColumns addToSelectColumns} for how the column list is modified,
	 * {@link #addToFromClause addToFromClause} for how the from clause is modified, and
	 * {@link #addToWhereClause addToWhereClause} for how the where clause is modified by
	 * a request manager to reflect type-specific filtered queries.
	 * Conditions added by this
	 * method should insert a leading comma.
	 *
	 * @param query         the string buffer being constructed, the generic where clauses have already been
	 *                      added, this method should append its conditions with a leading AND and both front and rear pad with a space.
	 * @param requestFilter the request filter
	 * @param sortColumn    identifies the column to use to sort the requests.
	 *                      The constants that define the expected values are in
	 *                      {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
	 * @param sortDir       This string is either &quot; ASC &quot; or &quot; DESC &quot; depending on whether or not the
	 *                      sort is ascending or descending.  (Note spaces around values for convenience.)
	 */
	@Override
	public void addOrderByClause(StringBuffer query, RequestFilter requestFilter, int sortColumn, String sortDir) {
<span class="nc" id="L405">		super.addOrderByClause(query, requestFilter, sortColumn, sortDir);</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">		if (sortColumn == Request.SORT_CS_SHIFTID) {</span>
<span class="nc" id="L408">			query.append(&quot; ORDER BY SHIFT.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L410">			query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_CS_STARTTIME) {</span>
<span class="nc" id="L412">			query.append(&quot; GROUP BY FRM.TIMEOFFREQUESTID ORDER BY min(FRM.STARTTIME) &quot;).append(sortDir);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_CS_ENDTIME) {</span>
<span class="nc" id="L414">			query.append(&quot; GROUP BY FRM.TIMEOFFREQUESTID ORDER BY max(FRM.ENDTIME) &quot;).append(sortDir);</span>
		}
<span class="nc" id="L416">	}</span>

	@Override
	public void changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment)
			throws Exception {
<span class="nc" id="L421">		checkChangeRequestStatePrivilege(reqID, newState);</span>
<span class="nc" id="L422">		_changeRequestStateByID(reqID, newState, objectVersionNumber, comment, false);</span>
<span class="nc" id="L423">	}</span>

	@Override
	protected void markRequestViolateSpecialRulesAsInValidIfNeeded(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
		//Should do nothing since this should only apply for Time Off requests
<span class="nc" id="L428">	}</span>

	public Collection&lt;ID&gt; getApprovedFlexRequestIDs(ID employeeID, TimeRange timeOffRange, boolean includeLimit) throws BbmFinderException {
<span class="nc" id="L431">		TORequestDAO toReqDao = new TORequestDAO(TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES);</span>
		try {
<span class="nc" id="L433">			return toReqDao.getApprovedFlexRequestIDs(employeeID, timeOffRange, includeLimit);</span>
		} finally {
<span class="nc" id="L435">			toReqDao.cleanUp();</span>
		}

	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>