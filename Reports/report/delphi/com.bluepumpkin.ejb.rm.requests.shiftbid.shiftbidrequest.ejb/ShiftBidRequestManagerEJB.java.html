<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftBidRequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb</a> &gt; <span class="el_source">ShiftBidRequestManagerEJB.java</span></div><h1>ShiftBidRequestManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import org.apache.log4j.Level;
import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.core.filterconfig.model.Filter;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.RequestNotExpiredOnCreateHV;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.SerializedAuctionDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.SerializedAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuctionFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidPreference;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequestBiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequestFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidder;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidderFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.UnsubmittedShiftBidPreference;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.AgentSchedulesInSPNotChangeHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.AuctionIsValidHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleDoesNotAllowOvertimeHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleDoesNotOverlapShiftAssignmentsHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleFollowsWorkPatternHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleSingleActivityShiftAssignmentsHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.CalendarEventsValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MaxBidsPerEmployeeNotExceededHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MaxConsecutiveDaysForSBReqHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MaxShiftBlocksPerBidNotExceededHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MinMaxHoursPerDayHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoApprovedShiftBidRequestsForBidderHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoMultipleShiftAssignmentsForADayHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoShiftBidRequestDuplicateNamesHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoShiftsForBidderDuringSPHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.RequestBiddableSchedulesAreValidHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.ShiftBidRequestMeetDeadlineHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.ShiftBidRequestNoDuplicatePreferences;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.ShiftBidRequestNoDuplicatesHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.ShiftBidderInGoodStandingHV;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftBidAuctionUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;

/**
 *
 * see {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionManager ShiftBidAuctionManager}
 * for a description of the shift bidding process.
 *
 * Title:        ShiftBidRequestManagerEJB
 * Description:  EJB for ShiftBidRequest
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, Inc.
 * @author       Jagdish Seelam
 * @version 1.0
 */
<span class="nc bnc" id="L109" title="All 2 branches missed.">public class ShiftBidRequestManagerEJB extends RequestAggregateManager { //OUTSIDE_CONTAINER</span>
//public class ShiftBidRequestManagerEJB extends RequestAggregateManager implements ShiftBidRequestManager { //OUTSIDE_CONTAINER
<span class="nc" id="L111">	private static final String COLNAME_SHIFTBIDREQUEST_SHIFTBIDAUCTIONID =</span>
			ShiftBidRequestFieldInfo.m_strTableName + '.' + ShiftBidRequestFieldInfo.COLNAME_AUCTIONID;

<span class="nc" id="L114">	private static final String COLNAME_SHIFTBIDREQUEST_SHIFTBIDDERID =</span>
			ShiftBidRequestFieldInfo.m_strTableName + '.' + ShiftBidRequestFieldInfo.COLNAME_SHIFTBIDDERID;

	private static final String COLNAME_SHIFTBIDDER_ID = ShiftBidderFieldInfo.m_strTableName + &quot;.ID&quot;;

<span class="nc" id="L119">	private static final String COLNAME_SHIFTBIDDER_DEADLINE =</span>
			ShiftBidderFieldInfo.m_strTableName + '.' + ShiftBidderFieldInfo.COLNAME_DEADLINE;

<span class="nc" id="L122">	private static final String COLNAME_PREFERENCE =</span>
			ShiftBidRequestFieldInfo.m_strTableName + &quot;.&quot; + ShiftBidRequestFieldInfo.COLNAME_PREFERENCE;

<span class="nc" id="L125">	private static final String COLNAME_SHIFTBIDDER_BONUSTHISAUCTION =</span>
			ShiftBidderFieldInfo.m_strTableName + '.' + ShiftBidderFieldInfo.COLNAME_BONUSTHISAUCTION;

	public static final String TABLE_EMPLOYEEAM_ALIAS = RequestUtil.TABLE_EMPLOYEEAM_ALIAS;

	public static final String COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS = TABLE_EMPLOYEEAM_ALIAS + &quot;.ASSIGNEDPOINTS&quot;;

	public static final String COLNAME_EMPLOYEEAM_RANK = &quot;EMPLOYEERANK.RANK&quot;;

	public static final String COLNAME_EMPLOYEEAM_STARTTIME = TABLE_EMPLOYEEAM_ALIAS + &quot;.STARTTIME&quot;;

<span class="nc" id="L136">	public static final String COLNAME_SHIFTBIDAUCTION_ID =</span>
			ShiftBidAuctionFieldInfo.m_strTableName + &quot;.ID&quot;;

<span class="nc" id="L139">	private static final String m_className = ShiftBidRequestManagerEJB.class.getName();</span>

<span class="nc" id="L141">	private static final Category m_cat = Log.initCategory(m_className);</span>

	// states for which soft validations are performed
	//    private static final Collection m_softValidationStates = Arrays.asList(
	//        new String[] {
	//            RequestAuditTrail.STATUS_PENDING,
	//            RequestAuditTrail.STATUS_ESCALATED
	//        });

<span class="nc" id="L150">	public static final List m_possibleStates = RequestAuditTrail.SBR_POSSIBLE_STATES;</span>

<span class="nc" id="L152">	protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArr = {</span>
			// this must be run before most other rules as without a valid biddable schedule
			// the other validators will certainly fail.
<span class="nc" id="L155">			new ValidatorDescriptor(RequestBiddableSchedulesAreValidHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L157">			new ValidatorDescriptor(AuctionIsValidHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFTBID_AUCTION),
			// Must be run after AuctionIsValidHV.java as the expiration date is set by this rule.
<span class="nc" id="L160">			new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L162">			new ValidatorDescriptor(MaxBidsPerEmployeeNotExceededHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					ShiftBidRequest.DL_BASIC), //validator needs just the auctionID and shiftBidderID.
			// Commented as org holidays are not used by DE for scheduling yet.  Decided after an e-mail discussion.
			//        new HardValidatorDescriptor(BiddableSchedOrgHolidayNoOverlapHV.class.getName(), RequestUtil.METHODTYPE_ALL,
			//            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L167">			new ValidatorDescriptor(AgentSchedulesInSPNotChangeHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L169">			new ValidatorDescriptor(BiddableScheduleDoesNotOverlapShiftAssignmentsHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L171">			new ValidatorDescriptor(BiddableScheduleSingleActivityShiftAssignmentsHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L173">			new ValidatorDescriptor(BiddableScheduleFollowsWorkPatternHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC),
<span class="nc" id="L175">			new ValidatorDescriptor(CalendarEventsValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L177">			new ValidatorDescriptor(ShiftBidderInGoodStandingHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_EMPLOYEE),
<span class="nc" id="L179">			new ValidatorDescriptor(ShiftBidRequestNoDuplicatesHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_BIDDABLESCHEDULE_IDS),
<span class="nc" id="L181">			new ValidatorDescriptor(MinMaxHoursPerDayHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL | ShiftBidRequest.DL_SHIFTBID_AUCTION),
<span class="nc" id="L183">			new ValidatorDescriptor(BiddableScheduleDoesNotAllowOvertimeHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC),
<span class="nc" id="L185">			new ValidatorDescriptor(NoMultipleShiftAssignmentsForADayHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL | ShiftBidRequest.DL_SHIFTBID_AUCTION),
<span class="nc" id="L187">			new ValidatorDescriptor(NoShiftsForBidderDuringSPHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFTBID_AUCTION),
<span class="nc" id="L189">			new ValidatorDescriptor(NoApprovedShiftBidRequestsForBidderHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC),
<span class="nc" id="L191">			new ValidatorDescriptor(NoShiftBidRequestDuplicateNamesHV.class.getName(),</span>
					RequestUtil.METHODTYPE_CREATOR | RequestUtil.METHODTYPE_MODIFIER, null, ShiftBidRequest.DL_BASIC),
<span class="nc" id="L193">			new ValidatorDescriptor(ShiftBidRequestMeetDeadlineHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					ShiftBidRequest.DL_BASIC),
<span class="nc" id="L195">			new ValidatorDescriptor(MaxShiftBlocksPerBidNotExceededHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
					ShiftBidRequest.DL_BASIC),
<span class="nc" id="L197">			new ValidatorDescriptor(MaxConsecutiveDaysForSBReqHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					ShiftBidRequest.DL_BASIC),
<span class="nc" id="L199">			new ValidatorDescriptor(ShiftBidRequestNoDuplicatePreferences.class.getName(),</span>
					RequestUtil.METHODTYPE_CREATOR | RequestUtil.METHODTYPE_MODIFIER, null, ShiftBidRequest.DL_BASIC),
	};

<span class="nc" id="L203">	private final static ValidatorDescriptor[] m_softValidatorDescMandArr = {</span>
			};

	{
<span class="nc" id="L207">		super.init(ShiftBidRequestManagerEJB.class.getName());</span>
<span class="nc" id="L208">	}</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="nc" id="L213">		return m_cat;</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#getPossibleStates()
	 */
	@Override
	public List getPossibleStates() {
<span class="nc" id="L221">		return m_possibleStates;</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getDAO()
	 */
	@Override
	protected RequestAggregateDAO getDAO(long detailLevel) {
<span class="nc" id="L229">		return new ShiftBidRequestDAO(detailLevel);</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getHardValidatorNames()
	 */
	@Override
	protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc" id="L237">		return m_hardValidatorDescriptorArr;</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidatorDescriptorsMandatory()
	 */
	@Override
	protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc" id="L245">		return m_softValidatorDescMandArr;</span>
	}

	@Override
	protected IRequestType getRequestManager() throws Exception {
<span class="nc" id="L250">		return RequestUtil.getShiftBidRequestManager(null, null);</span>
	}

	@Override
	protected String getRequestType() {
<span class="nc" id="L255">		return Request.REQUESTTYPE_SHIFTBID;</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addToSelectColumns(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
	 */
	@Override
	public void addToSelectColumns(StringBuffer selectClause, RequestFilter requestFilter, int sortColumn) {

		// DIRECT_DB_ACCESS
		// Add columns specified in the SORT clause.
<span class="nc bnc" id="L266" title="All 2 branches missed.">		if (sortColumn == Request.SORT_SHIFTBID_PREFERENCE) {</span>
<span class="nc" id="L267">			selectClause.append(&quot;, SHIFTBIDREQUEST.PREFERENCE &quot;);</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_SHIFTBID_ISBONUSUSED) {</span>
<span class="nc" id="L269">			selectClause.append(&quot;, SHIFTBIDREQUEST.ISBONUSUSED &quot;);</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_SHIFTBID_SENIORITY) {</span>
<span class="nc" id="L271">			selectClause.append(&quot;, &quot;).append(COLNAME_EMPLOYEEAM_STARTTIME).append(' ');</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_SHIFTBID_POINTS) {</span>
<span class="nc" id="L273">			selectClause.append(&quot;, &quot;).append(COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS).append(' ');</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_SHIFTBID_BIDDERBONUS) {</span>
<span class="nc" id="L275">			selectClause.append(&quot;, SHIFTBIDDER.BONUSTHISAUCTION &quot;);</span>
		}

		// If requestFilter type == shift-bid, then SHIFTBIDREQUEST.PREFERENCE must always be
		// used as the secondary sort key irrespective of the primary sort key used.
		// (needed for group approvals; see javadoc for addOrderByClause()).
		//
		// If PREFERENCE column already added, do not add again
<span class="nc bnc" id="L283" title="All 2 branches missed.">		if (sortColumn != Request.SORT_SHIFTBID_PREFERENCE) {</span>
<span class="nc" id="L284">			selectClause.append(&quot;, &quot;).append(ShiftBidRequestFieldInfo.m_strTableName).</span>
<span class="nc" id="L285">					append('.').append(ShiftBidRequestFieldInfo.COLNAME_PREFERENCE).append(' ');</span>
		}

<span class="nc" id="L288">	}</span>

	/**
	 * {@link RequestFilter#BID_DEADLINE_KEY BID_DEADLINE_KEY}: join ShiftBidRequest, ShiftBidder&lt;br&gt;
	 * {@link RequestFilter#BID_PREF_KEY BID_PREF_KEY}: join ShiftBidRequest. &lt;br&gt;
	 * {@link RequestFilter#BID_REQUESTED_DAY BID_REQUESTED_DAY}: done by
	 * {@link #filterReqAggUsingReqFilter(RequestAggregate, RequestFilter) filterReqAggUsingReqFilter} method.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addToFromClause(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
	 */
	@Override
	public void addToFromClause(StringBuffer fromClause, RequestFilter reqFilter, int sortColumn) {

		// If requestFilter type == shift-bid, then SHIFTBIDREQUEST.PREFERENCE must always be
		// used as the secondary sort key irrespective of the primary sort key used.
		// (needed for group approvals; see javadoc for addOrderByClause()).
<span class="nc" id="L304">		boolean joinSBReqTable = true;</span>

<span class="nc" id="L306">		boolean joinShiftBidderTable = false;</span>

<span class="nc bnc" id="L308" title="All 3 branches missed.">		switch (sortColumn) {</span>
		// if sorting by fields in shift bid request, then join table.
		case Request.SORT_SHIFTBID_ISBONUSUSED:
		case Request.SORT_SHIFTBID_PREFERENCE:
<span class="nc" id="L312">			joinSBReqTable = true;</span>
<span class="nc" id="L313">			break;</span>
		case Request.SORT_SHIFTBID_BIDDERBONUS:
<span class="nc" id="L315">			joinSBReqTable = true;</span>
<span class="nc" id="L316">			joinShiftBidderTable = true;</span>
			break;
		//Note: EMPLOYEEAM table, needed for sorting SBReqs by SENIORITY, RANK and POINTS, is already 'joined' with
		// the 'request' table in CommonReqMgr.getSelectFromWhereOrderByClause().
		//case Request.SORT_SHIFTBID_SENIORITY:
		//case Request.SORT_SHIFTBID_RANK:
		//case Request.SORT_SHIFTBID_POINTS:
		//    break;
		}

		// Filter by the shift bidder deadline date
<span class="nc bnc" id="L327" title="All 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.BID_DEADLINE_KEY)) {</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">			if (!reqFilter.isKeySet(RequestFilter.BID_DEADLINE_OPERATOR_KEY)) {</span>
<span class="nc" id="L329">				throw new IllegalArgumentException(</span>
						&quot;RequestFilter.BID_DEADLINE_KEY cannot be set without specifiying RequestFilter.BID_DEADLINE_OPERATOR_KEY as well&quot;);
			}

			// SHIFTBIDDER table needed to use SHIFTBIDDER.DEADLINE in the 'where' clause
<span class="nc" id="L334">			joinShiftBidderTable = true;</span>
<span class="nc" id="L335">			joinSBReqTable = true; //need sbReq.shiftBidderID column to join with shiftBidder table</span>
		}

		// filter by shift bid request's preference key.
<span class="nc bnc" id="L339" title="All 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.BID_PREF_KEY)) {</span>
<span class="nc" id="L340">			joinSBReqTable = true;</span>
		}

<span class="nc bnc" id="L343" title="All 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.BID_BONUS_KEY)) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">			if (!reqFilter.isKeySet(RequestFilter.BID_BONUS_OPERATOR_KEY)) {</span>
<span class="nc" id="L345">				throw new IllegalArgumentException(RequestFilter.BID_BONUS_OPERATOR_KEY);</span>
			}

<span class="nc" id="L348">			joinShiftBidderTable = true;</span>
<span class="nc" id="L349">			joinSBReqTable = true; //need sbReq.shiftBidderID column to join with shiftBidder table</span>
		}

<span class="nc bnc" id="L352" title="All 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.BID_POINTS_KEY)) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">			if (!reqFilter.isKeySet(RequestFilter.BID_POINTS_OPERATOR_KEY)) {</span>
<span class="nc" id="L354">				throw new IllegalArgumentException(RequestFilter.BID_POINTS_OPERATOR_KEY);</span>
			}

			// the points column belongs to employeeAM table which is always included in the 'from'
			// clause for the query.  See CmnReqMgr.getReqsForMgr().
		}

		//RequestFilter.BID_REQUESTED_DAY_KEY implemented by filterReqAggUsingReqFilter() method.

<span class="nc" id="L363">		fromClause.append(&quot;, &quot;).append(ShiftBidAuctionFieldInfo.m_strTableName);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">		fromClause = (joinSBReqTable) ? fromClause.append(&quot;, &quot; + ShiftBidRequestFieldInfo.m_strTableName) : fromClause;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">		fromClause = (joinShiftBidderTable) ? fromClause.append(&quot;, &quot; + ShiftBidderFieldInfo.m_strTableName) : fromClause;</span>
<span class="nc" id="L366">	}</span>

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addToWhereClause(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
	 */
	@Override
	public void addToWhereClause(StringBuffer whereClause, RequestFilter reqFilter, int sortColumn)
			throws RmException, RmHardValidationException {
<span class="nc" id="L374">		Jdmo dmo = new Jdmo();</span>
		try {

			//QA 95168 Request must be within range of filter start and end dates, which are always
			// present because the calendar date picker is always visible on the page. Query must also
			// take the request employee's organization within the context of the dates
<span class="nc" id="L380">			StringsPair datesPair = RmFilterUtil.getStartAndEndDates(reqFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>

<span class="nc" id="L382">			Date dtNow = new Date();</span>
<span class="nc" id="L383">			String strDtNow = JdmoUtil.formatDBString(dtNow);</span>

<span class="nc" id="L385">			whereClause.append(&quot; AND &quot;)</span>
<span class="nc" id="L386">					.append(COLNAME_SHIFTBIDAUCTION_ID).append(&quot;=&quot;).append(COLNAME_SHIFTBIDREQUEST_SHIFTBIDAUCTIONID)</span>
<span class="nc" id="L387">					.append(&quot; AND &quot;);</span>
<span class="nc" id="L388">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot;&quot;, ShiftBidAuctionFieldInfo.m_strTableName,</span>
<span class="nc" id="L389">					datesPair.getKey(), datesPair.getValue(), strDtNow);</span>
<span class="nc" id="L390">			whereClause.append(&quot; &quot;);</span>
			//End #95168

			// If requestFilter type == shift-bid, then SHIFTBIDREQUEST.PREFERENCE must always be
			// used as the secondary sort key irrespective of the primary sort key used.
			// (needed for group approvals; see javadoc for addOrderByClause()).
<span class="nc" id="L396">			boolean sbReqTableJoinFlag = true;</span>

<span class="nc" id="L398">			boolean shiftBidderTableJoinFlag = false;</span>

<span class="nc bnc" id="L400" title="All 3 branches missed.">			switch (sortColumn) {</span>
			// if sorting enabled by shift bid request fields, join the shift bid request table
			case Request.SORT_SHIFTBID_ISBONUSUSED:
			case Request.SORT_SHIFTBID_PREFERENCE:
<span class="nc" id="L404">				sbReqTableJoinFlag = true;</span>
<span class="nc" id="L405">				break;</span>
			case Request.SORT_SHIFTBID_BIDDERBONUS:
<span class="nc" id="L407">				sbReqTableJoinFlag = true;</span>
<span class="nc" id="L408">				shiftBidderTableJoinFlag = true;</span>
				break;
			}
			// if sorting
			// Filter by SHIFTBIDAUCTION.ID

<span class="nc bnc" id="L414" title="All 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.BID_AUCTIONS_KEY)) {</span>
<span class="nc" id="L415">				String auctionIdsInClauseList = dmo.createInClause((Collection) reqFilter.getValueForKey(RequestFilter.BID_AUCTIONS_KEY));</span>
				//ID bidID = new ID(reqFilter.getValueForKey(RequestFilter.BID_AUCTIONS_KEY).toString());
<span class="nc" id="L417">				whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDAUCTION_ID + &quot; IN &quot;).append(auctionIdsInClauseList);</span>

			}
			// Filter by ShiftBidRequest.Preference
<span class="nc bnc" id="L421" title="All 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.BID_PREF_KEY)) {</span>
				// get the preference value set in the filter.
<span class="nc" id="L423">				Integer pref = (Integer) reqFilter.getValueForKey(RequestFilter.BID_PREF_KEY);</span>
<span class="nc" id="L424">				int prefInt = pref.intValue();</span>

				// need to join the sbReq table to filter by preference
<span class="nc" id="L427">				sbReqTableJoinFlag = true;</span>
				// check if preference filter is 'preferences 5 and above'
<span class="nc bnc" id="L429" title="All 2 branches missed.">				if (prefInt == RequestFilter.BID_PREF_VALUE_FIVEANDABOVE) {</span>
<span class="nc" id="L430">					whereClause.append(&quot; AND &quot; + COLNAME_PREFERENCE + &quot;&gt;= 5 &quot;);</span>
				} else {
<span class="nc" id="L432">					whereClause.append(&quot; AND &quot; + COLNAME_PREFERENCE + '=' + pref + ' ');</span>
				}
			}

			// Filter by the shift bidder deadline date: deadline &lt; givenDate; deadline &gt; givenDate or
			// deadline between date1 and date2
<span class="nc bnc" id="L438" title="All 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.BID_DEADLINE_KEY)) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">				if (!reqFilter.isKeySet(RequestFilter.BID_DEADLINE_OPERATOR_KEY)) {</span>
<span class="nc" id="L440">					throw new IllegalArgumentException(&quot;RequestFilter.BID_DEADLINE_KEY cannot be set without &quot; +</span>
							&quot;specifiying RequestFilter.BID_DEADLINE_OPERATOR_KEY as well&quot;);
				}

<span class="nc" id="L444">				sbReqTableJoinFlag = true;</span>
<span class="nc" id="L445">				shiftBidderTableJoinFlag = true;</span>

				// retrieve the bid deadline
<span class="nc" id="L448">				Date bidDeadline = (Date) reqFilter.getValueForKey(RequestFilter.BID_DEADLINE_KEY);</span>

				// get the bid deadline operator
<span class="nc" id="L451">				String bidDeadlineOp = (String) reqFilter.getValueForKey(RequestFilter.BID_DEADLINE_OPERATOR_KEY);</span>

<span class="nc bnc" id="L453" title="All 2 branches missed.">				if (bidDeadlineOp.equals(Filter.LESS_THAN_OPERATION)) {</span>
<span class="nc" id="L454">					whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_DEADLINE + &quot; &lt; '&quot; + JdmoUtil.formatDBString(bidDeadline) + '\'');</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">				} else if (bidDeadlineOp.equals(Filter.GREATER_THAN_OPERATION)) {</span>
<span class="nc" id="L456">					whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_DEADLINE + &quot; &gt; '&quot; + JdmoUtil.formatDBString(bidDeadline) + '\'');</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">				} else if (bidDeadlineOp.equals(Filter.EQUAL_OPERATION)) {</span>
					//get the timezone for the logged in employee (manager).
<span class="nc" id="L459">					ID empID = RequestUtil.getLoginUserBasic(m_sessionContext).getEmployeeID();</span>
<span class="nc" id="L460">					TimeZone mgrTZ = ValidationUtil.getOrganizationForEmployeeDuringPeriod(</span>
<span class="nc" id="L461">							empID, bidDeadline, bidDeadline).getTimeZone();</span>

					// get the dates for midnight to midnight for the bid deadline date in the manager's timezone
<span class="nc" id="L464">					Date dayBeginForBidDeadline = RequestUtil.getDateForDayEnd(bidDeadline, mgrTZ);</span>
<span class="nc" id="L465">					Date dayEndForBidDeadline = RequestUtil.getDateForDayEnd(bidDeadline, mgrTZ);</span>

<span class="nc" id="L467">					whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_DEADLINE + &quot; BETWEEN '&quot;</span>
<span class="nc" id="L468">							+ JdmoUtil.formatDBString(dayBeginForBidDeadline)</span>
<span class="nc" id="L469">							+ &quot;' AND '&quot; + JdmoUtil.formatDBString(dayEndForBidDeadline) + '\'');</span>
<span class="nc" id="L470">				} else {</span>
<span class="nc" id="L471">					throw new IllegalArgumentException(&quot;Invalid bid deadline operator value: &quot; + bidDeadlineOp);</span>
				}
			}

			//RequestFilter.BID_REQUESTED_DAY_KEY implemented by filterReqAggUsingReqFilter.

			// if filtering by bidder bonus.
<span class="nc bnc" id="L478" title="All 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.BID_BONUS_KEY)) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">				if (!reqFilter.isKeySet(RequestFilter.BID_BONUS_OPERATOR_KEY)) {</span>
<span class="nc" id="L480">					throw new IllegalArgumentException(RequestFilter.BID_BONUS_OPERATOR_KEY);</span>
				}

<span class="nc" id="L483">				sbReqTableJoinFlag = true;</span>
<span class="nc" id="L484">				shiftBidderTableJoinFlag = true;</span>

<span class="nc" id="L486">				whereClause.append(&quot; AND &quot; + getWhereClauseForFilterKeyWithIntVal(reqFilter, COLNAME_SHIFTBIDDER_BONUSTHISAUCTION,</span>
						RequestFilter.BID_BONUS_OPERATOR_KEY, RequestFilter.BID_BONUS_KEY));
			}

			// if filtering by employee accumulated points
<span class="nc bnc" id="L491" title="All 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.BID_POINTS_KEY)) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">				if (!reqFilter.isKeySet(RequestFilter.BID_POINTS_OPERATOR_KEY)) {</span>
<span class="nc" id="L493">					throw new IllegalArgumentException(RequestFilter.BID_POINTS_OPERATOR_KEY);</span>
				}

<span class="nc" id="L496">				whereClause.append(&quot; AND &quot; + getWhereClauseForFilterKeyWithIntVal(reqFilter, COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS,</span>
						RequestFilter.BID_POINTS_OPERATOR_KEY, RequestFilter.BID_POINTS_KEY));
			}

			// if filtering by employee rank
<span class="nc bnc" id="L501" title="All 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.EMP_RANK_OPERATOR_KEY)) {</span>
<span class="nc" id="L502">				whereClause.append(&quot;AND &quot;);</span>
<span class="nc" id="L503">				whereClause.append(getWhereClauseForFilterKeyWithIntVal(reqFilter, &quot;EMPRANK.RANK&quot;, RequestFilter.EMP_RANK_OPERATOR_KEY,</span>
						RequestFilter.EMP_RANK_KEY));
			}

<span class="nc bnc" id="L507" title="All 2 branches missed.">			if (sbReqTableJoinFlag) {</span>
<span class="nc" id="L508">				whereClause.append(&quot; AND REQ.ID = SHIFTBIDREQUEST.ID &quot;);</span>
			}
<span class="nc bnc" id="L510" title="All 2 branches missed.">			if (shiftBidderTableJoinFlag) {</span>
<span class="nc" id="L511">				whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_ID + &quot; = &quot; + COLNAME_SHIFTBIDREQUEST_SHIFTBIDDERID);</span>
			}

<span class="nc" id="L514">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation.  If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L521">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L522">			throw e;</span>
<span class="nc" id="L523">		} catch (RmException e) {</span>
<span class="nc" id="L524">			m_cat.error(e, e);</span>
<span class="nc" id="L525">			handleException(e);</span>
<span class="nc" id="L526">			throw e;</span>
<span class="nc" id="L527">		} catch (Exception e) {</span>
<span class="nc" id="L528">			handleException(e);</span>
<span class="nc" id="L529">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L531" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L532">				dmo.cleanUp();</span>
			}
		}
<span class="nc" id="L535">	}</span>

	/**
	 * @param reqFilter
	 * @param colname_shiftbidder_bonusthisauction
	 * @param string
	 * @param string2
	 * @return
	 */
	private String getWhereClauseForFilterKeyWithIntVal(RequestFilter reqFilter,
			String columnName, String operatorKey, String filterKey) {

		// translate filter opeartor to SQL operator.
<span class="nc" id="L548">		String filtOperatorVal = (String) reqFilter.getValueForKey(operatorKey);</span>
<span class="nc" id="L549">		String sqlOperator = null;</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">		if (filtOperatorVal.equals(Filter.LESS_THAN_OPERATION)) {</span>
<span class="nc" id="L551">			sqlOperator = &quot; &lt; &quot;;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">		} else if (filtOperatorVal.equals(Filter.EQUAL_OPERATION)) {</span>
<span class="nc" id="L553">			sqlOperator = &quot; = &quot;;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">		} else if (filtOperatorVal.equals(Filter.GREATER_THAN_OPERATION)) {</span>
<span class="nc" id="L555">			sqlOperator = &quot; &gt; &quot;;</span>
		} else {
<span class="nc" id="L557">			throw RequestUtil.createIllegalArgumentException(filtOperatorVal, m_cat);</span>
		}

		// get value of filter key.
<span class="nc" id="L561">		Integer filtKeyValInt = (Integer) reqFilter.getValueForKey(filterKey);</span>

		// get where clause: columnName + operator + valueOfFilterKey
<span class="nc" id="L564">		return columnName + &quot; &quot; + sqlOperator + &quot; &quot; + filtKeyValInt.toString();</span>
	}

	/**
	 * &lt;p&gt; if fetching reqs of type 'shiftbidreqs', automatically add 'preference' as the
	 * secondary sort key.  This is necessary for group processing of shiftbidreqs as
	 * the req with the highest 'preference' in a group of requests, with the same value for the
	 * primary sort key, for an employee, must be group processed (approval process) first.
	 *
	 * &lt;p&gt; For example, if sorting by rank as the primary sort key and if an employee has submitted
	 * 4 reqs, then the req with the highest priority must be approved first when performing
	 * group approval.
	 *
	 * &lt;p&gt; Note: it is guaranteed that the 'order by' phrase has already been added to the
	 * 'query' since the reqs are always sorted by a primary key.  So we do not have be
	 * concerned about adding or not adding the 'order by' clause
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addOrderByClause(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter, int, java.lang.String)
	 */
	@Override
	public void addOrderByClause(StringBuffer orderByClause, RequestFilter requestFilter, int sortColumn, String sortDir) {
<span class="nc" id="L585">		final String orderByPhrase = &quot; ORDER BY &quot;;</span>

		// flag to indicate if an &quot;ORDER BY&quot; cluase was added during processing.
<span class="nc" id="L588">		boolean orderByClauseAdded = true;</span>
<span class="nc bnc" id="L589" title="All 6 branches missed.">		switch (sortColumn) {</span>
		case Request.SORT_SHIFTBID_PREFERENCE:
<span class="nc" id="L591">			orderByClause.append(&quot; ORDER BY SHIFTBIDREQUEST.PREFERENCE &quot;).append(sortDir);</span>
<span class="nc" id="L592">			break;</span>
		case Request.SORT_SHIFTBID_ISBONUSUSED:
<span class="nc" id="L594">			orderByClause.append(&quot; ORDER BY SHIFTBIDREQUEST.ISBONUSUSED &quot;).append(sortDir);</span>
<span class="nc" id="L595">			break;</span>
		case Request.SORT_SHIFTBID_SENIORITY:
			//DIRECT_DB_ACCESS
<span class="nc" id="L598">			orderByClause.append(orderByPhrase).append(COLNAME_EMPLOYEEAM_STARTTIME).append(' ').append(invertSortDir(sortDir));</span>
<span class="nc" id="L599">			break;</span>
		case Request.SORT_SHIFTBID_POINTS:
			//DIRECT_DB_ACCESS
<span class="nc" id="L602">			orderByClause.append(orderByPhrase).append(COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS).append(' ').append(sortDir);</span>
<span class="nc" id="L603">			break;</span>
		case Request.SORT_SHIFTBID_BIDDERBONUS:
<span class="nc" id="L605">			orderByClause.append(&quot; ORDER BY SHIFTBIDDER.BONUSTHISAUCTION &quot;).append(sortDir);</span>
<span class="nc" id="L606">			break;</span>
		default:
<span class="nc" id="L608">			orderByClauseAdded = false;</span>
		}

		// see javadoc for an explanation as to why this is done.
		//
		// do not add the 'PREFERENCE' column again if already added.
		// do not add the secondary sort if sorting by 'PREFERENCE' (inmemory sort).
<span class="nc bnc" id="L615" title="All 6 branches missed.">		if ((orderByClauseAdded || sortColumn &gt; 0) &amp;&amp; sortColumn != Request.SORT_SHIFTBID_PREFERENCE) {</span>
<span class="nc" id="L616">			orderByClause.append(&quot;, &quot;).append(ShiftBidRequestFieldInfo.m_strTableName).</span>
<span class="nc" id="L617">					append('.').append(ShiftBidRequestFieldInfo.COLNAME_PREFERENCE).</span>
<span class="nc" id="L618">					append(&quot; &quot;).append(RequestUtil.SORTDIR_ASC);</span>
		}
<span class="nc" id="L620">	}</span>

	/**
	 *
	 * used to filter and sort request IDs for CmReqManager.getRequestsForManager() API.  Does filtering and sorting
	 * that cannot be done at the SQL level (For example, RequestFilter.BID_REQUESTED_DAY_KEY).
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#applyFilterAndSortCriteriaForRequests(java.util.List, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter, int, int)
	 *
	 * @param mgrEmpID empID of manager on behalf of whom requests are being fetched.
	 * @param reqIDsSorted list of reqIDs for which filtering and sorting needs to be applied.  &lt;b&gt; This list
	 * may already be sorted and hence the list ordering must be preserved by this method for the
	 * returned list of request IDs. &lt;/b&gt;
	 * @param reqFilter
	 * @param sortColumn
	 * @param inclExpired
	 *
	 * @param detailLevel
	 * @return list of reqIDs after filtering and sorting.
	 */
	@Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDsSorted, RequestFilter reqFilter,
			int sortColumn, int sortDir, boolean inclExpired, long detailLevel,
			boolean runSoftValids, boolean runNetStaffingSoftVal) throws RmException, RmHardValidationException {

<span class="nc" id="L645">		String _method_ = &quot;applyFilterAndSortCriteriaForRequests&quot;;</span>
<span class="nc" id="L646">		methodStart(_method_, reqIDsSorted, reqFilter, new Integer(sortColumn), new Integer(sortDir));</span>

<span class="nc" id="L648">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L649">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L651">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L653">			super.applyFilterAndSortCriteriaForReqIDs(mgrEmpID, reqIDsSorted, reqFilter, sortColumn, sortDir, inclExpired, detailLevel,</span>
					runSoftValids, runNetStaffingSoftVal);

<span class="nc bnc" id="L656" title="All 2 branches missed.">			boolean sortByBidderScore = (sortColumn == Request.SORT_SHIFTBID_SCORE);</span>
<span class="nc" id="L657">			Collection&lt;ID&gt; filteredIds = FilterAndSortShiftBidRequests.filterAndSort(mgrEmpID, reqIDsSorted, reqFilter,</span>
					sortByBidderScore, sortDir);
<span class="nc" id="L659">			return new Pair&lt;Collection&lt;ID&gt;, Collection&lt;Request&gt;&gt;(filteredIds, null);</span>

<span class="nc" id="L661">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation.  If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L668">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L669">			throw e;</span>
<span class="nc" id="L670">		} catch (RmException e) {</span>
<span class="nc" id="L671">			m_cat.error(e, e);</span>
<span class="nc" id="L672">			handleException(e);</span>
<span class="nc" id="L673">			throw e;</span>
<span class="nc" id="L674">		} catch (Exception e) {</span>
<span class="nc" id="L675">			handleException(e);</span>
<span class="nc" id="L676">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L678" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L679">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L681">			methodFinish();</span>
		}
	}

	public String createShiftsDataList(ShiftBidRequest sbr) throws Exception {
<span class="nc" id="L686">		ShiftBidAuction sba = RmManagerFactory.getInstance().getShiftBidAuctionManager()</span>
<span class="nc" id="L687">				.getAuctionByID(sbr.getShiftBidAuctionID(), ShiftBidAuction.DL_CAMPAIGN);</span>
<span class="nc" id="L688">		SchedulingPeriod schedPeriod = sba.getOptMethods().getSP();</span>
<span class="nc" id="L689">		Collection shifts = sbr.getOptMethods().getShiftAssignments();</span>
<span class="nc" id="L690">		TimeZone campaignTz = WfmManagerFactory.getCampaignManager().getCampaignByID(schedPeriod.getCampaignID()).getTimeZone();</span>
<span class="nc" id="L691">		TimeZone userViewingTz = campaignTz;</span>
<span class="nc" id="L692">		StringBuffer result = new StringBuffer();</span>

<span class="nc" id="L694">		Localizer localizer = RequestUtil.getLocalizerForAppDefLocale();</span>
<span class="nc" id="L695">		Locale locale = localizer.getLocaleContext().getRegionalFormatLocale();</span>
<span class="nc" id="L696">		CalendarRange cRange = new CalendarRange(schedPeriod.getStartTime(), schedPeriod.getEndTime(), userViewingTz, locale);</span>
<span class="nc" id="L697">		Calendar startCal = cRange.getStartCalendar();</span>
<span class="nc" id="L698">		Calendar endCal = cRange.getEndCalendar();</span>
<span class="nc" id="L699">		String dayPatterm = RegionalFormatBundleKey.DATE_NOYEAR_DAYINWEEKFULL_FORMAT;</span>
<span class="nc" id="L700">		result.append(&quot;&lt;TABLE&gt;&quot;);</span>
<span class="nc" id="L701">		boolean retVal = false;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">		while (endCal.after(startCal)) {</span>
<span class="nc" id="L703">			Date currentDate = startCal.getTime();</span>
<span class="nc" id="L704">			CalendarRange dayRange = DateTimeUtil.makeDayRange(currentDate, campaignTz);</span>
<span class="nc" id="L705">			Collection selectedShiftList = RequestUtil.findShifts(dayRange, shifts);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">			if (!selectedShiftList.isEmpty()) {</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">				for (Iterator it = selectedShiftList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L708">					ShiftAssignment sa = (ShiftAssignment) it.next();</span>
<span class="nc" id="L709">					Date startDate = RequestUtil.getDisplayStartTime(sa);</span>
<span class="nc" id="L710">					Date endDate = sa.getEndTime();</span>
<span class="nc" id="L711">					String saDisp = RequestUtil.makeShiftDatesString(dayRange, startDate, endDate, localizer, userViewingTz);</span>
<span class="nc" id="L712">					result.append(&quot;&lt;TR class=\&quot;tblRow\&quot;&gt;&lt;TD&gt;&quot;).append(localizer.formatDate(currentDate, campaignTz, dayPatterm));</span>
<span class="nc" id="L713">					result.append(&quot;&lt;/TD&gt;&lt;TD&gt;&quot;).append(saDisp).append(&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);</span>
<span class="nc" id="L714">					retVal = true;</span>
<span class="nc" id="L715">				}</span>
			}
<span class="nc" id="L717">			startCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L718">		}</span>
<span class="nc" id="L719">		result.append(&quot;&lt;/TABLE&gt;&quot;);</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">		return (retVal ? result.toString() : &quot;&quot;);</span>
	}

	@Override
	protected void _approveRequest(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment,
			boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="nc" id="L727">		m_cat.debug(&quot;Approving request: ID = &quot; + reqAgg.getID());</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">		comment = ((comment != null) ? comment + &quot;&lt;BR&gt;&quot; : &quot;&quot;) + createShiftsDataList((ShiftBidRequest) reqAgg);</span>

		//update status to approved, validate status transition, check privilege and run hard validations
<span class="nc" id="L731">		_updateRequest(reqAgg, RequestAuditTrail.STATUS_APPROVED, comment, RequestAuditTrail.STATUS_APPROVED,</span>
				suppressPrivilegeChecking, loadedFromDB);

<span class="nc" id="L734">		ShiftBidRequest shiftBidRequest = (ShiftBidRequest) reqAgg;</span>

<span class="nc" id="L736">		List&lt;BiddableSchedule&gt; bidSchedList = shiftBidRequest.getOptMethods().getBiddableSchedules();</span>
<span class="nc" id="L737">		ID bidderEmpID = shiftBidRequest.getEmployeeID();</span>
<span class="nc" id="L738">		TimeRange dateRange = reqAgg.getValidationCache().getDateRange();</span>
<span class="nc" id="L739">		ShiftBidAuction auction = shiftBidRequest.getOptMethods().getShiftBidAuction();</span>

<span class="nc" id="L741">		createSchedulesForBidder(bidSchedList, dateRange, bidderEmpID, auction);</span>

		// switch bidder state from &quot;added&quot; to &quot;scheduled&quot;.
<span class="nc" id="L744">		ShiftBidder bidder = shiftBidRequest.getOptMethods().getShiftBidder();</span>
<span class="nc" id="L745">		bidder.getSetters().setStatus(ShiftBidder.STATUS_UNAVAILABLE);</span>

<span class="nc" id="L747">		ShiftBidRequestDAO dao = new ShiftBidRequestDAO(ShiftBidder.DL_BASIC);</span>
		try {
<span class="nc" id="L749">			dao.runAfterApprovalProcess(shiftBidRequest.getID());</span>
<span class="nc" id="L750">			ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate(shiftBidRequest.getShiftBidAuctionID(),</span>
<span class="nc" id="L751">					Collections.singleton(bidder), null, null);</span>
		} finally {
<span class="nc" id="L753">			dao.cleanUp();</span>
<span class="nc" id="L754">		}</span>
<span class="nc" id="L755">	}</span>

	/*
	 * Creates shifts for the employee and publish the range
	 */
	private void createSchedulesForBidder(List&lt;BiddableSchedule&gt; bidSchedList, TimeRange dateRange, ID bidderEmpID, ShiftBidAuction auction)
			throws Exception {

<span class="nc" id="L763">		boolean isMultiShiftBlocks = auction.getIsMultiShift();</span>

<span class="nc" id="L765">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">		for (Iterator&lt;BiddableSchedule&gt; it = bidSchedList.iterator(); it.hasNext();) {</span>

<span class="nc" id="L769">			BiddableSchedule sched = it.next();</span>

			// Retrieve the shift Assignments related to the biddable schedule Instance
<span class="nc" id="L772">			Collection&lt;ShiftAssignment&gt; shiftAssignments = sched.getShiftAssignments();</span>

			// only publish on last iteration of the loop
<span class="nc bnc" id="L775" title="All 2 branches missed.">			boolean bPublish = !it.hasNext();</span>

			// Create employee's shift assignments
<span class="nc" id="L778">			RequestUtil.moveShiftAssnsToEmp(shiftAssignments, bidderEmpID, bPublish,</span>
					dateRange,
					//deleteUnderlyingUnavails = true
					true, sam, isMultiShiftBlocks,
					//allowOverlap = false
					false);

<span class="nc" id="L785">		}</span>

<span class="nc" id="L787">	}</span>

	@Override
	protected void _approveRequestPostProcess(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment) {
		try {
<span class="nc" id="L792">			addNextShiftBidderIfNecessary(reqAgg);</span>
<span class="nc" id="L793">		} catch (Exception e) {</span>
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
			// Exception is not rethrown but just logged.  Necessary to prevent the entire transaction
			// from being rolled back if the next shift bidder cannot be added successfully.
			//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
<span class="nc" id="L798">			m_cat.error(&quot;_approveRequestPostProcess&quot;, e);</span>
<span class="nc" id="L799">		}</span>
<span class="nc" id="L800">	}</span>

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestTentatively(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
	 */
	@Override
	protected void _approveRequestTentatively(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceID, String comment, boolean loadedFromDB)
			throws Exception
	{
		//validate request

		//mark request as tentatively approved.

		//make schedule changes.
<span class="nc" id="L814">		throw new UnsupportedOperationException(m_tentativeNotImplemented + reqAgg);</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String, boolean)
	 */
	//TODO: Pass DAO as an argument to reduce # of DAOs created during request processing.
	@Override
	protected void _denyRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB)
			throws Exception
	{
		//do not have to validate request.

		//if tentatively approved, undo changes.

		//mark request denied.
<span class="nc" id="L830">		_updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null,</span>
				suppressPrivilegeChecking, loadedFromDB);
<span class="nc" id="L832">	}</span>

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
	 */
	@Override
	protected void _denyRequestPostProcess(RequestAggregate reqAgg, String comment) {
		//QA58518: deny should not trigger addition of next agent
		/*try {
		    addNextShiftBidderIfNecessary(reqAgg);
		} catch (Exception e) {
		    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		    // Exception is not rethrown but just logged.  Necessary to prevent the entire transaction
		    // from being rolled back if the next shift bidder cannot be added successfully.
		    //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
		    m_cat.error(&quot;_denyRequestPostProcess&quot;, e);
		}*/
<span class="nc" id="L849">	}</span>

	/**
	 * Called when a shift bid request is approved, denied, autoapproved or autodenied.
	 *
	 * Adds the next bidder provided the following conditions are met:
	 * &lt;li&gt; if auction associated with the given shift bid request is in serialized mode
	 * &lt;li&gt; if the bidder associated with the given shift bid request is the current bidder of the
	 *   auction.
	 * @param reqAgg
	 */
	private void addNextShiftBidderIfNecessary(RequestAggregate reqAgg) throws Exception {
<span class="nc" id="L861">		SerializedAuctionDAO aucSerDAO = null;</span>
		try {
<span class="nc" id="L863">			ShiftBidRequest sbReq = (ShiftBidRequest) reqAgg;</span>
			// check if this is a serailized auction and if so, if this request's bidder is the current bidder.
<span class="nc" id="L865">			aucSerDAO = new SerializedAuctionDAO();</span>

<span class="nc" id="L867">			ID auctionID = sbReq.getShiftBidAuctionID();</span>
<span class="nc" id="L868">			SerializedAuction aucSer = aucSerDAO.getSerializedAuctionForAuctionID(auctionID);</span>

			// if auction is not in serialization mode, end of story.
<span class="nc bnc" id="L871" title="All 2 branches missed.">			if (aucSer == null) {</span>
<span class="nc" id="L872">				return;</span>
			}

			// if request does not belong to the current bidder for the serialized auction
<span class="nc" id="L876">			ID reqBidderID = sbReq.getShiftBidderID();</span>
<span class="nc" id="L877">			ID serAucCurrentBidderID = aucSer.getCurrentBidderID();</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">			if (!reqBidderID.equals(serAucCurrentBidderID)) {</span>
<span class="nc" id="L879">				m_cat.debug(&quot;Not adding next bidder since request does not belong to current bidder: &quot; +</span>
						&quot; reqBidderID, serAucCurrBidderID: &quot; + reqBidderID + ',' + serAucCurrentBidderID);
<span class="nc" id="L881">				return;</span>
			}

			// Otherwise, add next shift bidder to auction.
<span class="nc" id="L885">			ShiftBidAuctionUtil.addNextBidderToSerAucUpdateAndNotify(aucSer, aucSerDAO, null);</span>
		} finally {
<span class="nc bnc" id="L887" title="All 8 branches missed.">			if (aucSerDAO != null) {</span>
<span class="nc" id="L888">				aucSerDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L891">	}</span>

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_undoTentativeApprovalByID(com.bluepumpkin.common.datatypes.ID, java.lang.String, java.lang.String)
	 */
	@Override
	protected RequestAggregate _undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment)
			throws Exception {
<span class="nc" id="L899">		throw new UnsupportedOperationException(m_tentativeNotImplemented);</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_undoRequestAndSchedule(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
	 */
	@Override
	protected void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
			Object[] optUndoData) throws Exception {
<span class="nc" id="L908">		throw new UnsupportedOperationException();</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDPurge()
	 */
	@Override
	protected ID getPrivIDPurge() {
<span class="nc" id="L916">		return PrivilegeKeys.SB_PURGEREQUESTS_ID;</span>
	}

	/**
	 * This method:
	 * &lt;li&gt; does some basic validations of the given shiftBidRequest
	 * &lt;li&gt; and loads the necessary child objects for running hard validations.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#createRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
	 */
	@Override
	protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO)
			throws Exception
	{
<span class="nc" id="L930">		ShiftBidderDAO shiftBidderDAO = null;</span>
		try {
<span class="nc" id="L932">			super.createRequestPreProcess(reqAgg, reqAggDAO);</span>

<span class="nc" id="L934">			ShiftBidRequest sbRequest = (ShiftBidRequest) reqAgg;</span>

			// Error if both employeeID and shiftBidderID not set
<span class="nc bnc" id="L937" title="All 4 branches missed.">			if (sbRequest.getShiftBidderID() == null &amp;&amp; sbRequest.getEmployeeID() == null) {</span>
<span class="nc" id="L938">				throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
			}

			// Error if auction ID not set
<span class="nc bnc" id="L942" title="All 2 branches missed.">			if (sbRequest.getShiftBidAuctionID() == null) {</span>
<span class="nc" id="L943">				throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
			}

			//translate empID to shiftBidderID if necessary.
<span class="nc bnc" id="L947" title="All 2 branches missed.">			if (sbRequest.getShiftBidderID() == null) {</span>
<span class="nc" id="L948">				shiftBidderDAO = new ShiftBidderDAO(reqAggDAO.getDMO(), ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L950">				ShiftBidder shiftBidder = shiftBidderDAO.getShiftBidderForEmpAndAuctionID(sbRequest.getEmployeeID(),</span>
<span class="nc" id="L951">						sbRequest.getShiftBidAuctionID(), ShiftBidder.DL_BASIC);</span>

<span class="nc bnc" id="L953" title="All 2 branches missed.">				if (shiftBidder == null) {</span>
<span class="nc" id="L954">					throw RequestUtil.createRmException(RmEjbLogBundleKey.SBR_CANNOT_FIND_SHIFTBIDDER,</span>
<span class="nc" id="L955">							sbRequest.getEmployeeID(), sbRequest.getShiftBidAuctionID(), m_cat);</span>
				}

<span class="nc" id="L958">				sbRequest.setShiftBidderID(shiftBidder.getID());</span>
			}

			// obtain employeeID if necessary.
<span class="nc bnc" id="L962" title="All 2 branches missed.">			if (sbRequest.getEmployeeID() == null) {</span>
<span class="nc" id="L963">				shiftBidderDAO = new ShiftBidderDAO(reqAggDAO.getDMO(), ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L964">				ShiftBidder shiftBidder = shiftBidderDAO.getShiftBidderByID(sbRequest.getShiftBidderID(), ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L965">				sbRequest.setEmployeeID(shiftBidder.getEmployeeID());</span>
			}

<span class="nc bnc" id="L968" title="All 2 branches missed.">			if (sbRequest.getName() == null) {</span>
<span class="nc" id="L969">				sbRequest.setName(&quot;Default ShiftBidRequest Name&quot;);</span>
			}

			// load all associated data.
<span class="nc" id="L973">			loadAssocDataForCreateReqValidation(sbRequest);</span>
		} finally {
<span class="nc bnc" id="L975" title="All 4 branches missed.">			if (shiftBidderDAO != null) {</span>
<span class="nc" id="L976">				shiftBidderDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L979">	}</span>

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestManager#validateRequestBeforeCreate(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate)
	 */
	public RequestAggregate validateRequestAndComputeRank(RequestAggregate reqAgg)
			throws RmException, RmHardValidationException {
<span class="nc" id="L986">		String _method_ = &quot;validateRequestBeforeCreate&quot;;</span>
<span class="nc" id="L987">		methodStart(_method_, reqAgg);</span>

		//The passed shiftBidRequest only has ShiftBidRequestBiddableSChedule children.  We need
		// more info to compute the rank and run the hard validations.  The primary hard validation to  be run
		// is if the given set of biddable schedules are valid (ie, shift assignments will not overlap
		// unavailabilities etc).
<span class="nc" id="L993">		ShiftBidRequestDAO sbReqDAO = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
<span class="nc" id="L994">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L995">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L997">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// if requestID != null and any hard validations fail, during doHardValidations() below, the
			// request is marked 'invalid' in the DB by doHardValidations().  This scenario happens when
			// the webtier calls validateRequestBeforeCreate() twice, once before call to createRequest()
			// once after call to createRequest().  The 2nd call has a non-null requestID which results
			// in the request getting marked as 'invalid'.
<span class="nc" id="L1004">			reqAgg.setID(null);</span>

			// assign default values to request fields
<span class="nc" id="L1007">			assignDefaultsForReqAgg(reqAgg);</span>

			// this pre-processes the request and loads the necessary child objects.
<span class="nc" id="L1010">			createRequestPreProcess(reqAgg, sbReqDAO);</span>

<span class="nc" id="L1012">			doHardValidations(reqAgg, RequestUtil.METHODTYPE_CREATOR, null, true);</span>

<span class="nc" id="L1014">			sbReqDAO.setRankForUncreatedRequest((ShiftBidRequest) reqAgg);</span>

<span class="nc" id="L1016">			return reqAgg;</span>
<span class="nc" id="L1017">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation.  If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1024">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1025">			throw e;</span>
<span class="nc" id="L1026">		} catch (RmException e) {</span>
<span class="nc" id="L1027">			m_cat.error(e, e);</span>
<span class="nc" id="L1028">			handleException(e);</span>
<span class="nc" id="L1029">			throw e;</span>
<span class="nc" id="L1030">		} catch (Exception e) {</span>
			// reset the ID temporarily set to Integer.MAX_VALUE earlier.
<span class="nc" id="L1032">			reqAgg.setID(null);</span>

<span class="nc" id="L1034">			handleException(e);</span>
<span class="nc" id="L1035">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1037" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1038">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}

<span class="nc" id="L1041">			sbReqDAO.cleanUp();</span>

<span class="nc" id="L1043">			methodFinish();</span>
		}
	}

	/**
	 * This method:
	 * &lt;li&gt; loads the biddable schedules associated with the shift bid request.
	 * &lt;li&gt; attaches the biddable schedule to the proper shiftbidRequestBidSched as a child.
	 * &lt;li&gt; fills the shiftBidReqBidSched.order field which maintains the order of the shift assignments assoc
	 * with the shift bid request (in a single shift auction).
	 * &lt;li&gt; loads the shift bid auction and assoicates it with the shift bid request.
	 * &lt;li&gt; loads the shift bidder and makes it a child of sbREq.
	 *
	 * @param sbReq
	 * @throws Exception
	 */
	private void loadAssocDataForCreateReqValidation(ShiftBidRequest sbReq) throws Exception {

		// fetch the associated shift bid auction.
<span class="nc" id="L1062">		ShiftBidAuction sbAuction = sbReq.getValidationCacheSBR().getShiftBidAuction();</span>
<span class="nc" id="L1063">		sbReq.getSetters().setShiftBidAuction(sbAuction);</span>

		// if scoring disabled in auction, then reset &quot;use scoring&quot; flag for request.
<span class="nc bnc" id="L1066" title="All 2 branches missed.">		if (!sbAuction.getUsesScoring()) {</span>
<span class="nc" id="L1067">			sbReq.setIsBonusUsed(false);</span>
		}

		// fetch the biddableSchedules and associate them with the ShiftBidRequestbiddableSchedule children.
<span class="nc" id="L1071">		List&lt;ShiftBidRequestBiddableSchedule&gt; sbRbsList = sbReq.getOptMethods().getShiftBidRequestBiddableSchedules();</span>
<span class="nc bnc" id="L1072" title="All 4 branches missed.">		assert sbRbsList.size() != 0 : &quot;sbRbs.size() != 0&quot;;</span>

		// load biddable schedules using the biddbale schedule IDs in the request.
<span class="nc" id="L1075">		Collection&lt;BiddableSchedule&gt; bidSchedsFromDB = sbReq.getValidationCacheSBR().getBiddableSchedules();</span>

<span class="nc" id="L1077">		validateAllBidsInAuction(bidSchedsFromDB, sbAuction);</span>

<span class="nc" id="L1079">		assocBidSchedsToShiftBidReqBidSched(sbRbsList, bidSchedsFromDB, sbAuction);</span>

		// After attaching the biddable schedules as children of ShiftBidrequestBiddableSchedules, adjust the detail
		// level for the shiftBidReq.
<span class="nc" id="L1083">		sbReq.addDetailLevel(ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL);</span>

		// Set expiration date if request is being created.
<span class="nc bnc" id="L1086" title="All 2 branches missed.">		if (sbReq.getExpirationDate() == null) {</span>
<span class="nc" id="L1087">			sbReq.setExpirationDate(sbAuction.getStartTime());</span>
		}

		// fetch the associated shift bidder
<span class="nc" id="L1091">		ShiftBidder shiftBidder = sbReq.getValidationCacheSBR().getShiftBidder();</span>
<span class="nc" id="L1092">		sbReq.getSetters().setShiftBidder(shiftBidder);</span>
<span class="nc" id="L1093">	}</span>

	private void validateAllBidsInAuction(Collection&lt;BiddableSchedule&gt; bidSchedsFromDB, ShiftBidAuction sbAuction)
			throws RmHardValidationException {
<span class="nc" id="L1097">		ID auctionID = sbAuction.getID();</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">		for (BiddableSchedule bidSchedule : bidSchedsFromDB) {</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">			if (!bidSchedule.getShiftBidAuctionID().equals(auctionID)) {</span>
<span class="nc" id="L1100">				throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.SBR_BIDDABLE_SCHEDULE_NOT_IN_AUCTION,</span>
<span class="nc" id="L1101">						bidSchedule.getID(), sbAuction.getName(), m_cat);</span>
			}
<span class="nc" id="L1103">		}</span>
<span class="nc" id="L1104">	}</span>

	/**
	 * Associate the biddable schedules loaded from DB with ShiftBidRequestBiddableSchedule
	 * Also set the proper order for the ShiftBidRequestBiddableSchedule.
	 *
	 * @param SBRBSList
	 * @param bidSchedsFromDB
	 * @param sbAuction
	 */
	private void assocBidSchedsToShiftBidReqBidSched(List&lt;ShiftBidRequestBiddableSchedule&gt; sbRbsList, Collection bidSchedsFromDB,
			ShiftBidAuction sbAuction) {
		//if auction type == full period schedule.
<span class="nc bnc" id="L1117" title="All 2 branches missed.">		if (sbAuction.getIsFullPeriodSchedule()) {</span>
			// full period auctions can have only one bidSched
<span class="nc bnc" id="L1119" title="All 4 branches missed.">			assert bidSchedsFromDB.size() == 1 : &quot;bidSchedsFromDB.size() == 1&quot;;</span>

<span class="nc" id="L1121">			setSingleBiddableScheduleItemOrder(sbRbsList, bidSchedsFromDB);</span>
		} else { // auction type == single shift schedule
			// Order the ShiftBidRequestBiddbaleSchedules associated with this request using the
			// (indirectly) associated shift assignments.
			// ShiftBidRequestBiddableSchedule --&gt; BiddableSchedule --&gt; ShiftAssignemnt
<span class="nc bnc" id="L1126" title="All 2 branches missed.">			if (sbRbsList.size() &gt; 1) {</span>
				// obtain map of biddableSchedule.ID to ShiftBidRequestBiddableSchedule
<span class="nc" id="L1128">				Map&lt;ID, ShiftBidRequestBiddableSchedule&gt; bidSchedIDToSbRbs = new HashMap&lt;ID, ShiftBidRequestBiddableSchedule&gt;(5);</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">				for (ShiftBidRequestBiddableSchedule sbRbs : sbRbsList) {</span>

<span class="nc" id="L1131">					bidSchedIDToSbRbs.put(sbRbs.getBiddableScheduleID(), sbRbs);</span>
<span class="nc" id="L1132">				}</span>

				// obtain map of shift assignment ID to biddableSchdule.
				// Also compile a shift assignment list associated with the biddable schedules
<span class="nc" id="L1136">				List shiftAssnsList = new ArrayList(5);</span>
<span class="nc" id="L1137">				Map shiftAssnIDToBiddableSchedMap = new HashMap(5);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">				for (Iterator bidSchedFromDBIter = bidSchedsFromDB.iterator(); bidSchedFromDBIter.hasNext();) {</span>
<span class="nc" id="L1139">					BiddableSchedule bidSched = (BiddableSchedule) bidSchedFromDBIter.next();</span>

<span class="nc" id="L1141">					List bidSchedShifts = bidSched.getShiftAssignments();</span>
<span class="nc bnc" id="L1142" title="All 4 branches missed.">					assert bidSchedShifts.size() == 1 : &quot;bidSchedShifts.size() == 1&quot;;</span>

<span class="nc" id="L1144">					shiftAssnsList.addAll(bidSchedShifts);</span>
					//Note: this is a single shift auction. so a biddable schedule is associated with only one shift assn.
<span class="nc" id="L1146">					shiftAssnIDToBiddableSchedMap.put(((ShiftAssignment) bidSchedShifts.get(0)).getID(), bidSched);</span>
<span class="nc" id="L1147">				}</span>

				// sort the shift assignments
<span class="nc" id="L1150">				Collections.sort(shiftAssnsList, new ShiftBidAuctionUtil.ShiftAssignmentComparator());</span>

				// iterate thru' the sorted shift assignments and identify the ShiftBidRequestBiddableSchedule each is
				// associated with.  Then set the 'itemorder' field in the shiftbidRequestBiddableSchedule.
<span class="nc bnc" id="L1154" title="All 2 branches missed.">				for (int shiftAssnIdx = 0; shiftAssnIdx &lt; shiftAssnsList.size(); shiftAssnIdx++) {</span>
<span class="nc" id="L1155">					ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsList.get(shiftAssnIdx);</span>
<span class="nc" id="L1156">					BiddableSchedule bidSched = (BiddableSchedule) shiftAssnIDToBiddableSchedMap.get(shiftAssn.getID());</span>
<span class="nc" id="L1157">					ShiftBidRequestBiddableSchedule sbrBS = bidSchedIDToSbRbs.get(bidSched.getID());</span>

<span class="nc" id="L1159">					sbrBS.setOrder(shiftAssnIdx + 1);</span>
				}

				// Attach BiddableSchedules as children of shiftBidRequestBiddableschedule.
<span class="nc" id="L1163">				Map bidSchedMap = RequestUtil.getMapOfIDsForVOBases(bidSchedsFromDB);</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">				for (int idx = 0; idx &lt; sbRbsList.size(); idx++) {</span>
<span class="nc" id="L1165">					ShiftBidRequestBiddableSchedule sbrBidSched = sbRbsList.get(idx);</span>
<span class="nc" id="L1166">					sbrBidSched.setBiddableSchedule((BiddableSchedule) bidSchedMap.get(sbrBidSched.getBiddableScheduleID()));</span>
				}
<span class="nc" id="L1168">			} else {</span>
				// Only one shiftbidRequestBiddableSchedule. Just set the item order
<span class="nc" id="L1170">				setSingleBiddableScheduleItemOrder(sbRbsList, bidSchedsFromDB);</span>
			}
		}
<span class="nc" id="L1173">	}</span>

	protected void setSingleBiddableScheduleItemOrder(List&lt;ShiftBidRequestBiddableSchedule&gt; sbRbsList, Collection bidSchedsFromDB) {
<span class="nc" id="L1176">		Iterator it = bidSchedsFromDB.iterator();</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">		if (it.hasNext()) {</span>
<span class="nc" id="L1178">			ShiftBidRequestBiddableSchedule sbrBS = (sbRbsList.get(0));</span>
<span class="nc" id="L1179">			sbrBS.setOrder(1);</span>
<span class="nc" id="L1180">			sbrBS.setBiddableSchedule((BiddableSchedule) it.next());</span>
		}
<span class="nc" id="L1182">	}</span>

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#updateRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
	 */
	@Override
	protected RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
			boolean loadedFromDB) throws Exception
	{
		// updatable fields: Name, Preference, isBonusUsed,
		//verify if fields have valid values.

		//verify if immutable fields have changed (compare with request in db).
<span class="nc" id="L1195">		ShiftBidRequest sbReqFromDB = (ShiftBidRequest) reqAgg;</span>
		// reload from DB if the given request was not loadedFromDB or the detail level is not adequate for validation
<span class="nc" id="L1197">		long detailForVal = getDetailLevelForValidation();</span>
<span class="nc bnc" id="L1198" title="All 4 branches missed.">		if (!loadedFromDB || ((reqAgg.getDetailLevel() &amp; detailForVal) != detailForVal)) {</span>
<span class="nc" id="L1199">			ShiftBidRequestDAO sbReqDAO = (ShiftBidRequestDAO) reqAggDAO;</span>
<span class="nc" id="L1200">			sbReqFromDB =</span>
<span class="nc" id="L1201">					(ShiftBidRequest) sbReqDAO.getRequestByID(reqAgg.getID(), detailForVal);</span>

			//set updatable fields
<span class="nc bnc" id="L1204" title="All 2 branches missed.">			if (!StringUtil.isEmpty(reqAgg.getObjectVersionNumber())) {</span>
<span class="nc" id="L1205">				sbReqFromDB.getAggregatedRequest().setObjectVersionNumber(reqAgg.getObjectVersionNumber());</span>
			}
<span class="nc bnc" id="L1207" title="All 2 branches missed.">			if (!StringUtil.isEmpty(reqAgg.getRequestStatus())) {</span>
<span class="nc" id="L1208">				sbReqFromDB.setRequestStatus(reqAgg.getRequestStatus());</span>
			}

<span class="nc" id="L1211">			ShiftBidRequest sbReqGiven = (ShiftBidRequest) reqAgg;</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">			if (!StringUtil.isEmpty(sbReqGiven.getName())) {</span>
<span class="nc" id="L1213">				sbReqFromDB.setName(sbReqGiven.getName());</span>
			}
<span class="nc" id="L1215">			sbReqFromDB.setPreference(sbReqGiven.getPreference());</span>

			//if &quot;auction uses scoring&quot; flag == false, then &quot;use bonus&quot; flag for the bid request must be reset.
<span class="nc" id="L1218">			sbReqFromDB.setIsBonusUsed(sbReqGiven.getIsBonusUsed());</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">			if (sbReqGiven.getIsBonusUsed()) {</span>
<span class="nc" id="L1220">				ShiftBidAuction sbAuctionForReq = sbReqFromDB.getOptMethods().getShiftBidAuction();</span>
				// if &quot;auction uses scoring&quot; == false, then reset &quot;use bonus&quot; flag for request.
<span class="nc bnc" id="L1222" title="All 2 branches missed.">				if (!sbAuctionForReq.getUsesScoring()) {</span>
<span class="nc" id="L1223">					sbReqFromDB.setIsBonusUsed(false);</span>
				}
			}
		}

<span class="nc" id="L1228">		return sbReqFromDB;</span>
	}

	@Override
	protected void getRequestPostProcess(Collection reqAggs, long givenDetailLevel) throws Exception {

<span class="nc bnc" id="L1234" title="All 2 branches missed.">		if ((givenDetailLevel &amp; ShiftBidRequest.DL_BIDRANK_FOR_SHIFTBIDREQUEST) == 0) {</span>
			//don't need to compute the rank
<span class="nc" id="L1236">			return;</span>
		}

		//Set the request's RankWithBonus and RankWithoutBonus fields
<span class="nc" id="L1240">		Map&lt;ID, ShiftBidRequest&gt; requestsByID = new HashMap&lt;ID, ShiftBidRequest&gt;(reqAggs.size());</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">		for (Object request : reqAggs) {</span>
<span class="nc" id="L1242">			ShiftBidRequest sbRequest = (ShiftBidRequest) request;</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">			if (!sbRequest.isGetRequestPostProcNeeded()) {</span>
<span class="nc" id="L1244">				continue;</span>
			}
<span class="nc" id="L1246">			requestsByID.put(sbRequest.getID(), sbRequest);</span>
<span class="nc" id="L1247">		}</span>

<span class="nc" id="L1249">		ShiftBidRequestDAO dao = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
		try {
<span class="nc" id="L1251">			dao.loadRequestRankAndScore(requestsByID);</span>
		} finally {
<span class="nc" id="L1253">			dao.cleanUp();</span>
<span class="nc" id="L1254">		}</span>

<span class="nc" id="L1256">	}</span>

	//get the requests associated with a bidder
	public ID getApprovedRequestID(ID shiftBidderID, ID auctionID) throws Exception {
<span class="nc" id="L1260">		ShiftBidRequestDAO sbrDAO = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
		try {
<span class="nc" id="L1262">			m_cat.debug(&quot;Getting requests for agent ID = &quot; + shiftBidderID);</span>
<span class="nc" id="L1263">			return sbrDAO.getApprovedRequestIDByShiftBidderAndAuctionID(shiftBidderID, auctionID);</span>
		} finally {
<span class="nc" id="L1265">			sbrDAO.cleanUp();</span>
		}
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public void withdrawApprovedBidRequest(ShiftBidRequest request, String comment) throws Exception {
<span class="nc" id="L1271">		Jdmo dmo = new Jdmo(false);</span>

		try {

<span class="nc" id="L1275">			ShiftBidderDAO sbDAO = new ShiftBidderDAO(dmo, RequestDetailLevel.DL_SHIFTBIDDER);</span>
<span class="nc" id="L1276">			BiddableScheduleMiscDAO shiftDaoMisc = new BiddableScheduleMiscDAO(dmo);</span>

<span class="nc" id="L1278">			ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L1279">			ShiftBidder bidder = request.getOptMethods().getShiftBidder();</span>

<span class="nc" id="L1281">			List&lt;ID&gt; shiftAssignemntToDeleteIds = shiftDaoMisc.getShiftAssignmentIdsCreatedForRequest(request.getID());</span>

<span class="nc bnc" id="L1283" title="All 2 branches missed.">			if (bidder != null) {</span>
				// Update ShiftBidder (status) 
<span class="nc" id="L1285">				bidder.getSetters().setStatus(ShiftBidder.STATUS_ADDED);</span>
<span class="nc" id="L1286">				sbDAO.updateObject(bidder);</span>

				// Update BiddableShift and shift assignments (for employee and phantoms)
<span class="nc" id="L1289">				withdrawUpdateBiddableShiftsAndShiftAssignments(request, sam, shiftAssignemntToDeleteIds);</span>
			}

			//update employee request with status==withdrawn
<span class="nc" id="L1293">			changeRequestStateByID(request.getID(), RequestAuditTrail.STATUS_WITHDRAWN, request.getObjectVersionNumber(), comment);</span>

<span class="nc" id="L1295">			ShiftBidRequestDAO.runAfterWithdrawalProcess(dmo, request.getID());</span>

<span class="nc" id="L1297">		} catch (Exception e) {</span>
<span class="nc" id="L1298">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1299">			throw e;</span>
		} finally {
<span class="nc" id="L1301">			dmo.cleanUp();</span>
<span class="nc" id="L1302">		}</span>
<span class="nc" id="L1303">	}</span>

	private void withdrawUpdateBiddableShiftsAndShiftAssignments(ShiftBidRequest request, ScheduleAccessManager sam,
			Collection&lt;ID&gt; shiftAssignmentIDs)
			throws Exception {

		// If employee cannot have existing schedules (auction has IncPrevSchedEmp = false), delete employee published schedules
		// If employee can have existing schedules (auction has IncPrevSchedEmp = true), republish employee schedule (to avoid data loss)

<span class="nc" id="L1312">		Collection&lt;TimeRange&gt; timeRangesToPublish = getTimeRangesToPublishForWithdrawal(request);</span>

<span class="nc" id="L1314">		sam.deleteShiftAssignments(shiftAssignmentIDs);</span>

		// Update employee published schedule
<span class="nc bnc" id="L1317" title="All 4 branches missed.">		if (!request.getOptMethods().getShiftBidAuction().getIncPrevSchedEmp() &amp;&amp; timeRangesToPublish.size() == 1) {</span>
			// legacy logic
<span class="nc" id="L1319">			TimeRange timeRangeToPublish = timeRangesToPublish.iterator().next();</span>
<span class="nc" id="L1320">			sam.unPublishSchedule(Collections.singleton(request.getEmployeeID()), timeRangeToPublish.getStartDate(),</span>
<span class="nc" id="L1321">					timeRangeToPublish.getEndDate());</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">		} else if (request.getOptMethods().getShiftBidAuction().getIncPrevSchedEmp()) {</span>
			// new logic
<span class="nc bnc" id="L1324" title="All 2 branches missed.">			for (TimeRange timeRangeToPublish : timeRangesToPublish) {</span>
<span class="nc" id="L1325">				sam.publishSchedule(Collections.singleton(request.getEmployeeID()), timeRangeToPublish.getStartDate(),</span>
<span class="nc" id="L1326">						timeRangeToPublish.getEndDate());</span>
<span class="nc" id="L1327">			}</span>
		}
<span class="nc" id="L1329">	}</span>

	private Collection&lt;TimeRange&gt; getTimeRangesToPublishForWithdrawal(ShiftBidRequest request) {
<span class="nc" id="L1332">		Collection&lt;TimeRange&gt; timeRangesToPublish = new HashSet&lt;TimeRange&gt;();</span>

		// Get assigned shift assignments
<span class="nc" id="L1335">		Collection&lt;ShiftAssignment&gt; shiftAssignments = request.getOptMethods().getShiftAssignments();</span>

<span class="nc bnc" id="L1337" title="All 2 branches missed.">		if (request.getOptMethods().getShiftBidAuction().getIncPrevSchedEmp()) {</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">			for (ShiftAssignment sa : shiftAssignments) {</span>
<span class="nc" id="L1339">				timeRangesToPublish.add(new TimeRange(sa.getStartTime(), sa.getEndTime()));</span>
<span class="nc" id="L1340">			}</span>

<span class="nc" id="L1342">			return timeRangesToPublish;</span>
		}

		// legacy logic using un-publish method for whole request range
<span class="nc" id="L1346">		Date startPub = null;</span>
<span class="nc" id="L1347">		Date endPub = null;</span>

<span class="nc bnc" id="L1349" title="All 2 branches missed.">		for (ShiftAssignment sa : shiftAssignments) {</span>
<span class="nc bnc" id="L1350" title="All 4 branches missed.">			if (startPub == null || sa.getStartTime().before(startPub)) {</span>
<span class="nc" id="L1351">				startPub = sa.getStartTime();</span>
			}
<span class="nc bnc" id="L1353" title="All 4 branches missed.">			if (endPub == null || sa.getEndTime().after(endPub)) {</span>
<span class="nc" id="L1354">				endPub = sa.getEndTime();</span>
			}
<span class="nc" id="L1356">		}</span>

<span class="nc bnc" id="L1358" title="All 4 branches missed.">		if (startPub != null &amp;&amp; endPub != null) {</span>
<span class="nc" id="L1359">			timeRangesToPublish.add(new TimeRange(startPub, endPub));</span>
		}

<span class="nc" id="L1362">		return timeRangesToPublish;</span>
	}

	@Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
			throws BbmRemoveException, RmHardValidationException
	{
<span class="nc" id="L1369">		String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L1370">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L1372">		ShiftBidRequestDAO toReqDao = null;</span>
<span class="nc" id="L1373">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1374">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1376">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1378">			String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L1380">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L1382">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
			}

<span class="nc" id="L1385">			toReqDao = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL);</span>
<span class="nc" id="L1386">			toReqDao.deleteRequestsByStartDateRange(organizationId, isForBranch, range);</span>
<span class="nc" id="L1387">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation.  If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1393">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1394">			throw e;</span>
<span class="nc" id="L1395">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1396">			m_cat.error(e, e);</span>
<span class="nc" id="L1397">			handleException(e);</span>
<span class="nc" id="L1398">			throw e;</span>
<span class="nc" id="L1399">		} catch (Exception e) {</span>
<span class="nc" id="L1400">			handleException(e);</span>
<span class="nc" id="L1401">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1403" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1404">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1406" title="All 4 branches missed.">			if (toReqDao != null) {</span>
<span class="nc" id="L1407">				toReqDao.cleanUp();</span>
			}
<span class="nc" id="L1409">			methodFinish();</span>
<span class="nc" id="L1410">		}</span>
<span class="nc" id="L1411">	}</span>

	public Map&lt;ID, ShiftBidPreference&gt; getUnsubmittedSchedulePreference(ID auctionID, ID employeeID) {
<span class="nc" id="L1414">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L1416">			return dao.getUnsubmittedSchedulePreference(auctionID, employeeID);</span>
		} finally {
<span class="nc" id="L1418">			dao.cleanUp();</span>
		}
	}

	public void updateUnsubmittedSchedulePreference(Collection&lt;UnsubmittedShiftBidPreference&gt; preferences) {
<span class="nc" id="L1423">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L1425">			dao.updateUnsubmittedSchedulePreference(preferences);</span>
		} finally {
<span class="nc" id="L1427">			dao.cleanUp();</span>
<span class="nc" id="L1428">		}</span>
<span class="nc" id="L1429">	}</span>

	//The transaction setting for this method is set to &quot;NotSupported&quot; in ejb-jar.xml
	//createRequest which is the main call to create an individual request also has &quot;NotSupported&quot; specified
	//This ensures that each create logic runs in its own transaction and an error on one does not cause the whole process
	//to be rolled back
	public void createRequestsFromUnsubmittedPreferences(ShiftBidAuction auction, ID bidderID, int minimumBidSubmissions,
			boolean enforceUniquePreferences) {
<span class="nc" id="L1437">		MultiSubmitProcessor processor = new MultiSubmitProcessor(auction, bidderID, minimumBidSubmissions, enforceUniquePreferences);</span>
<span class="nc" id="L1438">		processor.process(this);</span>
<span class="nc" id="L1439">	}</span>

	public int getAvailableShiftsForSubmittedBids(ID auctionID, ID bidderID) {
<span class="nc" id="L1442">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L1444">			return dao.getAvailableShiftsForSubmittedBids(auctionID, bidderID);</span>
		} finally {
<span class="nc" id="L1446">			dao.cleanUp();</span>
		}
	}

	/**
	 * &lt;p&gt;
	 * Gets the number of requests by the employee for the specified list of auctions.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * The map's key is the auction ID and the value is the count.
	 * &lt;/p&gt;
	 */
	public Map&lt;ID, Integer&gt; getRequestCountsForEmployeeAuctions(ID employeeID, Collection&lt;ID&gt; auctionIDs)
			throws RmException {
<span class="nc" id="L1460">		ShiftBidRequestDAO dao = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
		try {
<span class="nc" id="L1462">			return dao.getRequestCountsForEmployeeAuctions(employeeID, auctionIDs);</span>
<span class="nc" id="L1463">		} catch (Exception e) {</span>
<span class="nc" id="L1464">			handleException(e);</span>
<span class="nc" id="L1465">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1467">			dao.cleanUp();</span>
		}
	}

	/**
	 * Updates the preferences for the specified requests.
	 */
	public void updatePreferences(Collection&lt;ShiftBidRequest&gt; requests)
			throws RmException, RmHardValidationException {
<span class="nc" id="L1476">		ShiftBidRequestDAO dao = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
		try {
<span class="nc bnc" id="L1478" title="All 2 branches missed.">			if (requests.isEmpty()) {</span>
<span class="nc" id="L1479">				return;</span>
			}
<span class="nc" id="L1481">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>

<span class="nc" id="L1483">			Set&lt;ID&gt; employeeIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">			for (ShiftBidRequest request : requests) {</span>
<span class="nc" id="L1485">				ID employeeID = request.getEmployeeID();</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">				if (!employeeIDs.contains(employeeID)) {</span>
<span class="nc" id="L1487">					ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(employeeID);</span>

					// we aren't changing status so use it for both
<span class="nc" id="L1490">					String status = request.getRequestStatus();</span>
<span class="nc" id="L1491">					checkModifyPrivilege(user, request, status, status, orgID);</span>

<span class="nc" id="L1493">					employeeIDs.add(request.getEmployeeID());</span>
				}
<span class="nc" id="L1495">			}</span>

<span class="nc" id="L1497">			dao.updatePreferences(requests);</span>
<span class="nc" id="L1498">		} catch (RmHardValidationException ex) {</span>
<span class="nc" id="L1499">			handleException(Level.DEBUG, ex);</span>
<span class="nc" id="L1500">			throw ex;</span>
<span class="nc" id="L1501">		} catch (Exception e) {</span>
<span class="nc" id="L1502">			handleException(e);</span>
<span class="nc" id="L1503">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1505">			dao.cleanUp();</span>
<span class="nc" id="L1506">		}</span>
<span class="nc" id="L1507">	}</span>

	@Override
	protected void updateRequestPostProcess(RequestAggregate reqAgg,
			RequestAggregateDAO reqAggDAO, boolean loadedFromDB, String origState) throws Exception {
<span class="nc" id="L1512">		updateUnsubmittedPreference(reqAgg, reqAggDAO);</span>
<span class="nc" id="L1513">	}</span>

	@Override
	protected void createRequestPostProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L1517">		updateUnsubmittedPreference(reqAgg, reqAggDAO);</span>
<span class="nc" id="L1518">	}</span>

	private static void updateUnsubmittedPreference(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) {
<span class="nc bnc" id="L1521" title="All 2 branches missed.">		if (!LicenseUtil.isAdvancedRMLicense()) {</span>
<span class="nc" id="L1522">			return;</span>
		}

<span class="nc" id="L1525">		ShiftBidRequest sbReq = (ShiftBidRequest) reqAgg;</span>
<span class="nc" id="L1526">		Jdmo dmo = reqAggDAO.getDMO();</span>
<span class="nc" id="L1527">		ID requestID = sbReq.getID();</span>

<span class="nc bnc" id="L1529" title="All 2 branches missed.">		if (requestID == null) {</span>
<span class="nc" id="L1530">			return;</span>
		}

<span class="nc bnc" id="L1533" title="All 2 branches missed.">		if (sbReq.isWithdrawn()) {</span>
<span class="nc" id="L1534">			UnsubmittedSchedulePreferenceDao.deleteUnsubmittedPreferences(dmo, requestID);</span>
<span class="nc" id="L1535">			return;</span>
		}

<span class="nc" id="L1538">		UnsubmittedSchedulePreferenceDao.updateUnsubmittedPreferences(dmo, requestID);</span>

<span class="nc" id="L1540">	}</span>


	public RequestAggregate approveAllShiftBidsWithoutViolations(ID reqID) throws Exception {
<span class="nc" id="L1544">		return super.groupApproveAllWithoutViolations(reqID);</span>
	}
	
	@Override
	public boolean isUserAuthorizedToViewPersonalRequests(User user) { 
<span class="nc" id="L1549">		return user.isAuthorized(PrivilegeKeys.SB_VIEWPERSONALBIDS_ID);</span>
    	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>