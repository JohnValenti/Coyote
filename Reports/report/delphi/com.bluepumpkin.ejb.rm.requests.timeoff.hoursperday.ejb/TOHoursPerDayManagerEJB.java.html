<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOHoursPerDayManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb</a> &gt; <span class="el_source">TOHoursPerDayManagerEJB.java</span></div><h1>TOHoursPerDayManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.IDPair;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.holiday.ejb.HolidayManager;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculator;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculatorHelper;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffDefaultFieldInfo;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignmentFieldInfo;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDayFieldInfo;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TimeOffActivitySummary;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.util.DAOUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;


<span class="nc" id="L69">public class TOHoursPerDayManagerEJB extends SessionEJBBase {    </span>
<span class="nc" id="L70">	private static final String CLASSNAME = TOHoursPerDayManagerEJB.class.getName();</span>
<span class="nc" id="L71">	private static final Category LOG = Log.initCategory(TOHoursPerDayManagerEJB.CLASSNAME);</span>
	private static final long ONEDAYINMILLISECS = 24 * 60 * 60 * 1000;
<span class="nc" id="L73">	private static Byte lock = new Byte(&quot;1&quot;);</span>

	private static final int DEFAULT_NOTIFY_MSG_TYPE = TONotifyMessage.TO_NOTIFY_TOREQUEST_UPDATE;
	
	// non-static initializer
	{
<span class="nc" id="L79">		super.init(TOHoursPerDayManagerEJB.class.getName());</span>
	}

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="nc" id="L87">		return LOG;</span>
	}

	public Collection getTOHoursPerDaysByTimeOffRequestIds(Collection toReqCol) throws BbmFinderException {
<span class="nc" id="L91">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc bnc" id="L93" title="All 4 branches missed.">			if (toReqCol == null || toReqCol.isEmpty()) {</span>
<span class="nc" id="L94">				return toReqCol;</span>
			}
<span class="nc" id="L96">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L97">			HashMap toChoiceMap = new HashMap();</span>
<span class="nc" id="L98">			HashMap toChoiceReqIdsMap = new HashMap();</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">			for (Iterator iterator = toReqCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L100">				TORequest tor = (TORequest) iterator.next();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">				for (Iterator iter1 = tor.getRequestChoiceList().iterator(); iter1.hasNext();) {</span>
<span class="nc" id="L102">					TOChoice toChoice = (TOChoice) iter1.next();</span>
<span class="nc" id="L103">					toChoiceMap.put(toChoice.getID(), toChoice);</span>
<span class="nc" id="L104">					toChoiceReqIdsMap.put(toChoice.getID(), tor);</span>
<span class="nc" id="L105">				}</span>
<span class="nc" id="L106">			}</span>
<span class="nc" id="L107">			Collection colTOHrsPerDay = toHoursPerDayDAO.getObjects(toChoiceMap.keySet(), TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFCHOICEID, null);</span>
<span class="nc bnc" id="L108" title="All 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L110">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc" id="L111">					TOChoice toChoice = (TOChoice) toChoiceMap.get(hoursPerDay.getTOChoiceID());</span>
<span class="nc" id="L112">					TORequest tor = (TORequest) toChoiceReqIdsMap.get(toChoice.getID());</span>
<span class="nc" id="L113">					toChoice.setHoursPerDay(hoursPerDay);</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">					if (!hoursPerDay.getIsDirty() &amp;&amp; hoursPerDay.getStatus().equals(tor.getRequestStatus())) {</span>
<span class="nc" id="L115">						toChoiceMap.remove(hoursPerDay.getTOChoiceID());</span>
					}
<span class="nc" id="L117">				}</span>
			}
<span class="nc bnc" id="L119" title="All 4 branches missed.">			if (toChoiceMap != null &amp;&amp; !toChoiceMap.isEmpty()) {</span>
<span class="nc" id="L120">				Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">				for (Iterator iter1 = toChoiceMap.values().iterator(); iter1.hasNext();) {</span>
<span class="nc" id="L122">					TOChoice choice = (TOChoice) iter1.next();</span>
<span class="nc" id="L123">					TORequest tor = (TORequest) toChoiceReqIdsMap.get(choice.getID());</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">					if (tor.getTimeOffDebitType().equals(TORequest.DEBITTYPE_DONT_DEBIT)) {</span>
<span class="nc" id="L125">						choice.setHoursPerDay(new TOHoursPerDay());</span>
<span class="nc" id="L126">						LOG.info(&quot;Ignoring TO Request since it is of TYPE DONT-DEBIT:&quot; + tor);</span>
<span class="nc" id="L127">						continue;</span>
					}
<span class="nc" id="L129">					toHoursPerDayToUpdate.add(TOHoursPerDayUtil.convertTOChoiceToHoursPerDay(tor, choice, tor.getEmployeeID()));</span>
<span class="nc" id="L130">				}</span>
<span class="nc" id="L131">				refreshAndUpdateTOHoursPerDay(toHoursPerDayToUpdate, false);</span>
			}
<span class="nc" id="L133">		} catch (Exception e) {</span>
<span class="nc" id="L134">			handleException(e);</span>
<span class="nc" id="L135">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L137" title="All 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L138">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L141">		return toReqCol;</span>
	}

	public TOHoursPerDay getTOHoursPerDaysForTOEvent(ID empID, TimeOffEvent timeoffEvt) throws BbmFinderException {
<span class="nc" id="L145">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L146">		TOHoursPerDay hoursPerDay = null;</span>
		try {
<span class="nc" id="L148">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L149">			Collection colTOHrsPerDay = toHoursPerDayDAO.getObjects(Collections.singleton(timeoffEvt.getID()), TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFEVENTID, null);</span>
<span class="nc bnc" id="L150" title="All 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L152">					hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">					if (!hoursPerDay.getIsDirty()) {</span>
<span class="nc" id="L154">						return hoursPerDay;</span>
					}
				}
			}
<span class="nc" id="L158">			hoursPerDay = TOHoursPerDayUtil.convertTOEventToHoursPerDay(hoursPerDay, timeoffEvt, empID);</span>
<span class="nc" id="L159">			ArrayList list = new ArrayList();</span>
<span class="nc" id="L160">			list.add(hoursPerDay);</span>
<span class="nc" id="L161">			refreshAndUpdateTOHoursPerDay(list, true);</span>
<span class="nc" id="L162">		} catch (Exception e) {</span>
<span class="nc" id="L163">			handleException(e);</span>
<span class="nc" id="L164">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L166" title="All 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L167">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L170">		return hoursPerDay;</span>
	}

	public void updateHoursPerDay(ScheduleChangeDetails changeDetails) throws BbmUpdateException {
<span class="nc" id="L174">		updateHoursPerDay(changeDetails, DEFAULT_NOTIFY_MSG_TYPE);</span>
<span class="nc" id="L175">	}</span>
	
	//Called on pulish &amp; unpublish
	@SuppressWarnings(&quot;rawtypes&quot;)
	private void updateHoursPerDay(ScheduleChangeDetails changeDetails, int msgType) throws BbmUpdateException {
				
<span class="nc" id="L181">		Iterator itWrk = changeDetails.getWorkResourceIDs().iterator();</span>
<span class="nc" id="L182">		Iterator itOldEvents = changeDetails.getOldEvents().iterator();</span>
<span class="nc" id="L183">		Iterator itNewEvents = changeDetails.getNewEvents().iterator();</span>
<span class="nc" id="L184">		HashSet setIDs = new HashSet();</span>
<span class="nc" id="L185">		HashSet newTOEventIDs = new HashSet();</span>
<span class="nc" id="L186">		Date startDate = changeDetails.getStartDate();</span>
<span class="nc" id="L187">		Date endDate = changeDetails.getEndDate();</span>
<span class="nc" id="L188">		HashSet toEventEmpPairsToDel = new HashSet();</span>
<span class="nc" id="L189">		HashMap newOrUpdatedTOEventsMap = new HashMap();</span>
<span class="nc bnc" id="L190" title="All 6 branches missed.">		while (itWrk.hasNext() &amp;&amp; itOldEvents.hasNext() &amp;&amp; itNewEvents.hasNext()) {</span>
<span class="nc" id="L191">			ID workResourceID = (ID) itWrk.next();</span>
<span class="nc" id="L192">			setIDs.add(workResourceID);</span>
<span class="nc" id="L193">			Collection listOldEvents = (Collection) itOldEvents.next();</span>
<span class="nc" id="L194">			Collection listNewEvents = (Collection) itNewEvents.next();</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">			if (listOldEvents != null) {</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">				for (Iterator iterator = listOldEvents.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L197">					Event event = (Event) iterator.next();</span>
<span class="nc bnc" id="L198" title="All 2 branches missed."> 					if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L199">						toEventEmpPairsToDel.add(new IDPair(event.getID(), workResourceID));</span>
					}
<span class="nc" id="L201">				}</span>
			}
<span class="nc bnc" id="L203" title="All 2 branches missed.">			if (listNewEvents != null) {</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">				for (Iterator iterator = listNewEvents.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L205">					Event event = (Event) iterator.next();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">					if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L207">						IDPair empTOEventPair = new IDPair(event.getID(), workResourceID);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">						if (!toEventEmpPairsToDel.remove(empTOEventPair)) {</span>
							// If the empTOEventPair does not exist in  toEventEmpPairsToDel set then its a new event
<span class="nc" id="L210">							newTOEventIDs.add(empTOEventPair.getFirst());</span>
						}
<span class="nc" id="L212">						newOrUpdatedTOEventsMap.put(empTOEventPair, TOHoursPerDayUtil.convertTOEventToHoursPerDay(null, (TimeOffEvent) event, workResourceID));</span>
					}
<span class="nc" id="L214">				}</span>
			}
<span class="nc" id="L216">		}</span>
<span class="nc" id="L217">		updateTOEventsForEmployees(msgType, changeDetails.isPublish(), changeDetails.getWorkResourceIDs(), startDate, endDate, toEventEmpPairsToDel, newOrUpdatedTOEventsMap, newTOEventIDs);</span>
<span class="nc" id="L218">	}</span>


	public void updateTOEventsForEmployees(boolean isPublish, Collection empIDs, Date startDate, Date endDate, Collection toEventEmpPairsToDel, HashMap newTOEvents, HashSet newTOEventIDs) throws BbmUpdateException {
<span class="nc" id="L222">		 updateTOEventsForEmployees(DEFAULT_NOTIFY_MSG_TYPE, isPublish, empIDs, startDate, endDate, toEventEmpPairsToDel, newTOEvents, newTOEventIDs);</span>
<span class="nc" id="L223">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private void updateTOEventsForEmployees(int msgType, boolean isPublish, Collection&lt;ID&gt; empIDs, Date startDate, Date endDate, Collection toEventEmpPairsToDel, HashMap newTOEvents, HashSet newTOEventIDs) throws BbmUpdateException {
<span class="nc" id="L227">		TOHoursPerDayDAO dao = null;</span>
<span class="nc" id="L228">		boolean isLastPubDateChanged = false;</span>
		try {
<span class="nc" id="L230">			dao = new TOHoursPerDayDAO();</span>
			//isLastPubDateChanged checks shifts against EMPLOYEELASTPUBDATE, which records (seemingly)
			//the last shift published for the employee by date
<span class="nc" id="L233">			isLastPubDateChanged = dao.isLastPublishedDateChanged(empIDs);</span>
			// this call returns true if the published / unpublished schedule causes changes in last published date of the workresource
<span class="nc bnc" id="L235" title="All 4 branches missed.">			if (newTOEventIDs == null || newTOEventIDs.isEmpty()) {</span>
<span class="nc" id="L236">				LOG.info(&quot;New TOEventIDs Collection is null or empty&quot;);</span>
			}
<span class="nc bnc" id="L238" title="All 6 branches missed.">			if (newTOEventIDs != null &amp;&amp; !newTOEventIDs.isEmpty() &amp;&amp; !dao.checkIfNewTOEventsAreCommited(newTOEventIDs)) {</span>
<span class="nc" id="L239">				LOG.info(&quot;Received Notification for New TOEvents but following IDs do not exist in Database:&quot; + newTOEventIDs + &quot;; Most probably the transaction has been rolled back&quot;);</span>
<span class="nc" id="L240">				return;</span>
			}
<span class="nc" id="L242">			List&lt;TOHoursPerDay&gt; hrsPerColToUpdate = new ArrayList&lt;TOHoursPerDay&gt;();</span>
			
<span class="nc bnc" id="L244" title="All 2 branches missed.">			if (!isPublish) { </span>
				//update last published date to current last published date before updating to hoursperday
<span class="nc bnc" id="L246" title="All 2 branches missed.">				if (isLastPubDateChanged) {    </span>
					 //only refresh the date if last published date has changed.
<span class="nc" id="L248">					dao.refreshLastPublishedDate(empIDs);</span>
				}
			} else {
<span class="nc bnc" id="L251" title="All 2 branches missed.">				if (isLastPubDateChanged) {</span>
					//lock the employees whose last pub date has changed
					//to prevent issues related to simultaneous publish of same employee
					//from several DE clients.
<span class="nc" id="L255">					lockEmployees(empIDs);</span>
				}
			}
			
			// always check for deleted TOEvents. We do not always receive deleted events in published schedule
			// deleted events are never received in unpublished schedule
<span class="nc" id="L261">			dao.deleteTOHoursPerDayOnUnPublish(empIDs, startDate, endDate);</span>
<span class="nc bnc" id="L262" title="All 4 branches missed.">			if (toEventEmpPairsToDel != null &amp;&amp; !toEventEmpPairsToDel.isEmpty()) {</span>
<span class="nc" id="L263">				deleteTOHoursPerDayForTOEventEmpPairs(toEventEmpPairsToDel);</span>
			}
<span class="nc bnc" id="L265" title="All 2 branches missed.">			if (isLastPubDateChanged) {</span>
				//if last published shift date changed, get updates from end date + 7 days
				//Why? 
				//this call is required on publish and unpublish schedule only where the last pub date has changed.
				// Not required on the TO Request approval / withdrawal.
<span class="nc" id="L270">				hrsPerColToUpdate.addAll(dao.getHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(empIDs, null, TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null))); // NOSONAR</span>
			} else {
				//if last published shift date changed, get updates after last pub date. Why?
				//if TO approval or withdrawal then get all valid Requests that have &quot;USE MY TO HOURS&quot;
				// intersecting +- 7 days of the date range only if end date falls after the last pub date
<span class="nc" id="L275">				hrsPerColToUpdate.addAll(dao.getValidHoursPerDayForDateRangeOnlyAfterLastPubDate(empIDs, null,</span>
<span class="nc" id="L276">				        new TimeRange(TOHoursPerDayUtil.getDateForDaysBefore(startDate, 7, null),</span>
<span class="nc" id="L277">				                TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null))));</span>
			}
			
			//Need to update Valid requests &amp; TO Events intersecting the date range
<span class="nc" id="L281">			hrsPerColToUpdate.addAll(dao.getValidHoursPerDayForEmpIds((empIDs), null, new TimeRange(startDate, endDate)));</span>
			
			// REFERENCE SCHEDULES
			// Get the requests that are generated using reference schedules (assuming this period may be referenced)
			// The dates may be wildly different from this period
<span class="nc" id="L286">			Collection&lt;TOHoursPerDay&gt; listReferenceScheduleHoursPerDay = getHoursPerDayGeneratedByReferenceSchedule(empIDs, startDate, endDate);</span>
<span class="nc" id="L287">			hrsPerColToUpdate.addAll(listReferenceScheduleHoursPerDay);</span>
			
			
<span class="nc bnc" id="L290" title="All 4 branches missed.">			if (newTOEvents != null &amp;&amp; !newTOEvents.isEmpty()) { </span>
				// identify the TOevents  to be updated
<span class="nc bnc" id="L292" title="All 4 branches missed.">				if (hrsPerColToUpdate != null &amp;&amp; !hrsPerColToUpdate.isEmpty()) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">					for (Iterator iterator = hrsPerColToUpdate.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L294">						TOHoursPerDay hrsPerDayOld = (TOHoursPerDay) iterator.next();</span>
<span class="nc" id="L295">						IDPair empTOEventPair = new IDPair(hrsPerDayOld.getID(), hrsPerDayOld.getEmployeeID());</span>
<span class="nc bnc" id="L296" title="All 4 branches missed.">						if (hrsPerDayOld.getTOEventID() != null &amp;&amp; newTOEvents.containsKey(empTOEventPair)) {</span>
<span class="nc" id="L297">							TOHoursPerDay toHoursPerDayNew = (TOHoursPerDay) newTOEvents.get(empTOEventPair);</span>
<span class="nc" id="L298">							iterator.remove();</span>
<span class="nc" id="L299">							toHoursPerDayNew.setID(hrsPerDayOld.getID());</span>
						}
<span class="nc" id="L301">					}</span>
				}
<span class="nc" id="L303">				hrsPerColToUpdate.addAll(newTOEvents.values());//add the  events</span>
			}

<span class="nc bnc" id="L306" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L307">				LOG.info(&quot;TOTAL TIME in PUBLISH SCHEDULE:&quot;</span>
<span class="nc" id="L308">						+ RmUtil.dumpCollection(empIDs, &quot;,&quot;)</span>
<span class="nc" id="L309">						+ &quot; updated objects=&quot; + hrsPerColToUpdate.size());</span>
			}
			
<span class="nc bnc" id="L312" title="All 4 branches missed.">			if (hrsPerColToUpdate != null &amp;&amp; !hrsPerColToUpdate.isEmpty()) {</span>
<span class="nc" id="L313">				refreshAndUpdateTOHoursPerDay(msgType, hrsPerColToUpdate, true,</span>
						true);
			}
			
<span class="nc bnc" id="L317" title="All 4 branches missed.">			if (isLastPubDateChanged &amp;&amp; isPublish) {//update last published date to current last published date after updating to hoursperday</span>
<span class="nc" id="L318">				dao.refreshLastPublishedDate(empIDs);</span>
			}
<span class="nc" id="L320">		} catch (Exception e) {</span>
<span class="nc" id="L321">			handleException(e);</span>
<span class="nc" id="L322">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L324" title="All 6 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L325">				dao.cleanUp();</span>
			}
		}
<span class="nc" id="L328">	}</span>

	/*
	 * getHoursPerDayGeneratedByReferenceSchedule
	 * Some requests are generated from reference schedules.
	 * The dates of the reference schedule will likely not coincide with the request date.
	 * When the reference schedule is published/unpublished, we need to update those
	 * requests. Return here a list of their Hours Per Day. 
	 */
	
	private Collection&lt;TOHoursPerDay&gt; getHoursPerDayGeneratedByReferenceSchedule(
			Collection&lt;ID&gt; empIDs, Date startDate, Date endDate) throws BbmFinderException {
			
<span class="nc" id="L341">			TOHoursPerDayDAO dao = null;</span>
			
			try {
<span class="nc" id="L344">				dao = new TOHoursPerDayDAO();</span>
<span class="nc" id="L345">				 return dao.getHoursPerDayGeneratedByReferenceSchedule(empIDs,startDate, endDate);</span>
<span class="nc" id="L346">			}catch(Exception e){</span>
<span class="nc" id="L347">				throw new BbmFinderException(e);</span>
			}finally{
<span class="nc bnc" id="L349" title="All 4 branches missed.">				if (dao != null) {</span>
<span class="nc" id="L350">					dao.cleanUp();</span>
				}
			}
			
	}
	
	private Collection&lt;TOHoursPerDay&gt; getHoursPerDayFromTOChoiceList(Collection&lt;ID&gt; toChoiceList) throws BbmFinderException {
			
<span class="nc" id="L358">			TOHoursPerDayDAO dao = null;</span>
			
			try {
<span class="nc" id="L361">				dao = new TOHoursPerDayDAO();</span>
<span class="nc" id="L362">				 return dao.getHoursPerDayFromTOChoiceList(toChoiceList);</span>
<span class="nc" id="L363">			}catch(Exception e){</span>
<span class="nc" id="L364">				throw new BbmFinderException(e);</span>
			}finally{
<span class="nc bnc" id="L366" title="All 4 branches missed.">				if (dao != null) {</span>
<span class="nc" id="L367">					dao.cleanUp();</span>
				}
			}
			
	}
	
	
	
	

	public void updateTOHoursPerDayForTORequest(TORequest tor, boolean refreshOrigMinutes) throws BbmUpdateException {
<span class="nc" id="L378">		updateTOHoursPerDayForTORequest(DEFAULT_NOTIFY_MSG_TYPE, tor, refreshOrigMinutes);</span>
<span class="nc" id="L379">	}</span>
	
	private void updateTOHoursPerDayForTORequest(int msgType, TORequest tor, boolean refreshOrigMinutes) throws BbmUpdateException {
<span class="nc" id="L382">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L383">		TOHoursPerDay hoursPerDay = null;</span>
		try {
<span class="nc" id="L385">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L386">			Collection toHoursPerDayToRefresh = new ArrayList();</span>
<span class="nc" id="L387">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">			if (tor.getTimeOffDebitType().equals(TORequest.DEBITTYPE_DONT_DEBIT)) {</span>
<span class="nc" id="L389">				LOG.info(&quot;Ignoring TO Request since it is of TYPE DONT-DEBIT:&quot; + tor);</span>
<span class="nc" id="L390">				return;</span>
			}
<span class="nc" id="L392">			HashMap toChoiceMap = ValueObjectUtil.getIDObjectMap(tor.getRequestChoiceList());</span>
<span class="nc" id="L393">			Collection colTOHrsPerDay = toHoursPerDayDAO.getObjects(toChoiceMap.keySet(), TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFCHOICEID, null);</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L396">					hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc" id="L397">					TOChoice choice = (TOChoice) toChoiceMap.remove(hoursPerDay.getTOChoiceID());</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">					if (TOHoursPerDayUtil.isTOHoursPerDayDifferentFromTOChoice(tor, choice, hoursPerDay)) {</span>
<span class="nc" id="L399">						choice.setHoursPerDay(hoursPerDay);</span>
<span class="nc" id="L400">						hoursPerDay = TOHoursPerDayUtil.convertTOChoiceToHoursPerDay(tor, choice, tor.getEmployeeID());</span>
<span class="nc" id="L401">						hoursPerDay.setRefreshOrignalMinutes(refreshOrigMinutes);</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">						if (TOHoursPerDayUtil.isTOHoursPerDayRefreshRequired(tor, choice, hoursPerDay)) {</span>
<span class="nc" id="L403">							toHoursPerDayToRefresh.add(hoursPerDay);</span>
						} else {
<span class="nc" id="L405">							hoursPerDay.setIsDirty(false);</span>
<span class="nc" id="L406">							toHoursPerDayToUpdate.add(hoursPerDay);</span>
						}
					}
<span class="nc" id="L409">				}</span>
			}
<span class="nc bnc" id="L411" title="All 4 branches missed.">			if (toChoiceMap != null &amp;&amp; !toChoiceMap.isEmpty()) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">				for (Iterator iterator = toChoiceMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L413">					TOChoice toChoice = (TOChoice) iterator.next();</span>
<span class="nc" id="L414">					hoursPerDay = TOHoursPerDayUtil.convertTOChoiceToHoursPerDay(tor, toChoice, tor.getEmployeeID());</span>
<span class="nc" id="L415">					hoursPerDay.setRefreshOrignalMinutes(refreshOrigMinutes);</span>
<span class="nc" id="L416">					toHoursPerDayToRefresh.add(hoursPerDay);</span>
<span class="nc" id="L417">				}</span>
			}
<span class="nc bnc" id="L419" title="All 4 branches missed.">			if (toHoursPerDayToRefresh != null &amp;&amp; !toHoursPerDayToRefresh.isEmpty()) {</span>
<span class="nc" id="L420">				refreshAndUpdateTOHoursPerDay(msgType, toHoursPerDayToRefresh, false, false);</span>
			}
<span class="nc bnc" id="L422" title="All 4 branches missed.">			if (toHoursPerDayToUpdate != null &amp;&amp; !toHoursPerDayToUpdate.isEmpty()) {</span>
<span class="nc" id="L423">				updateObjects(toHoursPerDayToUpdate);</span>
			}
<span class="nc" id="L425">		} catch (Exception e) {</span>
<span class="nc" id="L426">			handleException(e);</span>
<span class="nc" id="L427">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L429" title="All 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L430">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L433">	}</span>

	public float calculateTotalLength(ID empID, Date startDate, Date endDate, ID activityID) throws BbmFinderException {
<span class="nc" id="L436">		float totalHrs = 0f;</span>
<span class="nc" id="L437">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L438">		TOHoursPerDay hoursPerDay = null;</span>
		try {
<span class="nc" id="L440">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L441">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc" id="L442">			Collection colTOHrsPerDay = toHoursPerDayDAO.getHoursPerDayForTOevents(Collections.singleton(empID), Collections.singleton(activityID), new TimeRange(startDate, endDate));</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L445">					hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">					if (!hoursPerDay.getIsDirty()) {</span>
<span class="nc" id="L447">						boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(startDate);</span>
<span class="nc" id="L448">						boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(endDate);</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">						if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">							DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">							        isToEvtStartBeforeStart ? startDate : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L452">							        isToEvtEndAfterEnd ? endDate : hoursPerDay.getEndTime());</span>
<span class="nc" id="L453">							totalHrs += dailyBuckets.getTotalHours();</span>
<span class="nc" id="L454">						} else {</span>
<span class="nc" id="L455">							totalHrs += (hoursPerDay.getTotalMinutes() / 60f);</span>
						}
<span class="nc" id="L457">					} else {</span>
<span class="nc" id="L458">						toHoursPerDayToUpdate.add(hoursPerDay);</span>
					}
				}
			}
<span class="nc bnc" id="L462" title="All 4 branches missed.">			if (toHoursPerDayToUpdate != null &amp;&amp; !toHoursPerDayToUpdate.isEmpty()) {</span>
<span class="nc" id="L463">				refreshAndUpdateTOHoursPerDay(toHoursPerDayToUpdate, true);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">				for (Iterator it = toHoursPerDayToUpdate.iterator(); it.hasNext();) {</span>
<span class="nc" id="L465">					hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc" id="L466">					boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(startDate);</span>
<span class="nc" id="L467">					boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(endDate);</span>
<span class="nc bnc" id="L468" title="All 4 branches missed.">					if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">						DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">						        isToEvtStartBeforeStart ? startDate : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L471">						        isToEvtEndAfterEnd ? endDate : hoursPerDay.getEndTime());</span>
<span class="nc" id="L472">						totalHrs += dailyBuckets.getTotalHours();</span>
<span class="nc" id="L473">					} else {</span>
<span class="nc" id="L474">						totalHrs += (hoursPerDay.getTotalMinutes() / 60f);</span>
					}
<span class="nc" id="L476">					totalHrs += (hoursPerDay.getTotalMinutes() / 60f);</span>
<span class="nc" id="L477">				}</span>
			}
<span class="nc" id="L479">		} catch (Exception e) {</span>
<span class="nc" id="L480">			handleException(e);</span>
<span class="nc" id="L481">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L483" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L484">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L487">		return totalHrs;</span>
	}

	public Collection getHoursPerDayForCalendar(Collection empIDs, Date startDate, Date endDate, Collection activityIDs, boolean schedOrPending) throws BbmFinderException {
<span class="nc" id="L491">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L493">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L494">			Map&lt;Boolean, List&lt;TOHoursPerDay&gt;&gt; hrsPerDaySchedMap = toHoursPerDayDAO.getHoursPerDayForCalendar(empIDs, activityIDs,</span>
					new TimeRange(startDate, endDate), schedOrPending);

<span class="nc" id="L497">			return updateDirtyHoursIfNeeded(hrsPerDaySchedMap);</span>

<span class="nc" id="L499">		} catch (Exception e) {</span>
<span class="nc" id="L500">			handleException(e);</span>
<span class="nc" id="L501">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L503" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L504">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
	}

	public Collection[] getHoursPerDayForCalendar(Collection empIDsSched, Collection empIDsPending, Date startDate, Date endDate, Collection activityIDs) throws BbmFinderException {
<span class="nc" id="L510">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L511">		Collection&lt;TOHoursPerDay&gt; hrsPerDaySchedCol = new ArrayList&lt;TOHoursPerDay&gt;();</span>
<span class="nc" id="L512">		Collection&lt;TOHoursPerDay&gt; hrsPerDayPendingCol = new ArrayList&lt;TOHoursPerDay&gt;();</span>
<span class="nc" id="L513">		long currentime = new Date().getTime();</span>
		try {
<span class="nc" id="L515">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L516">			Map&lt;Boolean, List&lt;TOHoursPerDay&gt;&gt; hrsPerDaySchedMap = toHoursPerDayDAO.getHoursPerDayForCalendar(empIDsSched, activityIDs,</span>
					new TimeRange(startDate, endDate), true);

<span class="nc" id="L519">			hrsPerDaySchedCol = hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">			if (hrsPerDaySchedCol == null) {</span>
<span class="nc" id="L521">				hrsPerDaySchedCol = new ArrayList&lt;TOHoursPerDay&gt;();</span>
			}
<span class="nc" id="L523">			Collection&lt;TOHoursPerDay&gt; hrsPerDaySchedToUpdate = hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>

<span class="nc" id="L525">			Map&lt;Boolean, List&lt;TOHoursPerDay&gt;&gt; hrsPerDayPendingMap = toHoursPerDayDAO.getHoursPerDayForCalendar(empIDsPending, activityIDs,</span>
					new TimeRange(startDate, endDate), false);
<span class="nc bnc" id="L527" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L528">				LOG.info(&quot;$$$$TOTAL TIME for FETCH ALL DATA FOR CALC=&quot; + (new Date().getTime() - currentime));</span>
			}
<span class="nc" id="L530">			hrsPerDayPendingCol = hrsPerDayPendingMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">			if (hrsPerDayPendingCol == null) {</span>
<span class="nc" id="L532">				hrsPerDayPendingCol = new ArrayList&lt;TOHoursPerDay&gt;();</span>
			}
<span class="nc" id="L534">			Collection&lt;TOHoursPerDay&gt; hrsPerDayPendingToUpdate = hrsPerDayPendingMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>
<span class="nc" id="L535">			Collection&lt;TOHoursPerDay&gt; hrsPerDayCol = new ArrayList&lt;TOHoursPerDay&gt;();</span>
<span class="nc bnc" id="L536" title="All 4 branches missed.">			if (hrsPerDaySchedToUpdate != null &amp;&amp; !hrsPerDaySchedToUpdate.isEmpty()) {</span>
<span class="nc" id="L537">				hrsPerDayCol.addAll(hrsPerDaySchedToUpdate);</span>
<span class="nc" id="L538">				hrsPerDaySchedCol.addAll(hrsPerDaySchedToUpdate);</span>
			}
<span class="nc bnc" id="L540" title="All 4 branches missed.">			if (hrsPerDayPendingToUpdate != null &amp;&amp; !hrsPerDayPendingToUpdate.isEmpty()) {</span>
<span class="nc" id="L541">				hrsPerDayPendingCol.addAll(hrsPerDayPendingToUpdate);</span>
<span class="nc" id="L542">				hrsPerDayCol.addAll(hrsPerDayPendingToUpdate);</span>
			}
<span class="nc bnc" id="L544" title="All 4 branches missed.">			if (hrsPerDayCol != null &amp;&amp; !hrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L545">				refreshAndUpdateTOHoursPerDay(hrsPerDayCol, true);</span>
			}

<span class="nc" id="L548">		} catch (Exception e) {</span>
<span class="nc" id="L549">			handleException(e);</span>
<span class="nc" id="L550">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L552" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L553">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc bnc" id="L556" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L557">			LOG.info(&quot;TOTAL TIME for entire CALC LOAD=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj sched=&quot; + hrsPerDaySchedCol.size() + &quot;:pend=&quot; + hrsPerDayPendingCol.size());</span>
		}
<span class="nc" id="L559">		Collection[] hrsPerDayCol = new Collection[2];</span>
<span class="nc" id="L560">		hrsPerDayCol[TOCalendarUtil.BKT_PENDING] = hrsPerDayPendingCol;</span>
<span class="nc" id="L561">		hrsPerDayCol[TOCalendarUtil.BKT_SCHED] = hrsPerDaySchedCol;</span>
<span class="nc" id="L562">		return hrsPerDayCol;</span>
	}

	public Collection refreshAndUpdateTOHoursPerDay(Collection toHoursPerDayCol, boolean verifyTOChoiceStatus) throws BbmFinderException {
<span class="nc" id="L566">		return refreshAndUpdateTOHoursPerDay(DEFAULT_NOTIFY_MSG_TYPE, toHoursPerDayCol, verifyTOChoiceStatus, false);</span>
	}

	public Collection refreshAndUpdateTOHoursPerDay(int msgType, Collection toHoursPerDayCol, boolean verifyTOChoiceStatus, boolean doNotRefreshLongReq) throws BbmFinderException {
<span class="nc" id="L570">		long currentime = new Date().getTime();</span>
<span class="nc" id="L571">		TOHoursPerDay hoursPerDay = null;</span>
<span class="nc" id="L572">		Collection toHoursPerDayToInsert = new ArrayList();</span>
<span class="nc" id="L573">		Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc" id="L574">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L576">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc bnc" id="L577" title="All 4 branches missed.">			if (toHoursPerDayCol != null &amp;&amp; !toHoursPerDayCol.isEmpty()) {</span>
<span class="nc" id="L578">				Date startDate = null;</span>
<span class="nc" id="L579">				Date endDate = null;</span>
<span class="nc" id="L580">				HashMap empHrsPerDayMap = new HashMap();</span>
<span class="nc" id="L581">				Set activtyIds = new HashSet(toHoursPerDayCol.size());</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">				for (Iterator it = toHoursPerDayCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L583">					hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L584" title="All 4 branches missed.">					if (doNotRefreshLongReq &amp;&amp; isGreaterThanMaxAllowedLength(hoursPerDay)) { //Do not adjust start &amp; end Date based on extraordinarily long requests</span>
<span class="nc" id="L585">						hoursPerDay.setIsDirty(true);</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">						if (hoursPerDay.getID() == null) {</span>
<span class="nc" id="L587">							toHoursPerDayToInsert.add(hoursPerDay);</span>
						} else {
<span class="nc" id="L589">							toHoursPerDayToUpdate.add(hoursPerDay);</span>
						}
<span class="nc" id="L591">						LOG.info(&quot;Skipping This TOHoursPerday Since it Exceeds Max Size;&quot; + hoursPerDay);</span>
					} else {
<span class="nc bnc" id="L593" title="All 4 branches missed.">						startDate = (startDate == null || startDate.after(hoursPerDay.getStartTime()) ? hoursPerDay.getStartTime() : startDate);</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">						endDate = (endDate == null || endDate.before(hoursPerDay.getEndTime()) ? hoursPerDay.getEndTime() : endDate);</span>

<span class="nc" id="L596">						EmpHrsPerDayCol empHrsPerDayCol = (EmpHrsPerDayCol) empHrsPerDayMap.get(hoursPerDay.getEmployeeID());</span>
<span class="nc" id="L597">						activtyIds.add(hoursPerDay.getActivityID());</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">						if (empHrsPerDayCol == null) {</span>
<span class="nc" id="L599">							empHrsPerDayCol = new EmpHrsPerDayCol();</span>
<span class="nc" id="L600">							empHrsPerDayMap.put(hoursPerDay.getEmployeeID(), empHrsPerDayCol);</span>
						}
<span class="nc" id="L602">						empHrsPerDayCol.add(hoursPerDay);</span>
<span class="nc" id="L603">					}</span>
				}
<span class="nc bnc" id="L605" title="All 4 branches missed.">				if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="nc" id="L606">					Map bulkDataMap = getTOCalcDataForEmpIDs(empHrsPerDayMap.keySet(), startDate, endDate);</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">					for (Iterator iterator = empHrsPerDayMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L608">						EmpHrsPerDayCol empHrsPerDayCol = (EmpHrsPerDayCol) iterator.next();</span>
<span class="nc" id="L609">						refreshHoursPerDayForEmployee(msgType, empHrsPerDayCol, bulkDataMap, toHoursPerDayToInsert, toHoursPerDayToUpdate, doNotRefreshLongReq);</span>
<span class="nc" id="L610">					}</span>
				}
<span class="nc bnc" id="L612" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L613">					LOG.info(&quot;\t$$$$TOTAL TIME FOR CALC REFRESH=&quot; + (new Date().getTime() - currentime) + &quot; :: TOTAL objs updated=&quot; + toHoursPerDayCol.size());</span>
				}
<span class="nc" id="L615">				toHoursPerDayCol.clear();</span>
<span class="nc" id="L616">				toHoursPerDayCol.addAll(toHoursPerDayToInsert);</span>
<span class="nc" id="L617">				toHoursPerDayCol.addAll(toHoursPerDayToUpdate);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">				if (verifyTOChoiceStatus) {</span>
<span class="nc" id="L619">					toHoursPerDayDAO.refreshStatusForTOChoices(toHoursPerDayCol);</span>
				}
<span class="nc" id="L621">				createObjects(toHoursPerDayToInsert);</span>
<span class="nc" id="L622">				updateObjects(toHoursPerDayToUpdate);</span>
			}
<span class="nc" id="L624">		} catch (Exception e) {</span>
<span class="nc" id="L625">			handleException(e);</span>
<span class="nc" id="L626">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L628" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L629">				toHoursPerDayDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L631" title="All 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L632">				LOG.info(&quot;TOTAL TIME for DB REFRESH=&quot; + (new Date().getTime() - currentime) + &quot;:TOTAL records affected=&quot; + toHoursPerDayCol.size());</span>
			}
		}
<span class="nc" id="L635">		return toHoursPerDayCol;</span>
	}

	public void deleteTOHoursPerDayForTOEventEmpPairs(Collection toEventEmpPairs) throws BbmUpdateException {
<span class="nc" id="L639">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L641">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L642">			toHoursPerDayDAO.deleteTOHoursPerDayForTOEventEmpPairs(toEventEmpPairs);</span>
<span class="nc" id="L643">		} catch (Exception e) {</span>
<span class="nc" id="L644">			handleException(e);</span>
<span class="nc" id="L645">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L647" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L648">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L651">	}</span>


	public void createObjects(Collection toHoursPerDayToInsert) throws BbmFinderException {
<span class="nc" id="L655">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L657">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L659">				LOG.info(&quot;start of createObjects=[&quot; + RmUtil.dumpCollection(toHoursPerDayToInsert, &quot;\n&quot;) + &quot;]&quot;);</span>
			}
<span class="nc" id="L661">			toHoursPerDayDAO.createObjects(toHoursPerDayToInsert);</span>
<span class="nc" id="L662">		} catch (Exception e) {</span>
<span class="nc" id="L663">			LOG.info(&quot;Caught Exception in createObjects (Collection) now trying insertOrUpdate:&quot;+ e.getMessage());</span>
			try {
<span class="nc bnc" id="L665" title="All 2 branches missed.">				if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L666">					toHoursPerDayDAO.cleanUp();</span>
				}
<span class="nc" id="L668">				toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L669">				Set toEventSet = TOHoursPerDayUtil.extractFieldSet(TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFEVENTID, toHoursPerDayToInsert);</span>
<span class="nc bnc" id="L670" title="All 6 branches missed.">				if (toEventSet != null &amp;&amp; !toEventSet.isEmpty() &amp;&amp; !toHoursPerDayDAO.checkIfNewTOEventsAreCommited(toEventSet)) {</span>
<span class="nc" id="L671">					LOG.info(&quot;one of the following TOEvents IDs do not exist in Database:&quot; + TOCalcUtil.dumpCollection(toEventSet, &quot;,&quot;) + &quot;; Most probably the transaction has been rolled back&quot;);</span>
<span class="nc" id="L672">					return;</span>
				}
<span class="nc" id="L674">			} catch (Exception ep) {</span>
<span class="nc" id="L675">				LOG.info(&quot; Caught Exception in checkIfNewTOEventsAreCommited() still continuing&quot;, ep);</span>
<span class="nc" id="L676">			}</span>
			try {
<span class="nc" id="L678">				toHoursPerDayDAO.insertOrUpdateObjects(toHoursPerDayToInsert);</span>
<span class="nc" id="L679">			} catch (Exception ed) {</span>
<span class="nc" id="L680">				LOG.error(&quot; Caught Exception in insertOrUpdateObjects() now trying one object a time&quot;, ed);</span>
<span class="nc" id="L681">				int exceptionCou = 0;</span>
<span class="nc" id="L682">				TOHoursPerDay hoursPerDay = null;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">				for (Iterator iterator = toHoursPerDayToInsert.iterator(); iterator.hasNext();) {</span>
					try {
<span class="nc" id="L685">						hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc" id="L686">						toHoursPerDayDAO.createObject(hoursPerDay);</span>
<span class="nc" id="L687">					} catch (Exception ex) {</span>
<span class="nc" id="L688">						exceptionCou++;</span>
<span class="nc" id="L689">						handleException(&quot;Caught Exception in createObject one at a time ) hoursPerDay= &quot; + hoursPerDay, ex);</span>
<span class="nc" id="L690">						String str = hoursPerDay.toString() + dumpDuplicateEvents(hoursPerDay);</span>
<span class="nc" id="L691">						traceDebugData(&quot;CREATEOBJECT:&quot;, str, ex, 0);</span>
<span class="nc" id="L692">					}</span>
				}
<span class="nc" id="L694">				LOG.info(&quot;Number of exceptions in createObjects one at a time=&quot; + exceptionCou + &quot; : Total HrsPerDay Count=&quot; + toHoursPerDayToInsert.size());</span>
<span class="nc bnc" id="L695" title="All 4 branches missed.">				if (exceptionCou &gt; 1 &amp;&amp; exceptionCou == toHoursPerDayToInsert.size()) {</span>
<span class="nc" id="L696">					throw new BbmFinderException(e);</span>
				}
<span class="nc" id="L698">			}</span>
		} finally {
<span class="nc bnc" id="L700" title="All 8 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L701">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L704">	}</span>

	private String dumpDuplicateEvents(TOHoursPerDay hoursPerDay) {
<span class="nc" id="L707">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L708">		StringBuffer sb = new StringBuffer(1000);</span>
		try {
<span class="nc" id="L710">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L711">			StringBuffer buf = new StringBuffer(256);</span>
<span class="nc" id="L712">			buf.append(&quot;SELECT EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME , MIN(CALENDAREVENTASSIGNMENTID)IDMIN,MAX(CALENDAREVENTASSIGNMENTID ) IDMAX ,COUNT(*) COUNT, 'U*P' PUB ,getdate() ATWHEN &quot;);</span>
<span class="nc" id="L713">			buf.append(&quot;FROM CALENDAREVENTATTENDEE A,CALENDAREVENTASSIGNMENT P  &quot;);</span>
<span class="nc" id="L714">			buf.append(&quot;WHERE P.ID= A.CALENDAREVENTASSIGNMENTID  and EVENTTYPE=512      &quot;);</span>
<span class="nc" id="L715">			buf.append(&quot;GROUP BY EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME  &quot;);</span>
<span class="nc" id="L716">			buf.append(&quot;HAVING COUNT(1)&gt;1 &quot;);</span>
<span class="nc" id="L717">			JdmoRowset rs = toHoursPerDayDAO.getDMO().createRowset(buf.toString());</span>
<span class="nc" id="L718">			sb.append(&quot;\n DUPEVENT UNPUB :&quot;);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L720">				sb.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">				for (int ix = 1; ix &lt;= rs.getMetaData().getColumnCount(); ix++) {</span>
<span class="nc" id="L722">					sb.append(&quot;\t&quot;).append(rs.getMetaData().getColumnName(ix)).append(&quot;=&quot;).append(rs.getObject(ix));</span>
				}
			}
<span class="nc bnc" id="L725" title="All 2 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L726">				toHoursPerDayDAO.cleanUp();</span>
			}
<span class="nc" id="L728">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L729">			buf = new StringBuffer(256);</span>
<span class="nc" id="L730">			buf.append(&quot;SELECT EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME , MIN(CALENDAREVENTASSIGNMENTID)IDMIN,MAX(CALENDAREVENTASSIGNMENTID ) IDMAX ,COUNT(*) COUNT, 'P*B' PUB ,getdate() ATWHEN &quot;);</span>
<span class="nc" id="L731">			buf.append(&quot;FROM CALENDAREVENTATTENDEEPUB A,CALENDAREVENTASSIGNMENTPUB P  &quot;);</span>
<span class="nc" id="L732">			buf.append(&quot;WHERE P.ID= A.CALENDAREVENTASSIGNMENTID and EVENTTYPE=512       &quot;);</span>
<span class="nc" id="L733">			buf.append(&quot;GROUP BY EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME  &quot;);</span>
<span class="nc" id="L734">			buf.append(&quot;HAVING COUNT(1)&gt;1 &quot;);</span>
<span class="nc" id="L735">			rs = toHoursPerDayDAO.getDMO().createRowset(buf.toString());</span>
<span class="nc" id="L736">			sb.append(&quot;\n DUPEVENT PUB :&quot;);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L738">				sb.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">				for (int ix = 1; ix &lt;= rs.getMetaData().getColumnCount(); ix++) {</span>
<span class="nc" id="L740">					sb.append(&quot;\t&quot;).append(rs.getMetaData().getColumnName(ix)).append(&quot;=&quot;).append(rs.getObject(ix));</span>
				}

			}
<span class="nc" id="L744">			sb.append(&quot;\n DUPLICATE EVENTS IN TIMEOFFHOURSPERDAY&quot;).append(TOCalcUtil.dumpCollection(toHoursPerDayDAO.getObjectsWithExactMatch(hoursPerDay), &quot;\n&quot;));</span>
<span class="nc" id="L745">		} catch (Exception e) {</span>
<span class="nc" id="L746">			handleException(e);</span>
		} finally {
<span class="nc bnc" id="L748" title="All 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L749">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
		
<span class="nc" id="L753">		return sb.toString();</span>
	}

	public void updateObjects(Collection toHoursPerDayToUpdate) throws BbmFinderException {
<span class="nc" id="L757">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L759">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L761">				LOG.info(&quot;start of updateObjects=[&quot; + RmUtil.dumpCollection(toHoursPerDayToUpdate, &quot;\n&quot;) + &quot;]&quot;);</span>
			}
<span class="nc" id="L763">			toHoursPerDayDAO.updateObjects(toHoursPerDayToUpdate);</span>
<span class="nc" id="L764">		} catch (Exception e) {</span>
<span class="nc" id="L765">			handleException(e);</span>
<span class="nc" id="L766">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L768" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L769">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L772">	}</span>

	private void refreshHoursPerDayForEmployee(int msgType, EmpHrsPerDayCol empHrsPerDayCol, Map bulkDataMap, Collection toHoursPerDayToInsert, Collection toHoursPerDayToUpdate, boolean doNotRefreshLongReq) throws Exception {
<span class="nc bnc" id="L775" title="All 4 branches missed.">		if (empHrsPerDayCol.hrsPerDaySet != null &amp;&amp; !empHrsPerDayCol.hrsPerDaySet.isEmpty()) {</span>
<span class="nc" id="L776">			ID empID = empHrsPerDayCol.empID;</span>
<span class="nc" id="L777">			Map orgIDMap = (Map) bulkDataMap.get(&quot;orgIDMap&quot;);</span>
<span class="nc" id="L778">			Map empIDToLastShiftAssnMap = (Map) bulkDataMap.get(&quot;empIDToLastShiftAssnMap&quot;);</span>
<span class="nc" id="L779">			Map empAllotmentMap = (Map) bulkDataMap.get(&quot;empAllotmentMap&quot;);</span>
<span class="nc" id="L780">			Map adjTimeRangeMap = (Map) bulkDataMap.get(&quot;adjTimeRangeMap&quot;);</span>
<span class="nc" id="L781">			Map empIDToShiftAssnsPubMap = (Map) bulkDataMap.get(&quot;empIDToShiftAssnsPubMap&quot;);</span>
<span class="nc" id="L782">			Map empIDToUnavailsPubMap = (Map) bulkDataMap.get(&quot;empIDToUnavailsPubMap&quot;);</span>
<span class="nc" id="L783">			Map empIDToTimeOffPubMap = (Map) bulkDataMap.get(&quot;empIDToTimeOffPubMap&quot;);</span>
<span class="nc" id="L784">			Map hoosForOrgMap = (Map) bulkDataMap.get(&quot;hoosForOrgMap&quot;);</span>
<span class="nc" id="L785">			Map holidayMap = (Map) bulkDataMap.get(&quot;holidayMap&quot;);</span>
<span class="nc" id="L786">			Map empIdOrgAssignmentMap = (Map) bulkDataMap.get(&quot;empOrgAssignment&quot;);</span>
<span class="nc" id="L787">			Map empIdTerminationDateMap = (Map) bulkDataMap.get(&quot;empIdTerminationDateMap&quot;);</span>
			//start building the calc and removing data from maps that are relevant to employee
<span class="nc" id="L789">			Collection empShiftAssns = (Collection) empIDToShiftAssnsPubMap.remove(empID); //only remove emp assignments</span>
<span class="nc" id="L790">			Collection empUnavails = (Collection) empIDToUnavailsPubMap.remove(empID);</span>
<span class="nc" id="L791">			Collection empTimeOffPub = (Collection) empIDToTimeOffPubMap.remove(empID);</span>
<span class="nc" id="L792">			Collection empOrgAssignmentsCol = (Collection) empIdOrgAssignmentMap.remove(empID);</span>
<span class="nc" id="L793">			Date terminationDate = (Date) empIdTerminationDateMap.remove(empID);</span>
<span class="nc bnc" id="L794" title="All 4 branches missed.">			if (empOrgAssignmentsCol == null || empOrgAssignmentsCol.isEmpty()) {</span>
<span class="nc" id="L795">				LOG.debug(&quot;WorkResource Assignment For empID =&quot; + empID + &quot;null=[&quot; + RmUtil.dumpCollection(empOrgAssignmentsCol, &quot;\n&quot;) + &quot;]&quot;);</span>
			}
<span class="nc" id="L797">			HashMap allotmentMap = ValueObjectUtil.getFieldObjectMap(EmployeeTimeOffDefaultFieldInfo.TMOFFDEFAULT_ACTIVITYID, (ArrayList) empAllotmentMap.remove(empID));</span>
<span class="nc" id="L798">			ShiftAssignment lastShift = (ShiftAssignment) empIDToLastShiftAssnMap.remove(empID);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">			lastShift = (lastShift == null ? defaultLastShift : lastShift);</span>
<span class="nc" id="L800">			TimeOffLengthCalculator toCalc = null;</span>
<span class="nc" id="L801">			TOHoursPerDay hoursPerDay = null;</span>
<span class="nc" id="L802">			WorkResourceAssignment workResourceAssignment = null;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">			for (Iterator it = empHrsPerDayCol.hrsPerDaySet.iterator(); it.hasNext();) {</span>
<span class="nc" id="L804">				hoursPerDay = (TOHoursPerDay) it.next();</span>

				//decide Org for Employee Here; based on the startDate  &amp; then build a new CALC if there is a ORG change
<span class="nc bnc" id="L807" title="All 6 branches missed.">				if (workResourceAssignment == null || (workResourceAssignment.getEndTime() != null &amp;&amp; hoursPerDay.getStartTime().after(workResourceAssignment.getEndTime()))) {</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">					if (workResourceAssignment != null){</span>
<span class="nc" id="L809">						LOG.debug(&quot;Changing Employee ORG Here hrsPerDay St Time=&quot; + hoursPerDay.getStartTime() + &quot;:OLD WRA=&quot; + workResourceAssignment);</span>
					}
<span class="nc" id="L811">					workResourceAssignment = getWorkResourceAssignmentForGivenDate(empOrgAssignmentsCol, hoursPerDay.getStartTime());</span>
					//The employee has been terminated before the given start date . use the root org to avoid exception
<span class="nc bnc" id="L813" title="All 2 branches missed.">					ID orgID = workResourceAssignment == null ? Organization.ROOT_ORG_ID_OBJ : workResourceAssignment.getOrganizationID();</span>
<span class="nc" id="L814">					Organization org = (Organization) orgIDMap.get(orgID);</span>
										
<span class="nc" id="L816">					toCalc = TimeOffLengthCalculatorHelper.getCalculator(empID,</span>
<span class="nc" id="L817">					        org, (TimeRange) adjTimeRangeMap.get(org.getID()),</span>
					        empShiftAssns, empUnavails, empTimeOffPub,
<span class="nc" id="L819">					        (Collection) hoosForOrgMap.get(org.getID()),</span>
<span class="nc" id="L820">					        (Collection) holidayMap.get(org.getID()),</span>
					        lastShift, allotmentMap, terminationDate);
				}
<span class="nc bnc" id="L823" title="All 4 branches missed.">				if (doNotRefreshLongReq &amp;&amp; isGreaterThanMaxAllowedLength(hoursPerDay)) {</span>
					 //Do not adjust start &amp; end Date based on extraordinarily long requests
<span class="nc" id="L825">					LOG.info(&quot;Skipping This TOHoursPerday Since it Exceeds Max Size;&quot; + hoursPerDay);</span>
<span class="nc" id="L826">					hoursPerDay.setIsDirty(true);</span>
				} else {
<span class="nc" id="L828">					StringBuilder hoursPerDayChange = new StringBuilder();</span>
<span class="nc" id="L829">					hoursPerDay = TOHoursPerDayUtil.refreshMinsForTOHoursPerDay(hoursPerDay, toCalc, hoursPerDayChange);</span>
					// audit for only TO events hours/day changes for employee
<span class="nc bnc" id="L831" title="All 2 branches missed.">					if (!hoursPerDayChange.toString().isEmpty()) { </span>
<span class="nc" id="L832">						auditTOHoursPerDayChange(empID, msgType, hoursPerDay.getStartTime(), hoursPerDay.getEndTime(), hoursPerDayChange.toString());</span>
					}
				}
<span class="nc bnc" id="L835" title="All 2 branches missed.">				if (hoursPerDay.getID() == null) {</span>
<span class="nc" id="L836">					toHoursPerDayToInsert.add(hoursPerDay);</span>
				} else {
<span class="nc" id="L838">					toHoursPerDayToUpdate.add(hoursPerDay);</span>
				}
			}
		}
<span class="nc" id="L842">	}</span>

	private void auditTOHoursPerDayChange(ID empID, int msgType, Date startDate, Date endDate, String hoursPerDayChange) {
<span class="nc" id="L845">		AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT,</span>
														AuditTrailEntry.ACTION_TIME_OFF_HOURS_PER_DAY,
														empID, null, startDate, endDate);
		try {
<span class="nc" id="L849">			String notifyType = TONotifyMessage.getNotifyString(msgType);</span>
			
<span class="nc" id="L851">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TIMEOFF, </span>
								   hoursPerDayChange,
								   notifyType, false);
<span class="nc" id="L854">			BbmManagerFactory.getEventAuditTrailManager().createAuditEntry(auditEntry);</span>
<span class="nc" id="L855">		} catch (Exception e) {</span>
<span class="nc" id="L856">		  LOG.debug(&quot;unable to audit TO hours per day changes for employee with id: &quot; + empID + </span>
<span class="nc" id="L857">			&quot; because of exception : &quot; + e.getMessage());</span>
<span class="nc" id="L858">		} </span>
<span class="nc" id="L859">	}</span>

	private WorkResourceAssignment getWorkResourceAssignmentForGivenDate(Collection wras, Date startDate) {
<span class="nc" id="L862">		WorkResourceAssignment wra = null;</span>
<span class="nc bnc" id="L863" title="All 4 branches missed.">		if (wras != null &amp;&amp; !wras.isEmpty()) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">			for (Iterator it = wras.iterator(); it.hasNext();) {</span>
<span class="nc" id="L865">				wra = (WorkResourceAssignment) it.next();</span>
<span class="nc bnc" id="L866" title="All 4 branches missed.">				if (wra != null &amp;&amp; startDate != null &amp;&amp;</span>
<span class="nc bnc" id="L867" title="All 6 branches missed.">				        (wra.getEndTime() == null || !startDate.after(wra.getEndTime())) &amp;&amp; !startDate.before(wra.getStartTime())) {</span>
<span class="nc" id="L868">					break;</span>
				}
			}
		}
<span class="nc" id="L872">		return wra;</span>
	}

	//Called on HOLIDAY change
	private Collection updateTOHoursPerDayForOrg(ID orgID, Date startDate, Date endDate, int msgType) throws BbmUpdateException {
<span class="nc" id="L877">		TOHoursPerDayDAO dao = null;</span>
		try {
<span class="nc" id="L879">			dao = new TOHoursPerDayDAO();</span>
			//should add 7 days before and after date range to accomdate for Change in accounted hours for requests
			//  in that period on account of emp weekly defaults.
<span class="nc" id="L882">			Collection empIDs = RequestUtil.getEmpIdsInOrg(orgID, startDate, endDate, true);</span>
<span class="nc" id="L883">			Collection returnCol = dao.getObjects(empIDs, TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_EMPLOYEEID,</span>
<span class="nc" id="L884">			        new TimeRange(TOHoursPerDayUtil.getDateForDaysBefore(startDate, 7, null),</span>
<span class="nc" id="L885">			                TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null)));</span>
<span class="nc" id="L886">			return refreshAndUpdateTOHoursPerDay(msgType, returnCol, true, false);</span>
<span class="nc" id="L887">		} catch (Exception e) {</span>
<span class="nc" id="L888">			handleException(e);</span>
<span class="nc" id="L889">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L891" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L892">				dao.cleanUp();</span>
			}
		}

	}

	//Called on any TOHoursPerday change
	public void updateTOHoursPerDay(TONotifyMessage msg) throws BbmUpdateException {
<span class="nc" id="L900">		int notifyType = msg.getNotificationType();</span>
		//TODO: convert to xml &amp; save the msg to database as a task
<span class="nc bnc" id="L902" title="All 8 branches missed.">		switch (notifyType) {</span>
			case TONotifyMessage.TO_NOTIFY_EMP_ORG_CHANGE:
<span class="nc" id="L904">				updateTOHoursPerDayForEmp(notifyType, msg.getObject());</span>
<span class="nc" id="L905">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_UNAVAIL_CHANGE:
<span class="nc" id="L907">				updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(notifyType, msg.getEmployeeIDs(), null, msg.getEndDate());</span>
<span class="nc" id="L908">				break;</span>
			case TONotifyMessage.TO_NOTIFY_HOLIDAY_CHANGE:
<span class="nc" id="L910">				updateTOHoursPerDayForOrg(msg.getOrgId(), msg.getStartDate(), msg.getEndDate(), notifyType);</span>
<span class="nc" id="L911">				break;</span>
			case TONotifyMessage.TO_NOTIFY_ORG_HOO_CHANGE:
<span class="nc" id="L913">				updateTOHoursPerDayForOrgAfterLastPublishedDate(msg.getOrgId(), notifyType);</span>
<span class="nc" id="L914">				break;</span>
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_PART:
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH:
			case TONotifyMessage.TO_NOTIFY_SCHED_UNPUBLISH:
<span class="nc" id="L918">				updateHoursPerDay((ScheduleChangeDetails) msg.getObject(), notifyType);</span>
<span class="nc" id="L919">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_TO_DEF_HOURS_CHANGE:
<span class="nc" id="L921">				updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(notifyType, msg.getEmployeeIDs(), Collections.singleton(msg.getActivityId()), null);</span>
<span class="nc" id="L922">				break;</span>
			case TONotifyMessage.TO_NOTIFY_TOREQUEST_UPDATE:
<span class="nc" id="L924">				Pair pair = (Pair) msg.getObject();</span>
<span class="nc" id="L925">				updateTOHoursPerDayForTORequest(notifyType, (TORequest) pair.getFirst(), ((Boolean) pair.getSecond()).booleanValue());</span>
<span class="nc" id="L926">				break;</span>
			default: 
				//should never come to this block
		}
		//TODO: flag the task saved to DB as completed
<span class="nc" id="L931">	}</span>

	private Collection updateTOHoursPerDayForEmp(int msgType, Object obj) throws BbmUpdateException {
<span class="nc" id="L934">		TOHoursPerDayDAO dao = null;</span>
		try {
<span class="nc" id="L936">			dao = new TOHoursPerDayDAO();</span>
<span class="nc" id="L937">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc" id="L938">			Pair pair = (Pair) obj;</span>
<span class="nc" id="L939">			Employee empBefore = (Employee) pair.getFirst();</span>
<span class="nc" id="L940">			Employee empAfter = (Employee) pair.getSecond();</span>
<span class="nc" id="L941">			Collection empIDs = Collections.singleton(empAfter.getID());</span>
<span class="nc bnc" id="L942" title="All 4 branches missed.">			long endTimeBefore = empBefore != null &amp;&amp; empBefore.getEndTime() != null ? empBefore.getEndTime().getTime() : -1;</span>
<span class="nc bnc" id="L943" title="All 4 branches missed.">			long endTimeAfter = empAfter != null &amp;&amp; empAfter.getEndTime() != null ? empAfter.getEndTime().getTime() : -1;</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">			if (endTimeBefore != endTimeAfter) {//Employee Termination</span>
				//take the scan date as earliest of the two dates
<span class="nc bnc" id="L946" title="All 6 branches missed.">				Date scanStartDate = new Date((endTimeBefore == -1 || (endTimeAfter != -1 &amp;&amp; endTimeBefore &gt; endTimeAfter)) ? endTimeAfter : endTimeBefore);</span>
<span class="nc" id="L947">				toHoursPerDayToUpdate.addAll(dao.getHoursPerDayForEmpAfterGivenDate(empAfter.getID(), null, scanStartDate, false));</span>
				//This is required since the Total minutes are updated on employee termination
				// and we need to restore them to original values when termination date is changed.
<span class="nc bnc" id="L950" title="All 2 branches missed.">				for (Iterator iterator = toHoursPerDayToUpdate.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L951">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">					if (hoursPerDay.getTimeOffRule() == TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES) {</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">						if (hoursPerDay.getTOEventID() != null) {</span>
							//toChoiceHrsPerDayMap.put(hoursPerDay.getTOEventID(), hoursPerDay);
							//QC164874
<span class="nc" id="L956">							hoursPerDay.setHoursPerDay(hoursPerDay.getOriginalHoursPerDay());</span>
<span class="nc" id="L957">							hoursPerDay.setTotalMinutes(hoursPerDay.getOriginalMinutes());</span>
						}
<span class="nc bnc" id="L959" title="All 4 branches missed.">						if (hoursPerDay.getTOChoiceID() != null &amp;&amp; RequestAuditTrail.STATUS_APPROVED.equals(hoursPerDay.getStatus())) {</span>
<span class="nc" id="L960">							hoursPerDay.setTotalMinutes(hoursPerDay.getOriginalMinutes());</span>
						}
					}
<span class="nc" id="L963">				}</span>
<span class="nc" id="L964">			} else { </span>
				//Employee creation or Org change
<span class="nc" id="L966">				toHoursPerDayToUpdate.addAll(dao.getHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(empIDs, null, null));</span>
			}
<span class="nc" id="L968">			return refreshAndUpdateTOHoursPerDay(msgType, toHoursPerDayToUpdate, true, false);</span>
<span class="nc" id="L969">		} catch (Exception e) {</span>
<span class="nc" id="L970">			handleException(e);</span>
<span class="nc" id="L971">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L973" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L974">				dao.cleanUp();</span>
			}
		}
	}

	//Called on  EMP org change &amp; termination only
	private Collection updateTOHoursPerDayForEmp(Collection empIDs, Date startDate, Date endDate) throws BbmUpdateException {
<span class="nc" id="L981">		TOHoursPerDayDAO dao = null;</span>
		try {
<span class="nc" id="L983">			dao = new TOHoursPerDayDAO();</span>
<span class="nc" id="L984">			dao.insertLastPublishedDate(empIDs, null);</span>
<span class="nc" id="L985">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc" id="L986">			Map empIDToLastnShiftAssnMap = TOCalcUtil.getLastShiftAssignmentsForEmpIDs(empIDs, true, null);</span>
<span class="nc" id="L987">			WorkResourceManager wrMgr = RequestUtil.getWorkResourceManager();</span>
<span class="nc" id="L988">			Map terminatedEmpIdMap = wrMgr.getTerminatedEmployees(empIDs);</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">			for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L990">				ID empId = (ID) iterator.next();</span>
				//scanStartDate is the earliest of the
				// 1&gt; passed start date OR
				// 2&gt; passed end date  OR
				// 3&gt; actual employee termination date  OR
				// 4&gt; last published date if it exists.
<span class="nc" id="L996">				Date scanStartDate = startDate;</span>
<span class="nc bnc" id="L997" title="All 6 branches missed.">				if (endDate != null &amp;&amp; (scanStartDate == null || scanStartDate.after(endDate))) {</span>
<span class="nc" id="L998">					scanStartDate = endDate;</span>
				}
<span class="nc" id="L1000">				Date empEndDate = (Date) terminatedEmpIdMap.get(empId);</span>
<span class="nc bnc" id="L1001" title="All 6 branches missed.">				if (empEndDate != null &amp;&amp; (scanStartDate == null || scanStartDate.after(empEndDate))) {</span>
<span class="nc" id="L1002">					scanStartDate = empEndDate;</span>
				}
<span class="nc" id="L1004">				ShiftAssignment lastShift = (ShiftAssignment) empIDToLastnShiftAssnMap.remove(empId);</span>
<span class="nc bnc" id="L1005" title="All 6 branches missed.">				if (lastShift != null &amp;&amp; (scanStartDate == null || scanStartDate.after(lastShift.getStartTime()))) {</span>
<span class="nc" id="L1006">					scanStartDate = lastShift.getStartTime();</span>
				}
<span class="nc" id="L1008">				toHoursPerDayToUpdate.addAll(dao.getHoursPerDayForEmpAfterGivenDate(empId, null, scanStartDate, false));</span>
<span class="nc" id="L1009">			}</span>
<span class="nc" id="L1010">			return refreshAndUpdateTOHoursPerDay(toHoursPerDayToUpdate, true);</span>
<span class="nc" id="L1011">		} catch (Exception e) {</span>
<span class="nc" id="L1012">			handleException(e);</span>
<span class="nc" id="L1013">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L1015" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1016">				dao.cleanUp();</span>
			}
		}
	}
	

	//Called on ORG HOO change
	private void updateTOHoursPerDayForOrgAfterLastPublishedDate(ID orgID, int msgType) throws BbmUpdateException {
		try {
<span class="nc" id="L1025">			Collection empIds = RequestUtil.getEmpIdsInOrg(orgID, new Date(), RequestUtil.MAX_DATE, false);</span>
<span class="nc bnc" id="L1026" title="All 4 branches missed.">			if (empIds != null &amp;&amp; !empIds.isEmpty()) {</span>
<span class="nc" id="L1027">				int maxEmpRefreshSize = getMaxEmpRefreshSize();</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">				if (empIds.size() &gt; maxEmpRefreshSize) {</span>
<span class="nc" id="L1029">					List empList = new ArrayList();</span>
<span class="nc" id="L1030">					empList.addAll(empIds);</span>
<span class="nc" id="L1031">					Collection empIdListArray[] = split(empList, maxEmpRefreshSize);</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">					for (int i = 0; i &lt; empIdListArray.length; i++) {</span>
<span class="nc" id="L1033">						LOG.info(&quot;empList =&quot; + empList.size() + &quot;; empIdListArray[i]=&quot; + empIdListArray[i].size() + &quot; :count=&quot; + i);</span>
<span class="nc" id="L1034">						updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(msgType, empIdListArray[i], null, null);</span>
					}
<span class="nc" id="L1036">				} else {</span>
<span class="nc" id="L1037">					updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(msgType, empIds, null, null);</span>
				}
			}
<span class="nc" id="L1040">		} catch (Exception e) {</span>
<span class="nc" id="L1041">			handleException(e);</span>
<span class="nc" id="L1042">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L1043">		}</span>
<span class="nc" id="L1044">	}</span>

	public static List[] split(final List pList, final int pSize) {
<span class="nc bnc" id="L1047" title="All 6 branches missed.">		if (pList == null || pList.isEmpty() || pSize == 0) {</span>
<span class="nc" id="L1048">			return new List[]{};</span>
		}
<span class="nc bnc" id="L1050" title="All 4 branches missed.">		if (pSize &lt; 0 || pSize &gt; pList.size()){</span>
<span class="nc" id="L1051">			return new List[]{pList};</span>
		}
		// Calculate the number of batches
<span class="nc" id="L1054">		int numBatches = (pList.size() / pSize) + 1;</span>
		// Create a new array of Lists to hold the return value
<span class="nc" id="L1056">		List[] batches = new List[numBatches];</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">		for (int index = 0; index &lt; numBatches; index++) {</span>
<span class="nc" id="L1058">			int count = index + 1;</span>
<span class="nc" id="L1059">			int fromIndex = Math.max(((count - 1) * pSize), 0);</span>
<span class="nc" id="L1060">			int toIndex = Math.min((count * pSize), pList.size());</span>
<span class="nc" id="L1061">			batches[index] = pList.subList(fromIndex, toIndex);</span>
		}
<span class="nc" id="L1063">		return batches;</span>
	}

	private boolean isGreaterThanMaxAllowedLength(TOHoursPerDay hrsPerDay) {
<span class="nc" id="L1067">		long timeIndays = -1;</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">		if (hrsPerDay != null) {</span>
<span class="nc" id="L1069">			timeIndays = (hrsPerDay.getEndTime().getTime() - hrsPerDay.getStartTime().getTime()) / ONEDAYINMILLISECS;</span>
		}
<span class="nc bnc" id="L1071" title="All 2 branches missed.">		return (timeIndays &gt; getMaxAlowedTOLength());</span>
	}

<span class="nc" id="L1074">	private static Integer maxLengthInDays = null;</span>

	private static long getMaxAlowedTOLength() {
		try {
<span class="nc bnc" id="L1078" title="All 2 branches missed.">			if (maxLengthInDays == null) {</span>
<span class="nc" id="L1079">				int maxLenInDays = BbmManagerFactory.getDBConfigManager(false).getIntValue(&quot;HOURS_PER_DAY_MAX_TO_LENGTH&quot;);</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">				if (maxLenInDays &lt; 0) {</span>
<span class="nc" id="L1081">					maxLenInDays = 100;</span>
				}
<span class="nc" id="L1083">				maxLengthInDays = new Integer(maxLenInDays);</span>
			}
<span class="nc" id="L1085">			return maxLengthInDays.intValue();</span>
<span class="nc" id="L1086">		} catch (Exception e) {</span>
<span class="nc" id="L1087">			LOG.debug(e);</span>
<span class="nc" id="L1088">			return 100;</span>
		}
	}

	private int getMaxEmpRefreshSize() {
<span class="nc" id="L1093">		int maxEmpRefreshSize = 100;</span>
		try {
<span class="nc" id="L1095">			maxEmpRefreshSize = BbmManagerFactory.getDBConfigManager(false).getIntValue(&quot;HOURS_PER_DAY_MAX_EMP_REFRESH_SIZE&quot;);</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">			if (maxEmpRefreshSize &lt; 0) {</span>
<span class="nc" id="L1097">				maxEmpRefreshSize = 100;</span>
			}
<span class="nc" id="L1099">		} catch (Exception e) {</span>
<span class="nc" id="L1100">			LOG.debug(e);</span>
<span class="nc" id="L1101">		}</span>
<span class="nc" id="L1102">		return maxEmpRefreshSize;</span>
	}

	private void updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(int msgType, Collection empIds, Collection activityIdCol, Date endDate) throws BbmUpdateException {
<span class="nc" id="L1106">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L1108">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1109">			refreshAndUpdateTOHoursPerDay(msgType, toHoursPerDayDAO.getHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(empIds, activityIdCol, TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null)), true, false);</span>
			/*
			for (Iterator iterator = empIds.iterator(); iterator.hasNext();) {
				ID empID = (ID) iterator.next();
				updateTOHoursPerDayForEmp(empID, null);
			}*/
<span class="nc" id="L1115">		} catch (Exception e) {</span>
<span class="nc" id="L1116">			handleException(e);</span>
<span class="nc" id="L1117">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L1119" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1120">				toHoursPerDayDAO.cleanUp();</span>
			}
		}

<span class="nc" id="L1124">	}</span>

<span class="nc" id="L1126">	class EmpHrsPerDayCol {</span>
		ID empID;
<span class="nc" id="L1128">		Date startDate = null;</span>
<span class="nc" id="L1129">		Date endDate = null;</span>
<span class="nc" id="L1130">		Set hrsPerDaySet = new TreeSet();</span>

		void add(TOHoursPerDay hrsPerDay) {
<span class="nc bnc" id="L1133" title="All 2 branches missed.">			if (empID == null) {</span>
<span class="nc" id="L1134">				empID = hrsPerDay.getEmployeeID();</span>
			}
<span class="nc bnc" id="L1136" title="All 4 branches missed.">			startDate = (startDate == null || startDate.after(hrsPerDay.getStartTime()) ? hrsPerDay.getStartTime() : startDate);</span>
<span class="nc bnc" id="L1137" title="All 4 branches missed.">			endDate = (endDate == null || endDate.before(hrsPerDay.getEndTime()) ? hrsPerDay.getEndTime() : endDate);</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">			if (hrsPerDaySet.contains(hrsPerDay)) {</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1140">					LOG.info(&quot;hrsPerDaySet already contains this row=&quot; + hrsPerDay);</span>
				}
			} else {
<span class="nc" id="L1143">				hrsPerDaySet.add(hrsPerDay);</span>
			}

<span class="nc" id="L1146">		}</span>
	}

	protected static TORequestManager getTORequestManager() throws BbmCreateException {
<span class="nc" id="L1150">		return RmManagerFactory.getInstance(true).getTimeOffRequestManager();</span>
	}

	public Collection&lt;TOHoursPerDay&gt; getAllDirtyTOHoursPerDay(Collection empIDs) throws BbmFinderException {
<span class="nc" id="L1154">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L1155">		Collection returnCol = new ArrayList();</span>
		try {
<span class="nc" id="L1157">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1158">			returnCol = toHoursPerDayDAO.getAllDirtyTOHoursPerDay(empIDs);</span>
<span class="nc" id="L1159">		} catch (Exception e) {</span>
<span class="nc" id="L1160">			handleException(e);</span>
<span class="nc" id="L1161">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1163" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1164">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1167">		return returnCol;</span>
	}

	public int getCountOfAllDirtyTOHoursPerDay() throws BbmFinderException {
<span class="nc" id="L1171">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L1172">		int retVal = -1;</span>
		try {
<span class="nc" id="L1174">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1175">			retVal = toHoursPerDayDAO.getCountOfAllDirtyTOHoursPerDay();</span>
<span class="nc" id="L1176">		} catch (Exception e) {</span>
<span class="nc" id="L1177">			handleException(e);</span>
<span class="nc" id="L1178">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1180" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1181">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1184">		return retVal;</span>
	}

	private Map getTOCalcDataForEmpIDs(Set empIDsUncachedSet, Date startDate, Date endDate) throws Exception {
<span class="nc" id="L1188">		long currentime = new Date().getTime();</span>
<span class="nc" id="L1189">		ScheduleAccessManager sam = RequestUtil.getScheduleAccessManager();</span>
<span class="nc" id="L1190">		WorkResourceManager wrMgr = RequestUtil.getWorkResourceManager();</span>
		// readjust range to start and end of org week boundaries.
<span class="nc bnc" id="L1192" title="All 4 branches missed.">		Date adjStDate =  startDate==null|| startDate.after(new Date())? new Date():startDate;</span>
<span class="nc" id="L1193">		HashMap empOrgAssignment = wrMgr.getValidWorkResourceAssignments(empIDsUncachedSet, new LocalDate(adjStDate), new LocalDate(endDate), false);</span>
<span class="nc" id="L1194">		Collection empOrgs = new ArrayList();</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">		for (Iterator iterator = empOrgAssignment.values().iterator(); iterator.hasNext(); empOrgs.addAll((Collection) iterator.next())) {</span>
			;
		}
<span class="nc" id="L1198">		long diff = new Date().getTime() - currentime;</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1200">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getEmployeesReportingOrgs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L1202">		Collection&lt;ID&gt; orgList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1203">		orgList.addAll(TOHoursPerDayUtil.extractFieldSet(WorkResourceAssignmentFieldInfo.WRASSIGNMENT_ORGANIZATIONID, empOrgs));</span>
<span class="nc" id="L1204">		orgList.add(Organization.ROOT_ORG_ID_OBJ);</span>
<span class="nc" id="L1205">		HashMap orgIDMap = ValueObjectUtil.getIDObjectMap(wrMgr.getOrganizationsByIDs(orgList));</span>
<span class="nc" id="L1206">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1208">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getOrganizationsByIDs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L1210">		Date startDateX = null;</span>
<span class="nc" id="L1211">		Date endDateX = null;</span>
<span class="nc" id="L1212">		HashMap adjTimeRangeMap = new HashMap(orgIDMap.size() * 2);</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">		for (Iterator iterator = orgIDMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1214">			Organization org = (Organization) iterator.next();</span>
<span class="nc" id="L1215">			Date m_adjStartDate = TimeOffLengthCalculatorHelper.expandTOCalcRangeStart(startDate, null, org);</span>
<span class="nc" id="L1216">			Date m_adjEndDate = TimeOffLengthCalculatorHelper.expandTOCalcRangeEnd(endDate, null, org);</span>
<span class="nc bnc" id="L1217" title="All 4 branches missed.">			startDateX = (startDateX == null || startDateX.after(m_adjStartDate) ? m_adjStartDate : startDateX);</span>
<span class="nc bnc" id="L1218" title="All 4 branches missed.">			endDateX = (endDateX == null || endDateX.before(m_adjEndDate) ? m_adjEndDate : endDateX);</span>
<span class="nc" id="L1219">			adjTimeRangeMap.put(org.getID(), new TimeRange(m_adjStartDate, m_adjEndDate));</span>
<span class="nc" id="L1220">		}</span>
<span class="nc" id="L1221">		HashMap hoosForOrgMap = wrMgr.getOrganizationHOOAssignments(orgIDMap.keySet(), startDateX, endDateX);</span>
<span class="nc" id="L1222">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1224">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getOrganizationHOOAssignments=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
		
<span class="nc" id="L1227">		HolidayManager hm = BbmManagerFactory.getHolidayManager();</span>
<span class="nc" id="L1228">	    Map holidayMap = hm.getHolidays(orgIDMap.keySet(), new LocalDate(startDateX), new LocalDate(endDateX));</span>
		
<span class="nc" id="L1230">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1232">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getOrganizationsByIDs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L1234">		HashMap empAllotmentMap = wrMgr.getTOAllotmentMapForEmpIDs(empIDsUncachedSet);</span>
		// bulk load published events (unavails, shifts) for all org employees.
<span class="nc" id="L1236">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1238">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getTOAllotmentMapForEmpIDs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L1240">		List pubShiftAssnEvtsForEmps = sam.getPublishedEventsForWorkResourcesByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT | Event.EVENT_TYPE_TIME_OFF,</span>
		        empIDsUncachedSet, startDateX, endDateX);
<span class="nc" id="L1242">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1244">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getPublishedEventsForWorkResourcesByType size=&quot; + pubShiftAssnEvtsForEmps.size() + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

<span class="nc" id="L1247">		List unavailEvtsForEmps = sam.getEventsForWorkResourcesByType(Event.EVENT_TYPE_UNAVAILABILITY, empIDsUncachedSet, startDateX, endDateX);</span>
<span class="nc" id="L1248">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1250">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getEventsForWorkResourcesByType=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

		// segregate the bulk loaded events by empID and eventType.
<span class="nc" id="L1254">		Map empIDToUnavailsPubMap = new HashMap(empIDsUncachedSet.size() * 2);</span>
<span class="nc" id="L1255">		Map empIDToShiftAssnsPubMap = new HashMap(empIDsUncachedSet.size() * 2);</span>
<span class="nc" id="L1256">		Map empIDToTimeOffPubMap = new HashMap(empIDsUncachedSet.size() * 2);</span>

		//To reuse the moved moved to ToCalUtil
<span class="nc" id="L1259">		TOCalcUtil.segregateBulkLoadedEvts(empIDsUncachedSet, pubShiftAssnEvtsForEmps, empIDToShiftAssnsPubMap, empIDToTimeOffPubMap);</span>
<span class="nc" id="L1260">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1262">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.segregateBulkLoadedEvts=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

<span class="nc" id="L1265">		TOCalcUtil.createUnavailsMap(empIDsUncachedSet, unavailEvtsForEmps, empIDToUnavailsPubMap);</span>
<span class="nc" id="L1266">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1268">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.createUnavailsMap=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

		// fetch the last shift assignments for employees
<span class="nc" id="L1272">		Map empIDToLastShiftAssnMap = TOCalcUtil.getLastShiftAssignmentsForEmpIDs(empIDsUncachedSet, true, sam);</span>
<span class="nc" id="L1273">		Map empIdTerminationDateMap = wrMgr.getTerminatedEmployees(empIDsUncachedSet);</span>
<span class="nc" id="L1274">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1276">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.empIDToLastShiftAssnMap=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L1278">		HashMap bulkDataMap = new HashMap(12);</span>
<span class="nc" id="L1279">		bulkDataMap.put(&quot;orgIDMap&quot;, orgIDMap);</span>
<span class="nc" id="L1280">		bulkDataMap.put(&quot;empOrgAssignment&quot;, empOrgAssignment);</span>
<span class="nc" id="L1281">		bulkDataMap.put(&quot;empIDToLastShiftAssnMap&quot;, empIDToLastShiftAssnMap);</span>
<span class="nc" id="L1282">		bulkDataMap.put(&quot;empAllotmentMap&quot;, empAllotmentMap);</span>
<span class="nc" id="L1283">		bulkDataMap.put(&quot;adjTimeRangeMap&quot;, adjTimeRangeMap);</span>
<span class="nc" id="L1284">		bulkDataMap.put(&quot;empIDToShiftAssnsPubMap&quot;, empIDToShiftAssnsPubMap);</span>
<span class="nc" id="L1285">		bulkDataMap.put(&quot;empIDToUnavailsPubMap&quot;, empIDToUnavailsPubMap);</span>
<span class="nc" id="L1286">		bulkDataMap.put(&quot;empIDToTimeOffPubMap&quot;, empIDToTimeOffPubMap);</span>
<span class="nc" id="L1287">		bulkDataMap.put(&quot;hoosForOrgMap&quot;, hoosForOrgMap);</span>
<span class="nc" id="L1288">		bulkDataMap.put(&quot;holidayMap&quot;, holidayMap);</span>
<span class="nc" id="L1289">		bulkDataMap.put(&quot;empIdTerminationDateMap&quot;, empIdTerminationDateMap);</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1291">			LOG.info(&quot;TOTAL TIME FOR building CALC DATA=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L1293">		return bulkDataMap;</span>
	}

<span class="nc" id="L1296">	static ShiftAssignment defaultLastShift = TOCalcUtil.getDefaultLastShift();</span>

	public boolean checkHealth() throws BbmFinderException {
<span class="nc" id="L1299">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L1300">		boolean retVal = false;</span>
		try {
<span class="nc" id="L1302">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1303">			retVal = toHoursPerDayDAO.checkHealth();</span>
<span class="nc" id="L1304">		} catch (Exception e) {</span>
<span class="nc" id="L1305">			handleException(e);</span>
<span class="nc" id="L1306">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1308" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1309">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1312">		return retVal;</span>
	}

	public HashMap getSumOfAccountedHoursForDateRange(ID empID, HashMap activitySummaryMap, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L1316">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L1318">			toHoursPerDayDAO.getHoursPerDayContainedInDateRange(activitySummaryMap, empID, startDate, endDate, true);</span>
<span class="nc" id="L1319">			toHoursPerDayDAO.getHoursPerDayContainedInDateRange(activitySummaryMap, empID, startDate, endDate, false);</span>
			//process scheduled/taken time- off that cross the year boundaries.
<span class="nc" id="L1321">			Collection scheduleOrTakenTimeOffEvents = null;</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">			if (scheduleOrTakenTimeOffEvents != null) {</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">				for (Iterator it = scheduleOrTakenTimeOffEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1324">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc" id="L1325">					boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(startDate);</span>
<span class="nc" id="L1326">					boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(endDate);</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">					DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L1328" title="All 2 branches missed.">					        isToEvtStartBeforeStart ? startDate : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L1329">					        isToEvtEndAfterEnd ? endDate : hoursPerDay.getEndTime());</span>
<span class="nc" id="L1330">					float usedHoursForTOYear = dailyBuckets.getTotalHours();</span>
<span class="nc" id="L1331">				}</span>
			}
			// At this point, the total, used and scheduled fields are filled in.  We can calculate the remaining hours
<span class="nc bnc" id="L1334" title="All 2 branches missed.">			for (Iterator it = activitySummaryMap.values().iterator(); it.hasNext();) {</span>
<span class="nc" id="L1335">				TimeOffActivitySummary summary = (TimeOffActivitySummary) it.next();</span>
<span class="nc" id="L1336">				summary.setRemaining(summary.getTotal() - summary.getUsed() - summary.getScheduled());</span>
<span class="nc" id="L1337">			}</span>
<span class="nc" id="L1338">		} catch (Exception e) {</span>
<span class="nc" id="L1339">			handleException(e);</span>
<span class="nc" id="L1340">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1342" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1343">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1346">		return activitySummaryMap;</span>
	}

	public void lockRecords(TONotifyMessage msgObj) throws BbmUpdateException {
<span class="nc" id="L1350">		LOG.debug(&quot;from TOHoursPerDayManagerEJB; before lockRecords uniqID=&quot; + msgObj.getUniqID());</span>
<span class="nc" id="L1351">		int returnVal = msgObj.lockRecords();</span>
<span class="nc" id="L1352">		LOG.debug(&quot;from TOHoursPerDayManagerEJB; after lockRecords count=&quot; + returnVal + msgObj);</span>
<span class="nc bnc" id="L1353" title="All 4 branches missed.">		if (msgObj.isMessageForTOHoursPerDayUpdate() &amp;&amp; returnVal &lt; 1) {</span>
<span class="nc" id="L1354">			msgObj.setRetryDelivery(false); // no point in trying redeliver the message. It will always fail.</span>
<span class="nc" id="L1355">			throw new BbmUpdateException(&quot;Cannot lock or proceed with TOHoursUpdate;  lockRecords count=&quot; + returnVal + &quot; For:&quot; + msgObj);</span>
		}
<span class="nc" id="L1357">	}</span>

	public void lockEmployees(Collection empIDs) throws JdmoException {
<span class="nc" id="L1360">		Jdmo jdmo = null;</span>
		try {
<span class="nc" id="L1362">			jdmo = new Jdmo();</span>
<span class="nc" id="L1363">			jdmo.executeCommand(&quot; UPDATE EMPLOYEELASTPUBDATE SET ID = ID  WHERE ID IN &quot; + jdmo.createInClause(empIDs));</span>
		} finally {
<span class="nc bnc" id="L1365" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L1366">				jdmo.cleanUp();</span>
			}
		}
<span class="nc" id="L1369">	}</span>

	/**
	 * Finds time Off events that exists in published calendar events assignments, but  are missing from  TIMEOFFHOURSPERDAY
	 * and add them to TIMEOFFHOURSPERDAY. This function will also update EMPLOYEELASTPUBDATE with any employee IDs that are missing 
	 * from EMPLOYEELASTPUBDATE   
	 */

	public void syncTOHoursPerDay() throws BbmUpdateException {
<span class="nc" id="L1378">		StringBuilder strBuff = new StringBuilder();</span>
<span class="nc" id="L1379">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L1381">			ScheduleAccessManager sam = RequestUtil.getScheduleAccessManager();</span>
<span class="nc" id="L1382">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
			//Get Missing TOEvents
<span class="nc" id="L1384">			Collection&lt;IDPair&gt; col = toHoursPerDayDAO.getMissingTOEventsToBeSynced();</span>
<span class="nc bnc" id="L1385" title="All 4 branches missed.">			if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1386">				strBuff.append(&quot;Missing TOEVENTIDS: &quot; + RmUtil.dumpCollection(col));</span>
			}

<span class="nc" id="L1389">			logSyncInfoMessage(&quot; Syncing TimeOffEvent start :&quot;, col);</span>

<span class="nc bnc" id="L1391" title="All 2 branches missed.">			for (IDPair idPair : col) {</span>
<span class="nc" id="L1392">				CalendarEventAssignment cAss = sam.getPublishedCalendarEventAssignmentByID((ID) idPair.getFirst());</span>
<span class="nc" id="L1393">				LOG.debug(&quot; Syncing TimeOffEvent for EMPID=&quot; + idPair.getSecond().toString() + &quot; EVENT=&quot; + cAss);</span>
<span class="nc" id="L1394">				getTOHoursPerDaysForTOEvent((ID) idPair.getSecond(), (TimeOffEvent) cAss);</span>
<span class="nc" id="L1395">			}</span>

<span class="nc" id="L1397">			logSyncInfoMessage(&quot; Syncing TimeOffEvent end:&quot;, col);</span>

<span class="nc" id="L1399">			List&lt;ID&gt; employeeIDsNotInLastPub = toHoursPerDayDAO.getMissingEntriesInLastPubDate();</span>
<span class="nc bnc" id="L1400" title="All 4 branches missed.">			if (employeeIDsNotInLastPub != null &amp;&amp; !employeeIDsNotInLastPub.isEmpty()) {</span>
<span class="nc" id="L1401">				strBuff.append(&quot;Missing LASTPUBDATE: &quot; + RmUtil.dumpCollection(employeeIDsNotInLastPub));</span>
			}

			//Update Missing Entries in EMP LAST PUB DATE
<span class="nc" id="L1405">			logSyncInfoMessage(&quot; Syncing MissingEntries InLast PubDate start:&quot;, employeeIDsNotInLastPub);</span>

<span class="nc bnc" id="L1407" title="All 4 branches missed.">			if (employeeIDsNotInLastPub != null &amp;&amp; !employeeIDsNotInLastPub.isEmpty()) {</span>
<span class="nc" id="L1408">				toHoursPerDayDAO.insertLastPublishedDate(employeeIDsNotInLastPub, null);</span>
<span class="nc" id="L1409">				toHoursPerDayDAO.refreshLastPublishedDate(employeeIDsNotInLastPub);</span>
			}

<span class="nc" id="L1412">			logSyncInfoMessage(&quot; Syncing MissingEntries InLast PubDate End:&quot;, employeeIDsNotInLastPub);</span>

<span class="nc bnc" id="L1414" title="All 2 branches missed.">			if (strBuff.length() &gt; 10) {</span>
<span class="nc" id="L1415">				traceDebugData(null, strBuff.toString(), null, 0);</span>
			}

<span class="nc" id="L1418">		} catch (Exception e) {</span>
<span class="nc" id="L1419">			handleException(e);</span>
<span class="nc" id="L1420">			traceDebugData(null, strBuff.toString(), e, 0);</span>
<span class="nc" id="L1421">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L1423" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1424">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1427">	}</span>

	private static void logSyncInfoMessage(String infoMsg, Collection&lt;?&gt; col) {
<span class="nc bnc" id="L1430" title="All 6 branches missed.">		if (RequestUtil.isRMDebugEnabled() || (col != null &amp;&amp; !col.isEmpty())) {</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">			LOG.info(infoMsg + (col != null ? Integer.toString(col.size()) : &quot; NULL&quot;));</span>
		}
<span class="nc" id="L1433">	}</span>

	public void traceDebugData(String objectID, Object object, Exception e, int count) {
<span class="nc" id="L1436">		Jdmo jdmo = null;</span>
		try {
<span class="nc bnc" id="L1438" title="All 2 branches missed.">			if (&quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager().getValue(&quot;bluepumpkin/rm/traceDebugData/TOHoursPerDayManager&quot;))) {</span>
<span class="nc" id="L1439">				String sStackTraceStr = null;</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">				if (e != null) {</span>
<span class="nc" id="L1441">					StringWriter sStackTrace = new StringWriter();</span>
<span class="nc" id="L1442">					PrintWriter pStackTrace = new PrintWriter(sStackTrace);</span>
<span class="nc" id="L1443">					e.printStackTrace(pStackTrace);</span>
<span class="nc" id="L1444">					sStackTraceStr = sStackTrace.toString();</span>
				}

<span class="nc" id="L1447">				jdmo = new Jdmo();</span>
<span class="nc" id="L1448">				ArrayList colFieldValues = new ArrayList();</span>
<span class="nc" id="L1449">				String arrFieldNames[] = new String[]{&quot;OBJECTID&quot;, &quot;OBJECTDATA&quot;, &quot;STACKTRACE&quot;, &quot;ATWHEN&quot;, &quot;COUNT&quot;};</span>
<span class="nc" id="L1450">				int arrFieldTypes[] = {Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.TIMESTAMP, Types.INTEGER};</span>
<span class="nc bnc" id="L1451" title="All 4 branches missed.">				Object arrFieldValues[] = new Object[]{</span>
					(objectID != null) ? objectID : &quot;NULL&quot;,
<span class="nc" id="L1453">					(object != null) ? object.toString() : &quot;NULL&quot;,</span>
					sStackTraceStr, new Date(), new Integer(count)};
<span class="nc" id="L1455">				colFieldValues.add(arrFieldValues);</span>
<span class="nc" id="L1456">				jdmo.insertBatchAndExecute(&quot;BPTRACEDEBUGDATA&quot;, arrFieldNames, arrFieldTypes, colFieldValues);</span>
			}
<span class="nc" id="L1458">		} catch (Exception e2) {</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">			LOG.error(&quot;Trace TO notification handler exception failed \n&quot; +</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">			        &quot;Ex: &quot; + ((e != null) ? e.getMessage() : &quot; NULL&quot;) +</span>
<span class="nc" id="L1461">			        &quot;Msg: &quot; + ((object != null) ? object.toString() : &quot;NULL&quot;));</span>
		} finally {
<span class="nc bnc" id="L1463" title="All 6 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L1464">				jdmo.cleanUp();</span>
			}
		}
<span class="nc" id="L1467">	}</span>

	public Map&lt;ID, List&lt;TOHoursPerDay&gt;&gt; getHoursPerDayForRange(HashMap empStDateMap, HashMap empEnDateMap, Collection activityIDs)
			throws BbmFinderException {
<span class="nc" id="L1471">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L1472">		long currentime = new Date().getTime();</span>
<span class="nc" id="L1473">		Map&lt;ID, List&lt;TOHoursPerDay&gt;&gt; hrsPerDaySchedMap = new HashMap&lt;ID, List&lt;TOHoursPerDay&gt;&gt;();</span>
<span class="nc" id="L1474">		Collection&lt;TOHoursPerDay&gt; hrsPerDayCol = null;</span>
		try {
<span class="nc" id="L1476">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1477">			Map&lt;Boolean, List&lt;TOHoursPerDay&gt;&gt; hourPerDayByFlag = toHoursPerDayDAO.getHoursPerDayForRange(empStDateMap, empEnDateMap,</span>
					activityIDs);

<span class="nc" id="L1480">			hrsPerDayCol = hourPerDayByFlag.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">			if (hrsPerDayCol == null) {</span>
<span class="nc" id="L1482">				hrsPerDayCol = new ArrayList();</span>
			}
<span class="nc" id="L1484">			Collection&lt;TOHoursPerDay&gt; hrsPerDaySchedToUpdate = hourPerDayByFlag.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1486">				LOG.info(&quot;$$$$TOTAL TIME for FETCH ALL getHoursPerDayForRange=&quot; + (new Date().getTime() - currentime));</span>
			}

<span class="nc bnc" id="L1489" title="All 4 branches missed.">			if (hrsPerDaySchedToUpdate != null &amp;&amp; !hrsPerDaySchedToUpdate.isEmpty()) {</span>
<span class="nc" id="L1490">				refreshAndUpdateTOHoursPerDay(hrsPerDaySchedToUpdate, true);</span>
<span class="nc" id="L1491">				hrsPerDayCol.addAll(hrsPerDaySchedToUpdate);</span>
			}
<span class="nc" id="L1493">			hrsPerDaySchedMap = DAOUtil.groupByField(TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_EMPLOYEEID, hrsPerDayCol);</span>

<span class="nc" id="L1495">		} catch (Exception e) {</span>
<span class="nc" id="L1496">			handleException(e);</span>
<span class="nc" id="L1497">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1499" title="All 4 branches missed.">			if (toHoursPerDayDAO != null){</span>
<span class="nc" id="L1500">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc bnc" id="L1503" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1504">			LOG.info(&quot;TOTAL TIME for getHoursPerDayForRange=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj =&quot; + hrsPerDayCol.size());</span>
		}
<span class="nc" id="L1506">		return hrsPerDaySchedMap;</span>
	}

	//Returns a list of (RequestID, TOHoursPerDay) for the given employees that use the given pool in the given date interval
	public List&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt; getOrderedTOWaitlists(TOPool pTOPool, Collection&lt;ID&gt; empIds, Date stDate, Date enDate)
			throws BbmFinderException {
<span class="nc" id="L1512">		new ArrayList&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt;();</span>
<span class="nc" id="L1513">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L1514">		long currentime = new Date().getTime();</span>
<span class="nc" id="L1515">		List&lt;TOHoursPerDay&gt; hrsPerDayToUpdate = new ArrayList&lt;TOHoursPerDay&gt;();</span>
		List&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt; arrItems;
		try {
<span class="nc" id="L1518">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1519">			arrItems = toHoursPerDayDAO.getOrderedTOWaitlists(pTOPool, empIds, stDate, enDate);</span>

<span class="nc bnc" id="L1521" title="All 2 branches missed.">			for (Pair&lt;ID, TOHoursPerDay&gt; item : arrItems) {</span>
<span class="nc" id="L1522">				TOHoursPerDay hrPerDay = item.getSecond();</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">				if (hrPerDay.getIsDirty()) {</span>
<span class="nc" id="L1524">					hrsPerDayToUpdate.add(hrPerDay);</span>
				}
<span class="nc" id="L1526">			}</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">			if (!hrsPerDayToUpdate.isEmpty()) {</span>
<span class="nc" id="L1528">				refreshAndUpdateTOHoursPerDay(hrsPerDayToUpdate, true);</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1530">					LOG.info(&quot;TOTAL TIME for hrsPerDay refresh in getOrderedTOWaitlists=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj =&quot; +  hrsPerDayToUpdate.size());</span>
				}
			}
<span class="nc" id="L1533">		} catch (Exception e) {</span>
<span class="nc" id="L1534">			handleException(e);</span>
<span class="nc" id="L1535">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1537" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1538">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc bnc" id="L1541" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1542">			LOG.info(&quot;TOTAL TIME for getOrderedTOWaitlists=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj =&quot; + arrItems.size());</span>
		}
<span class="nc" id="L1544">		return arrItems;</span>
	}


	/*
	 * A reference schedule assignment has changed (not published/unpublished), affecting the TORequestChoices passed in.
	 * We must update those choices.
	 */

	public void onReferenceScheduleChange(TONotifyMessage message, List&lt;ID&gt; choiceIDs) throws BbmUpdateException {
		try {
			
<span class="nc" id="L1556">			List&lt;TOHoursPerDay&gt; hrsPerColToUpdate = new ArrayList&lt;TOHoursPerDay&gt;();</span>

			// REFERENCE SCHEDULES
			// Get the HoursPerDay that are generated using reference schedules
			// (assuming this period may be referenced)
			// The dates may be wildly different from this period
<span class="nc" id="L1562">			Collection&lt;TOHoursPerDay&gt; listReferenceScheduleHoursPerDay = getHoursPerDayFromTOChoiceList(choiceIDs);</span>
<span class="nc" id="L1563">			hrsPerColToUpdate.addAll(listReferenceScheduleHoursPerDay);</span>

<span class="nc bnc" id="L1565" title="All 2 branches missed.">			if (!hrsPerColToUpdate.isEmpty()) {</span>
<span class="nc" id="L1566">				refreshAndUpdateTOHoursPerDay(hrsPerColToUpdate, true);</span>
			}

<span class="nc" id="L1569">		} catch (Exception e) {</span>
<span class="nc" id="L1570">			handleException(e);</span>
<span class="nc" id="L1571">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L1572">		}finally {</span>
			
<span class="nc" id="L1574">		}</span>
<span class="nc" id="L1575">	}</span>



	private List&lt;TOHoursPerDay&gt; updateDirtyHoursIfNeeded(Map&lt;Boolean, List&lt;TOHoursPerDay&gt;&gt; hrsPerDaySchedMap) throws BbmFinderException {

<span class="nc" id="L1581">		List&lt;TOHoursPerDay&gt; cleanHrsPerDay = hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="nc" id="L1582">		List&lt;TOHoursPerDay&gt; dirtyHrsPerDay = hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>

<span class="nc bnc" id="L1584" title="All 2 branches missed.">		if (cleanHrsPerDay == null) {</span>
<span class="nc" id="L1585">			cleanHrsPerDay = new ArrayList&lt;TOHoursPerDay&gt;();</span>
		}

<span class="nc bnc" id="L1588" title="All 2 branches missed.">		if (dirtyHrsPerDay != null) {</span>
<span class="nc" id="L1589">			cleanHrsPerDay.addAll(refreshAndUpdateTOHoursPerDay(dirtyHrsPerDay, true));</span>
		}

<span class="nc" id="L1592">		return cleanHrsPerDay;</span>
	}

}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>